---------------------------------------------------------------
[ 2018-10-09T01:28:56+08:00 ] 74.120.168.12 66.249.66.90 GET /daily/admin/login/passdaily.html
[ error ] [8]未定义数组索引: password
---------------------------------------------------------------
[ 2018-10-09T01:29:06+08:00 ] 74.120.168.12 66.249.66.90 GET /daily/admin/login/passessay.html
[ error ] [8]未定义数组索引: password
---------------------------------------------------------------
[ 2018-10-09T08:48:34+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002240s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002626s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000681s ]
---------------------------------------------------------------
[ 2018-10-09T08:48:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001347s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001895s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002617s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000862s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001026s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000436s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000786s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001114s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000332s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000606s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000483s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000431s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000892s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000338s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001169s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000821s ]
---------------------------------------------------------------
[ 2018-10-09T08:48:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001180s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001538s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000610s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001058s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000286s ]
---------------------------------------------------------------
[ 2018-10-09T08:49:43+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/noteview.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001348s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001434s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000640s ]
---------------------------------------------------------------
[ 2018-10-09T08:52:31+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/noteview.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001016s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001371s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000375s ]
---------------------------------------------------------------
[ 2018-10-09T08:52:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000980s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001377s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000569s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000867s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000295s ]
---------------------------------------------------------------
[ 2018-10-09T08:53:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001190s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001434s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000344s ]
---------------------------------------------------------------
[ 2018-10-09T08:54:28+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001749s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001542s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000818s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000495s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001268s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000405s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000438s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE\r',`content`='# Java SE\r\n[TOC]\r\n## 一. 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## 二. JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 3. 单例设计模式\r\n### 1.意义（想要保证对象唯一）\r\neg: 配置文件的使用。\r\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\r\n### 2.使用方法\r\n先按常规方法对事物进行描述，最后再加上这三步内即可:\r\n1.将构造函数私有化。（其他类中无法再创建该类对象）\r\n2.在类中创建一个本类对象。（静态）\r\n3.提供一个方法可以获取到该对象。（静态）\r\n\r\n>Ps: 为什么要使用静态？\r\n\r\n在主函数中需要调用方法（3），方法的调用有两种：\r\n1.通过对象调用\r\n2.通过类名调用\r\n\r\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\r\n\r\n### 3.例子（饿汉式）\r\n```\r\npackage study;\r\n\r\n/**\r\n * 单例设计模式\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class SingletonPattern {\r\n    public static void main(String[] args) {\r\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\r\n        Student stu2 = Student.getStudent();\r\n        stu1.setAge(18);\r\n        System.out.println(\"stu1 age = \" + stu1.getAge());\r\n        System.out.println(\"stu2 age = \" + stu2.getAge());\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int age;\r\n    private Student(){};    //1. 私有构造函数\r\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\r\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\r\n        return stu;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~stu1 age = 18\r\nstu2 age = 18~~\r\n\r\n---\r\n## 三. 多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 四. 内部类\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.001550s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001225s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000465s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000906s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000420s ]
---------------------------------------------------------------
[ 2018-10-09T08:54:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001114s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001440s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000633s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000944s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000325s ]
---------------------------------------------------------------
[ 2018-10-09T08:54:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001011s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001270s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000381s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000314s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000319s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.000945s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('临时\r' , '# 临时\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### Buffered\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n##### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n##### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n' , 'Default' , 1 , '2018-10-09') [ RunTime:0.000898s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000956s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000634s ]
---------------------------------------------------------------
[ 2018-10-09T08:54:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001253s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001417s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001263s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000727s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001440s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000498s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000690s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001349s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000509s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000620s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000437s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000562s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001092s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000345s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001652s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000978s ]
---------------------------------------------------------------
[ 2018-10-09T08:54:59+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001005s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001237s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 1  AND `id` > 2 ORDER BY date desc [ RunTime:0.001519s ]
---------------------------------------------------------------
[ 2018-10-09T08:55:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/213
[ sql ] [ DB ] CONNECT:[ UseTime:0.001299s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001681s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000565s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000386s ]
---------------------------------------------------------------
[ 2018-10-09T08:55:05+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001370s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001308s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000565s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000355s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000945s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000289s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000323s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000277s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=213,`p_id`=1,`title`='临时\r',`content`='# 临时\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### Buffered\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n##### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n##### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n',`groups`='Default',`is_show`=1  WHERE  `id` = 213 [ RunTime:0.001147s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000954s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000429s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000851s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000420s ]
---------------------------------------------------------------
[ 2018-10-09T08:55:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000966s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001653s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000455s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000891s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000352s ]
---------------------------------------------------------------
[ 2018-10-09T08:55:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001340s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001573s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000486s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001057s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000325s ]
---------------------------------------------------------------
[ 2018-10-09T08:55:28+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001187s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001530s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000551s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000377s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001092s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000330s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000318s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000338s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=213,`p_id`=1,`title`='临时\r',`content`='# 临时\r\n[TOC]\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### Buffered\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n##### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n##### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n',`groups`='Default',`is_show`=1  WHERE  `id` = 213 [ RunTime:0.001133s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000977s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000473s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000954s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000488s ]
---------------------------------------------------------------
[ 2018-10-09T08:55:28+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001424s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001819s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000619s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001925s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000440s ]
---------------------------------------------------------------
[ 2018-10-09T09:06:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001077s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001334s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000486s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000898s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000284s ]
---------------------------------------------------------------
[ 2018-10-09T09:07:52+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001070s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001415s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000646s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000888s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000285s ]
---------------------------------------------------------------
[ 2018-10-09T20:07:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002291s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003058s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000857s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001069s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000381s ]
---------------------------------------------------------------
[ 2018-10-09T20:07:28+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001222s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001442s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001183s ]
---------------------------------------------------------------
[ 2018-10-09T20:07:33+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001216s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002218s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000596s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000966s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000288s ]
---------------------------------------------------------------
[ 2018-10-09T20:08:11+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001275s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001351s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000942s ]
---------------------------------------------------------------
[ 2018-10-09T20:08:14+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001157s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001187s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000846s ]
---------------------------------------------------------------
[ 2018-10-09T20:14:18+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001253s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001275s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000772s ]
---------------------------------------------------------------
[ 2018-10-09T20:14:22+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001038s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001209s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000784s ]
---------------------------------------------------------------
[ 2018-10-09T20:14:27+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001130s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001449s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000552s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000358s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000909s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000352s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000349s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000325s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=213,`p_id`=1,`title`='临时\r',`content`='# 临时\r\n[TOC]\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### Buffered\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n##### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n##### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n### 过滤流和转换流\r\n\r\n',`groups`='Default',`is_show`=1  WHERE  `id` = 213 [ RunTime:0.000942s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.002053s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000659s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000321s ]
---------------------------------------------------------------
[ 2018-10-09T20:14:28+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001052s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001266s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000485s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000963s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000300s ]
---------------------------------------------------------------
[ 2018-10-09T20:14:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001081s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001213s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000544s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000848s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000301s ]
---------------------------------------------------------------
[ 2018-10-09T20:14:39+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001462s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001876s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001608s ]
---------------------------------------------------------------
[ 2018-10-09T20:15:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.000962s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001260s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001343s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000492s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000972s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000403s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000415s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000935s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000289s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000426s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000310s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000378s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000701s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000269s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001083s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000681s ]
---------------------------------------------------------------
[ 2018-10-09T20:15:05+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001080s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000607s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001065s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000303s ]
---------------------------------------------------------------
[ 2018-10-09T20:22:17+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001024s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001299s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000978s ]
---------------------------------------------------------------
[ 2018-10-09T20:23:41+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000954s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001202s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000721s ]
---------------------------------------------------------------
[ 2018-10-09T20:26:17+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000943s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001292s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- PutputStreamWriter：将字符输出流转换为字节输出流',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000903s ]
---------------------------------------------------------------
[ 2018-10-09T20:26:22+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001150s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001220s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000952s ]
---------------------------------------------------------------
[ 2018-10-09T20:30:31+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000994s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001384s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000974s ]
---------------------------------------------------------------
[ 2018-10-09T20:31:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000948s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001299s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000462s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000855s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000389s ]
---------------------------------------------------------------
[ 2018-10-09T20:32:03+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000994s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001269s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 4. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 5. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 对象流\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000895s ]
---------------------------------------------------------------
[ 2018-10-09T20:32:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000977s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001325s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000511s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000893s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000387s ]
---------------------------------------------------------------
[ 2018-10-09T20:33:10+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000979s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001332s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n#### 6. 过滤流和转换流\n##### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n##### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n#### 对象流\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001377s ]
---------------------------------------------------------------
[ 2018-10-09T20:33:11+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000942s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001212s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000531s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000847s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000274s ]
---------------------------------------------------------------
[ 2018-10-09T20:34:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000930s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001317s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 对象流\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001294s ]
---------------------------------------------------------------
[ 2018-10-09T20:34:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000974s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001281s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000528s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000931s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-10-09T20:41:44+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/api/synTemp?content=*%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%B8%A4%E4%B8%AA%E7%89%B9%E7%82%B9%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%A6%81%E6%B1%82%E6%89%80%E6%9C%89%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%A3%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E9%83%BD%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%99%E4%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%80%8C%E4%B8%94%E9%80%9A%E8%BF%87%E5%BE%AA%E7%8E%AF%E5%8F%AF%E4%BB%A5%E4%BF%9D%E5%AD%98%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%A3%E6%8D%AE*%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%B6%B3%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%EF%BC%8C%E5%88%99%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E4%BE%A7avaJang%E5%8C%85%E4%B8%8B%E7%9A%84Serializable%E6%8E%A5%E5%8F%A3%E6%88%96Externalizable%E6%8E%A5%E5%8F%A3*Java%E4%B8%AD%E7%9A%84Serializable%E6%8E%A5%E5%8F%A3%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E5%BF%97%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E7%94%A8%E4%BA%8E%E8%A1%A8%E6%98%8E%E8%AF%A5%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0A
[ sql ] [ DB ] CONNECT:[ UseTime:0.001482s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001914s ]
[ sql ] [ SQL ] UPDATE `note`  SET `content`='*对象序列化具有以下两个特点：对象序列化可以在分布式应用中进行使用，要求所有传递的参散、返回值都必须实现序列化则会序列化不仅可以保存一个对象的数据，而且通过循环可以保存每个对象的散据*一个类的对象足可序列化的，则该类必须实侧avaJang包下的Serializable接口或Externalizable接口*Java中的Serializable接口只是一个标志接口，接口中没有任何的方法，只是用于表明该类的实例对象是可以序列化的\n*=============*\n'  WHERE  `id` = 2 [ RunTime:0.000654s ]
---------------------------------------------------------------
[ 2018-10-09T20:41:51+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000957s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001258s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000479s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001011s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000471s ]
---------------------------------------------------------------
[ 2018-10-09T20:47:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000952s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001327s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000368s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000909s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000321s ]
---------------------------------------------------------------
[ 2018-10-09T20:47:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000981s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000410s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000876s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000324s ]
---------------------------------------------------------------
[ 2018-10-09T20:47:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001010s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001534s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000483s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001281s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000285s ]
---------------------------------------------------------------
[ 2018-10-09T20:47:55+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/api/synTemp?content=%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B0%86%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A3%81%E7%9B%98%E6%88%96%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%88%99%E8%AF%A5%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%28serializable%29%E3%80%82%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%EF%BC%8C%E5%88%99%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0java.lang%E5%8C%85%E4%B8%8B%E7%9A%84Serializable%E6%8E%A5%E5%8F%A3%E6%88%96Externali%E5%90%8Dable%E6%8E%A5%E5%8F%A3%E3%80%82%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0A
[ sql ] [ DB ] CONNECT:[ UseTime:0.001189s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001642s ]
[ sql ] [ SQL ] UPDATE `note`  SET `content`='在Java中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的(serializable)。一个类的对象是可序列化的，则该类必须实现java.lang包下的Serializable接口或Externali名able接口。\n*=============*\n'  WHERE  `id` = 2 [ RunTime:0.000442s ]
---------------------------------------------------------------
[ 2018-10-09T20:47:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000983s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001238s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000471s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000300s ]
---------------------------------------------------------------
[ 2018-10-09T20:48:50+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001045s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001288s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的(serializable)。\n\n一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000939s ]
---------------------------------------------------------------
[ 2018-10-09T20:55:05+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000991s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001165s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\n\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n\n```\n//定义一个可以序列化的 Person 实体类\npublic class Person implements Serializable {\n	...\n}\n```\n\n>序列化\n\n```\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutputStreamDemo {\n\n	public static void main(String[] args) {\n\n		// 创建一个ObjectOutputStream对象输出流\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 创建一个Person类型的对象\n			Person person = new Person(\"张三\", 25, \"青岛\");\n			// 把对象写入到文件中\n			obs.writeObject(person);\n			obs.flush();\n			System.out.println(\"序列化完毕！\");\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n>反序列化\n\n```\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStreamDemo {\n	public static void main(String[] args) {\n		// 创建一个ObjectInputStream对象输入流\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\n			Person person =(Person)ois.readObject();\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\n			System.out.println(person);\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000949s ]
---------------------------------------------------------------
[ 2018-10-09T20:55:21+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001886s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002361s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\n\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n\n```\n//定义一个可以序列化的 Person 实体类\npublic class Person implements Serializable {\n	...\n}\n```\n\n>序列化\n\n```\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutputStreamDemo {\n\n	public static void main(String[] args) {\n\n		// 创建一个ObjectOutputStream对象输出流\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 创建一个Person类型的对象\n			Person person = new Person(\"张三\", 25, \"青岛\");\n			// 把对象写入到文件中\n			obs.writeObject(person);\n			obs.flush();\n			System.out.println(\"序列化完毕！\");\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n>反序列化\n\n```\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStreamDemo {\n	public static void main(String[] args) {\n		// 创建一个ObjectInputStream对象输入流\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\n			Person person =(Person)ois.readObject();\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\n			System.out.println(person);\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n### NIO\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001373s ]
---------------------------------------------------------------
[ 2018-10-09T20:55:22+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001002s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001275s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000523s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001103s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000310s ]
---------------------------------------------------------------
[ 2018-10-09T20:55:50+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001181s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001439s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\n\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n\n```\n//定义一个可以序列化的 Person 实体类\npublic class Person implements Serializable {\n	...\n}\n```\n\n>序列化\n\n```\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutputStreamDemo {\n\n	public static void main(String[] args) {\n\n		// 创建一个ObjectOutputStream对象输出流\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 创建一个Person类型的对象\n			Person person = new Person(\"张三\", 25, \"青岛\");\n			// 把对象写入到文件中\n			obs.writeObject(person);\n			obs.flush();\n			System.out.println(\"序列化完毕！\");\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n>反序列化\n\n```\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStreamDemo {\n	public static void main(String[] args) {\n		// 创建一个ObjectInputStream对象输入流\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\n			Person person =(Person)ois.readObject();\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\n			System.out.println(person);\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n### 8. NIO\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000992s ]
---------------------------------------------------------------
[ 2018-10-09T21:10:32+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/api/synTemp?content=%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B0%86%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A3%81%E7%9B%98%E6%88%96%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%88%99%E8%AF%A5%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%28serializable%29%E3%80%82%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%EF%BC%8C%E5%88%99%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0java.lang%E5%8C%85%E4%B8%8B%E7%9A%84Serializable%E6%8E%A5%E5%8F%A3%E6%88%96Externali%E5%90%8Dable%E6%8E%A5%E5%8F%A3%E3%80%82%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0A*Channel%E6%98%AF%E5%AF%B9%E4%BC%A0%E5%AA%92%E7%94%B0%E7%93%A00%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E6%8B%9F%EF%BC%8C%E5%9C%A8N10%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E9%83%BD%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E9%80%9A%E9%81%93%E4%BC%A0%E8%BE%93%EF%BC%9BChannel%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84Inputstream%E3%80%81Outputstream%E6%9C%80%E5%A4%A7%E6%9B%B2%E5%8C%BA%E5%88%AB%E6%98%AF%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAmapo%E6%96%B9%E6%B3%95%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AF%A5%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%B0%86%E4%B8%80%E5%9D%97%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0A
[ sql ] [ DB ] CONNECT:[ UseTime:0.001121s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001609s ]
[ sql ] [ SQL ] UPDATE `note`  SET `content`='在Java中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的(serializable)。一个类的对象是可序列化的，则该类必须实现java.lang包下的Serializable接口或Externali名able接口。\n*=============*\n*Channel是对传媒田瓠0系统的模拟，在N10系统中所有数据都需要经过通道传输；Channel与传统的Inputstream、Outputstream最大曲区别是提供一个mapo方法，通过该方法可以直接将一块数据映射到内存中\n*=============*\n'  WHERE  `id` = 2 [ RunTime:0.000551s ]
---------------------------------------------------------------
[ 2018-10-09T21:10:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001126s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001938s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000500s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001327s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000422s ]
---------------------------------------------------------------
[ 2018-10-09T21:15:56+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/api/synTemp?content=%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B0%86%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A3%81%E7%9B%98%E6%88%96%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%88%99%E8%AF%A5%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%28serializable%29%E3%80%82%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%EF%BC%8C%E5%88%99%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0java.lang%E5%8C%85%E4%B8%8B%E7%9A%84Serializable%E6%8E%A5%E5%8F%A3%E6%88%96Externali%E5%90%8Dable%E6%8E%A5%E5%8F%A3%E3%80%82%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0A*Channel%E6%98%AF%E5%AF%B9%E4%BC%A0%E5%AA%92%E7%94%B0%E7%93%A00%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E6%8B%9F%EF%BC%8C%E5%9C%A8N10%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E9%83%BD%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E9%80%9A%E9%81%93%E4%BC%A0%E8%BE%93%EF%BC%9BChannel%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84Inputstream%E3%80%81Outputstream%E6%9C%80%E5%A4%A7%E6%9B%B2%E5%8C%BA%E5%88%AB%E6%98%AF%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AAmapo%E6%96%B9%E6%B3%95%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AF%A5%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%B0%86%E4%B8%80%E5%9D%97%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0AChannel%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%8410%E6%B5%81%E7%B1%BB%E4%BC%BC%EF%BC%8C%E4%BD%86%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%A4%E7%82%B9%E5%8C%BA%E5%88%AB%EF%BC%9A%E5%9B%BDChannel%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%B0%86%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E9%83%A8%E5%88%86%E6%88%96%E5%85%A8%E9%83%A8%E7%9B%B4%E6%8E%A5%E8%9E%8D%E5%B0%84%E6%88%90Buffer%E5%B7%A5%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AEChannel%E4%B8%AD%E7%9A%84%E9%BB%BC%EF%BC%8CChannel%E5%8F%AA%E8%83%BD%E4%B8%8EBuffer%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%0A*%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D*%0A
[ sql ] [ DB ] CONNECT:[ UseTime:0.001002s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001363s ]
[ sql ] [ SQL ] UPDATE `note`  SET `content`='在Java中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的(serializable)。一个类的对象是可序列化的，则该类必须实现java.lang包下的Serializable接口或Externali名able接口。\n*=============*\n*Channel是对传媒田瓠0系统的模拟，在N10系统中所有数据都需要经过通道传输；Channel与传统的Inputstream、Outputstream最大曲区别是提供一个mapo方法，通过该方法可以直接将一块数据映射到内存中\n*=============*\nChannel与传统的10流类似，但主要有两点区别：国Channel类可以直接将指定文件的部分或全部直接融射成Buffer工程序不能直接访问Channel中的黼，Channel只能与Buffer进行交互\n*=============*\n'  WHERE  `id` = 2 [ RunTime:0.000470s ]
---------------------------------------------------------------
[ 2018-10-09T21:15:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000987s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001175s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000455s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000878s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000340s ]
---------------------------------------------------------------
[ 2018-10-09T21:18:33+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000989s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001292s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\n\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n\n```\n//定义一个可以序列化的 Person 实体类\npublic class Person implements Serializable {\n	...\n}\n```\n\n>序列化\n\n```\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutputStreamDemo {\n\n	public static void main(String[] args) {\n\n		// 创建一个ObjectOutputStream对象输出流\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 创建一个Person类型的对象\n			Person person = new Person(\"张三\", 25, \"青岛\");\n			// 把对象写入到文件中\n			obs.writeObject(person);\n			obs.flush();\n			System.out.println(\"序列化完毕！\");\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n>反序列化\n\n```\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStreamDemo {\n	public static void main(String[] args) {\n		// 创建一个ObjectInputStream对象输入流\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\n			Person person =(Person)ois.readObject();\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\n			System.out.println(person);\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n### 8. NIO\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\n\nBuffer 和 Channel 是 NIO 中两个核心对象：\n- Buffer 可以理解成一个容器，其本质是一个数组。\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\n\n#### Buffer\n\n```\nimport java.nio.CharBuffer;\n\npublic class NIOBufferDemo {\n	public static void main(String[] args) {\n		// 实例化一个容量为 8 的 CharBuffer\n		CharBuffer buff = CharBuffer.allocate(8);\n		System.out.println(\"capacity: \"	+ buff.capacity());\n		System.out.println(\"limit: \" + buff.limit());\n		System.out.println(\"position: \" + buff.position());\n		\n		// 使用 put 方法，放入元素\n		buff.put(\'a\');\n		buff.put(\'b\');\n		buff.put(\'c\');     \n		System.out.println(\"加入三个元素后，position = \" + buff.position());\n		\n		// 调用 flip() 方法，反转缓冲区\n		buff.flip();	  // ③\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\n		System.out.println(\"position = \" + buff.position());\n		\n		// get 方法，取出第一个元素\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \n		System.out.println(\"取出一个元素后，position = \" + buff.position());\n		\n		// 调用 clear 方法，清除缓冲区\n		buff.clear(); \n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\n		System.out.println(\"执行clear()后，position = \" + buff.position());\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\n\n	}\n\n}\n```\n#### Channel\nChannel 与传统的 IO流 类似，但主要有两点区别：\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\n>将 FileChannel 的所有数据映射成 ByteBuffer\n\n```\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.CharBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\n\npublic class NIOFileChannelDemo {\n	public static void main(String[] args) {\n		File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\n		try (\n		// 创建FileInputStream，以该文件输入流创建FileChannel\n		FileChannel inChannel = new FileInputStream(f).getChannel();\n				// 以文件输出流创建FileBuffer，用以控制输出\n				FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\n						.getChannel()) {\n			// 将FileChannel里的全部数据映射成ByteBuffer\n			MappedByteBuffer buffer = inChannel.map(\n					FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\n			// 使用GBK的字符集来创建解码器\n			Charset charset = Charset.forName(\"GBK\");\n			// 直接将buffer里的数据全部输出\n			outChannel.write(buffer); // ②\n			// 再次调用buffer的clear()方法，复原limit、position的位置\n			buffer.clear();\n			// 创建解码器(CharsetDecoder)对象\n			CharsetDecoder decoder = charset.newDecoder();\n			// 使用解码器将ByteBuffer转换成CharBuffer\n			CharBuffer charBuffer = decoder.decode(buffer);\n			// CharBuffer的toString方法可以获取对应的字符串\n			System.out.println(charBuffer);\n		} catch (IOException ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001209s ]
---------------------------------------------------------------
[ 2018-10-09T21:19:26+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001306s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001315s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\n\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n\n```\n//定义一个可以序列化的 Person 实体类\npublic class Person implements Serializable {\n	...\n}\n```\n\n>序列化\n\n```\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutputStreamDemo {\n\n	public static void main(String[] args) {\n\n		// 创建一个ObjectOutputStream对象输出流\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 创建一个Person类型的对象\n			Person person = new Person(\"张三\", 25, \"青岛\");\n			// 把对象写入到文件中\n			obs.writeObject(person);\n			obs.flush();\n			System.out.println(\"序列化完毕！\");\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n>反序列化\n\n```\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStreamDemo {\n	public static void main(String[] args) {\n		// 创建一个ObjectInputStream对象输入流\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\n			Person person =(Person)ois.readObject();\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\n			System.out.println(person);\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n### 8. NIO\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\n\nBuffer 和 Channel 是 NIO 中两个核心对象：\n- Buffer 可以理解成一个容器，其本质是一个数组。\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\n\n#### Buffer\n\n```\nimport java.nio.CharBuffer;\n\npublic class NIOBufferDemo {\n	public static void main(String[] args) {\n		// 实例化一个容量为 8 的 CharBuffer\n		CharBuffer buff = CharBuffer.allocate(8);\n		System.out.println(\"capacity: \"	+ buff.capacity());\n		System.out.println(\"limit: \" + buff.limit());\n		System.out.println(\"position: \" + buff.position());\n		\n		// 使用 put 方法，放入元素\n		buff.put(\'a\');\n		buff.put(\'b\');\n		buff.put(\'c\');     \n		System.out.println(\"加入三个元素后，position = \" + buff.position());\n		\n		// 调用 flip() 方法，反转缓冲区\n		buff.flip();	  // ③\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\n		System.out.println(\"position = \" + buff.position());\n		\n		// get 方法，取出第一个元素\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \n		System.out.println(\"取出一个元素后，position = \" + buff.position());\n		\n		// 调用 clear 方法，清除缓冲区\n		buff.clear(); \n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\n		System.out.println(\"执行clear()后，position = \" + buff.position());\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\n\n	}\n\n}\n```\n#### Channel\nChannel 与传统的 IO流 类似，但主要有两点区别：\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\n>将 FileChannel 的所有数据映射成 ByteBuffer\n\n```\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.CharBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\n\npublic class NIOFileChannelDemo {\n    public static void main(String[] args) {\n        File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\n        try (\n                // 创建FileInputStream，以该文件输入流创建FileChannel\n                FileChannel inChannel = new FileInputStream(f).getChannel();\n                // 以文件输出流创建FileBuffer，用以控制输出\n                FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\n                        .getChannel()) {\n            // 将FileChannel里的全部数据映射成ByteBuffer\n            MappedByteBuffer buffer = inChannel.map(\n                    FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\n            // 使用GBK的字符集来创建解码器\n            Charset charset = Charset.forName(\"GBK\");\n            // 直接将buffer里的数据全部输出\n            outChannel.write(buffer); // ②\n            // 再次调用buffer的clear()方法，复原limit、position的位置\n            buffer.clear();\n            // 创建解码器(CharsetDecoder)对象\n            CharsetDecoder decoder = charset.newDecoder();\n            // 使用解码器将ByteBuffer转换成CharBuffer\n            CharBuffer charBuffer = decoder.decode(buffer);\n            // CharBuffer的toString方法可以获取对应的字符串\n            System.out.println(charBuffer);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001282s ]
---------------------------------------------------------------
[ 2018-10-09T21:19:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000954s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001166s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000492s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000857s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000272s ]
---------------------------------------------------------------
[ 2018-10-09T21:24:34+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000992s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001233s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='临时',`content`='# 临时\n[TOC]\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n### 5. Buffered 缓冲区\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n#### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n#### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n### 6. 过滤流和转换流\n#### 过滤流\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\n```\npackage io;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\n\npublic class BufferedInputStreamDemo {\n\n    public static void main(String[] args) {\n        try (\n                // 利用FileInputStream对象创建一个输入缓冲流\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\n                )\n        {\n            int result = 0;\n            //循环读数据\n            while ((result = bi.read()) != -1) {\n                //输出\n                System.out.print((char) result);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### 转换流\nJava 的 IO流 体系中提供了两个转换流：\n- InputStreamReader：将字节输入流转换为字符输入流\n- OutputStreamWriter：将字符输出流转换为字节输出流\n\n```\npackage io;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) {\n        try (\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\n                InputStreamReader reader = new InputStreamReader(System.in);\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\n                BufferedReader br = new BufferedReader(reader)) {\n            String line = null;\n            // 采用循环方式来一行一行的读取\n            while ((line = br.readLine()) != null) {\n                // 如果读取的字符串为\"exit\"，程序退出\n                if (line.equals(\"exit\")) {\n                    System.exit(1);\n                }\n                // 打印读取的内容\n                System.out.println(\"输入内容为:\" + line);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n}\n```\n### 7. 对象流\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\n\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\n\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\n\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\n\n```\n//定义一个可以序列化的 Person 实体类\npublic class Person implements Serializable {\n	...\n}\n```\n\n>序列化\n\n```\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class ObjectOutputStreamDemo {\n\n	public static void main(String[] args) {\n\n		// 创建一个ObjectOutputStream对象输出流\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 创建一个Person类型的对象\n			Person person = new Person(\"张三\", 25, \"青岛\");\n			// 把对象写入到文件中\n			obs.writeObject(person);\n			obs.flush();\n			System.out.println(\"序列化完毕！\");\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n>反序列化\n\n```\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\n\npublic class ObjectInputStreamDemo {\n	public static void main(String[] args) {\n		// 创建一个ObjectInputStream对象输入流\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\n			Person person =(Person)ois.readObject();\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\n			System.out.println(person);\n		} catch (Exception ex) {\n			ex.printStackTrace();\n		}\n	}\n}\n```\n### 8. NIO\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\n\nBuffer 和 Channel 是 NIO 中两个核心对象：\n- Buffer 可以理解成一个容器，其本质是一个数组。\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\n\n#### Buffer\n\n```\nimport java.nio.CharBuffer;\n\npublic class NIOBufferDemo {\n	public static void main(String[] args) {\n		// 实例化一个容量为 8 的 CharBuffer\n		CharBuffer buff = CharBuffer.allocate(8);\n		System.out.println(\"capacity: \"	+ buff.capacity());\n		System.out.println(\"limit: \" + buff.limit());\n		System.out.println(\"position: \" + buff.position());\n		\n		// 使用 put 方法，放入元素\n		buff.put(\'a\');\n		buff.put(\'b\');\n		buff.put(\'c\');     \n		System.out.println(\"加入三个元素后，position = \" + buff.position());\n		\n		// 调用 flip() 方法，反转缓冲区\n		buff.flip();	  // ③\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\n		System.out.println(\"position = \" + buff.position());\n		\n		// get 方法，取出第一个元素\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \n		System.out.println(\"取出一个元素后，position = \" + buff.position());\n		\n		// 调用 clear 方法，清除缓冲区\n		buff.clear(); \n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\n		System.out.println(\"执行clear()后，position = \" + buff.position());\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\n\n	}\n\n}\n```\n#### Channel\nChannel 与传统的 IO流 类似，但主要有两点区别：\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\n>将 FileChannel 的所有数据映射成 ByteBuffer\n\n```\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.CharBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\n\npublic class NIOFileChannelDemo {\n    public static void main(String[] args) {\n        File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\n        try (\n                // 创建FileInputStream，以该文件输入流创建FileChannel\n                FileChannel inChannel = new FileInputStream(f).getChannel();\n                // 以文件输出流创建FileBuffer，用以控制输出\n                FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\n                        .getChannel()) {\n            // 将FileChannel里的全部数据映射成ByteBuffer\n            MappedByteBuffer buffer = inChannel.map(\n                    FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\n            // 使用GBK的字符集来创建解码器\n            Charset charset = Charset.forName(\"GBK\");\n            // 直接将buffer里的数据全部输出\n            outChannel.write(buffer); // ②\n            // 再次调用buffer的clear()方法，复原limit、position的位置\n            buffer.clear();\n            // 创建解码器(CharsetDecoder)对象\n            CharsetDecoder decoder = charset.newDecoder();\n            // 使用解码器将ByteBuffer转换成CharBuffer\n            CharBuffer charBuffer = decoder.decode(buffer);\n            // CharBuffer的toString方法可以获取对应的字符串\n            System.out.println(charBuffer);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n```\n\n### 9. NOI.2\n>java.nio.file.Path 下的 Path类\n\n```\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\npublic class NIO2PathDemo {\n	public static void main(String[] args) {\n		// 以当前路径来创建Path对象\n		Path path = Paths.get(\".\");\n		System.out.println(\"path里包含的路径数量：\" + path.getNameCount());\n		System.out.println(\"path的根路径：\" + path.getRoot());\n		\n		// 获取path对应的绝对路径。\n		Path absolutePath = path.toAbsolutePath();\n		System.out.println(absolutePath);\n		\n		// 获取绝对路径的根路径\n		System.out.println(\"absolutePath的根路径：\" + absolutePath.getRoot());\n		\n		// 获取绝对路径所包含的路径数量\n		System.out.println(\"absolutePath里包含的路径数量：\" + absolutePath.getNameCount());\n		System.out.println(absolutePath.getName(3));\n		\n		// 以多个String来构建Path对象\n		Path path2 = Paths.get(\"g:\", \"publish\", \"codes\");\n		System.out.println(path2);\n	}\n}\n```\n\n>Files类\n\n```\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.file.FileStore;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NIO2FilesDemo {\n	public static void main(String[] args) {\n		try {\n			// 复制文件\n			Files.copy(\n					Paths.get(\"src\\\\com\\\\qst\\\\chapter01\\\\NIO2FilesDemo.java\"),\n					new FileOutputStream(\"a.txt\"));\n			// 判断NIO2FilesDemo.java文件是否为隐藏文件\n			System.out.println(\"NIO2FilesDemo.java是否为隐藏文件：\"\n					+ Files.isHidden(Paths\n							.get(\"src/com/qst/chapter09/NIO2FilesDemo.java\")));\n			// 一次性读取FilesTest.java文件的所有行\n			List<String> lines = Files.readAllLines(Paths.get(\"src\", \"com\",\n					\"qst\", \"chapter09\", \"NIO2FilesDemo.java\"), Charset\n					.forName(\"gbk\"));\n			System.out.println(\"行数：\" + lines.size());\n			// 判断指定文件的大小\n			System.out.println(\"a.txt文件的大小为：\" + Files.size(Paths.get(\"a.txt\")));\n			List<String> poem = new ArrayList<>();\n			poem.add(\"使用NIO.2技术\");\n			poem.add(\"往文件中写内容\");\n			// 直接将多个字符串内容写入指定文件中\n			Files.write(Paths.get(\"pome.txt\"), poem, Charset.forName(\"gbk\"));\n			FileStore cStore = Files.getFileStore(Paths.get(\"C:\"));\n			// 判断C盘的总空间，可用空间\n			System.out.println(\"C:共有空间：\" + cStore.getTotalSpace());\n			System.out.println(\"C:可用空间：\" + cStore.getUsableSpace());\n		} catch (FileNotFoundException e) {\n			e.printStackTrace();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001338s ]
---------------------------------------------------------------
[ 2018-10-09T21:24:45+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001021s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001315s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000459s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000318s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000949s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000298s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000283s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=213,`p_id`=1,`title`='临时\r',`content`='# 临时\r\n[TOC]\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n### 5. Buffered 缓冲区\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n#### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n#### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n### 6. 过滤流和转换流\r\n#### 过滤流\r\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.FileInputStream;\r\n\r\npublic class BufferedInputStreamDemo {\r\n\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 利用FileInputStream对象创建一个输入缓冲流\r\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\r\n                )\r\n        {\r\n            int result = 0;\r\n            //循环读数据\r\n            while ((result = bi.read()) != -1) {\r\n                //输出\r\n                System.out.print((char) result);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### 转换流\r\nJava 的 IO流 体系中提供了两个转换流：\r\n- InputStreamReader：将字节输入流转换为字符输入流\r\n- OutputStreamWriter：将字符输出流转换为字节输出流\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class InputStreamReaderDemo {\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\r\n                InputStreamReader reader = new InputStreamReader(System.in);\r\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\r\n                BufferedReader br = new BufferedReader(reader)) {\r\n            String line = null;\r\n            // 采用循环方式来一行一行的读取\r\n            while ((line = br.readLine()) != null) {\r\n                // 如果读取的字符串为\"exit\"，程序退出\r\n                if (line.equals(\"exit\")) {\r\n                    System.exit(1);\r\n                }\r\n                // 打印读取的内容\r\n                System.out.println(\"输入内容为:\" + line);\r\n            }\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n### 7. 对象流\r\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\r\n\r\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\r\n\r\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\r\n\r\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\r\n\r\n```\r\n//定义一个可以序列化的 Person 实体类\r\npublic class Person implements Serializable {\r\n	...\r\n}\r\n```\r\n\r\n>序列化\r\n\r\n```\r\nimport java.io.FileOutputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class ObjectOutputStreamDemo {\r\n\r\n	public static void main(String[] args) {\r\n\r\n		// 创建一个ObjectOutputStream对象输出流\r\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 创建一个Person类型的对象\r\n			Person person = new Person(\"张三\", 25, \"青岛\");\r\n			// 把对象写入到文件中\r\n			obs.writeObject(person);\r\n			obs.flush();\r\n			System.out.println(\"序列化完毕！\");\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n>反序列化\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.ObjectInputStream;\r\n\r\npublic class ObjectInputStreamDemo {\r\n	public static void main(String[] args) {\r\n		// 创建一个ObjectInputStream对象输入流\r\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\r\n			Person person =(Person)ois.readObject();\r\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\r\n			System.out.println(person);\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n### 8. NIO\r\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\r\n\r\nBuffer 和 Channel 是 NIO 中两个核心对象：\r\n- Buffer 可以理解成一个容器，其本质是一个数组。\r\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\r\n\r\n#### Buffer\r\n\r\n```\r\nimport java.nio.CharBuffer;\r\n\r\npublic class NIOBufferDemo {\r\n	public static void main(String[] args) {\r\n		// 实例化一个容量为 8 的 CharBuffer\r\n		CharBuffer buff = CharBuffer.allocate(8);\r\n		System.out.println(\"capacity: \"	+ buff.capacity());\r\n		System.out.println(\"limit: \" + buff.limit());\r\n		System.out.println(\"position: \" + buff.position());\r\n		\r\n		// 使用 put 方法，放入元素\r\n		buff.put(\'a\');\r\n		buff.put(\'b\');\r\n		buff.put(\'c\');     \r\n		System.out.println(\"加入三个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 flip() 方法，反转缓冲区\r\n		buff.flip();	  // ③\r\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\r\n		System.out.println(\"position = \" + buff.position());\r\n		\r\n		// get 方法，取出第一个元素\r\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \r\n		System.out.println(\"取出一个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 clear 方法，清除缓冲区\r\n		buff.clear(); \r\n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\r\n		System.out.println(\"执行clear()后，position = \" + buff.position());\r\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\r\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\r\n\r\n	}\r\n\r\n}\r\n```\r\n#### Channel\r\nChannel 与传统的 IO流 类似，但主要有两点区别：\r\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\r\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\r\n>将 FileChannel 的所有数据映射成 ByteBuffer\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.CharBuffer;\r\nimport java.nio.MappedByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.CharsetDecoder;\r\n\r\npublic class NIOFileChannelDemo {\r\n    public static void main(String[] args) {\r\n        File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\r\n        try (\r\n                // 创建FileInputStream，以该文件输入流创建FileChannel\r\n                FileChannel inChannel = new FileInputStream(f).getChannel();\r\n                // 以文件输出流创建FileBuffer，用以控制输出\r\n                FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\r\n                        .getChannel()) {\r\n            // 将FileChannel里的全部数据映射成ByteBuffer\r\n            MappedByteBuffer buffer = inChannel.map(\r\n                    FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\r\n            // 使用GBK的字符集来创建解码器\r\n            Charset charset = Charset.forName(\"GBK\");\r\n            // 直接将buffer里的数据全部输出\r\n            outChannel.write(buffer); // ②\r\n            // 再次调用buffer的clear()方法，复原limit、position的位置\r\n            buffer.clear();\r\n            // 创建解码器(CharsetDecoder)对象\r\n            CharsetDecoder decoder = charset.newDecoder();\r\n            // 使用解码器将ByteBuffer转换成CharBuffer\r\n            CharBuffer charBuffer = decoder.decode(buffer);\r\n            // CharBuffer的toString方法可以获取对应的字符串\r\n            System.out.println(charBuffer);\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 9. NOI.2\r\n>java.nio.file.Path 下的 Path类\r\n\r\n```\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\npublic class NIO2PathDemo {\r\n	public static void main(String[] args) {\r\n		// 以当前路径来创建Path对象\r\n		Path path = Paths.get(\".\");\r\n		System.out.println(\"path里包含的路径数量：\" + path.getNameCount());\r\n		System.out.println(\"path的根路径：\" + path.getRoot());\r\n		\r\n		// 获取path对应的绝对路径。\r\n		Path absolutePath = path.toAbsolutePath();\r\n		System.out.println(absolutePath);\r\n		\r\n		// 获取绝对路径的根路径\r\n		System.out.println(\"absolutePath的根路径：\" + absolutePath.getRoot());\r\n		\r\n		// 获取绝对路径所包含的路径数量\r\n		System.out.println(\"absolutePath里包含的路径数量：\" + absolutePath.getNameCount());\r\n		System.out.println(absolutePath.getName(3));\r\n		\r\n		// 以多个String来构建Path对象\r\n		Path path2 = Paths.get(\"g:\", \"publish\", \"codes\");\r\n		System.out.println(path2);\r\n	}\r\n}\r\n```\r\n\r\n>Files类\r\n\r\n```\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.FileStore;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class NIO2FilesDemo {\r\n	public static void main(String[] args) {\r\n		try {\r\n			// 复制文件\r\n			Files.copy(\r\n					Paths.get(\"src\\\\com\\\\qst\\\\chapter01\\\\NIO2FilesDemo.java\"),\r\n					new FileOutputStream(\"a.txt\"));\r\n			// 判断NIO2FilesDemo.java文件是否为隐藏文件\r\n			System.out.println(\"NIO2FilesDemo.java是否为隐藏文件：\"\r\n					+ Files.isHidden(Paths\r\n							.get(\"src/com/qst/chapter09/NIO2FilesDemo.java\")));\r\n			// 一次性读取FilesTest.java文件的所有行\r\n			List<String> lines = Files.readAllLines(Paths.get(\"src\", \"com\",\r\n					\"qst\", \"chapter09\", \"NIO2FilesDemo.java\"), Charset\r\n					.forName(\"gbk\"));\r\n			System.out.println(\"行数：\" + lines.size());\r\n			// 判断指定文件的大小\r\n			System.out.println(\"a.txt文件的大小为：\" + Files.size(Paths.get(\"a.txt\")));\r\n			List<String> poem = new ArrayList<>();\r\n			poem.add(\"使用NIO.2技术\");\r\n			poem.add(\"往文件中写内容\");\r\n			// 直接将多个字符串内容写入指定文件中\r\n			Files.write(Paths.get(\"pome.txt\"), poem, Charset.forName(\"gbk\"));\r\n			FileStore cStore = Files.getFileStore(Paths.get(\"C:\"));\r\n			// 判断C盘的总空间，可用空间\r\n			System.out.println(\"C:共有空间：\" + cStore.getTotalSpace());\r\n			System.out.println(\"C:可用空间：\" + cStore.getUsableSpace());\r\n		} catch (FileNotFoundException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```',`groups`='Default',`is_show`=1  WHERE  `id` = 213 [ RunTime:0.001492s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001342s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000338s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000715s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000341s ]
---------------------------------------------------------------
[ 2018-10-09T21:24:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000887s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001266s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000463s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001025s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000400s ]
---------------------------------------------------------------
[ 2018-10-09T21:27:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/213.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000931s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001402s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000480s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000889s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000309s ]
---------------------------------------------------------------
[ 2018-10-09T21:27:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000967s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001254s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000487s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000995s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000310s ]
---------------------------------------------------------------
[ 2018-10-09T21:27:55+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001164s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002540s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000661s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001503s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000507s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000393s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE 基础\r',`content`='# Java SE 基础\r\n[TOC]\r\n## 一. 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## 二. JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 3. 单例设计模式\r\n### 1.意义（想要保证对象唯一）\r\neg: 配置文件的使用。\r\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\r\n### 2.使用方法\r\n先按常规方法对事物进行描述，最后再加上这三步内即可:\r\n1.将构造函数私有化。（其他类中无法再创建该类对象）\r\n2.在类中创建一个本类对象。（静态）\r\n3.提供一个方法可以获取到该对象。（静态）\r\n\r\n>Ps: 为什么要使用静态？\r\n\r\n在主函数中需要调用方法（3），方法的调用有两种：\r\n1.通过对象调用\r\n2.通过类名调用\r\n\r\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\r\n\r\n### 3.例子（饿汉式）\r\n```\r\npackage study;\r\n\r\n/**\r\n * 单例设计模式\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class SingletonPattern {\r\n    public static void main(String[] args) {\r\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\r\n        Student stu2 = Student.getStudent();\r\n        stu1.setAge(18);\r\n        System.out.println(\"stu1 age = \" + stu1.getAge());\r\n        System.out.println(\"stu2 age = \" + stu2.getAge());\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int age;\r\n    private Student(){};    //1. 私有构造函数\r\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\r\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\r\n        return stu;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~stu1 age = 18\r\nstu2 age = 18~~\r\n\r\n---\r\n## 三. 多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 四. 内部类\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.000773s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001027s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000481s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000859s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000420s ]
---------------------------------------------------------------
[ 2018-10-09T21:27:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001113s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001297s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000416s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000924s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000307s ]
---------------------------------------------------------------
[ 2018-10-09T21:28:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001009s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001200s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000327s ]
---------------------------------------------------------------
[ 2018-10-09T21:30:42+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000994s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001267s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000352s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.000913s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('Java SE - 文件和IO流\r' , '# Java SE - 文件和IO流\r\n[TOC]\r\n## 1. 文件\r\n### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n## 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n## 3. 字节流\r\n### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 4. 字符流\r\n### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n#### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n#### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n## 5. Buffered 缓冲区\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n## 6. 过滤流和转换流\r\n### 过滤流\r\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.FileInputStream;\r\n\r\npublic class BufferedInputStreamDemo {\r\n\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 利用FileInputStream对象创建一个输入缓冲流\r\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\r\n                )\r\n        {\r\n            int result = 0;\r\n            //循环读数据\r\n            while ((result = bi.read()) != -1) {\r\n                //输出\r\n                System.out.print((char) result);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n### 转换流\r\nJava 的 IO流 体系中提供了两个转换流：\r\n- InputStreamReader：将字节输入流转换为字符输入流\r\n- OutputStreamWriter：将字符输出流转换为字节输出流\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class InputStreamReaderDemo {\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\r\n                InputStreamReader reader = new InputStreamReader(System.in);\r\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\r\n                BufferedReader br = new BufferedReader(reader)) {\r\n            String line = null;\r\n            // 采用循环方式来一行一行的读取\r\n            while ((line = br.readLine()) != null) {\r\n                // 如果读取的字符串为\"exit\"，程序退出\r\n                if (line.equals(\"exit\")) {\r\n                    System.exit(1);\r\n                }\r\n                // 打印读取的内容\r\n                System.out.println(\"输入内容为:\" + line);\r\n            }\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n## 7. 对象流\r\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\r\n\r\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\r\n\r\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\r\n\r\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\r\n\r\n```\r\n//定义一个可以序列化的 Person 实体类\r\npublic class Person implements Serializable {\r\n	...\r\n}\r\n```\r\n\r\n>序列化\r\n\r\n```\r\nimport java.io.FileOutputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class ObjectOutputStreamDemo {\r\n\r\n	public static void main(String[] args) {\r\n\r\n		// 创建一个ObjectOutputStream对象输出流\r\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 创建一个Person类型的对象\r\n			Person person = new Person(\"张三\", 25, \"青岛\");\r\n			// 把对象写入到文件中\r\n			obs.writeObject(person);\r\n			obs.flush();\r\n			System.out.println(\"序列化完毕！\");\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n>反序列化\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.ObjectInputStream;\r\n\r\npublic class ObjectInputStreamDemo {\r\n	public static void main(String[] args) {\r\n		// 创建一个ObjectInputStream对象输入流\r\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\r\n			Person person =(Person)ois.readObject();\r\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\r\n			System.out.println(person);\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n## 8. NIO\r\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\r\n\r\nBuffer 和 Channel 是 NIO 中两个核心对象：\r\n- Buffer 可以理解成一个容器，其本质是一个数组。\r\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\r\n\r\n### Buffer\r\n\r\n```\r\nimport java.nio.CharBuffer;\r\n\r\npublic class NIOBufferDemo {\r\n	public static void main(String[] args) {\r\n		// 实例化一个容量为 8 的 CharBuffer\r\n		CharBuffer buff = CharBuffer.allocate(8);\r\n		System.out.println(\"capacity: \"	+ buff.capacity());\r\n		System.out.println(\"limit: \" + buff.limit());\r\n		System.out.println(\"position: \" + buff.position());\r\n		\r\n		// 使用 put 方法，放入元素\r\n		buff.put(\'a\');\r\n		buff.put(\'b\');\r\n		buff.put(\'c\');     \r\n		System.out.println(\"加入三个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 flip() 方法，反转缓冲区\r\n		buff.flip();	  // ③\r\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\r\n		System.out.println(\"position = \" + buff.position());\r\n		\r\n		// get 方法，取出第一个元素\r\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \r\n		System.out.println(\"取出一个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 clear 方法，清除缓冲区\r\n		buff.clear(); \r\n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\r\n		System.out.println(\"执行clear()后，position = \" + buff.position());\r\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\r\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\r\n\r\n	}\r\n\r\n}\r\n```\r\n### Channel\r\nChannel 与传统的 IO流 类似，但主要有两点区别：\r\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\r\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\r\n>将 FileChannel 的所有数据映射成 ByteBuffer\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.CharBuffer;\r\nimport java.nio.MappedByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.CharsetDecoder;\r\n\r\npublic class NIOFileChannelDemo {\r\n    public static void main(String[] args) {\r\n        File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\r\n        try (\r\n                // 创建FileInputStream，以该文件输入流创建FileChannel\r\n                FileChannel inChannel = new FileInputStream(f).getChannel();\r\n                // 以文件输出流创建FileBuffer，用以控制输出\r\n                FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\r\n                        .getChannel()) {\r\n            // 将FileChannel里的全部数据映射成ByteBuffer\r\n            MappedByteBuffer buffer = inChannel.map(\r\n                    FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\r\n            // 使用GBK的字符集来创建解码器\r\n            Charset charset = Charset.forName(\"GBK\");\r\n            // 直接将buffer里的数据全部输出\r\n            outChannel.write(buffer); // ②\r\n            // 再次调用buffer的clear()方法，复原limit、position的位置\r\n            buffer.clear();\r\n            // 创建解码器(CharsetDecoder)对象\r\n            CharsetDecoder decoder = charset.newDecoder();\r\n            // 使用解码器将ByteBuffer转换成CharBuffer\r\n            CharBuffer charBuffer = decoder.decode(buffer);\r\n            // CharBuffer的toString方法可以获取对应的字符串\r\n            System.out.println(charBuffer);\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 9. NOI.2\r\n>java.nio.file.Path 下的 Path类\r\n\r\n```\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\npublic class NIO2PathDemo {\r\n	public static void main(String[] args) {\r\n		// 以当前路径来创建Path对象\r\n		Path path = Paths.get(\".\");\r\n		System.out.println(\"path里包含的路径数量：\" + path.getNameCount());\r\n		System.out.println(\"path的根路径：\" + path.getRoot());\r\n		\r\n		// 获取path对应的绝对路径。\r\n		Path absolutePath = path.toAbsolutePath();\r\n		System.out.println(absolutePath);\r\n		\r\n		// 获取绝对路径的根路径\r\n		System.out.println(\"absolutePath的根路径：\" + absolutePath.getRoot());\r\n		\r\n		// 获取绝对路径所包含的路径数量\r\n		System.out.println(\"absolutePath里包含的路径数量：\" + absolutePath.getNameCount());\r\n		System.out.println(absolutePath.getName(3));\r\n		\r\n		// 以多个String来构建Path对象\r\n		Path path2 = Paths.get(\"g:\", \"publish\", \"codes\");\r\n		System.out.println(path2);\r\n	}\r\n}\r\n```\r\n\r\n>Files类\r\n\r\n```\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.FileStore;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class NIO2FilesDemo {\r\n	public static void main(String[] args) {\r\n		try {\r\n			// 复制文件\r\n			Files.copy(\r\n					Paths.get(\"src\\\\com\\\\qst\\\\chapter01\\\\NIO2FilesDemo.java\"),\r\n					new FileOutputStream(\"a.txt\"));\r\n			// 判断NIO2FilesDemo.java文件是否为隐藏文件\r\n			System.out.println(\"NIO2FilesDemo.java是否为隐藏文件：\"\r\n					+ Files.isHidden(Paths\r\n							.get(\"src/com/qst/chapter09/NIO2FilesDemo.java\")));\r\n			// 一次性读取FilesTest.java文件的所有行\r\n			List<String> lines = Files.readAllLines(Paths.get(\"src\", \"com\",\r\n					\"qst\", \"chapter09\", \"NIO2FilesDemo.java\"), Charset\r\n					.forName(\"gbk\"));\r\n			System.out.println(\"行数：\" + lines.size());\r\n			// 判断指定文件的大小\r\n			System.out.println(\"a.txt文件的大小为：\" + Files.size(Paths.get(\"a.txt\")));\r\n			List<String> poem = new ArrayList<>();\r\n			poem.add(\"使用NIO.2技术\");\r\n			poem.add(\"往文件中写内容\");\r\n			// 直接将多个字符串内容写入指定文件中\r\n			Files.write(Paths.get(\"pome.txt\"), poem, Charset.forName(\"gbk\"));\r\n			FileStore cStore = Files.getFileStore(Paths.get(\"C:\"));\r\n			// 判断C盘的总空间，可用空间\r\n			System.out.println(\"C:共有空间：\" + cStore.getTotalSpace());\r\n			System.out.println(\"C:可用空间：\" + cStore.getUsableSpace());\r\n		} catch (FileNotFoundException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```' , 'Java' , 2 , '2018-10-09') [ RunTime:0.001185s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000724s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=4  WHERE  `groups` = 'Java' [ RunTime:0.000392s ]
---------------------------------------------------------------
[ 2018-10-09T21:30:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001004s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001205s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001536s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000574s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001043s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000381s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000523s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001005s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000356s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000491s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000437s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000802s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000223s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001317s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000711s ]
---------------------------------------------------------------
[ 2018-10-09T21:30:48+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001061s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001465s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.001337s ]
---------------------------------------------------------------
[ 2018-10-09T21:30:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/209
[ sql ] [ DB ] CONNECT:[ UseTime:0.001207s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002945s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000510s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000943s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000345s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:12+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001053s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001317s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000358s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000965s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000323s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000271s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE - 基础\r',`content`='# Java SE - 基础\r\n[TOC]\r\n## 一. 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## 二. JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 3. 单例设计模式\r\n### 1.意义（想要保证对象唯一）\r\neg: 配置文件的使用。\r\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\r\n### 2.使用方法\r\n先按常规方法对事物进行描述，最后再加上这三步内即可:\r\n1.将构造函数私有化。（其他类中无法再创建该类对象）\r\n2.在类中创建一个本类对象。（静态）\r\n3.提供一个方法可以获取到该对象。（静态）\r\n\r\n>Ps: 为什么要使用静态？\r\n\r\n在主函数中需要调用方法（3），方法的调用有两种：\r\n1.通过对象调用\r\n2.通过类名调用\r\n\r\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\r\n\r\n### 3.例子（饿汉式）\r\n```\r\npackage study;\r\n\r\n/**\r\n * 单例设计模式\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class SingletonPattern {\r\n    public static void main(String[] args) {\r\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\r\n        Student stu2 = Student.getStudent();\r\n        stu1.setAge(18);\r\n        System.out.println(\"stu1 age = \" + stu1.getAge());\r\n        System.out.println(\"stu2 age = \" + stu2.getAge());\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int age;\r\n    private Student(){};    //1. 私有构造函数\r\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\r\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\r\n        return stu;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~stu1 age = 18\r\nstu2 age = 18~~\r\n\r\n---\r\n## 三. 多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 四. 内部类\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=0  WHERE  `id` = 209 [ RunTime:0.000530s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000784s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=4  WHERE  `groups` = 'Java' [ RunTime:0.000490s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000652s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=4  WHERE  `groups` = 'Java' [ RunTime:0.000304s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001319s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001860s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000651s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001352s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000443s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:21+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001354s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001415s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.001451s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:22+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000945s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001401s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Linux' ORDER BY date desc [ RunTime:0.001018s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:24+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000978s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001592s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.001204s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:42+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/214
[ sql ] [ DB ] CONNECT:[ UseTime:0.001019s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001450s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 214 LIMIT 1 [ RunTime:0.000526s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000925s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:49+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/214.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001048s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001285s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 214 LIMIT 1 [ RunTime:0.000466s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 214 LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000898s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000334s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=214,`p_id`=2,`title`='Java SE - 文件和 IO流\r',`content`='# Java SE - 文件和 IO流\r\n[TOC]\r\n## 1. 文件\r\n### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n## 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n## 3. 字节流\r\n### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 4. 字符流\r\n### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n#### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n#### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n## 5. Buffered 缓冲区\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n## 6. 过滤流和转换流\r\n### 过滤流\r\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.FileInputStream;\r\n\r\npublic class BufferedInputStreamDemo {\r\n\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 利用FileInputStream对象创建一个输入缓冲流\r\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\r\n                )\r\n        {\r\n            int result = 0;\r\n            //循环读数据\r\n            while ((result = bi.read()) != -1) {\r\n                //输出\r\n                System.out.print((char) result);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n### 转换流\r\nJava 的 IO流 体系中提供了两个转换流：\r\n- InputStreamReader：将字节输入流转换为字符输入流\r\n- OutputStreamWriter：将字符输出流转换为字节输出流\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class InputStreamReaderDemo {\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\r\n                InputStreamReader reader = new InputStreamReader(System.in);\r\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\r\n                BufferedReader br = new BufferedReader(reader)) {\r\n            String line = null;\r\n            // 采用循环方式来一行一行的读取\r\n            while ((line = br.readLine()) != null) {\r\n                // 如果读取的字符串为\"exit\"，程序退出\r\n                if (line.equals(\"exit\")) {\r\n                    System.exit(1);\r\n                }\r\n                // 打印读取的内容\r\n                System.out.println(\"输入内容为:\" + line);\r\n            }\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n## 7. 对象流\r\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\r\n\r\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\r\n\r\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\r\n\r\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\r\n\r\n```\r\n//定义一个可以序列化的 Person 实体类\r\npublic class Person implements Serializable {\r\n	...\r\n}\r\n```\r\n\r\n>序列化\r\n\r\n```\r\nimport java.io.FileOutputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class ObjectOutputStreamDemo {\r\n\r\n	public static void main(String[] args) {\r\n\r\n		// 创建一个ObjectOutputStream对象输出流\r\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 创建一个Person类型的对象\r\n			Person person = new Person(\"张三\", 25, \"青岛\");\r\n			// 把对象写入到文件中\r\n			obs.writeObject(person);\r\n			obs.flush();\r\n			System.out.println(\"序列化完毕！\");\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n>反序列化\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.ObjectInputStream;\r\n\r\npublic class ObjectInputStreamDemo {\r\n	public static void main(String[] args) {\r\n		// 创建一个ObjectInputStream对象输入流\r\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\r\n			Person person =(Person)ois.readObject();\r\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\r\n			System.out.println(person);\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n## 8. NIO\r\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\r\n\r\nBuffer 和 Channel 是 NIO 中两个核心对象：\r\n- Buffer 可以理解成一个容器，其本质是一个数组。\r\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\r\n\r\n### Buffer\r\n\r\n```\r\nimport java.nio.CharBuffer;\r\n\r\npublic class NIOBufferDemo {\r\n	public static void main(String[] args) {\r\n		// 实例化一个容量为 8 的 CharBuffer\r\n		CharBuffer buff = CharBuffer.allocate(8);\r\n		System.out.println(\"capacity: \"	+ buff.capacity());\r\n		System.out.println(\"limit: \" + buff.limit());\r\n		System.out.println(\"position: \" + buff.position());\r\n		\r\n		// 使用 put 方法，放入元素\r\n		buff.put(\'a\');\r\n		buff.put(\'b\');\r\n		buff.put(\'c\');     \r\n		System.out.println(\"加入三个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 flip() 方法，反转缓冲区\r\n		buff.flip();	  // ③\r\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\r\n		System.out.println(\"position = \" + buff.position());\r\n		\r\n		// get 方法，取出第一个元素\r\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \r\n		System.out.println(\"取出一个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 clear 方法，清除缓冲区\r\n		buff.clear(); \r\n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\r\n		System.out.println(\"执行clear()后，position = \" + buff.position());\r\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\r\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\r\n\r\n	}\r\n\r\n}\r\n```\r\n### Channel\r\nChannel 与传统的 IO流 类似，但主要有两点区别：\r\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\r\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\r\n>将 FileChannel 的所有数据映射成 ByteBuffer\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.CharBuffer;\r\nimport java.nio.MappedByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.CharsetDecoder;\r\n\r\npublic class NIOFileChannelDemo {\r\n    public static void main(String[] args) {\r\n        File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\r\n        try (\r\n                // 创建FileInputStream，以该文件输入流创建FileChannel\r\n                FileChannel inChannel = new FileInputStream(f).getChannel();\r\n                // 以文件输出流创建FileBuffer，用以控制输出\r\n                FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\r\n                        .getChannel()) {\r\n            // 将FileChannel里的全部数据映射成ByteBuffer\r\n            MappedByteBuffer buffer = inChannel.map(\r\n                    FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\r\n            // 使用GBK的字符集来创建解码器\r\n            Charset charset = Charset.forName(\"GBK\");\r\n            // 直接将buffer里的数据全部输出\r\n            outChannel.write(buffer); // ②\r\n            // 再次调用buffer的clear()方法，复原limit、position的位置\r\n            buffer.clear();\r\n            // 创建解码器(CharsetDecoder)对象\r\n            CharsetDecoder decoder = charset.newDecoder();\r\n            // 使用解码器将ByteBuffer转换成CharBuffer\r\n            CharBuffer charBuffer = decoder.decode(buffer);\r\n            // CharBuffer的toString方法可以获取对应的字符串\r\n            System.out.println(charBuffer);\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 9. NOI.2\r\n>java.nio.file.Path 下的 Path类\r\n\r\n```\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\npublic class NIO2PathDemo {\r\n	public static void main(String[] args) {\r\n		// 以当前路径来创建Path对象\r\n		Path path = Paths.get(\".\");\r\n		System.out.println(\"path里包含的路径数量：\" + path.getNameCount());\r\n		System.out.println(\"path的根路径：\" + path.getRoot());\r\n		\r\n		// 获取path对应的绝对路径。\r\n		Path absolutePath = path.toAbsolutePath();\r\n		System.out.println(absolutePath);\r\n		\r\n		// 获取绝对路径的根路径\r\n		System.out.println(\"absolutePath的根路径：\" + absolutePath.getRoot());\r\n		\r\n		// 获取绝对路径所包含的路径数量\r\n		System.out.println(\"absolutePath里包含的路径数量：\" + absolutePath.getNameCount());\r\n		System.out.println(absolutePath.getName(3));\r\n		\r\n		// 以多个String来构建Path对象\r\n		Path path2 = Paths.get(\"g:\", \"publish\", \"codes\");\r\n		System.out.println(path2);\r\n	}\r\n}\r\n```\r\n\r\n>Files类\r\n\r\n```\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.FileStore;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class NIO2FilesDemo {\r\n	public static void main(String[] args) {\r\n		try {\r\n			// 复制文件\r\n			Files.copy(\r\n					Paths.get(\"src\\\\com\\\\qst\\\\chapter01\\\\NIO2FilesDemo.java\"),\r\n					new FileOutputStream(\"a.txt\"));\r\n			// 判断NIO2FilesDemo.java文件是否为隐藏文件\r\n			System.out.println(\"NIO2FilesDemo.java是否为隐藏文件：\"\r\n					+ Files.isHidden(Paths\r\n							.get(\"src/com/qst/chapter09/NIO2FilesDemo.java\")));\r\n			// 一次性读取FilesTest.java文件的所有行\r\n			List<String> lines = Files.readAllLines(Paths.get(\"src\", \"com\",\r\n					\"qst\", \"chapter09\", \"NIO2FilesDemo.java\"), Charset\r\n					.forName(\"gbk\"));\r\n			System.out.println(\"行数：\" + lines.size());\r\n			// 判断指定文件的大小\r\n			System.out.println(\"a.txt文件的大小为：\" + Files.size(Paths.get(\"a.txt\")));\r\n			List<String> poem = new ArrayList<>();\r\n			poem.add(\"使用NIO.2技术\");\r\n			poem.add(\"往文件中写内容\");\r\n			// 直接将多个字符串内容写入指定文件中\r\n			Files.write(Paths.get(\"pome.txt\"), poem, Charset.forName(\"gbk\"));\r\n			FileStore cStore = Files.getFileStore(Paths.get(\"C:\"));\r\n			// 判断C盘的总空间，可用空间\r\n			System.out.println(\"C:共有空间：\" + cStore.getTotalSpace());\r\n			System.out.println(\"C:可用空间：\" + cStore.getUsableSpace());\r\n		} catch (FileNotFoundException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```',`groups`='Java',`is_show`=0  WHERE  `id` = 214 [ RunTime:0.000993s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000757s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=4  WHERE  `groups` = 'Java' [ RunTime:0.000350s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000642s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=4  WHERE  `groups` = 'Java' [ RunTime:0.000308s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:50+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/214.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001408s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002080s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 214 LIMIT 1 [ RunTime:0.000706s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001481s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000890s ]
---------------------------------------------------------------
[ 2018-10-09T21:31:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001008s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001254s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000302s ]
---------------------------------------------------------------
[ 2018-10-09T21:32:23+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001043s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001177s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000401s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000350s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.000899s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('Java SE - JDBC' , '# Java SE - JDBC' , 'Java' , 2 , '2018-10-09') [ RunTime:0.000391s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000888s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=5  WHERE  `groups` = 'Java' [ RunTime:0.000390s ]
---------------------------------------------------------------
[ 2018-10-09T21:32:24+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.000961s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001381s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001368s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000489s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000957s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000308s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000478s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000962s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000376s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000429s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000371s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000730s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000217s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001097s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000693s ]
---------------------------------------------------------------
[ 2018-10-09T21:32:29+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001042s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001341s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.000986s ]
---------------------------------------------------------------
[ 2018-10-09T21:32:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215
[ sql ] [ DB ] CONNECT:[ UseTime:0.000980s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001304s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000488s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.000957s ]
[ error ] [0]数据表字段不存在:[is_show]
---------------------------------------------------------------
[ 2018-10-09T21:32:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.000951s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001179s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000546s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001019s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000314s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000478s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001033s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000282s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000415s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000403s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000412s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000873s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000324s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001095s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000755s ]
---------------------------------------------------------------
[ 2018-10-09T21:32:57+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001045s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001568s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.001431s ]
---------------------------------------------------------------
[ 2018-10-09T21:33:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215
[ sql ] [ DB ] CONNECT:[ UseTime:0.001057s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001390s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000500s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000377s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.001093s ]
[ error ] [0]数据表字段不存在:[is_show]
---------------------------------------------------------------
[ 2018-10-09T21:33:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.000928s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001941s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001128s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000502s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000920s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000472s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000911s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000288s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000366s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000375s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000794s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000286s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001093s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000619s ]
---------------------------------------------------------------
[ 2018-10-09T21:33:04+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001026s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001215s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001220s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000567s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000936s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000483s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000954s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000423s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000449s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000360s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000743s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000227s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001137s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000648s ]
---------------------------------------------------------------
[ 2018-10-09T21:33:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001052s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001301s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000391s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000307s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.001035s ]
[ error ] [0]数据表字段不存在:[is_show]
---------------------------------------------------------------
[ 2018-10-09T21:33:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000951s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000405s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000280s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.000957s ]
[ error ] [0]数据表字段不存在:[is_show]
---------------------------------------------------------------
[ 2018-10-09T21:33:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001021s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002374s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001567s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000583s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001047s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000373s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000501s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001213s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000341s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000516s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000278s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000416s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000760s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000313s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001240s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000583s ]
---------------------------------------------------------------
[ 2018-10-09T21:33:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001047s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001294s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001409s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000723s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001095s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000377s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000436s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000840s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000317s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000464s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000297s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000352s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000798s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000219s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001066s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000606s ]
---------------------------------------------------------------
[ 2018-10-09T21:43:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215.html
[ info ] qingrang.top/daily/admin/note/delnote/id/215.html [运行时间：0.059895s][吞吐率：16.70req/s] [内存消耗：3,143.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'delnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '215',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->delNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000582s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001357s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000382s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000288s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.001142s ]
[ error ] [0]数据表字段不存在:[is_show][/var/www/html/daily/thinkphp/library/think/db/Builder.php:109]
---------------------------------------------------------------
[ 2018-10-09T21:44:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.111559s][吞吐率：8.96req/s] [内存消耗：2,254.92kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000630s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001658s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001611s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000665s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001285s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000424s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000656s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000365s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000565s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000382s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000495s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001071s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001507s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000910s ]
---------------------------------------------------------------
[ 2018-10-09T21:44:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/215.html
[ info ] qingrang.top/daily/admin/note/editnote/id/215.html [运行时间：0.055079s][吞吐率：18.16req/s] [内存消耗：2,036.54kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '215',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000565s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001300s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000421s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000901s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000350s ]
---------------------------------------------------------------
[ 2018-10-09T21:44:15+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/215.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/215.html [运行时间：0.055212s][吞吐率：18.11req/s] [内存消耗：2,044.40kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '48',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/215.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'content' => '# Java SE - JDBC',
  'groups' => 'Java',
  'showsel' => '0',
  'id' => '215',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000539s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001397s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000330s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001158s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000323s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000411s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=215,`p_id`=2,`title`='Java SE - JDBC',`content`='# Java SE - JDBC',`groups`='Java',`is_show`=0  WHERE  `id` = 215 [ RunTime:0.000431s ]
---------------------------------------------------------------
[ 2018-10-09T21:44:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/215.html
[ info ] qingrang.top/daily/admin/note/editnote/id/215.html [运行时间：0.053456s][吞吐率：18.71req/s] [内存消耗：2,036.89kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/updatenote/id/215.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '215',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000551s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001315s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000417s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001028s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000338s ]
---------------------------------------------------------------
[ 2018-10-09T21:45:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/213.html
[ info ] qingrang.top/daily/admin/note/delnote/id/213.html [运行时间：0.056434s][吞吐率：17.72req/s] [内存消耗：3,168.32kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'delnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '213',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->delNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000520s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001219s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000474s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000296s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.000883s ]
[ error ] [0]数据表字段不存在:[is_show][/var/www/html/daily/thinkphp/library/think/db/Builder.php:109]
---------------------------------------------------------------
[ 2018-10-09T21:45:24+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.068039s][吞吐率：14.70req/s] [内存消耗：2,254.92kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000526s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001176s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001257s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000581s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000963s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000486s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000863s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000296s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000668s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000603s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000376s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000825s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000225s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001196s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000694s ]
---------------------------------------------------------------
[ 2018-10-09T21:45:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215.html
[ info ] qingrang.top/daily/admin/note/delnote/id/215.html [运行时间：0.053601s][吞吐率：18.66req/s] [内存消耗：3,143.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'delnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '215',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->delNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000497s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000405s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000329s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.000864s ]
[ error ] [0]数据表字段不存在:[is_show][/var/www/html/daily/thinkphp/library/think/db/Builder.php:109]
---------------------------------------------------------------
[ 2018-10-09T21:47:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.070978s][吞吐率：14.09req/s] [内存消耗：2,254.92kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000869s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001233s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000536s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000966s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000426s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000644s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000943s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000366s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000457s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000393s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000781s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000224s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001093s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000772s ]
---------------------------------------------------------------
[ 2018-10-09T21:47:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.070728s][吞吐率：14.14req/s] [内存消耗：2,255.11kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000469s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001244s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000517s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000948s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000351s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000487s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000912s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000330s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000912s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000396s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000369s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000868s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000285s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001151s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000833s ]
---------------------------------------------------------------
[ 2018-10-09T21:48:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/215.html
[ info ] qingrang.top/daily/admin/note/delnote/id/215.html [运行时间：0.064714s][吞吐率：15.45req/s] [内存消耗：2,054.11kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'delnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '215',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->delNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000491s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001301s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000410s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 215 LIMIT 1 [ RunTime:0.000327s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.001338s ]
[ sql ] [ SQL ] INSERT INTO `note_del` (`id` , `title` , `content` , `date` , `groups` , `p_id` , `is_show`) VALUES (215 , 'Java SE - JDBC' , '# Java SE - JDBC' , '2018-10-09' , 'Java' , 2 , 0) [ RunTime:0.000406s ]
[ sql ] [ SQL ] DELETE FROM `note`    WHERE  `id` = 215 [ RunTime:0.000456s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000835s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001096s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=4  WHERE  `groups` = 'Java' [ RunTime:0.000405s ]
---------------------------------------------------------------
[ 2018-10-09T21:48:04+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.087624s][吞吐率：11.41req/s] [内存消耗：2,264.23kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000699s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001611s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001635s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000779s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001372s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000356s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000557s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001101s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000369s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000450s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000547s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000806s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000298s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001236s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000676s ]
---------------------------------------------------------------
[ 2018-10-09T21:48:11+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/213.html
[ info ] qingrang.top/daily/admin/note/delnote/id/213.html [运行时间：0.066065s][吞吐率：15.14req/s] [内存消耗：2,135.20kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'delnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '213',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->delNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000495s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001195s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000511s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 213 LIMIT 1 [ RunTime:0.000342s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.001311s ]
[ sql ] [ SQL ] INSERT INTO `note_del` (`id` , `title` , `content` , `date` , `groups` , `p_id` , `is_show`) VALUES (213 , '临时\r' , '# 临时\r\n[TOC]\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n### 5. Buffered 缓冲区\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n#### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n#### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n### 6. 过滤流和转换流\r\n#### 过滤流\r\n过滤流对一个已有的流进行连接和封装，以更加便利的方式对数据进行读写操作，过滤流又分为过滤输入流和过滤输出流。\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.FileInputStream;\r\n\r\npublic class BufferedInputStreamDemo {\r\n\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 利用FileInputStream对象创建一个输入缓冲流\r\n                BufferedInputStream bi = new BufferedInputStream(new FileInputStream(\"Demo.txt\"));\r\n                )\r\n        {\r\n            int result = 0;\r\n            //循环读数据\r\n            while ((result = bi.read()) != -1) {\r\n                //输出\r\n                System.out.print((char) result);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### 转换流\r\nJava 的 IO流 体系中提供了两个转换流：\r\n- InputStreamReader：将字节输入流转换为字符输入流\r\n- OutputStreamWriter：将字符输出流转换为字节输出流\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\n\r\npublic class InputStreamReaderDemo {\r\n    public static void main(String[] args) {\r\n        try (\r\n                // 将 Sytem.in 标准输入流 InputStream 字节流转换成 Reader 字符流\r\n                InputStreamReader reader = new InputStreamReader(System.in);\r\n                // 将普通 Reader 包装成 BufferedReader，BufferedReader 具有缓冲功能\r\n                BufferedReader br = new BufferedReader(reader)) {\r\n            String line = null;\r\n            // 采用循环方式来一行一行的读取\r\n            while ((line = br.readLine()) != null) {\r\n                // 如果读取的字符串为\"exit\"，程序退出\r\n                if (line.equals(\"exit\")) {\r\n                    System.exit(1);\r\n                }\r\n                // 打印读取的内容\r\n                System.out.println(\"输入内容为:\" + line);\r\n            }\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n### 7. 对象流\r\n在 Java 中，使用对象流可实现对象的序列化和反序列化。\r\n\r\n对象的序列化是指将对象数据写到一个输出流中的过程；而对象的反序列化是指从一个输入流中读取一个对象。\r\n\r\n在 Java 中，如果需要将某个对象保存到磁盘或通过网络传输，则该对象必须是可以序列化的。\r\n\r\n若一个类的对象是可序列化的，则该类必须实现 java.lang 包下的 Serializable 接口或 Externalizable 接口。\r\n\r\n```\r\n//定义一个可以序列化的 Person 实体类\r\npublic class Person implements Serializable {\r\n	...\r\n}\r\n```\r\n\r\n>序列化\r\n\r\n```\r\nimport java.io.FileOutputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class ObjectOutputStreamDemo {\r\n\r\n	public static void main(String[] args) {\r\n\r\n		// 创建一个ObjectOutputStream对象输出流\r\n		try (ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 创建一个Person类型的对象\r\n			Person person = new Person(\"张三\", 25, \"青岛\");\r\n			// 把对象写入到文件中\r\n			obs.writeObject(person);\r\n			obs.flush();\r\n			System.out.println(\"序列化完毕！\");\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n>反序列化\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.ObjectInputStream;\r\n\r\npublic class ObjectInputStreamDemo {\r\n	public static void main(String[] args) {\r\n		// 创建一个ObjectInputStream对象输入流\r\n		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:\\\\PersonObject.txt\"))) {\r\n			// 从ObjectInputStream对象输入流中读取一个对象，并强制转换成Person对象\r\n			Person person =(Person)ois.readObject();\r\n			System.out.println(\"序列化完毕！读出的对象信息如下：\");\r\n			System.out.println(person);\r\n		} catch (Exception ex) {\r\n			ex.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```\r\n### 8. NIO\r\nNIO 将文件或文件的一段区域映射到内存中，这样可以像访问内存一样来访问文件。\r\n\r\nBuffer 和 Channel 是 NIO 中两个核心对象：\r\n- Buffer 可以理解成一个容器，其本质是一个数组。\r\n- Channel 是对传统 IO 系统的模拟，在 NIO 系统中所有数据都需要经过通道传输；Channel 与传统的 InputStream、OutputStream最大的区别是提供一个 map() 方法，通过该方法可以直接将一块数据映射到内存中。\r\n\r\n#### Buffer\r\n\r\n```\r\nimport java.nio.CharBuffer;\r\n\r\npublic class NIOBufferDemo {\r\n	public static void main(String[] args) {\r\n		// 实例化一个容量为 8 的 CharBuffer\r\n		CharBuffer buff = CharBuffer.allocate(8);\r\n		System.out.println(\"capacity: \"	+ buff.capacity());\r\n		System.out.println(\"limit: \" + buff.limit());\r\n		System.out.println(\"position: \" + buff.position());\r\n		\r\n		// 使用 put 方法，放入元素\r\n		buff.put(\'a\');\r\n		buff.put(\'b\');\r\n		buff.put(\'c\');     \r\n		System.out.println(\"加入三个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 flip() 方法，反转缓冲区\r\n		buff.flip();	  // ③\r\n		System.out.println(\"执行flip()后，limit = \" + buff.limit());\r\n		System.out.println(\"position = \" + buff.position());\r\n		\r\n		// get 方法，取出第一个元素\r\n		System.out.println(\"第一个元素(position=0)：\" + buff.get()); \r\n		System.out.println(\"取出一个元素后，position = \" + buff.position());\r\n		\r\n		// 调用 clear 方法，清除缓冲区\r\n		buff.clear(); \r\n		System.out.println(\"执行clear()后，limit = \" + buff.limit());\r\n		System.out.println(\"执行clear()后，position = \" + buff.position());\r\n		System.out.println(\"执行clear()后，缓冲区内容并没有被清除：\" + \"第三个元素为：\" +  buff.get(2));\r\n		System.out.println(\"执行绝对读取后，position = \" + buff.position());\r\n\r\n	}\r\n\r\n}\r\n```\r\n#### Channel\r\nChannel 与传统的 IO流 类似，但主要有两点区别：\r\n- Channel 类可以直接将指定文件的部分或全部直接映射成 Buffer\r\n- 程序不能直接访问 Channel 中的数据，Channel 只能与 Buffer 进行交互\r\n>将 FileChannel 的所有数据映射成 ByteBuffer\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.CharBuffer;\r\nimport java.nio.MappedByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.CharsetDecoder;\r\n\r\npublic class NIOFileChannelDemo {\r\n    public static void main(String[] args) {\r\n        File f = new File(\"src\\\\com\\\\qst\\\\chapter01\\\\NIOFileChannelDemo.java\");\r\n        try (\r\n                // 创建FileInputStream，以该文件输入流创建FileChannel\r\n                FileChannel inChannel = new FileInputStream(f).getChannel();\r\n                // 以文件输出流创建FileBuffer，用以控制输出\r\n                FileChannel outChannel = new FileOutputStream(\"D:\\\\channel.txt\")\r\n                        .getChannel()) {\r\n            // 将FileChannel里的全部数据映射成ByteBuffer\r\n            MappedByteBuffer buffer = inChannel.map(\r\n                    FileChannel.MapMode.READ_ONLY, 0, f.length()); // ①\r\n            // 使用GBK的字符集来创建解码器\r\n            Charset charset = Charset.forName(\"GBK\");\r\n            // 直接将buffer里的数据全部输出\r\n            outChannel.write(buffer); // ②\r\n            // 再次调用buffer的clear()方法，复原limit、position的位置\r\n            buffer.clear();\r\n            // 创建解码器(CharsetDecoder)对象\r\n            CharsetDecoder decoder = charset.newDecoder();\r\n            // 使用解码器将ByteBuffer转换成CharBuffer\r\n            CharBuffer charBuffer = decoder.decode(buffer);\r\n            // CharBuffer的toString方法可以获取对应的字符串\r\n            System.out.println(charBuffer);\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 9. NOI.2\r\n>java.nio.file.Path 下的 Path类\r\n\r\n```\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\npublic class NIO2PathDemo {\r\n	public static void main(String[] args) {\r\n		// 以当前路径来创建Path对象\r\n		Path path = Paths.get(\".\");\r\n		System.out.println(\"path里包含的路径数量：\" + path.getNameCount());\r\n		System.out.println(\"path的根路径：\" + path.getRoot());\r\n		\r\n		// 获取path对应的绝对路径。\r\n		Path absolutePath = path.toAbsolutePath();\r\n		System.out.println(absolutePath);\r\n		\r\n		// 获取绝对路径的根路径\r\n		System.out.println(\"absolutePath的根路径：\" + absolutePath.getRoot());\r\n		\r\n		// 获取绝对路径所包含的路径数量\r\n		System.out.println(\"absolutePath里包含的路径数量：\" + absolutePath.getNameCount());\r\n		System.out.println(absolutePath.getName(3));\r\n		\r\n		// 以多个String来构建Path对象\r\n		Path path2 = Paths.get(\"g:\", \"publish\", \"codes\");\r\n		System.out.println(path2);\r\n	}\r\n}\r\n```\r\n\r\n>Files类\r\n\r\n```\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.file.FileStore;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class NIO2FilesDemo {\r\n	public static void main(String[] args) {\r\n		try {\r\n			// 复制文件\r\n			Files.copy(\r\n					Paths.get(\"src\\\\com\\\\qst\\\\chapter01\\\\NIO2FilesDemo.java\"),\r\n					new FileOutputStream(\"a.txt\"));\r\n			// 判断NIO2FilesDemo.java文件是否为隐藏文件\r\n			System.out.println(\"NIO2FilesDemo.java是否为隐藏文件：\"\r\n					+ Files.isHidden(Paths\r\n							.get(\"src/com/qst/chapter09/NIO2FilesDemo.java\")));\r\n			// 一次性读取FilesTest.java文件的所有行\r\n			List<String> lines = Files.readAllLines(Paths.get(\"src\", \"com\",\r\n					\"qst\", \"chapter09\", \"NIO2FilesDemo.java\"), Charset\r\n					.forName(\"gbk\"));\r\n			System.out.println(\"行数：\" + lines.size());\r\n			// 判断指定文件的大小\r\n			System.out.println(\"a.txt文件的大小为：\" + Files.size(Paths.get(\"a.txt\")));\r\n			List<String> poem = new ArrayList<>();\r\n			poem.add(\"使用NIO.2技术\");\r\n			poem.add(\"往文件中写内容\");\r\n			// 直接将多个字符串内容写入指定文件中\r\n			Files.write(Paths.get(\"pome.txt\"), poem, Charset.forName(\"gbk\"));\r\n			FileStore cStore = Files.getFileStore(Paths.get(\"C:\"));\r\n			// 判断C盘的总空间，可用空间\r\n			System.out.println(\"C:共有空间：\" + cStore.getTotalSpace());\r\n			System.out.println(\"C:可用空间：\" + cStore.getUsableSpace());\r\n		} catch (FileNotFoundException e) {\r\n			e.printStackTrace();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n	}\r\n}\r\n```' , '2018-10-09' , 'Default' , 1 , 1) [ RunTime:0.001534s ]
[ sql ] [ SQL ] DELETE FROM `note`    WHERE  `id` = 213 [ RunTime:0.000488s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001056s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001558s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000520s ]
---------------------------------------------------------------
[ 2018-10-09T21:48:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.065099s][吞吐率：15.36req/s] [内存消耗：2,217.82kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000474s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001282s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001190s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000533s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000984s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000358s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000468s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000925s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000298s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000372s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000284s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000367s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000722s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000217s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000978s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000598s ]
---------------------------------------------------------------
[ 2018-10-09T21:49:18+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.075949s][吞吐率：13.17req/s] [内存消耗：2,133.71kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '31',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => '亲爱的',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000953s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002201s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%亲爱的%' OR `content` LIKE '%亲爱的%' ) ORDER BY date desc [ RunTime:0.018993s ]
---------------------------------------------------------------
[ 2018-10-09T21:50:02+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.061445s][吞吐率：16.27req/s] [内存消耗：2,133.90kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '94',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => '数据库每天自动定时备',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000572s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002014s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%数据库每天自动定时备%' OR `content` LIKE '%数据库每天自动定时备%' ) ORDER BY date desc [ RunTime:0.007420s ]
---------------------------------------------------------------
[ 2018-10-09T21:50:06+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.059937s][吞吐率：16.68req/s] [内存消耗：2,133.90kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '94',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => '数据库每天自动定时备',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000475s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001491s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%数据库每天自动定时备%' OR `content` LIKE '%数据库每天自动定时备%' ) ORDER BY date desc [ RunTime:0.006768s ]
---------------------------------------------------------------
[ 2018-10-09T21:50:10+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.056894s][吞吐率：17.58req/s] [内存消耗：2,215.34kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '31',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => '数据库',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000490s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001196s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%数据库%' OR `content` LIKE '%数据库%' ) ORDER BY date desc [ RunTime:0.007005s ]
---------------------------------------------------------------
[ 2018-10-09T21:50:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/94
[ info ] qingrang.top/daily/admin/note/shownote/id/94 [运行时间：0.081583s][吞吐率：12.26req/s] [内存消耗：1,991.80kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '94',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000689s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001808s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 94 LIMIT 1 [ RunTime:0.000547s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001317s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000441s ]
---------------------------------------------------------------
[ 2018-10-09T21:50:29+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.051265s][吞吐率：19.51req/s] [内存消耗：2,219.11kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '15',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'Linux',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000519s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001390s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Linux' ORDER BY date desc [ RunTime:0.001081s ]
---------------------------------------------------------------
[ 2018-10-09T21:51:28+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.066830s][吞吐率：14.96req/s] [内存消耗：2,133.72kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '40',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => '可可西里',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000764s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001622s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%可可西里%' OR `content` LIKE '%可可西里%' ) ORDER BY date desc [ RunTime:0.007094s ]
---------------------------------------------------------------
[ 2018-10-09T21:54:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ info ] qingrang.top/daily/admin/note/ashownote1.html [运行时间：0.051497s][吞吐率：19.42req/s] [内存消耗：2,234.45kb] [文件加载：53]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote1',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupsID' => '3',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote1[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000728s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001787s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 3  AND `id` > 2 ORDER BY date desc [ RunTime:0.001138s ]
---------------------------------------------------------------
[ 2018-10-09T21:54:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/10
[ info ] qingrang.top/daily/admin/note/shownote/id/10 [运行时间：0.063567s][吞吐率：15.73req/s] [内存消耗：1,989.10kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '10',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000417s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 10 LIMIT 1 [ RunTime:0.000442s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000855s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000314s ]
---------------------------------------------------------------
[ 2018-10-09T21:54:38+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.054019s][吞吐率：18.51req/s] [内存消耗：2,135.46kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '58',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => '人生中最寂寞',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000526s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001277s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%人生中最寂寞%' OR `content` LIKE '%人生中最寂寞%' ) ORDER BY date desc [ RunTime:0.006463s ]
---------------------------------------------------------------
[ 2018-10-09T22:02:49+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ info ] qingrang.top/daily/admin/note/ashownote1.html [运行时间：0.074355s][吞吐率：13.45req/s] [内存消耗：2,234.45kb] [文件加载：53]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote1',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupsID' => '3',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote1[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000494s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001561s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 3  AND `id` > 2 ORDER BY date desc [ RunTime:0.001653s ]
---------------------------------------------------------------
[ 2018-10-09T22:03:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/10
[ info ] qingrang.top/daily/admin/note/shownote/id/10 [运行时间：0.053461s][吞吐率：18.71req/s] [内存消耗：1,988.63kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '10',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000638s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001325s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 10 LIMIT 1 [ RunTime:0.000419s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000846s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000300s ]
---------------------------------------------------------------
[ 2018-10-09T22:03:09+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ info ] qingrang.top/daily/admin/note/ashownote1.html [运行时间：0.052464s][吞吐率：19.06req/s] [内存消耗：2,226.46kb] [文件加载：53]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote1',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '11',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupsID' => '20',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote1[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000556s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001251s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 20  AND `id` > 2 ORDER BY date desc [ RunTime:0.001278s ]
---------------------------------------------------------------
[ 2018-10-09T22:03:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.077939s][吞吐率：12.83req/s] [内存消耗：2,220.39kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000725s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001439s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001357s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000622s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001167s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000363s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000633s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001112s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000322s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000451s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000311s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000397s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000918s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000267s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001301s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000715s ]
---------------------------------------------------------------
[ 2018-10-09T22:03:39+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ info ] qingrang.top/daily/admin/note/ashownote1.html [运行时间：0.051992s][吞吐率：19.23req/s] [内存消耗：2,234.45kb] [文件加载：53]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote1',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupsID' => '3',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote1[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000562s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001747s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 3  AND `id` > 2 ORDER BY date desc [ RunTime:0.001544s ]
---------------------------------------------------------------
[ 2018-10-09T22:15:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.098921s][吞吐率：10.11req/s] [内存消耗：2,220.39kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000742s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001441s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001770s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000541s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001105s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000407s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000500s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000949s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000304s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000522s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000450s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000617s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001205s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000407s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001759s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001073s ]
---------------------------------------------------------------
[ 2018-10-09T22:15:40+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.052464s][吞吐率：19.06req/s] [内存消耗：2,138.63kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '13',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=umh5sjtplqfv9ogsafvhvrcab7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'PHP',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000609s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001469s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'PHP' ORDER BY date desc [ RunTime:0.000928s ]
---------------------------------------------------------------
[ 2018-10-09T22:22:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.034238s][吞吐率：29.21req/s] [内存消耗：1,339.37kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-09T22:22:37+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.049268s][吞吐率：20.30req/s] [内存消耗：1,922.05kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000531s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001191s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000380s ]
---------------------------------------------------------------
[ 2018-10-09T22:22:38+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.082419s][吞吐率：12.13req/s] [内存消耗：2,220.56kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000463s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001259s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001118s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000594s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001062s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000365s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000632s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001028s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000363s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000440s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000281s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000451s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000814s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000251s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001083s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000695s ]
---------------------------------------------------------------
[ 2018-10-09T22:26:52+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/32.html
[ info ] qingrang.top/daily/admin/note/editnote/id/32.html [运行时间：0.060486s][吞吐率：16.53req/s] [内存消耗：2,100.14kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '32',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000652s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001571s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000535s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001219s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000288s ]
---------------------------------------------------------------
[ 2018-10-09T22:27:41+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/32.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/32.html [运行时间：0.082449s][吞吐率：12.13req/s] [内存消耗：2,338.91kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '106643',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/32.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'content' => '# 写出这些话的人，我估计一辈子都追不上了
1. 如果发出声音是危险的，那就保持沉默；如果自觉无力发光，那就别去照亮别人。但是，不要习惯了黑暗就为黑暗辩护不要为自己的苟且而得意洋洋；不要嘲讽那些比自己更勇敢，更有热量的人们。可以卑微如尘土，不可扭曲如蛆虫。
2. 你多学一样本事，就少说一句求人的话。
3. 我38岁那年，琢磨着要不要去读两年的放射线照相术大专学位。然后我跟我朋友说了这事，我觉得自己太老了，等拿到学位是，我都40岁了。
--朋友说，如果你不读，你还是会40岁，一个没有学位的40岁。
4.	这些年来我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没有放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。
5.	孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是，我希望你将来会拥有选择的权利，选择有意义，有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。
6.	最终我们都将学会，与他人交往，最重要的不是甜言蜜语，不是容貌金钱，而是你和他对于这个世界的看法，对人生的态度是否一致。
7.	我们一路奋战，不是为了改变世界，而是为了世界不再改变我们。
8.	不要欺骗别人，因为你能骗到的人，都是相信你的人。
9.	熟练的运用"关我屁事"和"关你屁事"可以省下人生80％的时间。
10.	我怎么敢倒下。我身后空无一人。
11.	"痛苦是财富，这话是扯淡。姑娘，痛苦就是痛苦，对痛苦的思考才是财富。"
12.	永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。
13.	如果我不曾见过太阳，我本可以忍受黑暗。
14.	社交之所以累，是因为每个人都试图展现出自己其实并不具备的品质。
15.	读书：之前觉得自己是一个人，现在觉得自己可以是一个世界。
16.	希望你今天白费的努力，早晚有一天变成值得。
17.	历史：遗忘，对倒下的人不公平。
18.	南京大屠杀：
安培说：现在日本的年轻人没有义务为过去的日本人像现在的中国人道歉。
那现在的中国人也没有权利为过去的中国人原谅现在的日本人。
19.	明明别人轻轻松松可以做到的事，我却做不了。满满的无力感，无力到没有力气。
20.	人的一切痛苦，本质上都是对自己无能的愤怒。
21.	不要试图同情你自己。
22.	你配得上你自己想要的生活吗？
23.	什么叫成熟？
了解自己，了解自己的欲望，了解自己的局限。理解别人，理解别人的欲望，理解别人的局限。
24.	我们会看到要寻找的东西，错失不去寻找的东西，虽然它在那里。我们的阅历被我们的关注点深深地影响了。
25.	做你害怕做的事，然后你会发现，不过如此。
26.	一直认为，所谓新鲜感，不是和未知的人一起去做同样的事，而是和已知的人一起去体验未知的人生。
27.	如果不能随时有限的反击，所有的宽容都是懦弱。
28.	群众的眼睛不是雪亮的，群众的眼睛是盲目的。
29.	不是所有的人都能功成名就，我们中有些人注定要在日常的点滴中寻找生命的意义。
30.	带人友善是修养，独来独往是性格。
31.	几年前踏上火车那一刻还没有意识到，从此故乡只有冬夏，再无春秋。
32.	十年饮水，难凉热血。
33.	德，律己为德，律人无异于私刑。
34.	信仰，他可以与宗教无关，代表自己的精神追求。
35.	人最重要的能力有两个，适应环境，不忘初心。适应环境可以安身，不忘初心可以立命。
36.	维护不在场的人，所言不多于所知。
37.	只有你愿意为之而死的东西，你才可以藉之而生。
38.	你见过树，却没见过森林。
39.	那些杀不死你的最终都会使你更强壮。
40.	是你把你的秘密告诉了风，那就别怪风把他带给树。
41.	似乎大家都这样。自命不凡，却无足轻重。
42.	保安笑着问我："你那么小个子，开那么大个车？"的时候。我傻笑着回答："你是当保安，我是当司机的。"
43.	猪会飞，是因为他站在了风口上，成功的飞起来以后他可以总结起飞技巧，但重要的，是风。
44.	你现在做的每一件事看来并没有什么意义，但他们也许会在未来助你 一臂之力。
45.	唱出本身就是最要不得的态度。当你做某件事的时候，一旦想要求快，就表示你再也不关心他，而是想去做别的事。
46.	命运啊，说是注定，不如说是你在何时做了选择。
47.	在一群出色的人中间，常常误以为自己也是其中一员，然后忘了努力。
48.	只有经历过地狱磨难的人，才有建造天堂的力量。
49.	一个伟大的人往往受到排挤，压抑，甚至被人斥为哗众取宠而陷于孤独中。
50.	与怪物战斗的人，应当小心自己不要成为怪物。当你远远凝视深渊时，深渊也在凝视你。
51.	一个人知道自己为什么而活，就可以忍受任何一种生活。
52.	假如我们不去打仗，敌人用刺刀杀死了我们，还要指着我们的骨头说：看，这是奴隶。
53.	我有一事，生死与之。
54.	我的体内啊，有个器官比心脏还重要，他虽然看不见，但却是在我的体内从脑袋一直贯穿到胯间。就因为他，我才能站着直，坐着正，就算脚步摇晃也能笔直地向前行，在这里退缩的话，那东西就会折断。
55.	不可能这三个字，你说的太多了。
56.	世界上没遇上帝，如果有的话，我无法容忍我不是。－－尼采
57.	剑在英雄手，登台傲王侯。－－比莫干《九州缥缈录》
58.	武士的一生，只相信自己手中可以握住的东西。－－赢无翳《九州缥缈录》
59.	为天地立心，为生民立命，为往圣继绝学，为万世开太平。－－北宋时期张载
60.	为不能作战的人而战。
61.	你的成功标准： 能做自己喜欢做的事，能只做自己喜欢做的事。
62.	如何不招人厌的展现自己的学识：别人问了，你再答。
63.	无论现实如何操蛋，你都能在心里有一个更诗意的世界，那个世界便是情怀。
64.	情怀就是以心灵的满足而不是功利的得失作为自己的行为标准的一种品质。一件没有什么用的事，还是要去做，也许只是因为我喜欢，也许只是因为它看起来很美。
65.	跟优秀的人相处是怎样一种体验：他从不刻意优秀，却总是无意中卓越。
66.	不要跟眼界不一样的人争辩。
67.	人穷尽一生追求另一个人的事，我一直无法理解，或许是因为我自己太有意思，无需他人陪伴，所以我祝你们在对方身上得到的快乐与我给自己的一样多。
68.	一个人需要控制的事情越少，他心理上就越自由。当你企图控制一件事情的时候，你同时也就被这件事情所控制，这永远是个相互的过程。
69.	我们痛恨限制的同时，也依赖限制。
70.	一个能够安住于不确定和不可控制中的人最自由。
71.	大部分的教育工作者都在教人找到工作，而不是寻找人生。
72.	漫画提供给我们的，也许就是这个早以被我们遗忘的世界。但将它看做一个逃避现实，发泄情绪的渠道，还是从中寻找勇气和激励，在现实生活中做一个真正的英雄，决定权在你。
73.	社会衡量一个人的价值，在于他能向外产出什么，至于他吸收了什么，没人在乎。
74.	我发现没有任何一个煤矿工人靠挖煤多又快当上了煤老板。
75.	有的人努力的时候是真的在努力，有的人努力的时候只是为了感动自己，这决定了一个人究竟能变成什么样。
76.	在这残酷的现实面前，除了吃人与被吃，我还有第三种选择，就是努力活下去，并且让这个社会再好一点。知大恶才知大善。知暗夜才知光明。不要低估人性的丑恶，也不要低估人性的光辉。
77.	群众的眼光到底是不是雪亮的？                                                                                  1）群众的智商，呈现非周期性的上升或者下降。                                                        2）其实群众的眼睛就是灯泡，而开关掌控在领导手中，需要时就是雪亮的，不需要时就是不明真相的。 
3）如果让群众挑错，那群众的眼睛无疑是雪亮的，他们最擅长干这个了，但要是问群众什么是对的，那就瞎了。
78.	我一向不太相信离别时的情真意切，我觉得那只是一种情绪渲染。
79.	为什么孩子喜欢看有关恐龙的书？                                                                                恐龙代表过去，宇宙飞船代表未来，我就是不喜欢现在。－－询问一7岁男孩得知
80.	纠正一个错误的方法有很多，而解决一个错误的终极方法就是不给他任何发生的机会。
81.	为什么父母一吵架，小孩就特别懂事？                                                                         小孩的沉默，隐忍，恐惧，以及讨好，在麻木的大人眼中，便是：懂事。
82.	凡我中华之寸土皆洒满我中华儿女之血泪，永世不忘倭寇侵占与残杀之历史。
83.	我相信再有一个妖精大闹天宫，悟空会是去镇压的那个人。
骑士杀死恶龙后，望着满地的财宝，身上长出了鳞片。
84.	只有写鸡汤的人才能从鸡汤中受益。
85.	没有中枪的觉悟，就没有开枪的资格。
86.	什么是人渣？   
浑身都是铠甲，没有一处软肋。
87.	一种人，天天都笑嘻嘻的，好似和谁都合得来，但是从不主动联系朋友，脾气也出奇的好，好像世上没有什么事情能让他们愤怒和悲伤。心中怀着宏伟的梦想，却不愿与现实中的人分担，只是默默的做，以为能用沙砾和泥土堆出山川。
88.	为什么我们愿意把钱捐给身边的乞丐，而不顾那些生活在水深火热之中的欠发达国家的人民呢？                                                                                                                         人类的所有善意都遵循邻避原则。坏的事可以发生，只要别发生在我家后院就行了。－－善意有效辐射范围
89.	后来许多人问我一个人夜晚踟蹰路上的心情，我想起的却不是孤单和路长，而是波澜壮阔的海和天空中闪耀的星光。－－张小砚
90.	当很重要的人寻求更大的世界，却因此不得不离开你的时候，支持还是阻止好？            
他走是因为他想走，他不走是因为他不想走，不要试图去背负别人的人生。
91.	一个人在对另一个人的内心世界做出评判时，最好怀有一定程度的谦逊和宽容。－－《群山回响》
92.	楼下的一个男人病的要死，那间壁的一家唱着留声机，对面是弄孩子，楼上两个人狂笑，还有打鼾声，还有打牌声，河中的船上有女人哭着她失去的母亲。 人类的悲欢并不相通，我只觉得他们吵闹。－－鲁迅
93.	什么样的状态最恐怖？ 
忙碌的学习，上班，以为忙碌了，就是充实了。一般还很满足，自以为比别人过得有意义。其实说到底，都是急于活得明白，反倒搞不清楚。
94.	未知的危险性是最恐怖的，而未知来自于你感官能力的丧失。比如说漆黑一片的屋子里你丧失的是视觉，比如说一片静谧的丛林里你丧失的是听觉。当你失去这些采集环境信息的渠道后，你会无法用经验体系构建一个稳定可预测的环境状况。人本能的就希望远离这种不稳定，这就是恐惧的作用了。
95.	我们千山万水来到这，为的也不过是说一声再见。
96.	遇见你所爱的人，时间就会停止。
97.	在遇到她之前，我不怕死，不惧远行，也不曾忧虑悠长岁月，现在却从未如此真切地思虑起将来。－－《平如美棠》
98.	从今往后，咱们只有死别，再无生离。－－《我们仨》
99.	别人的痛苦才是你艺术的源泉，而你去受苦只会成为别人艺术的源泉。
100.	我们大部分人根本谈不上独立的审美，而且美也是随着时代和环境在变化。
101.	无论我告诉你什么道理，当你的心智没有达到这个境界或接近的水平时或经历过一些事情的时候，你是不会理解这个道理的。或者你以为你知道这个道理，其实你不知道。
102.	除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。
103.	别人指责你的事情或批评的你的理由，往往最能伤害你的，是那些你也这样认为的事情。
104.	其实人跟人之间差别其实不大，所以不要与别人去比较，人生就是一场长跑，你可能不会是第一名，但也不不太会是最后一名，和前面比你会有动力，和后面比你会有幸福。但重要的是享受过程。
105.	永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。人生就是一场游戏，懂得你在玩的游戏的游戏规则，然后玩好它。
106.	生活其实是一种运营，时间是你最宝贵的资源，还有钱，关系，都是你的一种投入，自己重视什么，事业，友谊，家庭上，就多投入些，种瓜得瓜，好好平衡各个关系是你要做好的。
107.	人不会死在绝境。却往往栽在十字路口。
108.	编剧是你，我怎么知道结局。
109.	一只船孤独的航行在海上，它既不寻求幸福，也不逃避幸福，它只是向前航行，底下是沉静碧蓝的大海，而头顶是金色的太阳。   --莱蒙托夫
110.	历史学——孤证不成立
111.	新闻无需撒谎，它只需要给出“部分的真相”，就可以达到操纵民意的目的
112.	你所关注的东西，永远都是媒体想让你关注的
113.	很多时候舆论一边倒的声音，未必是大多数人所赞同的，只是不赞同的人以为自己是少数，不愿意发声而已
114.	除非你准备射击，否则不要把枪口对准人或物
115.	把自己不能理解的行为定义为「装」实在是非常不好的习惯，要改。
116.	画家不识渔家苦，好作寒江钓雪图。
117.	我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔
118.	人这一生为什么要努力？
是一种想去体验一个更大的世界的欲望。
119.	子路有闻，未能行之，唯恐有（又）闻。
120.	信任就像一张纸，皱了，即使抚平，也恢复不了原样了。。。 
用水胶带，喷水，绷木板上干后比原先还平。---做不到只是知识不够用。
121.	我第一次感受到时间是一种物质的存在。它就像是一条蠕动的虫子，拖着臃肿皱皮的身躯，从我的血管里缓缓缓缓地爬过，并且留下了一条粘乎乎的痕迹。
122.	原来死亡就是一种消失。不但是肉体，精神和思想的消失，更重要的是在人们的记忆中慢慢成为了空白，就像这个人从没在这个世界上来过一样。
123.	张浩站在他办公室高大的落地窗玻璃前，看着下面的芸芸众生。他说，林岚，你觉得他们生活得辛苦吗？我觉得很辛苦。每个人都很辛苦。这个世界不会符合你所有的想象，甚至连一个你的想象也不符合，可是我们还是得生存下去。
124.	人是为活着本身而活着，而不是为了活着之外的任何事物所活着。
125.	人生的意义是什么？
意义这个词太单薄，太卑微，低落到尘埃里，配不上生命，也承载不起人生。
126.	人生逆旅，一蓑烟雨。
127.	外行看热闹，都不知道别人家的事情，一群吃瓜群众指指点点，哈哈哈哈。。。被媒体玩的像猪一样。
128.	底线之上才有资格说各展所长。
129.	“我寄给你的信，总要送往邮局，不喜欢放在街边的绿色邮筒中，我总疑心那里会慢一点。”	--鲁迅《致许广平》
130.	我不要儿子，我要一个女儿--只要一个，像你的。--钱钟书
131.	孩子不是图画练习册，不要光顾着涂上自己喜欢的颜色。	--《追风筝的人》
132.	生活其实也很简单，喜欢的就争取，得到的就珍惜，失去了就忘记。
133.	有什么事情是游戏从业者不愿意告诉玩家的?
免费玩家也是我们提供给付费玩家的功能之一。
134.	哪有什么岁月静好，不过是有人为你付中负重前行，生活从来都不容易，当你觉得挺容易的时候，一点是有人再替你负重前行。
//好像现在是我人生中最轻松容易的时候了，那么到底有哪些人在为我负重前行呢？
135.	有枪但你没盾，你挡不住别人的子弹。
136.	没有人有义务了解你所尽力的艰辛。
137.	我从来没有想过一个节目会以无解来结尾，一直到明白真实的世界就是如此。 --柴静《双城的创伤》
138.	能够让你后悔的，从来不是你做过的事，而是你想做却没有做过的事。
139.	很多时候，你愿意讲给别人听的，大概是那些很想，却再也没有机会告诉以前的自己的话吧。--《肖申克的救赎》
140.	从童年起，我便独自一人。照顾着历代的星辰。--《孤独》白鹤林
141.	与这世界交手多年，你是否光彩依旧，兴致盎然。
142.	为什么你不让别人看到你善良的一面？因为如果他们看见了，就会期望我一直是善良的。
143. 周围认识的许多情侣，最后都步入了婚姻殿堂，但其中不少人在爱情长跑中都曾不忠。有些故事大家心照不宣，甚至帮他们遮掩。每次婚礼，我看着新人们热泪盈眶地念誓言，从没怀疑过他们在那一刻的真诚，可人性是如此幽深复杂，千帆过尽，我变得什么都能理解，也什么都无法相信。
144. 人生有5%的幸福，5%的痛苦，还有90%的平淡。人们往往被那5%的幸福诱惑着，幻想未来或怀念过去，忍受着5%的痛苦，在90%的平淡中慢慢度过漫长的一生。
145. 记得一个电影里面的女主说过”我不是喜欢钱，但是钱可以带来自由和尊严。我喜欢的是自由和尊严。”
146. 90次的反复下载上传，最后变成了这样，可见你认为最可靠的数据也是会在传播中失去原来的样子，更何况是你从被人嘴里听到的别人。
147. 无论你做的事情多正义，都不能强制我和你一个步调。
148. 既无法忍受现在的状态，又没能力改变这一切，可以像只猪一样懒，却无法像只猪一样心安理得。
149. 我们的祖先是被吃了无数回才走上了食物链的顶端。
150. 尊重粉丝维护偶像，但也请尊重一个人从内心深处鄙视另一个人的自由。
151. 皇帝为什么不多生孩子，最后选择优秀的孩子即位？”长幼”是常量，”优秀”是变量，政治稳定不能有太多的变量。
152. 我们看到的都是别人让我们看到的。
153. 没打出来的牌才是王牌。
154. 市场不一定是去迎合的，而是可以引导和培养的。
155. 后代子孙永远也不会知晓当初战争中零星冲突的悲惨情况；事实上，一无所知反而最好。真正的战争永远会隐没于历史的黑暗面。 ---沃尔特•惠特曼
156. 只有你才知道对你而言什么才是糟糕的生活，什么才是真正的一塌糊涂，这与旁人的教说，旁人的经验并无关系。
1. 这世上真话本就不多，一位女子的脸红胜过一大段对白。-- 老舍
1. 如果说有谁在看到流星的瞬时就能许下愿望，那一定是非常纯熟且迫切的愿望。
1. “我可以尽管向你们这个组合宣泄负面情绪，因为你们是被主流唾弃的，所以无论我说什么都没错，毕竟我是站在道德制高点上的。” --momo的老公
1. 不是返璞归真，转了个圈回到的却不是原处。两个放羊最大的区别，一个是满足物质生活，一个是满足精神生活。曾经的种地放羊是生活的根基，被迫接受的事没有什么美感，结束一天的工作后裹着一身臭汗上炕睡觉第二天周而复始，这种放羊与“舒适的生活”是没有挂钩的。而现在那种有情怀的种地放羊则是一种有钱人的主动选择，把过去的苦事中的精华提取，与其他美好的事相连接，在放羊的生活中也能享受惬意的生活。他们有能力选择和组合生活，这不该被批判。
1. 我看到的多数家庭的教育是颠倒混乱的。生下来到学龄前应当树立家长权威（要有敬畏），他们却去溺爱；小学应当严格培养学习习惯和基础，他们却宽松；青春期个性萌芽，父母应当从权威退到民主，让孩子学会理性和责任时，他们却开始各种着急焦虑和专制严管；到大学应该是退居二线，最多给于建议的时候他们开始对孩子人生规划指手画脚；工作了，父母应当放手让孩子完全独立对自己负责时，他们却最终升级到强迫相亲这种直接干涉。
1. 不愿费心力和别人交流。然而总是被指诘在躲避。内心不坦然，才是孤独者的坟墓。
1. 人生如逆旅，我亦是行人。
1. 你一直耿耿于怀的事事实上相关人物根本早就忘记了 耿耿于怀的果然只有你自己“
1. 当前的环境也许只是一个暂态，也许只是世界的一小面；如果你想要见见更大的世界，那就不要太急着让自己为了适应当前的环境而彻底改变。
1. 当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。——陶杰 《杀鹌鹑的少女》
1. 那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 — —王小波
1. 想要追求自由随性的生活，就一定要先从自律开始。
1. 别人口中越是容易让人得出倾向性结论的问题描述，往往代表他刻意隐瞒了越多关键的细节。
1. 走不进去的世界就不要硬挤了，为难了别人，也作贱了自己。
1. 古龙《多情剑客无情剑》里，提过一个例子：一对厨子，饭馆打烊后，他们在后厨，自己给自己炒了盘菜，找点小酒，很惬意的饮食一番，舒服那一两个时辰。
--古龙还说：他们还活着，就是因为一天还有那么一两个时辰。
1. 从来如此，便对么？——鲁迅《狂人日记》
1. 那……学校不好，难道知识也不好么?
1. 高三毕业的欢送会上，复读班上的五个男生合唱了这首歌，我知道他们都不是第一年参加高考，我也知道那一年他们仍然成绩平平，我们那一届复读班整体都考的很差，但这首歌我记到现在。好像长这么大，见过的最多的无功而返，苦苦挣扎都是在学习的道路上。可苦涩中的温暖最能长存。路漫漫，且行且珍重！
1. 我一直记得刘瑜写给女儿的一段话：愿你被很多人爱，如果没有，愿你在寂寞里学会宽容。
1. 开始并完成一件事，比做好它更重要，因为只要开始了，你就有机会把它做的更好———-一件看上去繁难的事，只要开始做了，就会变得越来越容易。”
1. 张一鸣有一句说的特别对：所谓成功，就是延迟满足。
1. 成长是件残酷的事情，也许久而久之我们活成了别人想要的模样。但世俗跟成熟是两码事：在熙熙攘攘之外学会“我愿意”，不愿将就的你也可以不那么讲究。
1. “秘密的暴力比公开的暴力更令人恐怖，它会使人失去思考能力、道德意识和抵抗意志，因此退化到最低等原始动物保命本能中去。为了保命求生、避免肉体折磨，人会变得全无廉耻、奴性十足、无所不为。秘密统治对政府权力的正当行使和合道德性同样有着严重的腐蚀作用。” ---《布达佩斯往事》
1. 一个成熟的人，他的标准来自他的内心，而大多数的人，却受环境左右。对自己的标准会不由自主的降低以适应这个环境，减少自身与环境的冲突，在一个低标准下，自觉“满意”的度过每一天。 ——《精进》
1. 梦想不一定要马上实现，如果身边的人反对，那就走慢一点，只要你每天确定自己在往那里走就行。
1. 他没有勇气，也没有兴趣使渴望的行动得以一气呵成，因此自己在半途中就会怀疑行动的意义。---夏目漱石
1. 我来不及认真地年轻，待明白过来时，只能选择认真地老去。 —— 三毛
1. 我会以我的标准与方式看待世界，但我并不会以他来要求他人。--清让
1. 时间，只是一个自称能治百病的庸医。
1. 当你能从你认可的人或者事物身上吸取经验与知识，这是大部分人能做到的，但是如果你能从你不认可的人或者事物身上吸取营养，学到东西，那就真的太难得
了。
1. 你想成为什么样的人，那就尽量去向他们靠近。
1. 真正幽默的人，是把快乐给了别人。
1. 人这一生有很多重要的决定，每个决定其实都决定了我未来的人生，是否被动接受做一个幼师、是否转专业、是否升本等等等，做这些所有的选择与决定前，想想自身的优势，结合趋势与实力，看一下自己做这件事的把握有多少，但凡重大的决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是一些人生的重大决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，我最该做的，是在一开始选择前，确定这场仗能打赢，再去打。
1. 面试造飞机，工作扭螺丝。
1. “让忙于务实的人务实，让乐于做梦的人做梦”。
1. 生命是一场华丽的冒险，只是我们永远都跨不过时间的深渊。
1. 曾经的你，以为只要带着那把长剑和赤子之心就可以说服自己不出卖理想的灵魂。在最艰难和不得不流泪的晚上，即使连自己都在笑自己傻，但仍然用长剑刺痛自己，提醒自己，勇往直前，直到将来。
1. 过往不恋，未来不迎，当下不负。
1. 忠言逆耳，良药苦口，可不都是这样吗。但我觉得最重要的是要培养自己的判断力，在兼容并包的基础上一定要有自己的主心骨。善听百家之言，思想上的言论抒发不分对错，要客观结合自己的情况，别人的经验也不全是对的，就算是对的，也不全适合自己，不同的人有不同的性格，脾气，要自己汲取自己认可的观点看法，适合自己才是最好的。
1. 世上最难的事之一，把自己的思想装进别人的脑袋。
1. 这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。 ——《大鱼海棠》
1. 有时候遇到瓶颈了，你应该停下来好好想想，是有四年工作经验，还是一个经验用了四年。
1. 这世上唯有病痛和亲人去世是真切的痛楚，其他都是不必要的伤感，是忽略了当下拥有的一切的贪婪。
1. 许多人所谓的成熟， 不过是被习俗磨去了棱角，变得世故而实际了。那不是成熟，而是精神的早衰和个性的消亡。真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。
1. 别嫌读书苦，你现在的气质里，藏着你走过的路，读书不是为了雄辩和驳斥，也不是为了轻信和盲从，而是为了思考和权衡。
1. 真的不要小看父母，不要觉得自己很厉害。以前笑父母遥控器还要套个手机套，其实和现在我们用手机还要贴膜戴手机套是一样的。以前笑父母为了一毛钱还和人家讨价还价，其实和我们现在用着手机在群里抢红包是一样的。以前父母无聊时磕着瓜子看着小说，其实和我们现在拿着手机刷着朋友圈是一样的。以前父母拉几个好友打麻将谈天说地，其实和我们现在拉几个网友王者农药开黑是一样的。以前父母在厂里上班踩着缝纫机，其实和我们现在写字楼里对着电脑写 PPT word 文档是一样的。所有的都没有变，只是时代在变，生活方式升级，换一种方式活着而已。很多年以后，可能会有10后笑着：瞧，我爸以前是在格子间苦逼写代码的工程师，我现在一家未来公司看着机器人帮我干活，公司只有我一个人呢。
1. 有勇气去改变那些可以改变的事，
有肚量去容忍那些无法改变的事，
有智慧去区分上述的事。
1. 识人不必探尽，探尽则多疑。
知人不必言尽，言尽则无友。
责人不必苛尽，苛尽则众远。
敬人不必卑尽，卑尽则少骨。
让人不必退尽，退尽则路寡。
1. 安全感在很多时候是束缚人的枷锁，过度追求会让人生少了很多可能性。
1. 大部分的恐惧，只有在你把它当回事儿的时候才是。
1. 很多时候，没有兴趣并不真的是没有兴趣，而是怕自己做不好。
1. 最好的兴趣就是永远达不到但可以不断精进的那些。
1. 很多时候，成功者是自证的，失败者也是。
1. 阻止大脑用思维定式进行自动加工，夺回大脑的控制权。
1. 努力不是盲目的，是定向的。
1. 要超越心智，首先要能辨别更好的心智与现有心智的区别。
1. 世俗的成功不是人人都可以达成的，按概率也就只有一小部分。
1. 盲目听信成功学故事并模仿，将离成功越来越远。
1. 不管是恋爱还是职场，要选得好就得先小范围尝试和观察，对所谓的“好坏”有个大体了解后，然后再选择，最后全情投入。
1. 完美的职业规划不存在，避免因为规划得太细而失去更多的可能性。
1. 过去的付出只代表过去，沉没成本不是成本。
1. 常认为自己是受害者的人往往真的会成为受害者。
1. 绝对公平并不存在，追求绝对公平只是追求自利。
1. 活在父母的世界跟活在子女的世界一样，都是人格尚未独立出来的婴儿。
1. 在事情没有快速变化的前提下，等待仅仅是无谓的消耗。
1. 要撕掉自己的短处，不要试图掩盖，用更强的标签去替代它。
1. 陷入指定的成功，你就基本不太可能成功了。
1. 握不住的沙，不如扬了它。
1. 优于别人并不高贵，真正的高贵因该是优于过去的自己。-- 海明威《真实的高贵》
1. 顶级组织至情至性，
 一流组织共同信仰，
二流组织共同利益，
三流组织共同规则。
1. 像老大寻求意见时，自己先思考出几套解决方案也就是“香蕉”，让你的老板去做选择而不是让他出想法。如果因为你的”香蕉”没熟透，放心你的老大会给你更好的解决方法，先养成动脑思考的好习惯。 --香蕉法则
1. 善良不是要求别人做什么，而是要求自己做什么。
1. 自己是既得利益者，说这不公平叫「觉悟高」，值得钦佩，自己不是既得利益者，就别眼里只看到不公平，因为这太正常了，如果不理解，或者心生抱怨，该想想自己的问题。
1. 文字传达观点，文字也能误传观点。
1. “检验一流智力的标准，就是看你能不能在头脑中同时存在两种相反的想法，还维持正常行事的能力。”
1. 有时候，鸡汤可能比所谓的干货更有用，很多道理其实大家都懂，我们做出改变缺乏的只是一个推动力。
1. 不自律，无自由：
曾经以为自由就是想做啥做啥，后来才发现自律者才会自由。当一个人缺乏自由的时候，他做的事情总是在受习惯和即时诱惑的影响，要么就是被他人的思想观念所扰，几乎永远不可能去做内心真正渴望的事。
1. 《海上钢琴师》中，1900 为什么最后没有下船？
我们的陆地就是他的海洋。无人愿意一生漂泊。
1. 永生是否是一种酷刑？
凡是能被适应的惩罚都不能算是酷刑。
1. 当有人做一件事并没有伤害到任何人的事情，你却要指手画脚的时候，你才是那个傻逼。
1. 这世上只有一种成功，就是能用自己喜欢的方式度过自己的一生。
1. 只有深入一座城市的边边角角，了解城市里的一花一草一木，才能真正看懂人生百态，品味酸甜苦辣的人生。
1. 信仰是用来约束自己的。
1. 习惯，是扼杀创造力的最大杀手！
当你所掌握的信息不足以帮自己判断的时候，你可以选择观望，但是用这些无比正确的废话来说服别人，就是最大的笑话，就等同于，你自己没有判断力，也要求别人也跟你一样没有判断力。
1. 没有观点的反驳更可怕，有那么一拨人，为了让自己无比正确，总说一大堆永远正确的话。
1. 穷人思维和富人的思维是，穷人花 10 块，总奢望得到 100 块的价值，而富人花 1w 块，只求得到 1000 块的价值就够了，但是即便如此，富人可以轻易获取 1000 块的资源，而穷人即便费劲九牛二虎之力得到 100 块的价值也差距很大。
1. 我自己也做了公众号，尤其是影响力越做越大，关注的人越来越多，当一个群体越来越大的时候，难免鱼龙混杂，什么样的人都有，也就意味着，你的所有观点，总会随着群体越来越大，不认可你的人越来越多，当然，认可你的人其实是更多的，但是认可你的人不会让你糟心，而不认可你的人，或者说一些杠精才会让你最糟心的。
1. 这个世界有几样东西是不能被取代的，第一：亲身感受。我拿着一碗水，告诉你：这个是海洋，你永远不会有感觉。第二：自我成长和努力。没有人可以取代你做事情，应该自己完成的，只能由自己完成。工具的善用，自我的实力，重要性是排在第一位。刘翔跑再快，我开车，轻松超越他。当然，前提是我会开车，四肢还得健全。
1. 吃不了起早贪黑的苦，你丢不起那个街头摆摊的人，你凭什么觉得不公平？
1. 活在当下。我 22 岁的时候从不会去考虑五六年之后的我会是怎样，我只是活在当下，做好当下的事而已。
1. 致正少年的你，愿你所有快乐无需假装，愿你此生尽兴赤诚善良。
1. 罗素说：只有一种英雄主义，就是在认清生活的真相后依然热爱生活。
1. 这世界就是一拨人昼夜不停的运转，另一拨人起床发现世界变了。',
  'groups' => 'Default',
  'showsel' => '1',
  'id' => '32',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000644s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001643s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000743s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000393s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001292s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000409s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000356s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000354s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=32,`p_id`=1,`title`='写出这些话的人，我估计一辈子都追不上了\r',`content`='# 写出这些话的人，我估计一辈子都追不上了\r\n1. 如果发出声音是危险的，那就保持沉默；如果自觉无力发光，那就别去照亮别人。但是，不要习惯了黑暗就为黑暗辩护不要为自己的苟且而得意洋洋；不要嘲讽那些比自己更勇敢，更有热量的人们。可以卑微如尘土，不可扭曲如蛆虫。\r\n2. 你多学一样本事，就少说一句求人的话。\r\n3. 我38岁那年，琢磨着要不要去读两年的放射线照相术大专学位。然后我跟我朋友说了这事，我觉得自己太老了，等拿到学位是，我都40岁了。\r\n--朋友说，如果你不读，你还是会40岁，一个没有学位的40岁。\r\n4.	这些年来我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没有放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。\r\n5.	孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是，我希望你将来会拥有选择的权利，选择有意义，有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。\r\n6.	最终我们都将学会，与他人交往，最重要的不是甜言蜜语，不是容貌金钱，而是你和他对于这个世界的看法，对人生的态度是否一致。\r\n7.	我们一路奋战，不是为了改变世界，而是为了世界不再改变我们。\r\n8.	不要欺骗别人，因为你能骗到的人，都是相信你的人。\r\n9.	熟练的运用\"关我屁事\"和\"关你屁事\"可以省下人生80％的时间。\r\n10.	我怎么敢倒下。我身后空无一人。\r\n11.	\"痛苦是财富，这话是扯淡。姑娘，痛苦就是痛苦，对痛苦的思考才是财富。\"\r\n12.	永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。\r\n13.	如果我不曾见过太阳，我本可以忍受黑暗。\r\n14.	社交之所以累，是因为每个人都试图展现出自己其实并不具备的品质。\r\n15.	读书：之前觉得自己是一个人，现在觉得自己可以是一个世界。\r\n16.	希望你今天白费的努力，早晚有一天变成值得。\r\n17.	历史：遗忘，对倒下的人不公平。\r\n18.	南京大屠杀：\r\n安培说：现在日本的年轻人没有义务为过去的日本人像现在的中国人道歉。\r\n那现在的中国人也没有权利为过去的中国人原谅现在的日本人。\r\n19.	明明别人轻轻松松可以做到的事，我却做不了。满满的无力感，无力到没有力气。\r\n20.	人的一切痛苦，本质上都是对自己无能的愤怒。\r\n21.	不要试图同情你自己。\r\n22.	你配得上你自己想要的生活吗？\r\n23.	什么叫成熟？\r\n了解自己，了解自己的欲望，了解自己的局限。理解别人，理解别人的欲望，理解别人的局限。\r\n24.	我们会看到要寻找的东西，错失不去寻找的东西，虽然它在那里。我们的阅历被我们的关注点深深地影响了。\r\n25.	做你害怕做的事，然后你会发现，不过如此。\r\n26.	一直认为，所谓新鲜感，不是和未知的人一起去做同样的事，而是和已知的人一起去体验未知的人生。\r\n27.	如果不能随时有限的反击，所有的宽容都是懦弱。\r\n28.	群众的眼睛不是雪亮的，群众的眼睛是盲目的。\r\n29.	不是所有的人都能功成名就，我们中有些人注定要在日常的点滴中寻找生命的意义。\r\n30.	带人友善是修养，独来独往是性格。\r\n31.	几年前踏上火车那一刻还没有意识到，从此故乡只有冬夏，再无春秋。\r\n32.	十年饮水，难凉热血。\r\n33.	德，律己为德，律人无异于私刑。\r\n34.	信仰，他可以与宗教无关，代表自己的精神追求。\r\n35.	人最重要的能力有两个，适应环境，不忘初心。适应环境可以安身，不忘初心可以立命。\r\n36.	维护不在场的人，所言不多于所知。\r\n37.	只有你愿意为之而死的东西，你才可以藉之而生。\r\n38.	你见过树，却没见过森林。\r\n39.	那些杀不死你的最终都会使你更强壮。\r\n40.	是你把你的秘密告诉了风，那就别怪风把他带给树。\r\n41.	似乎大家都这样。自命不凡，却无足轻重。\r\n42.	保安笑着问我：\"你那么小个子，开那么大个车？\"的时候。我傻笑着回答：\"你是当保安，我是当司机的。\"\r\n43.	猪会飞，是因为他站在了风口上，成功的飞起来以后他可以总结起飞技巧，但重要的，是风。\r\n44.	你现在做的每一件事看来并没有什么意义，但他们也许会在未来助你 一臂之力。\r\n45.	唱出本身就是最要不得的态度。当你做某件事的时候，一旦想要求快，就表示你再也不关心他，而是想去做别的事。\r\n46.	命运啊，说是注定，不如说是你在何时做了选择。\r\n47.	在一群出色的人中间，常常误以为自己也是其中一员，然后忘了努力。\r\n48.	只有经历过地狱磨难的人，才有建造天堂的力量。\r\n49.	一个伟大的人往往受到排挤，压抑，甚至被人斥为哗众取宠而陷于孤独中。\r\n50.	与怪物战斗的人，应当小心自己不要成为怪物。当你远远凝视深渊时，深渊也在凝视你。\r\n51.	一个人知道自己为什么而活，就可以忍受任何一种生活。\r\n52.	假如我们不去打仗，敌人用刺刀杀死了我们，还要指着我们的骨头说：看，这是奴隶。\r\n53.	我有一事，生死与之。\r\n54.	我的体内啊，有个器官比心脏还重要，他虽然看不见，但却是在我的体内从脑袋一直贯穿到胯间。就因为他，我才能站着直，坐着正，就算脚步摇晃也能笔直地向前行，在这里退缩的话，那东西就会折断。\r\n55.	不可能这三个字，你说的太多了。\r\n56.	世界上没遇上帝，如果有的话，我无法容忍我不是。－－尼采\r\n57.	剑在英雄手，登台傲王侯。－－比莫干《九州缥缈录》\r\n58.	武士的一生，只相信自己手中可以握住的东西。－－赢无翳《九州缥缈录》\r\n59.	为天地立心，为生民立命，为往圣继绝学，为万世开太平。－－北宋时期张载\r\n60.	为不能作战的人而战。\r\n61.	你的成功标准： 能做自己喜欢做的事，能只做自己喜欢做的事。\r\n62.	如何不招人厌的展现自己的学识：别人问了，你再答。\r\n63.	无论现实如何操蛋，你都能在心里有一个更诗意的世界，那个世界便是情怀。\r\n64.	情怀就是以心灵的满足而不是功利的得失作为自己的行为标准的一种品质。一件没有什么用的事，还是要去做，也许只是因为我喜欢，也许只是因为它看起来很美。\r\n65.	跟优秀的人相处是怎样一种体验：他从不刻意优秀，却总是无意中卓越。\r\n66.	不要跟眼界不一样的人争辩。\r\n67.	人穷尽一生追求另一个人的事，我一直无法理解，或许是因为我自己太有意思，无需他人陪伴，所以我祝你们在对方身上得到的快乐与我给自己的一样多。\r\n68.	一个人需要控制的事情越少，他心理上就越自由。当你企图控制一件事情的时候，你同时也就被这件事情所控制，这永远是个相互的过程。\r\n69.	我们痛恨限制的同时，也依赖限制。\r\n70.	一个能够安住于不确定和不可控制中的人最自由。\r\n71.	大部分的教育工作者都在教人找到工作，而不是寻找人生。\r\n72.	漫画提供给我们的，也许就是这个早以被我们遗忘的世界。但将它看做一个逃避现实，发泄情绪的渠道，还是从中寻找勇气和激励，在现实生活中做一个真正的英雄，决定权在你。\r\n73.	社会衡量一个人的价值，在于他能向外产出什么，至于他吸收了什么，没人在乎。\r\n74.	我发现没有任何一个煤矿工人靠挖煤多又快当上了煤老板。\r\n75.	有的人努力的时候是真的在努力，有的人努力的时候只是为了感动自己，这决定了一个人究竟能变成什么样。\r\n76.	在这残酷的现实面前，除了吃人与被吃，我还有第三种选择，就是努力活下去，并且让这个社会再好一点。知大恶才知大善。知暗夜才知光明。不要低估人性的丑恶，也不要低估人性的光辉。\r\n77.	群众的眼光到底是不是雪亮的？                                                                                  1）群众的智商，呈现非周期性的上升或者下降。                                                        2）其实群众的眼睛就是灯泡，而开关掌控在领导手中，需要时就是雪亮的，不需要时就是不明真相的。 \r\n3）如果让群众挑错，那群众的眼睛无疑是雪亮的，他们最擅长干这个了，但要是问群众什么是对的，那就瞎了。\r\n78.	我一向不太相信离别时的情真意切，我觉得那只是一种情绪渲染。\r\n79.	为什么孩子喜欢看有关恐龙的书？                                                                                恐龙代表过去，宇宙飞船代表未来，我就是不喜欢现在。－－询问一7岁男孩得知\r\n80.	纠正一个错误的方法有很多，而解决一个错误的终极方法就是不给他任何发生的机会。\r\n81.	为什么父母一吵架，小孩就特别懂事？                                                                         小孩的沉默，隐忍，恐惧，以及讨好，在麻木的大人眼中，便是：懂事。\r\n82.	凡我中华之寸土皆洒满我中华儿女之血泪，永世不忘倭寇侵占与残杀之历史。\r\n83.	我相信再有一个妖精大闹天宫，悟空会是去镇压的那个人。\r\n骑士杀死恶龙后，望着满地的财宝，身上长出了鳞片。\r\n84.	只有写鸡汤的人才能从鸡汤中受益。\r\n85.	没有中枪的觉悟，就没有开枪的资格。\r\n86.	什么是人渣？   \r\n浑身都是铠甲，没有一处软肋。\r\n87.	一种人，天天都笑嘻嘻的，好似和谁都合得来，但是从不主动联系朋友，脾气也出奇的好，好像世上没有什么事情能让他们愤怒和悲伤。心中怀着宏伟的梦想，却不愿与现实中的人分担，只是默默的做，以为能用沙砾和泥土堆出山川。\r\n88.	为什么我们愿意把钱捐给身边的乞丐，而不顾那些生活在水深火热之中的欠发达国家的人民呢？                                                                                                                         人类的所有善意都遵循邻避原则。坏的事可以发生，只要别发生在我家后院就行了。－－善意有效辐射范围\r\n89.	后来许多人问我一个人夜晚踟蹰路上的心情，我想起的却不是孤单和路长，而是波澜壮阔的海和天空中闪耀的星光。－－张小砚\r\n90.	当很重要的人寻求更大的世界，却因此不得不离开你的时候，支持还是阻止好？            \r\n他走是因为他想走，他不走是因为他不想走，不要试图去背负别人的人生。\r\n91.	一个人在对另一个人的内心世界做出评判时，最好怀有一定程度的谦逊和宽容。－－《群山回响》\r\n92.	楼下的一个男人病的要死，那间壁的一家唱着留声机，对面是弄孩子，楼上两个人狂笑，还有打鼾声，还有打牌声，河中的船上有女人哭着她失去的母亲。 人类的悲欢并不相通，我只觉得他们吵闹。－－鲁迅\r\n93.	什么样的状态最恐怖？ \r\n忙碌的学习，上班，以为忙碌了，就是充实了。一般还很满足，自以为比别人过得有意义。其实说到底，都是急于活得明白，反倒搞不清楚。\r\n94.	未知的危险性是最恐怖的，而未知来自于你感官能力的丧失。比如说漆黑一片的屋子里你丧失的是视觉，比如说一片静谧的丛林里你丧失的是听觉。当你失去这些采集环境信息的渠道后，你会无法用经验体系构建一个稳定可预测的环境状况。人本能的就希望远离这种不稳定，这就是恐惧的作用了。\r\n95.	我们千山万水来到这，为的也不过是说一声再见。\r\n96.	遇见你所爱的人，时间就会停止。\r\n97.	在遇到她之前，我不怕死，不惧远行，也不曾忧虑悠长岁月，现在却从未如此真切地思虑起将来。－－《平如美棠》\r\n98.	从今往后，咱们只有死别，再无生离。－－《我们仨》\r\n99.	别人的痛苦才是你艺术的源泉，而你去受苦只会成为别人艺术的源泉。\r\n100.	我们大部分人根本谈不上独立的审美，而且美也是随着时代和环境在变化。\r\n101.	无论我告诉你什么道理，当你的心智没有达到这个境界或接近的水平时或经历过一些事情的时候，你是不会理解这个道理的。或者你以为你知道这个道理，其实你不知道。\r\n102.	除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。\r\n103.	别人指责你的事情或批评的你的理由，往往最能伤害你的，是那些你也这样认为的事情。\r\n104.	其实人跟人之间差别其实不大，所以不要与别人去比较，人生就是一场长跑，你可能不会是第一名，但也不不太会是最后一名，和前面比你会有动力，和后面比你会有幸福。但重要的是享受过程。\r\n105.	永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。人生就是一场游戏，懂得你在玩的游戏的游戏规则，然后玩好它。\r\n106.	生活其实是一种运营，时间是你最宝贵的资源，还有钱，关系，都是你的一种投入，自己重视什么，事业，友谊，家庭上，就多投入些，种瓜得瓜，好好平衡各个关系是你要做好的。\r\n107.	人不会死在绝境。却往往栽在十字路口。\r\n108.	编剧是你，我怎么知道结局。\r\n109.	一只船孤独的航行在海上，它既不寻求幸福，也不逃避幸福，它只是向前航行，底下是沉静碧蓝的大海，而头顶是金色的太阳。   --莱蒙托夫\r\n110.	历史学——孤证不成立\r\n111.	新闻无需撒谎，它只需要给出“部分的真相”，就可以达到操纵民意的目的\r\n112.	你所关注的东西，永远都是媒体想让你关注的\r\n113.	很多时候舆论一边倒的声音，未必是大多数人所赞同的，只是不赞同的人以为自己是少数，不愿意发声而已\r\n114.	除非你准备射击，否则不要把枪口对准人或物\r\n115.	把自己不能理解的行为定义为「装」实在是非常不好的习惯，要改。\r\n116.	画家不识渔家苦，好作寒江钓雪图。\r\n117.	我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔\r\n118.	人这一生为什么要努力？\r\n是一种想去体验一个更大的世界的欲望。\r\n119.	子路有闻，未能行之，唯恐有（又）闻。\r\n120.	信任就像一张纸，皱了，即使抚平，也恢复不了原样了。。。 \r\n用水胶带，喷水，绷木板上干后比原先还平。---做不到只是知识不够用。\r\n121.	我第一次感受到时间是一种物质的存在。它就像是一条蠕动的虫子，拖着臃肿皱皮的身躯，从我的血管里缓缓缓缓地爬过，并且留下了一条粘乎乎的痕迹。\r\n122.	原来死亡就是一种消失。不但是肉体，精神和思想的消失，更重要的是在人们的记忆中慢慢成为了空白，就像这个人从没在这个世界上来过一样。\r\n123.	张浩站在他办公室高大的落地窗玻璃前，看着下面的芸芸众生。他说，林岚，你觉得他们生活得辛苦吗？我觉得很辛苦。每个人都很辛苦。这个世界不会符合你所有的想象，甚至连一个你的想象也不符合，可是我们还是得生存下去。\r\n124.	人是为活着本身而活着，而不是为了活着之外的任何事物所活着。\r\n125.	人生的意义是什么？\r\n意义这个词太单薄，太卑微，低落到尘埃里，配不上生命，也承载不起人生。\r\n126.	人生逆旅，一蓑烟雨。\r\n127.	外行看热闹，都不知道别人家的事情，一群吃瓜群众指指点点，哈哈哈哈。。。被媒体玩的像猪一样。\r\n128.	底线之上才有资格说各展所长。\r\n129.	“我寄给你的信，总要送往邮局，不喜欢放在街边的绿色邮筒中，我总疑心那里会慢一点。”	--鲁迅《致许广平》\r\n130.	我不要儿子，我要一个女儿--只要一个，像你的。--钱钟书\r\n131.	孩子不是图画练习册，不要光顾着涂上自己喜欢的颜色。	--《追风筝的人》\r\n132.	生活其实也很简单，喜欢的就争取，得到的就珍惜，失去了就忘记。\r\n133.	有什么事情是游戏从业者不愿意告诉玩家的?\r\n免费玩家也是我们提供给付费玩家的功能之一。\r\n134.	哪有什么岁月静好，不过是有人为你付中负重前行，生活从来都不容易，当你觉得挺容易的时候，一点是有人再替你负重前行。\r\n//好像现在是我人生中最轻松容易的时候了，那么到底有哪些人在为我负重前行呢？\r\n135.	有枪但你没盾，你挡不住别人的子弹。\r\n136.	没有人有义务了解你所尽力的艰辛。\r\n137.	我从来没有想过一个节目会以无解来结尾，一直到明白真实的世界就是如此。 --柴静《双城的创伤》\r\n138.	能够让你后悔的，从来不是你做过的事，而是你想做却没有做过的事。\r\n139.	很多时候，你愿意讲给别人听的，大概是那些很想，却再也没有机会告诉以前的自己的话吧。--《肖申克的救赎》\r\n140.	从童年起，我便独自一人。照顾着历代的星辰。--《孤独》白鹤林\r\n141.	与这世界交手多年，你是否光彩依旧，兴致盎然。\r\n142.	为什么你不让别人看到你善良的一面？因为如果他们看见了，就会期望我一直是善良的。\r\n143. 周围认识的许多情侣，最后都步入了婚姻殿堂，但其中不少人在爱情长跑中都曾不忠。有些故事大家心照不宣，甚至帮他们遮掩。每次婚礼，我看着新人们热泪盈眶地念誓言，从没怀疑过他们在那一刻的真诚，可人性是如此幽深复杂，千帆过尽，我变得什么都能理解，也什么都无法相信。\r\n144. 人生有5%的幸福，5%的痛苦，还有90%的平淡。人们往往被那5%的幸福诱惑着，幻想未来或怀念过去，忍受着5%的痛苦，在90%的平淡中慢慢度过漫长的一生。\r\n145. 记得一个电影里面的女主说过”我不是喜欢钱，但是钱可以带来自由和尊严。我喜欢的是自由和尊严。”\r\n146. 90次的反复下载上传，最后变成了这样，可见你认为最可靠的数据也是会在传播中失去原来的样子，更何况是你从被人嘴里听到的别人。\r\n147. 无论你做的事情多正义，都不能强制我和你一个步调。\r\n148. 既无法忍受现在的状态，又没能力改变这一切，可以像只猪一样懒，却无法像只猪一样心安理得。\r\n149. 我们的祖先是被吃了无数回才走上了食物链的顶端。\r\n150. 尊重粉丝维护偶像，但也请尊重一个人从内心深处鄙视另一个人的自由。\r\n151. 皇帝为什么不多生孩子，最后选择优秀的孩子即位？”长幼”是常量，”优秀”是变量，政治稳定不能有太多的变量。\r\n152. 我们看到的都是别人让我们看到的。\r\n153. 没打出来的牌才是王牌。\r\n154. 市场不一定是去迎合的，而是可以引导和培养的。\r\n155. 后代子孙永远也不会知晓当初战争中零星冲突的悲惨情况；事实上，一无所知反而最好。真正的战争永远会隐没于历史的黑暗面。 ---沃尔特•惠特曼\r\n156. 只有你才知道对你而言什么才是糟糕的生活，什么才是真正的一塌糊涂，这与旁人的教说，旁人的经验并无关系。\r\n1. 这世上真话本就不多，一位女子的脸红胜过一大段对白。-- 老舍\r\n1. 如果说有谁在看到流星的瞬时就能许下愿望，那一定是非常纯熟且迫切的愿望。\r\n1. “我可以尽管向你们这个组合宣泄负面情绪，因为你们是被主流唾弃的，所以无论我说什么都没错，毕竟我是站在道德制高点上的。” --momo的老公\r\n1. 不是返璞归真，转了个圈回到的却不是原处。两个放羊最大的区别，一个是满足物质生活，一个是满足精神生活。曾经的种地放羊是生活的根基，被迫接受的事没有什么美感，结束一天的工作后裹着一身臭汗上炕睡觉第二天周而复始，这种放羊与“舒适的生活”是没有挂钩的。而现在那种有情怀的种地放羊则是一种有钱人的主动选择，把过去的苦事中的精华提取，与其他美好的事相连接，在放羊的生活中也能享受惬意的生活。他们有能力选择和组合生活，这不该被批判。\r\n1. 我看到的多数家庭的教育是颠倒混乱的。生下来到学龄前应当树立家长权威（要有敬畏），他们却去溺爱；小学应当严格培养学习习惯和基础，他们却宽松；青春期个性萌芽，父母应当从权威退到民主，让孩子学会理性和责任时，他们却开始各种着急焦虑和专制严管；到大学应该是退居二线，最多给于建议的时候他们开始对孩子人生规划指手画脚；工作了，父母应当放手让孩子完全独立对自己负责时，他们却最终升级到强迫相亲这种直接干涉。\r\n1. 不愿费心力和别人交流。然而总是被指诘在躲避。内心不坦然，才是孤独者的坟墓。\r\n1. 人生如逆旅，我亦是行人。\r\n1. 你一直耿耿于怀的事事实上相关人物根本早就忘记了 耿耿于怀的果然只有你自己“\r\n1. 当前的环境也许只是一个暂态，也许只是世界的一小面；如果你想要见见更大的世界，那就不要太急着让自己为了适应当前的环境而彻底改变。\r\n1. 当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。——陶杰 《杀鹌鹑的少女》\r\n1. 那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 — —王小波\r\n1. 想要追求自由随性的生活，就一定要先从自律开始。\r\n1. 别人口中越是容易让人得出倾向性结论的问题描述，往往代表他刻意隐瞒了越多关键的细节。\r\n1. 走不进去的世界就不要硬挤了，为难了别人，也作贱了自己。\r\n1. 古龙《多情剑客无情剑》里，提过一个例子：一对厨子，饭馆打烊后，他们在后厨，自己给自己炒了盘菜，找点小酒，很惬意的饮食一番，舒服那一两个时辰。\r\n--古龙还说：他们还活着，就是因为一天还有那么一两个时辰。\r\n1. 从来如此，便对么？——鲁迅《狂人日记》\r\n1. 那……学校不好，难道知识也不好么?\r\n1. 高三毕业的欢送会上，复读班上的五个男生合唱了这首歌，我知道他们都不是第一年参加高考，我也知道那一年他们仍然成绩平平，我们那一届复读班整体都考的很差，但这首歌我记到现在。好像长这么大，见过的最多的无功而返，苦苦挣扎都是在学习的道路上。可苦涩中的温暖最能长存。路漫漫，且行且珍重！\r\n1. 我一直记得刘瑜写给女儿的一段话：愿你被很多人爱，如果没有，愿你在寂寞里学会宽容。\r\n1. 开始并完成一件事，比做好它更重要，因为只要开始了，你就有机会把它做的更好———-一件看上去繁难的事，只要开始做了，就会变得越来越容易。”\r\n1. 张一鸣有一句说的特别对：所谓成功，就是延迟满足。\r\n1. 成长是件残酷的事情，也许久而久之我们活成了别人想要的模样。但世俗跟成熟是两码事：在熙熙攘攘之外学会“我愿意”，不愿将就的你也可以不那么讲究。\r\n1. “秘密的暴力比公开的暴力更令人恐怖，它会使人失去思考能力、道德意识和抵抗意志，因此退化到最低等原始动物保命本能中去。为了保命求生、避免肉体折磨，人会变得全无廉耻、奴性十足、无所不为。秘密统治对政府权力的正当行使和合道德性同样有着严重的腐蚀作用。” ---《布达佩斯往事》\r\n1. 一个成熟的人，他的标准来自他的内心，而大多数的人，却受环境左右。对自己的标准会不由自主的降低以适应这个环境，减少自身与环境的冲突，在一个低标准下，自觉“满意”的度过每一天。 ——《精进》\r\n1. 梦想不一定要马上实现，如果身边的人反对，那就走慢一点，只要你每天确定自己在往那里走就行。\r\n1. 他没有勇气，也没有兴趣使渴望的行动得以一气呵成，因此自己在半途中就会怀疑行动的意义。---夏目漱石\r\n1. 我来不及认真地年轻，待明白过来时，只能选择认真地老去。 —— 三毛\r\n1. 我会以我的标准与方式看待世界，但我并不会以他来要求他人。--清让\r\n1. 时间，只是一个自称能治百病的庸医。\r\n1. 当你能从你认可的人或者事物身上吸取经验与知识，这是大部分人能做到的，但是如果你能从你不认可的人或者事物身上吸取营养，学到东西，那就真的太难得\r\n了。\r\n1. 你想成为什么样的人，那就尽量去向他们靠近。\r\n1. 真正幽默的人，是把快乐给了别人。\r\n1. 人这一生有很多重要的决定，每个决定其实都决定了我未来的人生，是否被动接受做一个幼师、是否转专业、是否升本等等等，做这些所有的选择与决定前，想想自身的优势，结合趋势与实力，看一下自己做这件事的把握有多少，但凡重大的决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是一些人生的重大决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，我最该做的，是在一开始选择前，确定这场仗能打赢，再去打。\r\n1. 面试造飞机，工作扭螺丝。\r\n1. “让忙于务实的人务实，让乐于做梦的人做梦”。\r\n1. 生命是一场华丽的冒险，只是我们永远都跨不过时间的深渊。\r\n1. 曾经的你，以为只要带着那把长剑和赤子之心就可以说服自己不出卖理想的灵魂。在最艰难和不得不流泪的晚上，即使连自己都在笑自己傻，但仍然用长剑刺痛自己，提醒自己，勇往直前，直到将来。\r\n1. 过往不恋，未来不迎，当下不负。\r\n1. 忠言逆耳，良药苦口，可不都是这样吗。但我觉得最重要的是要培养自己的判断力，在兼容并包的基础上一定要有自己的主心骨。善听百家之言，思想上的言论抒发不分对错，要客观结合自己的情况，别人的经验也不全是对的，就算是对的，也不全适合自己，不同的人有不同的性格，脾气，要自己汲取自己认可的观点看法，适合自己才是最好的。\r\n1. 世上最难的事之一，把自己的思想装进别人的脑袋。\r\n1. 这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。 ——《大鱼海棠》\r\n1. 有时候遇到瓶颈了，你应该停下来好好想想，是有四年工作经验，还是一个经验用了四年。\r\n1. 这世上唯有病痛和亲人去世是真切的痛楚，其他都是不必要的伤感，是忽略了当下拥有的一切的贪婪。\r\n1. 许多人所谓的成熟， 不过是被习俗磨去了棱角，变得世故而实际了。那不是成熟，而是精神的早衰和个性的消亡。真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。\r\n1. 别嫌读书苦，你现在的气质里，藏着你走过的路，读书不是为了雄辩和驳斥，也不是为了轻信和盲从，而是为了思考和权衡。\r\n1. 真的不要小看父母，不要觉得自己很厉害。以前笑父母遥控器还要套个手机套，其实和现在我们用手机还要贴膜戴手机套是一样的。以前笑父母为了一毛钱还和人家讨价还价，其实和我们现在用着手机在群里抢红包是一样的。以前父母无聊时磕着瓜子看着小说，其实和我们现在拿着手机刷着朋友圈是一样的。以前父母拉几个好友打麻将谈天说地，其实和我们现在拉几个网友王者农药开黑是一样的。以前父母在厂里上班踩着缝纫机，其实和我们现在写字楼里对着电脑写 PPT word 文档是一样的。所有的都没有变，只是时代在变，生活方式升级，换一种方式活着而已。很多年以后，可能会有10后笑着：瞧，我爸以前是在格子间苦逼写代码的工程师，我现在一家未来公司看着机器人帮我干活，公司只有我一个人呢。\r\n1. 有勇气去改变那些可以改变的事，\r\n有肚量去容忍那些无法改变的事，\r\n有智慧去区分上述的事。\r\n1. 识人不必探尽，探尽则多疑。\r\n知人不必言尽，言尽则无友。\r\n责人不必苛尽，苛尽则众远。\r\n敬人不必卑尽，卑尽则少骨。\r\n让人不必退尽，退尽则路寡。\r\n1. 安全感在很多时候是束缚人的枷锁，过度追求会让人生少了很多可能性。\r\n1. 大部分的恐惧，只有在你把它当回事儿的时候才是。\r\n1. 很多时候，没有兴趣并不真的是没有兴趣，而是怕自己做不好。\r\n1. 最好的兴趣就是永远达不到但可以不断精进的那些。\r\n1. 很多时候，成功者是自证的，失败者也是。\r\n1. 阻止大脑用思维定式进行自动加工，夺回大脑的控制权。\r\n1. 努力不是盲目的，是定向的。\r\n1. 要超越心智，首先要能辨别更好的心智与现有心智的区别。\r\n1. 世俗的成功不是人人都可以达成的，按概率也就只有一小部分。\r\n1. 盲目听信成功学故事并模仿，将离成功越来越远。\r\n1. 不管是恋爱还是职场，要选得好就得先小范围尝试和观察，对所谓的“好坏”有个大体了解后，然后再选择，最后全情投入。\r\n1. 完美的职业规划不存在，避免因为规划得太细而失去更多的可能性。\r\n1. 过去的付出只代表过去，沉没成本不是成本。\r\n1. 常认为自己是受害者的人往往真的会成为受害者。\r\n1. 绝对公平并不存在，追求绝对公平只是追求自利。\r\n1. 活在父母的世界跟活在子女的世界一样，都是人格尚未独立出来的婴儿。\r\n1. 在事情没有快速变化的前提下，等待仅仅是无谓的消耗。\r\n1. 要撕掉自己的短处，不要试图掩盖，用更强的标签去替代它。\r\n1. 陷入指定的成功，你就基本不太可能成功了。\r\n1. 握不住的沙，不如扬了它。\r\n1. 优于别人并不高贵，真正的高贵因该是优于过去的自己。-- 海明威《真实的高贵》\r\n1. 顶级组织至情至性，\r\n 一流组织共同信仰，\r\n二流组织共同利益，\r\n三流组织共同规则。\r\n1. 像老大寻求意见时，自己先思考出几套解决方案也就是“香蕉”，让你的老板去做选择而不是让他出想法。如果因为你的”香蕉”没熟透，放心你的老大会给你更好的解决方法，先养成动脑思考的好习惯。 --香蕉法则\r\n1. 善良不是要求别人做什么，而是要求自己做什么。\r\n1. 自己是既得利益者，说这不公平叫「觉悟高」，值得钦佩，自己不是既得利益者，就别眼里只看到不公平，因为这太正常了，如果不理解，或者心生抱怨，该想想自己的问题。\r\n1. 文字传达观点，文字也能误传观点。\r\n1. “检验一流智力的标准，就是看你能不能在头脑中同时存在两种相反的想法，还维持正常行事的能力。”\r\n1. 有时候，鸡汤可能比所谓的干货更有用，很多道理其实大家都懂，我们做出改变缺乏的只是一个推动力。\r\n1. 不自律，无自由：\r\n曾经以为自由就是想做啥做啥，后来才发现自律者才会自由。当一个人缺乏自由的时候，他做的事情总是在受习惯和即时诱惑的影响，要么就是被他人的思想观念所扰，几乎永远不可能去做内心真正渴望的事。\r\n1. 《海上钢琴师》中，1900 为什么最后没有下船？\r\n我们的陆地就是他的海洋。无人愿意一生漂泊。\r\n1. 永生是否是一种酷刑？\r\n凡是能被适应的惩罚都不能算是酷刑。\r\n1. 当有人做一件事并没有伤害到任何人的事情，你却要指手画脚的时候，你才是那个傻逼。\r\n1. 这世上只有一种成功，就是能用自己喜欢的方式度过自己的一生。\r\n1. 只有深入一座城市的边边角角，了解城市里的一花一草一木，才能真正看懂人生百态，品味酸甜苦辣的人生。\r\n1. 信仰是用来约束自己的。\r\n1. 习惯，是扼杀创造力的最大杀手！\r\n当你所掌握的信息不足以帮自己判断的时候，你可以选择观望，但是用这些无比正确的废话来说服别人，就是最大的笑话，就等同于，你自己没有判断力，也要求别人也跟你一样没有判断力。\r\n1. 没有观点的反驳更可怕，有那么一拨人，为了让自己无比正确，总说一大堆永远正确的话。\r\n1. 穷人思维和富人的思维是，穷人花 10 块，总奢望得到 100 块的价值，而富人花 1w 块，只求得到 1000 块的价值就够了，但是即便如此，富人可以轻易获取 1000 块的资源，而穷人即便费劲九牛二虎之力得到 100 块的价值也差距很大。\r\n1. 我自己也做了公众号，尤其是影响力越做越大，关注的人越来越多，当一个群体越来越大的时候，难免鱼龙混杂，什么样的人都有，也就意味着，你的所有观点，总会随着群体越来越大，不认可你的人越来越多，当然，认可你的人其实是更多的，但是认可你的人不会让你糟心，而不认可你的人，或者说一些杠精才会让你最糟心的。\r\n1. 这个世界有几样东西是不能被取代的，第一：亲身感受。我拿着一碗水，告诉你：这个是海洋，你永远不会有感觉。第二：自我成长和努力。没有人可以取代你做事情，应该自己完成的，只能由自己完成。工具的善用，自我的实力，重要性是排在第一位。刘翔跑再快，我开车，轻松超越他。当然，前提是我会开车，四肢还得健全。\r\n1. 吃不了起早贪黑的苦，你丢不起那个街头摆摊的人，你凭什么觉得不公平？\r\n1. 活在当下。我 22 岁的时候从不会去考虑五六年之后的我会是怎样，我只是活在当下，做好当下的事而已。\r\n1. 致正少年的你，愿你所有快乐无需假装，愿你此生尽兴赤诚善良。\r\n1. 罗素说：只有一种英雄主义，就是在认清生活的真相后依然热爱生活。\r\n1. 这世界就是一拨人昼夜不停的运转，另一拨人起床发现世界变了。',`groups`='Default',`is_show`=1  WHERE  `id` = 32 [ RunTime:0.001851s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000820s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000394s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000650s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000315s ]
---------------------------------------------------------------
[ 2018-10-09T22:27:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/32.html
[ info ] qingrang.top/daily/admin/note/shownote/id/32.html [运行时间：0.052209s][吞吐率：19.15req/s] [内存消耗：2,048.38kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/32.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '32',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000450s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001201s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000477s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000872s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000276s ]
---------------------------------------------------------------
[ 2018-10-09T22:28:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.068694s][吞吐率：14.56req/s] [内存消耗：2,220.74kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000499s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001289s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001065s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000549s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000903s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000445s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000521s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000944s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000308s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000432s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000415s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000781s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001182s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000628s ]
---------------------------------------------------------------
[ 2018-10-09T22:29:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.071304s][吞吐率：14.02req/s] [内存消耗：2,220.74kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000576s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001110s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000465s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000948s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000335s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000480s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000949s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000297s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000422s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000424s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000752s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000216s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001139s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001040s ]
---------------------------------------------------------------
[ 2018-10-09T22:30:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/0.html
[ info ] qingrang.top/daily/admin/note/editnote/id/0.html [运行时间：0.062311s][吞吐率：16.05req/s] [内存消耗：2,038.11kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '0',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000561s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001325s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000409s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000835s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-10-09T22:30:48+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/0.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/0.html [运行时间：0.060855s][吞吐率：16.43req/s] [内存消耗：2,066.84kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '4579',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/0.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'content' => '# 请看护好你曾经的激情和理想
我不需要提醒你们，未来将如何以具体琐碎，消磨这份浪漫与绚烂；
也不需要提醒你们，人生将以怎样的平庸世故，消解你们的万丈雄心；
更不需要提醒你们，走入社会，要如何变得务实与现实，因为你们终将以一生浸淫其中。
我唯一的害怕，是你们已经不相信了：不相信规则能战胜潜规则，不相信学场有别于官场；不相信学术不等于权术，不相信风骨远胜于媚骨。
你们或许不相信了，因为追求级别的越来越多，追求真理的越来越少；讲待遇的越来越多，讲理想的越来越少；大官越来越多，大师越来越少。
因此，在你们走向社会之际，我想说的只是，请看护好你曾经的激情和理想。在这个怀疑的时代，我们依然需要信仰。
从母校的教诲出发，二十多年社会生活给我的最大启示是：当许多同龄人都陷于时代的车轮下，那些能幸免的人，不仅因为坚强，更因为信仰。不用害怕圆滑的人说你不够成熟，不用在意聪明的人说你不够明智，不要照原样接受别人推荐给你的生活，选择坚守、选择理想，选择倾听内心的呼唤，才能拥有最饱满的人生。
无论中国怎样，请记得：你所站立的地方，就是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你有光明，中国便不再黑暗。
>卢新宁

',
  'groups' => 'Default',
  'showsel' => '0',
  'id' => '0',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000494s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001263s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000409s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000426s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000872s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000296s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000325s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=0,`p_id`=1,`title`='请看护好你曾经的激情和理想\r',`content`='# 请看护好你曾经的激情和理想\r\n我不需要提醒你们，未来将如何以具体琐碎，消磨这份浪漫与绚烂；\r\n也不需要提醒你们，人生将以怎样的平庸世故，消解你们的万丈雄心；\r\n更不需要提醒你们，走入社会，要如何变得务实与现实，因为你们终将以一生浸淫其中。\r\n我唯一的害怕，是你们已经不相信了：不相信规则能战胜潜规则，不相信学场有别于官场；不相信学术不等于权术，不相信风骨远胜于媚骨。\r\n你们或许不相信了，因为追求级别的越来越多，追求真理的越来越少；讲待遇的越来越多，讲理想的越来越少；大官越来越多，大师越来越少。\r\n因此，在你们走向社会之际，我想说的只是，请看护好你曾经的激情和理想。在这个怀疑的时代，我们依然需要信仰。\r\n从母校的教诲出发，二十多年社会生活给我的最大启示是：当许多同龄人都陷于时代的车轮下，那些能幸免的人，不仅因为坚强，更因为信仰。不用害怕圆滑的人说你不够成熟，不用在意聪明的人说你不够明智，不要照原样接受别人推荐给你的生活，选择坚守、选择理想，选择倾听内心的呼唤，才能拥有最饱满的人生。\r\n无论中国怎样，请记得：你所站立的地方，就是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你有光明，中国便不再黑暗。\r\n>卢新宁\r\n\r\n',`groups`='Default',`is_show`=0  WHERE  `id` = 0 [ RunTime:0.000454s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Think' LIMIT 1 [ RunTime:0.000783s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=16  WHERE  `groups` = 'Think' [ RunTime:0.000349s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000653s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Default' [ RunTime:0.000382s ]
---------------------------------------------------------------
[ 2018-10-09T22:30:49+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/0.html
[ info ] qingrang.top/daily/admin/note/shownote/id/0.html [运行时间：0.054264s][吞吐率：18.43req/s] [内存消耗：1,990.25kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/0.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '0',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000461s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001143s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000425s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000796s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-10-09T22:30:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.067886s][吞吐率：14.73req/s] [内存消耗：2,220.76kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000466s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001202s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001051s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000470s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000898s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000313s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000478s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001085s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000296s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000401s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000324s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000525s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000852s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000221s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001148s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000606s ]
---------------------------------------------------------------
[ 2018-10-09T22:31:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ info ] qingrang.top/daily/admin/note/shownote/id/1.html [运行时间：0.059977s][吞吐率：16.67req/s] [内存消耗：2,028.78kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000456s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001268s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000515s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000852s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000318s ]
---------------------------------------------------------------
[ 2018-10-09T22:31:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ info ] qingrang.top/daily/admin/note/editnote/id/208.html [运行时间：0.063303s][吞吐率：15.80req/s] [内存消耗：2,038.42kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '208',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000602s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001941s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000618s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001202s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000414s ]
---------------------------------------------------------------
[ 2018-10-09T22:31:34+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.070466s][吞吐率：14.19req/s] [内存消耗：2,043.73kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '3732',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/208.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Code 自定义快捷键
[TOC]
## 主流自定义
### 行操作
|含义|按键|
|-|-|
|删除行|Ctrl + d|
|向下复制行|Ctrl + b|
|移动行|Alt + Up/Down|
|上开新行|Ctrl + up|
|下开新行|Ctrl + down|
### 注释
>行注释

Ctrl + /

>块注释

Ctrl + Shift + /
### 其他常用操作
>提示

alt + /

>添加getter、setter方法

alt + insert

>替换文本

Ctrl + R

## Sublime Text 3
https://blog.csdn.net/u010994304/article/details/50866634

// Ctrl+Enter
// 插入行后

// Ctrl+Shift Enter
// 插入行前

// Shift+Tab
// 去除缩进

// Tab
// 缩进

// Ctrl+KK
// 从光标处删除至行尾
```
[
	// 删除当前行
	{ "keys": ["ctrl+d"], "command":"run_macro_file", "args": {"file":"Packages/Default/Delete Line.sublime-macro"} },
	
	// 与上行互换
	{ "keys": ["alt+up"], "command":"swap_line_up" },
	// 与下行互换
	{ "keys": ["alt+down"], "command":"swap_line_down" },

	// 向下复制行
	{ "keys": ["ctrl+alt+down"], "command":"duplicate_line" },
	
	// 自动提示、补全
	{ "keys": ["alt+/"], "command":"auto_complete" },
	{ "keys": ["alt+/"], "command":"replace_completion_with_auto_complete", "context":
	[
	{ "key": "last_command", "operator":"equal", "operand": "insert_best_completion" },
	{ "key": "auto_complete_visible", "operator":"equal", "operand": false },
	{ "key": "setting.tab_completion", "operator":"equal", "operand": true }
	]
	},

	//移动光标到行首或行末
	{ "keys": ["alt+b"], "command":"move_to", "args": {"to": "bol","extend": false} },
	{ "keys": ["alt+e"], "command":"move_to", "args": {"to": "eol","extend": false} },
	//移动光标到行首或行末并选择内容
	{ "keys": ["shift+alt+b"], "command":"move_to", "args": {"to": "bol","extend": true} },
	{ "keys": ["shift+alt+e"], "command":"move_to", "args": {"to": "eol","extend": true} },

]
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000554s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001378s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Code 自定义快捷键',`content`='# Code 自定义快捷键\n[TOC]\n## 主流自定义\n### 行操作\n|含义|按键|\n|-|-|\n|删除行|Ctrl + d|\n|向下复制行|Ctrl + b|\n|移动行|Alt + Up/Down|\n|上开新行|Ctrl + up|\n|下开新行|Ctrl + down|\n### 注释\n>行注释\n\nCtrl + /\n\n>块注释\n\nCtrl + Shift + /\n### 其他常用操作\n>提示\n\nalt + /\n\n>添加getter、setter方法\n\nalt + insert\n\n>替换文本\n\nCtrl + R\n\n## Sublime Text 3\nhttps://blog.csdn.net/u010994304/article/details/50866634\n\n// Ctrl+Enter\n// 插入行后\n\n// Ctrl+Shift Enter\n// 插入行前\n\n// Shift+Tab\n// 去除缩进\n\n// Tab\n// 缩进\n\n// Ctrl+KK\n// 从光标处删除至行尾\n```\n[\n	// 删除当前行\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\n	\n	// 与上行互换\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\n	// 与下行互换\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\n\n	// 向下复制行\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\n	\n	// 自动提示、补全\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\n	[\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\n	]\n	},\n\n	//移动光标到行首或行末\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\n	//移动光标到行首或行末并选择内容\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\n\n]\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000986s ]
---------------------------------------------------------------
[ 2018-10-09T22:31:38+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.105586s][吞吐率：9.47req/s] [内存消耗：2,198.10kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000596s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001719s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001539s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000689s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001639s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000431s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000582s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001355s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000400s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000611s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000400s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000532s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001113s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000332s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001626s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000954s ]
---------------------------------------------------------------
[ 2018-10-09T22:32:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/0.html
[ info ] qingrang.top/daily/admin/note/editnote/id/0.html [运行时间：0.052971s][吞吐率：18.88req/s] [内存消耗：2,038.14kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '0',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000537s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001297s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000417s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000941s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000303s ]
---------------------------------------------------------------
[ 2018-10-09T22:32:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ info ] qingrang.top/daily/admin/note/shownote/id/1.html [运行时间：0.054894s][吞吐率：18.22req/s] [内存消耗：1,990.12kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000662s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001380s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000450s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000894s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000308s ]
---------------------------------------------------------------
[ 2018-10-09T22:32:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/195.html
[ info ] qingrang.top/daily/admin/note/editnote/id/195.html [运行时间：0.062537s][吞吐率：15.99req/s] [内存消耗：2,037.48kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '195',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000629s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002701s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 195 LIMIT 1 [ RunTime:0.000604s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000964s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000432s ]
---------------------------------------------------------------
[ 2018-10-09T22:32:37+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.051950s][吞吐率：19.25req/s] [内存消耗：2,036.55kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '2004',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/195.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Python 基础知识
`python`

[TOC]
## 变量和简单数据类型
### 变量
尽量使用小写和下划线命名
```
result_msg = "Hello World!"
print(result_msg)
```
### 字符串
单双引号都行
#### 大小写转换
```
msg = \'"hello" world!\'
print(msg.title())
------------------
"Hello" World!
------------------
# 函数
title()：以首字母大写的方式显示每个单词
upper()：全大写
lower()：全小写
```
#### 去两端的特别字符
```
msg = " hel lo "
# 默认空格
print("-" + msg.strip() + "-")
--------------
-hel lo-
--------------
======================================
# 指定字符
msg = "+hello+"
print(msg.strip(\'+\'))
--------------
hello
--------------
# 函数
strip()：去两端的字符
lstrip()：去左端的字符
rstrip()：去右端的字符
```
### 整数
```
num1 = 3
num2 = 3
# ** 表示乘方运算
print(num1 ** num2)
------------------
27
------------------
```
## 列表


',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000472s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001446s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Python 基础知识',`content`='# Python 基础知识\n`python`\n\n[TOC]\n## 变量和简单数据类型\n### 变量\n尽量使用小写和下划线命名\n```\nresult_msg = \"Hello World!\"\nprint(result_msg)\n```\n### 字符串\n单双引号都行\n#### 大小写转换\n```\nmsg = \'\"hello\" world!\'\nprint(msg.title())\n------------------\n\"Hello\" World!\n------------------\n# 函数\ntitle()：以首字母大写的方式显示每个单词\nupper()：全大写\nlower()：全小写\n```\n#### 去两端的特别字符\n```\nmsg = \" hel lo \"\n# 默认空格\nprint(\"-\" + msg.strip() + \"-\")\n--------------\n-hel lo-\n--------------\n======================================\n# 指定字符\nmsg = \"+hello+\"\nprint(msg.strip(\'+\'))\n--------------\nhello\n--------------\n# 函数\nstrip()：去两端的字符\nlstrip()：去左端的字符\nrstrip()：去右端的字符\n```\n### 整数\n```\nnum1 = 3\nnum2 = 3\n# ** 表示乘方运算\nprint(num1 ** num2)\n------------------\n27\n------------------\n```\n## 列表\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000720s ]
---------------------------------------------------------------
[ 2018-10-09T22:32:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.066892s][吞吐率：14.95req/s] [内存消耗：2,197.22kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000532s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001302s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001092s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000557s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001090s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000318s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000368s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000893s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000274s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000384s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000732s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000233s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000995s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000590s ]
---------------------------------------------------------------
[ 2018-10-09T22:32:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/1.html
[ info ] qingrang.top/daily/admin/note/editnote/id/1.html [运行时间：0.055702s][吞吐率：17.95req/s] [内存消耗：2,037.53kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000508s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001739s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000482s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000997s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000294s ]
---------------------------------------------------------------
[ 2018-10-09T22:33:14+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/0.html
[ info ] qingrang.top/daily/admin/note/shownote/id/0.html [运行时间：0.098750s][吞吐率：10.13req/s] [内存消耗：1,989.84kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '0',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000639s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001921s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000668s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001593s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000495s ]
---------------------------------------------------------------
[ 2018-10-09T22:33:28+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/delnote/id/0.html
[ info ] qingrang.top/daily/admin/note/delnote/id/0.html [运行时间：0.059316s][吞吐率：16.86req/s] [内存消耗：2,058.08kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'delnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '0',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->delNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000492s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001248s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000377s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note_del` [ RunTime:0.001039s ]
[ sql ] [ SQL ] INSERT INTO `note_del` (`id` , `title` , `content` , `date` , `groups` , `p_id` , `is_show`) VALUES (0 , '请看护好你曾经的激情和理想\r' , '# 请看护好你曾经的激情和理想\r\n我不需要提醒你们，未来将如何以具体琐碎，消磨这份浪漫与绚烂；\r\n也不需要提醒你们，人生将以怎样的平庸世故，消解你们的万丈雄心；\r\n更不需要提醒你们，走入社会，要如何变得务实与现实，因为你们终将以一生浸淫其中。\r\n我唯一的害怕，是你们已经不相信了：不相信规则能战胜潜规则，不相信学场有别于官场；不相信学术不等于权术，不相信风骨远胜于媚骨。\r\n你们或许不相信了，因为追求级别的越来越多，追求真理的越来越少；讲待遇的越来越多，讲理想的越来越少；大官越来越多，大师越来越少。\r\n因此，在你们走向社会之际，我想说的只是，请看护好你曾经的激情和理想。在这个怀疑的时代，我们依然需要信仰。\r\n从母校的教诲出发，二十多年社会生活给我的最大启示是：当许多同龄人都陷于时代的车轮下，那些能幸免的人，不仅因为坚强，更因为信仰。不用害怕圆滑的人说你不够成熟，不用在意聪明的人说你不够明智，不要照原样接受别人推荐给你的生活，选择坚守、选择理想，选择倾听内心的呼唤，才能拥有最饱满的人生。\r\n无论中国怎样，请记得：你所站立的地方，就是你的中国；你怎么样，中国便怎么样；你是什么，中国便是什么；你有光明，中国便不再黑暗。\r\n>卢新宁\r\n\r\n' , '2017-00-00' , 'Default' , 1 , 0) [ RunTime:0.000487s ]
[ sql ] [ SQL ] DELETE FROM `note`    WHERE  `id` = 0 [ RunTime:0.000430s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000817s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000960s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000435s ]
---------------------------------------------------------------
[ 2018-10-09T22:33:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.073986s][吞吐率：13.52req/s] [内存消耗：2,194.26kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000469s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001417s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001125s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000680s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001374s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000490s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001033s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000299s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000291s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000381s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000916s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000307s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001214s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000722s ]
---------------------------------------------------------------
[ 2018-10-09T22:33:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.108030s][吞吐率：9.26req/s] [内存消耗：2,194.71kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000631s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001792s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001500s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000740s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001504s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000460s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000597s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001418s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000443s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000633s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000415s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000547s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001121s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000356s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001696s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001074s ]
---------------------------------------------------------------
[ 2018-10-09T22:33:48+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ info ] qingrang.top/daily/admin/note/ashownote1.html [运行时间：0.060461s][吞吐率：16.54req/s] [内存消耗：2,234.45kb] [文件加载：53]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote1',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=n0fv37m1vv23fvq0mk0eupuuo3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupsID' => '3',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote1[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000541s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001352s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 3  AND `id` > 2 ORDER BY date desc [ RunTime:0.001268s ]
