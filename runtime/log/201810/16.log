---------------------------------------------------------------
[ 2018-10-16T01:39:36+08:00 ] 74.120.168.12 66.249.75.30 GET /daily/admin/note/admin/note/shownote/id/
[ info ] qingrang.top/daily/admin/note/admin/note/shownote/id/ [运行时间：0.038223s][吞吐率：26.16req/s] [内存消耗：1,427.57kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'admin',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'from' => 'googlebot(at)googlebot.com',
  'user-agent' => 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
  'accept-encoding' => 'gzip,deflate,br',
)
[ info ] [ PARAM ] array (
  'note' => 'shownote',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T01:39:49+08:00 ] 74.120.168.12 66.249.75.30 GET /daily/admin/note/admin/note/editNote/id/
[ info ] qingrang.top/daily/admin/note/admin/note/editNote/id/ [运行时间：0.040474s][吞吐率：24.71req/s] [内存消耗：1,427.58kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'admin',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'from' => 'googlebot(at)googlebot.com',
  'user-agent' => 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
  'accept-encoding' => 'gzip,deflate,br',
)
[ info ] [ PARAM ] array (
  'note' => 'editNote',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T01:39:49+08:00 ] 74.120.168.12 66.249.75.30 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.036018s][吞吐率：27.76req/s] [内存消耗：1,340.31kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'referer' => 'http://qingrang.top/daily/admin/note/admin/note/shownote/id/',
  'cookie' => 'PHPSESSID=8aivsndi1pg89ofh53houelsc4',
  'accept-language' => 'en-US',
  'connection' => 'keep-alive',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'from' => 'googlebot(at)googlebot.com',
  'user-agent' => 'Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Safari/537.36',
  'accept-encoding' => 'gzip,deflate,br',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T01:40:19+08:00 ] 74.120.168.12 66.249.75.31 GET /daily/admin/note/admin/note/delnote/id/
[ info ] qingrang.top/daily/admin/note/admin/note/delnote/id/ [运行时间：0.037576s][吞吐率：26.61req/s] [内存消耗：1,427.66kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'admin',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'from' => 'googlebot(at)googlebot.com',
  'user-agent' => 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
  'accept-encoding' => 'gzip,deflate,br',
)
[ info ] [ PARAM ] array (
  'note' => 'delnote',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T09:49:40+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.044518s][吞吐率：22.46req/s] [内存消耗：1,339.47kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T09:50:31+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.076957s][吞吐率：12.99req/s] [内存消耗：1,922.04kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001434s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.003788s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000613s ]
---------------------------------------------------------------
[ 2018-10-16T09:50:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.090003s][吞吐率：11.11req/s] [内存消耗：2,195.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=c0puc3rssupe2fplr9ckdqk7o7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000717s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001999s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.004740s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000709s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001546s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000505s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000878s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001650s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000500s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000687s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000487s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000609s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001952s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000406s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001790s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001124s ]
---------------------------------------------------------------
[ 2018-10-16T09:51:23+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.074040s][吞吐率：13.51req/s] [内存消耗：2,103.61kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=c0puc3rssupe2fplr9ckdqk7o7',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000655s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001703s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000710s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001453s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000447s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000986s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000434s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000486s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000318s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000368s ]
---------------------------------------------------------------
[ 2018-10-16T16:25:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.041321s][吞吐率：24.20req/s] [内存消耗：1,339.45kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T16:25:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.072756s][吞吐率：13.74req/s] [内存消耗：2,103.29kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001417s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002627s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000914s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.002562s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000501s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001047s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000362s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000471s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000307s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000380s ]
---------------------------------------------------------------
[ 2018-10-16T16:25:38+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/224.html
[ info ] qingrang.top/daily/admin/show/shownote/id/224.html [运行时间：0.068039s][吞吐率：14.70req/s] [内存消耗：1,938.88kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
  'id' => '224',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000838s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001876s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 224 LIMIT 1 [ RunTime:0.000532s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001048s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000342s ]
---------------------------------------------------------------
[ 2018-10-16T16:25:58+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/223.html
[ info ] qingrang.top/daily/admin/show/shownote/id/223.html [运行时间：0.069077s][吞吐率：14.48req/s] [内存消耗：1,938.31kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
  'id' => '223',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000689s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001807s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 223 LIMIT 1 [ RunTime:0.000450s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001111s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
---------------------------------------------------------------
[ 2018-10-16T16:26:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/222.html
[ info ] qingrang.top/daily/admin/show/shownote/id/222.html [运行时间：0.062357s][吞吐率：16.04req/s] [内存消耗：1,937.46kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
  'id' => '222',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000628s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001467s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 222 LIMIT 1 [ RunTime:0.000479s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000940s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000358s ]
---------------------------------------------------------------
[ 2018-10-16T16:26:30+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/222.html
[ info ] qingrang.top/daily/admin/show/shownote/id/222.html [运行时间：0.064505s][吞吐率：15.50req/s] [内存消耗：1,937.46kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
  'id' => '222',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000783s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001601s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 222 LIMIT 1 [ RunTime:0.000434s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000918s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000290s ]
---------------------------------------------------------------
[ 2018-10-16T16:27:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/224.html
[ info ] qingrang.top/daily/admin/show/shownote/id/224.html [运行时间：0.063536s][吞吐率：15.74req/s] [内存消耗：1,938.88kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
  'id' => '224',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000587s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001499s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 224 LIMIT 1 [ RunTime:0.000480s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000914s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000297s ]
---------------------------------------------------------------
[ 2018-10-16T18:39:47+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.047268s][吞吐率：21.16req/s] [内存消耗：1,339.47kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T18:40:03+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.099342s][吞吐率：10.07req/s] [内存消耗：1,922.04kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002340s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.004254s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000751s ]
---------------------------------------------------------------
[ 2018-10-16T18:40:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.129291s][吞吐率：7.73req/s] [内存消耗：2,195.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000816s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002238s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.004097s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000850s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001753s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000648s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000961s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001835s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000567s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000793s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000528s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000674s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.002176s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000479s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.002235s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001971s ]
---------------------------------------------------------------
[ 2018-10-16T18:40:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.092532s][吞吐率：10.81req/s] [内存消耗：2,020.46kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000642s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001676s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000392s ]
---------------------------------------------------------------
[ 2018-10-16T18:40:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.079339s][吞吐率：12.60req/s] [内存消耗：2,195.63kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000602s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001291s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001925s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000394s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001021s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000407s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000527s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001065s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000301s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000403s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000391s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000349s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001042s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000320s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000995s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000692s ]
---------------------------------------------------------------
[ 2018-10-16T18:40:14+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.072450s][吞吐率：13.80req/s] [内存消耗：2,222.06kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '15',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'Linux',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000866s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001490s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Linux' ORDER BY date desc [ RunTime:0.001641s ]
---------------------------------------------------------------
[ 2018-10-16T18:40:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/212
[ info ] qingrang.top/daily/admin/note/editNote/id/212 [运行时间：0.085562s][吞吐率：11.69req/s] [内存消耗：2,027.70kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editNote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000600s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001556s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000455s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001174s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000421s ]
---------------------------------------------------------------
[ 2018-10-16T18:40:33+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.059567s][吞吐率：16.79req/s] [内存消耗：2,021.22kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '58',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000758s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001536s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000615s ]
---------------------------------------------------------------
[ 2018-10-16T18:46:00+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.076848s][吞吐率：13.01req/s] [内存消耗：2,025.50kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '1321',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 进程的其它属性
除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。
```
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000910s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001764s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 进程的其它属性\n除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。\n```\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000735s ]
---------------------------------------------------------------
[ 2018-10-16T18:48:36+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.053778s][吞吐率：18.59req/s] [内存消耗：2,025.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '1328',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000714s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001436s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000431s ]
---------------------------------------------------------------
[ 2018-10-16T18:48:57+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.053266s][吞吐率：18.77req/s] [内存消耗：2,025.76kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '1364',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000564s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001372s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000558s ]
---------------------------------------------------------------
[ 2018-10-16T19:32:07+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.064805s][吞吐率：15.43req/s] [内存消耗：2,031.85kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '2916',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000585s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001953s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000544s ]
---------------------------------------------------------------
[ 2018-10-16T19:40:26+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.057069s][吞吐率：17.52req/s] [内存消耗：2,038.18kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '4471',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){					//父进程
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){					//子进程
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000674s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001945s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){					//父进程\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){					//子进程\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000601s ]
---------------------------------------------------------------
[ 2018-10-16T19:50:51+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.057915s][吞吐率：17.27req/s] [内存消耗：2,040.96kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '5123',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000636s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001379s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000582s ]
---------------------------------------------------------------
[ 2018-10-16T20:43:59+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.075408s][吞吐率：13.26req/s] [内存消耗：2,052.99kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8913',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```

',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000701s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001392s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000609s ]
---------------------------------------------------------------
[ 2018-10-16T21:28:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.061929s][吞吐率：16.15req/s] [内存消耗：2,062.27kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '12130',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。





',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000638s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001619s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000646s ]
---------------------------------------------------------------
[ 2018-10-16T21:31:44+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.071734s][吞吐率：13.94req/s] [内存消耗：2,063.68kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '12484',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
>函数声明

`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
#### pause



',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000780s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001718s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n### 常见函数\n#### kill\n>函数声明\n\n`int kill(pid_t,int sig)`\npid：接收信号的进程ID\nsig：要发送的信号编号\n#### raise\n#### pause\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000760s ]
---------------------------------------------------------------
[ 2018-10-16T21:36:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.081721s][吞吐率：12.24req/s] [内存消耗：2,065.15kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '12976',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause(void)`


',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001901s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003296s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n### 常见函数\n#### kill\n给指定进程发送信号\n\n函数声明：`int kill(pid_t,int sig)`\npid：接收信号的进程ID\nsig：要发送的信号编号\n#### raise\n发送指定信号给当前进程自身\n\n函数声明：`int raise(int sig)`\n\n#### pause\n暂停进程，接收到任何信号后恢复\n\n函数声明：`int pause(void)`\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001137s ]
---------------------------------------------------------------
[ 2018-10-16T21:46:15+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.067962s][吞吐率：14.71req/s] [内存消耗：2,079.26kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '16819',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

#### 实验
>李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。

```
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"


pid_t pid;

//自定义信号处理函数
void sigusr1_handler(int n)
{
	//子进程打印 AAA，父进程打印 BBB
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0)
		kill(pid, SIGUSR1); //子进程，发送 SIGUSR1 信号给 pid 进程
	else
		kill(getppid(), SIGUSR1);//父进程，发送 SIGUSR1 信号给 父进程
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if(pid > 0)	//子进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000781s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002007s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n### 常见函数\n#### kill\n给指定进程发送信号\n\n函数声明：`int kill(pid_t,int sig)`\npid：接收信号的进程ID\nsig：要发送的信号编号\n#### raise\n发送指定信号给当前进程自身\n\n函数声明：`int raise(int sig)`\n\n#### pause\n暂停进程，接收到任何信号后恢复\n\n函数声明：`int pause()`\n\n#### alarm\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\n\n函数声明：`unsigned int alarm(unsigned int seconds)`\n\n#### signal\n捕获信号后，执行指定函数\n\n函数声明：\n`typedef void (* sighandler_t)(int);`\n`sighandler_t signal(int signum,sighandler_t handler);`\n\nsignum：信号编号\nhandler：自定义信号处理函数的函数指针\n\n#### 实验\n>李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\n\n```\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n\n\npid_t pid;\n\n//自定义信号处理函数\nvoid sigusr1_handler(int n)\n{\n	//子进程打印 AAA，父进程打印 BBB\n	if(pid > 0)\n		printf(\"AAAA\\n\");\n	else\n		printf(\"BBBB\\n\");\n\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\n}\n\nvoid sigalrm_handler(int n)\n{\n	if(pid > 0)\n		kill(pid, SIGUSR1); //子进程，发送 SIGUSR1 信号给 pid 进程\n	else\n		kill(getppid(), SIGUSR1);//父进程，发送 SIGUSR1 信号给 父进程\n}\n\nint main()\n{\n	//在fork()之前设置的信号处理函数会被子进程继承\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\n\n	pid = fork();\n	if(pid > 0)	//子进程\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\n\n	while(1)\n		pause();	//进程挂起，等待信号唤醒\n\n	return 0;\n}\n```\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000791s ]
---------------------------------------------------------------
[ 2018-10-16T21:51:39+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.062082s][吞吐率：16.11req/s] [内存消耗：2,109.91kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '24061',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

#### 实验
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"


pid_t pid;

//自定义信号处理函数
void sigusr1_handler(int n)
{
	//子进程打印 AAA，父进程打印 BBB
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0)
		kill(pid, SIGUSR1); //子进程，发送 SIGUSR1 信号给 pid 进程
	else
		kill(getppid(), SIGUSR1);//父进程，发送 SIGUSR1 信号给 父进程
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if(pid > 0)	//子进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000783s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002014s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n### 常见函数\n#### kill\n给指定进程发送信号\n\n函数声明：`int kill(pid_t,int sig)`\npid：接收信号的进程ID\nsig：要发送的信号编号\n#### raise\n发送指定信号给当前进程自身\n\n函数声明：`int raise(int sig)`\n\n#### pause\n暂停进程，接收到任何信号后恢复\n\n函数声明：`int pause()`\n\n#### alarm\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\n\n函数声明：`unsigned int alarm(unsigned int seconds)`\n\n#### signal\n捕获信号后，执行指定函数\n\n函数声明：\n`typedef void (* sighandler_t)(int);`\n`sighandler_t signal(int signum,sighandler_t handler);`\n\nsignum：信号编号\nhandler：自定义信号处理函数的函数指针\n\n#### 实验\n```\n/*---------------------------------------------------------------------------------------------------------\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\n---------------------------------------------------------------------------------------------------------*/\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n\n\npid_t pid;\n\n//自定义信号处理函数\nvoid sigusr1_handler(int n)\n{\n	//子进程打印 AAA，父进程打印 BBB\n	if(pid > 0)\n		printf(\"AAAA\\n\");\n	else\n		printf(\"BBBB\\n\");\n\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\n}\n\nvoid sigalrm_handler(int n)\n{\n	if(pid > 0)\n		kill(pid, SIGUSR1); //子进程，发送 SIGUSR1 信号给 pid 进程\n	else\n		kill(getppid(), SIGUSR1);//父进程，发送 SIGUSR1 信号给 父进程\n}\n\nint main()\n{\n	//在fork()之前设置的信号处理函数会被子进程继承\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\n\n	pid = fork();\n	if(pid > 0)	//子进程\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\n\n	while(1)\n		pause();	//进程挂起，等待信号唤醒\n\n	return 0;\n}\n```\n## 进程间通信\n```\n/*---------------------------------------------------------------------------------------------------------\n功能：\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\n\n思路：\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\n应使用信号量进行并发控制。	\n---------------------------------------------------------------------------------------------------------*/\n\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n#include \"sys/ipc.h\"\n#include \"sys/sem.h\"\n#include \"sys/shm.h\"\n\n\nunion semun\n{\n	int val;\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\n	ushort *array;\n};\n\n\nint semid;\nint shmid;\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\n\nvoid p(int semid)\n{\n	struct sembuf buf = {0, -1, 0};\n	semop(semid, &buf, 1);\n}\n\nvoid v(int semid)\n{\n	struct sembuf buf = {0, 1, 0};\n	semop(semid, &buf, 1);\n}\n\nvoid sigusr1_handler(int n)\n{\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\n	\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\n		printf(\"remove semaphore fail\\n\");\n	else\n		printf(\"remove semaphore ok\\n\");\n	\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\n		printf(\"remove shared-memory fail\\n\");\n	else\n		printf(\"remove shared-memory ok\\n\");\n\n	exit(0);\n}\n\nint main()\n{\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\n\n	//创建并初始化信号量\n	semid = semget(IPC_PRIVATE, 1, 0666);\n	if(semid == -1)\n	{\n		printf(\"create semaphore fail\\n\");\n		return 0;\n	}\n	else\n		printf(\"create semaphore ok\\n\");\n	union semun x;\n	x.val = 1;  //__为1___  //信号量初值应为多少？\n	semctl(semid, 0, SETVAL, x);\n	\n	//创建并关联到共享内存\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\n	if(shmid == -1)\n	{\n		printf(\"create shared-memory fail\\n\");\n		return 0;\n	}\n	else\n		printf(\"create shared-memory ok\\n\");\n	shm_virtualaddr = shmat(shmid, 0, 0);\n\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\n\n	char is_child = 0;\n	int i;\n	for(i=0; i<10; i++)\n	{\n		pid_t pid = fork();\n		if(pid == 0)\n		{\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\n			break;  //__退出循环_________________\n		}\n	}\n\n	if(is_child)\n	{\n		p(semid);  //P操作修改信号量（-1）____________________\n\n		srand(time(NULL) + i);\n		int num = rand()%10;\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\n\n		printf(\"child%d: %d\\n\", i, num);\n\n		v(semid);  //V操作修改信号量（+1）____________________\n\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\n	}\n	else\n	{\n		while(1)\n			pause();\n	}\n\n	return 0;\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000913s ]
---------------------------------------------------------------
[ 2018-10-16T21:51:47+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.112557s][吞吐率：8.88req/s] [内存消耗：2,109.82kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '24058',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

#### 实验
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"


pid_t pid;

//自定义信号处理函数
void sigusr1_handler(int n)
{
	//子进程打印 AAA，父进程打印 BBB
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0)
		kill(pid, SIGUSR1); //子进程，发送 SIGUSR1 信号给 pid 进程
	else
		kill(getppid(), SIGUSR1);//父进程，发送 SIGUSR1 信号给 父进程
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if(pid > 0)	//子进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000502s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001414s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n```\n\n---\n~~父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........~~\n\n---\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n```\n---\n>不 sleep 的输出：\n\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n\n---\n\n---\n>sleep() 后的输出\n\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n\n---\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n### 常见函数\n#### kill\n给指定进程发送信号\n\n函数声明：`int kill(pid_t,int sig)`\npid：接收信号的进程ID\nsig：要发送的信号编号\n#### raise\n发送指定信号给当前进程自身\n\n函数声明：`int raise(int sig)`\n\n#### pause\n暂停进程，接收到任何信号后恢复\n\n函数声明：`int pause()`\n\n#### alarm\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\n\n函数声明：`unsigned int alarm(unsigned int seconds)`\n\n#### signal\n捕获信号后，执行指定函数\n\n函数声明：\n`typedef void (* sighandler_t)(int);`\n`sighandler_t signal(int signum,sighandler_t handler);`\n\nsignum：信号编号\nhandler：自定义信号处理函数的函数指针\n\n#### 实验\n```\n/*---------------------------------------------------------------------------------------------------------\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\n---------------------------------------------------------------------------------------------------------*/\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n\n\npid_t pid;\n\n//自定义信号处理函数\nvoid sigusr1_handler(int n)\n{\n	//子进程打印 AAA，父进程打印 BBB\n	if(pid > 0)\n		printf(\"AAAA\\n\");\n	else\n		printf(\"BBBB\\n\");\n\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\n}\n\nvoid sigalrm_handler(int n)\n{\n	if(pid > 0)\n		kill(pid, SIGUSR1); //子进程，发送 SIGUSR1 信号给 pid 进程\n	else\n		kill(getppid(), SIGUSR1);//父进程，发送 SIGUSR1 信号给 父进程\n}\n\nint main()\n{\n	//在fork()之前设置的信号处理函数会被子进程继承\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\n\n	pid = fork();\n	if(pid > 0)	//子进程\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\n\n	while(1)\n		pause();	//进程挂起，等待信号唤醒\n\n	return 0;\n}\n```\n## 进程间通信\n```\n/*---------------------------------------------------------------------------------------------------------\n功能：\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\n\n思路：\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\n应使用信号量进行并发控制。\n---------------------------------------------------------------------------------------------------------*/\n\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n#include \"sys/ipc.h\"\n#include \"sys/sem.h\"\n#include \"sys/shm.h\"\n\n\nunion semun\n{\n	int val;\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\n	ushort *array;\n};\n\n\nint semid;\nint shmid;\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\n\nvoid p(int semid)\n{\n	struct sembuf buf = {0, -1, 0};\n	semop(semid, &buf, 1);\n}\n\nvoid v(int semid)\n{\n	struct sembuf buf = {0, 1, 0};\n	semop(semid, &buf, 1);\n}\n\nvoid sigusr1_handler(int n)\n{\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\n	\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\n		printf(\"remove semaphore fail\\n\");\n	else\n		printf(\"remove semaphore ok\\n\");\n	\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\n		printf(\"remove shared-memory fail\\n\");\n	else\n		printf(\"remove shared-memory ok\\n\");\n\n	exit(0);\n}\n\nint main()\n{\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\n\n	//创建并初始化信号量\n	semid = semget(IPC_PRIVATE, 1, 0666);\n	if(semid == -1)\n	{\n		printf(\"create semaphore fail\\n\");\n		return 0;\n	}\n	else\n		printf(\"create semaphore ok\\n\");\n	union semun x;\n	x.val = 1;  //__为1___  //信号量初值应为多少？\n	semctl(semid, 0, SETVAL, x);\n	\n	//创建并关联到共享内存\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\n	if(shmid == -1)\n	{\n		printf(\"create shared-memory fail\\n\");\n		return 0;\n	}\n	else\n		printf(\"create shared-memory ok\\n\");\n	shm_virtualaddr = shmat(shmid, 0, 0);\n\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\n\n	char is_child = 0;\n	int i;\n	for(i=0; i<10; i++)\n	{\n		pid_t pid = fork();\n		if(pid == 0)\n		{\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\n			break;  //__退出循环_________________\n		}\n	}\n\n	if(is_child)\n	{\n		p(semid);  //P操作修改信号量（-1）____________________\n\n		srand(time(NULL) + i);\n		int num = rand()%10;\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\n\n		printf(\"child%d: %d\\n\", i, num);\n\n		v(semid);  //V操作修改信号量（+1）____________________\n\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\n	}\n	else\n	{\n		while(1)\n			pause();\n	}\n\n	return 0;\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000940s ]
---------------------------------------------------------------
[ 2018-10-16T22:12:35+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.081287s][吞吐率：12.30req/s] [内存消耗：2,130.18kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '25991',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Linux - C 编程
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

创建成功，父进程返回子进程的 id ，子进程返回 0 
创建失败，父进程返回 -1
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

#### 实验
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '0',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000714s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001441s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000640s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000342s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001360s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000362s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000311s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n创建成功，父进程返回子进程的 id ，子进程返回 0 \r\n创建失败，父进程返回 -1\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n~~父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........~~\r\n\r\n---\r\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n#### 实验\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=0,`publish`=1,`summary`=''  WHERE  `id` = 212 [ RunTime:0.001039s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.002690s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000431s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001174s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000429s ]
---------------------------------------------------------------
[ 2018-10-16T22:12:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.083891s][吞吐率：11.92req/s] [内存消耗：1,990.70kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000780s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001949s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000898s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001597s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000418s ]
---------------------------------------------------------------
[ 2018-10-16T22:12:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/212.html
[ info ] qingrang.top/daily/admin/show/shownote/id/212.html [运行时间：0.063864s][吞吐率：15.66req/s] [内存消耗：1,948.00kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000719s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001637s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000739s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001304s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000419s ]
---------------------------------------------------------------
[ 2018-10-16T22:12:51+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.069722s][吞吐率：14.34req/s] [内存消耗：2,103.66kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'purpose' => 'prefetch',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000524s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002618s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000750s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001252s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000480s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001055s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000324s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000495s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000393s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000550s ]
---------------------------------------------------------------
[ 2018-10-16T22:12:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.067210s][吞吐率：14.88req/s] [内存消耗：2,103.72kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000668s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001448s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000539s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001377s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000545s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001051s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000357s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000499s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000316s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000394s ]
---------------------------------------------------------------
[ 2018-10-16T22:13:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.074532s][吞吐率：13.42req/s] [内存消耗：2,104.12kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000573s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001574s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000548s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001718s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000470s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001485s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000520s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000489s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000453s ]
---------------------------------------------------------------
[ 2018-10-16T22:13:07+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/notelst/groups/Linux.html
[ info ] qingrang.top/daily/admin/show/notelst/groups/Linux.html [运行时间：0.074222s][吞吐率：13.47req/s] [内存消耗：2,125.15kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'notelst',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Linux',
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000558s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001409s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000695s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001262s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000463s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Linux' )  AND `publish` = 1 LIMIT 1 [ RunTime:0.001208s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Linux' )  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000719s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001004s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000337s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000390s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000312s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000378s ]
---------------------------------------------------------------
[ 2018-10-16T22:13:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/212.html
[ info ] qingrang.top/daily/admin/show/shownote/id/212.html [运行时间：0.065613s][吞吐率：15.24req/s] [内存消耗：1,948.47kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Linux.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000670s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001363s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000499s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000882s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000348s ]
---------------------------------------------------------------
[ 2018-10-16T22:13:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.075061s][吞吐率：13.32req/s] [内存消耗：2,183.16kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000659s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001603s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001953s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000441s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001098s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000391s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000475s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000880s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000451s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000317s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000401s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000974s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000223s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001155s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000812s ]
---------------------------------------------------------------
[ 2018-10-16T22:13:25+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.083457s][吞吐率：11.98req/s] [内存消耗：2,249.20kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '15',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'Linux',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000631s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002213s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Linux' ORDER BY date desc [ RunTime:0.002473s ]
---------------------------------------------------------------
[ 2018-10-16T22:13:30+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/212
[ info ] qingrang.top/daily/admin/note/editNote/id/212 [运行时间：0.058369s][吞吐率：17.13req/s] [内存消耗：2,054.86kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editNote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000534s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001299s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000567s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000885s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000293s ]
---------------------------------------------------------------
[ 2018-10-16T22:14:28+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.064976s][吞吐率：15.39req/s] [内存消耗：2,130.71kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '26192',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

创建成功，父进程返回子进程的 id ，子进程返回 0 
创建失败，父进程返回 -1
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

#### 实验
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000589s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001318s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000606s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000346s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001221s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000342s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000304s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n创建成功，父进程返回子进程的 id ，子进程返回 0 \r\n创建失败，父进程返回 -1\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n~~父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........~~\r\n\r\n---\r\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n#### 实验\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.000710s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001185s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000537s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000893s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000338s ]
---------------------------------------------------------------
[ 2018-10-16T22:14:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.059303s][吞吐率：16.86req/s] [内存消耗：1,990.77kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/212',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000474s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001747s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000556s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001153s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000449s ]
---------------------------------------------------------------
[ 2018-10-16T22:14:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.080539s][吞吐率：12.42req/s] [内存消耗：2,054.56kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000756s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001853s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000607s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001279s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000390s ]
---------------------------------------------------------------
[ 2018-10-16T22:15:04+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.103990s][吞吐率：9.62req/s] [内存消耗：2,130.68kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '26189',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

创建成功，父进程返回子进程的 id ，子进程返回 0 
创建失败，父进程返回 -1
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000515s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001592s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000469s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000326s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.037605s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000371s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n创建成功，父进程返回子进程的 id ，子进程返回 0 \r\n创建失败，父进程返回 -1\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n~~父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........~~\r\n\r\n---\r\n> 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.000758s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001110s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000339s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000933s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000327s ]
---------------------------------------------------------------
[ 2018-10-16T22:15:05+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.056277s][吞吐率：17.77req/s] [内存消耗：1,990.89kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000499s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001262s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000463s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000927s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000345s ]
---------------------------------------------------------------
[ 2018-10-16T22:18:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.075033s][吞吐率：13.33req/s] [内存消耗：2,054.55kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000699s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001997s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000778s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002305s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000624s ]
---------------------------------------------------------------
[ 2018-10-16T22:20:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.062885s][吞吐率：15.90req/s] [内存消耗：2,131.19kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '26341',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验
#### 使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
#### 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验
#### 李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000537s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001292s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000459s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000930s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000288s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验\r\n#### 使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n~~父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........~~\r\n\r\n---\r\n#### 使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验\r\n#### 李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.000708s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001290s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000360s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000944s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000330s ]
---------------------------------------------------------------
[ 2018-10-16T22:20:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.054417s][吞吐率：18.38req/s] [内存消耗：1,990.95kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000503s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001252s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000929s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000292s ]
---------------------------------------------------------------
[ 2018-10-16T22:20:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editote/id/212.html
[ info ] qingrang.top/daily/admin/note/editote/id/212.html [运行时间：0.058052s][吞吐率：17.23req/s] [内存消耗：1,399.62kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T22:21:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.087489s][吞吐率：11.43req/s] [内存消耗：2,054.60kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000697s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002057s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000595s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001421s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000395s ]
---------------------------------------------------------------
[ 2018-10-16T22:23:01+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.081748s][吞吐率：12.23req/s] [内存消耗：2,134.46kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '27301',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验
#### fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
~~父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........~~

---
>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验
#### 李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000648s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001356s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000521s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001000s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000290s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000286s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验\r\n#### fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n~~父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........~~\r\n\r\n---\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验\r\n#### 李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.001138s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001708s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000575s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001894s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000539s ]
---------------------------------------------------------------
[ 2018-10-16T22:23:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.074619s][吞吐率：13.40req/s] [内存消耗：1,991.40kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000509s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001532s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000586s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001057s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000297s ]
---------------------------------------------------------------
[ 2018-10-16T22:24:07+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.055900s][吞吐率：17.89req/s] [内存消耗：2,055.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000499s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001321s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000442s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001033s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000278s ]
---------------------------------------------------------------
[ 2018-10-16T22:33:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.060714s][吞吐率：16.47req/s] [内存消耗：2,144.07kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '30824',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验
#### fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........

---
>多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?

- 父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

---

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
>观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

- 父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。

- 父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验
#### 李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000541s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001277s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000423s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000343s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000854s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000353s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000289s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验\r\n#### fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n\r\n---\r\n>多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n\r\n- 父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n---\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n>观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n- 父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n\r\n- 父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验\r\n#### 李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.000861s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001022s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000330s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001052s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000379s ]
---------------------------------------------------------------
[ 2018-10-16T22:33:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.056776s][吞吐率：17.61req/s] [内存消耗：1,992.62kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000610s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002328s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000488s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000985s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000283s ]
---------------------------------------------------------------
[ 2018-10-16T22:34:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.067979s][吞吐率：14.71req/s] [内存消耗：2,056.27kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000578s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001547s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000540s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000914s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000343s ]
---------------------------------------------------------------
[ 2018-10-16T22:35:32+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.064487s][吞吐率：15.51req/s] [内存消耗：2,144.21kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '30878',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验
#### fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........

---
- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

---

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验
#### 李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000621s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001276s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000481s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000301s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000896s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000361s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000312s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验\r\n#### fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n\r\n---\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n---\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验\r\n#### 李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.000741s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001250s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000422s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001029s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000522s ]
---------------------------------------------------------------
[ 2018-10-16T22:35:33+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.052827s][吞吐率：18.93req/s] [内存消耗：1,992.64kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000534s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000447s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000850s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000308s ]
---------------------------------------------------------------
[ 2018-10-16T22:37:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.062480s][吞吐率：16.01req/s] [内存消耗：2,056.30kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000605s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002065s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000546s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000995s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000469s ]
---------------------------------------------------------------
[ 2018-10-16T22:37:58+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.061745s][吞吐率：16.20req/s] [内存消耗：2,145.90kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '31220',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，网络编程等知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验
#### fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

```

---
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........

---
- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

---

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}
```
---
>不 sleep 的输出：

zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)

---

---
>sleep() 后的输出

I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842

---
- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验
#### 李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"


union semun
{
	int val;
	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））
	ushort *array;
};


int semid;
int shmid;
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________
	
	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联
	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________

	//创建并初始化信号量
	semid = semget(IPC_PRIVATE, 1, 0666);
	if(semid == -1)
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else
		printf("create semaphore ok\\n");
	union semun x;
	x.val = 1;  //__为1___  //信号量初值应为多少？
	semctl(semid, 0, SETVAL, x);
	
	//创建并关联到共享内存
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total
	if(shmid == -1)
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else
		printf("create shared-memory ok\\n");
	shm_virtualaddr = shmat(shmid, 0, 0);

	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________
	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________

	char is_child = 0;
	int i;
	for(i=0; i<10; i++)
	{
		pid_t pid = fork();
		if(pid == 0)
		{
			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________
			break;  //__退出循环_________________
		}
	}

	if(is_child)
	{
		p(semid);  //P操作修改信号量（-1）____________________

		srand(time(NULL) + i);
		int num = rand()%10;
		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________
		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作修改信号量（+1）____________________

		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后
			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________
	}
	else
	{
		while(1)
			pause();
	}

	return 0;
}
```

---
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok

---',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000653s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001372s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000511s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000373s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001034s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000328s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验\r\n#### fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n```\r\n\r\n---\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n\r\n---\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n---\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n```\r\n---\r\n>不 sleep 的输出：\r\n\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n\r\n---\r\n\r\n---\r\n>sleep() 后的输出\r\n\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n\r\n---\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验\r\n#### 李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;//semop的一个参数其中设置了对信号量的操作（P（-1）还是V（+1））\r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;\r\nint shmid;\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //_打印进程编号（不是进程ID）和随机数和_______________________________________________________________________\r\n	\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  //删除信号量\r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  //删除共享内存\r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //___用户定义的信号，用于捕获SIGUSR1信号执行处理函数___________________________________\r\n\r\n	//创建并初始化信号量\r\n	semid = semget(IPC_PRIVATE, 1, 0666);\r\n	if(semid == -1)\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create semaphore ok\\n\");\r\n	union semun x;\r\n	x.val = 1;  //__为1___  //信号量初值应为多少？\r\n	semctl(semid, 0, SETVAL, x);\r\n	\r\n	//创建并关联到共享内存\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //共享内存一共8字节，前4字节存放count，后4字节存放total\r\n	if(shmid == -1)\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else\r\n		printf(\"create shared-memory ok\\n\");\r\n	shm_virtualaddr = shmat(shmid, 0, 0);\r\n\r\n	*(int *)shm_virtualaddr = 0;  //___初始化进程编号_______________________________\r\n	*(int *)(shm_virtualaddr+4) = 0;  //_____初始化随机数和_____________________________\r\n\r\n	char is_child = 0;\r\n	int i;\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork();\r\n		if(pid == 0)\r\n		{\r\n			is_child = 1;  //__创建子进程成功设置子进程中ischild为1父进程不执行_________________\r\n			break;  //__退出循环_________________\r\n		}\r\n	}\r\n\r\n	if(is_child)\r\n	{\r\n		p(semid);  //P操作修改信号量（-1）____________________\r\n\r\n		srand(time(NULL) + i);\r\n		int num = rand()%10;\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增_________________________________\r\n		*(int *)(shm_virtualaddr+4) += num;  //随机数相加_________________________________\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作修改信号量（+1）____________________\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(__i==10________________________________)最后一个子进程善后\r\n			kill(getppid(), SIGUSR1);  //_____向父进程发送信号SIGUSER1____________________________\r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();\r\n	}\r\n\r\n	return 0;\r\n}\r\n```\r\n\r\n---\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n\r\n---',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，网络编程等知识'  WHERE  `id` = 212 [ RunTime:0.000733s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001039s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000415s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000977s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000405s ]
---------------------------------------------------------------
[ 2018-10-16T22:37:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.060794s][吞吐率：16.45req/s] [内存消耗：1,992.87kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=1v7u93h9aiseatdijl4mp7neh2',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000790s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001425s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000614s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001160s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000387s ]
---------------------------------------------------------------
[ 2018-10-16T22:49:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.043583s][吞吐率：22.94req/s] [内存消耗：1,339.45kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-16T22:50:05+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.050798s][吞吐率：19.69req/s] [内存消耗：1,922.07kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000500s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001392s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000463s ]
---------------------------------------------------------------
[ 2018-10-16T22:50:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.067585s][吞吐率：14.80req/s] [内存消耗：2,197.38kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=4supnq86lod2eb4l1bb684ng73',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000466s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001228s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001617s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000414s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000918s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000392s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000815s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000306s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000443s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000305s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000963s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000238s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001242s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000676s ]
---------------------------------------------------------------
[ 2018-10-16T22:50:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.093149s][吞吐率：10.74req/s] [内存消耗：2,103.80kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=4supnq86lod2eb4l1bb684ng73',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000520s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001900s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000551s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001284s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000484s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001319s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000466s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000555s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000382s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000553s ]
---------------------------------------------------------------
[ 2018-10-16T22:50:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/notelst/groups/Linux.html
[ info ] qingrang.top/daily/admin/show/notelst/groups/Linux.html [运行时间：0.082663s][吞吐率：12.10req/s] [内存消耗：2,126.98kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'notelst',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=4supnq86lod2eb4l1bb684ng73',
)
[ info ] [ PARAM ] array (
  'groups' => 'Linux',
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000568s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001522s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000515s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001241s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000592s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Linux' )  AND `publish` = 1 LIMIT 1 [ RunTime:0.001070s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Linux' )  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000706s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001037s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000321s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000425s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000400s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000447s ]
---------------------------------------------------------------
[ 2018-10-16T22:50:30+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/212.html
[ info ] qingrang.top/daily/admin/show/shownote/id/212.html [运行时间：0.049765s][吞吐率：20.09req/s] [内存消耗：1,966.67kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Linux.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=4supnq86lod2eb4l1bb684ng73',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000452s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001523s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000426s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000812s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000274s ]
---------------------------------------------------------------
[ 2018-10-16T22:50:40+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/212.html
[ info ] qingrang.top/daily/admin/show/shownote/id/212.html [运行时间：0.056359s][吞吐率：17.74req/s] [内存消耗：1,966.67kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Linux.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=4supnq86lod2eb4l1bb684ng73',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000526s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001343s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000548s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000929s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000444s ]
