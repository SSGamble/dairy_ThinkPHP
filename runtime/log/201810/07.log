---------------------------------------------------------------
[ 2018-10-07T13:09:15+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.004305s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002657s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000654s ]
---------------------------------------------------------------
[ 2018-10-07T13:09:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.004806s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002735s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002536s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000565s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001183s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000375s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000981s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000993s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000412s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000617s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000463s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000402s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000927s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000381s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001793s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000971s ]
---------------------------------------------------------------
[ 2018-10-07T13:09:30+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.003499s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001458s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000434s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001363s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000347s ]
---------------------------------------------------------------
[ 2018-10-07T13:09:35+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001028s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001716s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `p_id` = 20  AND `id` > 2 ORDER BY date desc [ RunTime:0.001736s ]
---------------------------------------------------------------
[ 2018-10-07T13:09:39+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/191
[ sql ] [ DB ] CONNECT:[ UseTime:0.000880s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001470s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 191 LIMIT 1 [ RunTime:0.000440s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000956s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000288s ]
---------------------------------------------------------------
[ 2018-10-07T13:12:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001138s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001544s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001391s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000439s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001249s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000319s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000394s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000912s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000286s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000395s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000307s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000366s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000839s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000230s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001079s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000586s ]
---------------------------------------------------------------
[ 2018-10-07T13:12:47+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/32.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002696s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002255s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000769s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001142s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000427s ]
---------------------------------------------------------------
[ 2018-10-07T13:13:26+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/32.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002576s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001370s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000620s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000305s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000996s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000281s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000332s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=32,`p_id`=1,`title`='写出这些话的人，我估计一辈子都追不上了\r',`content`='# 写出这些话的人，我估计一辈子都追不上了\r\n1. 如果发出声音是危险的，那就保持沉默；如果自觉无力发光，那就别去照亮别人。但是，不要习惯了黑暗就为黑暗辩护不要为自己的苟且而得意洋洋；不要嘲讽那些比自己更勇敢，更有热量的人们。可以卑微如尘土，不可扭曲如蛆虫。\r\n2. 你多学一样本事，就少说一句求人的话。\r\n3. 我38岁那年，琢磨着要不要去读两年的放射线照相术大专学位。然后我跟我朋友说了这事，我觉得自己太老了，等拿到学位是，我都40岁了。\r\n--朋友说，如果你不读，你还是会40岁，一个没有学位的40岁。\r\n4.	这些年来我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没有放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。\r\n5.	孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是，我希望你将来会拥有选择的权利，选择有意义，有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。\r\n6.	最终我们都将学会，与他人交往，最重要的不是甜言蜜语，不是容貌金钱，而是你和他对于这个世界的看法，对人生的态度是否一致。\r\n7.	我们一路奋战，不是为了改变世界，而是为了世界不再改变我们。\r\n8.	不要欺骗别人，因为你能骗到的人，都是相信你的人。\r\n9.	熟练的运用\"关我屁事\"和\"关你屁事\"可以省下人生80％的时间。\r\n10.	我怎么敢倒下。我身后空无一人。\r\n11.	\"痛苦是财富，这话是扯淡。姑娘，痛苦就是痛苦，对痛苦的思考才是财富。\"\r\n12.	永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。\r\n13.	如果我不曾见过太阳，我本可以忍受黑暗。\r\n14.	社交之所以累，是因为每个人都试图展现出自己其实并不具备的品质。\r\n15.	读书：之前觉得自己是一个人，现在觉得自己可以是一个世界。\r\n16.	希望你今天白费的努力，早晚有一天变成值得。\r\n17.	历史：遗忘，对倒下的人不公平。\r\n18.	南京大屠杀：\r\n安培说：现在日本的年轻人没有义务为过去的日本人像现在的中国人道歉。\r\n那现在的中国人也没有权利为过去的中国人原谅现在的日本人。\r\n19.	明明别人轻轻松松可以做到的事，我却做不了。满满的无力感，无力到没有力气。\r\n20.	人的一切痛苦，本质上都是对自己无能的愤怒。\r\n21.	不要试图同情你自己。\r\n22.	你配得上你自己想要的生活吗？\r\n23.	什么叫成熟？\r\n了解自己，了解自己的欲望，了解自己的局限。理解别人，理解别人的欲望，理解别人的局限。\r\n24.	我们会看到要寻找的东西，错失不去寻找的东西，虽然它在那里。我们的阅历被我们的关注点深深地影响了。\r\n25.	做你害怕做的事，然后你会发现，不过如此。\r\n26.	一直认为，所谓新鲜感，不是和未知的人一起去做同样的事，而是和已知的人一起去体验未知的人生。\r\n27.	如果不能随时有限的反击，所有的宽容都是懦弱。\r\n28.	群众的眼睛不是雪亮的，群众的眼睛是盲目的。\r\n29.	不是所有的人都能功成名就，我们中有些人注定要在日常的点滴中寻找生命的意义。\r\n30.	带人友善是修养，独来独往是性格。\r\n31.	几年前踏上火车那一刻还没有意识到，从此故乡只有冬夏，再无春秋。\r\n32.	十年饮水，难凉热血。\r\n33.	德，律己为德，律人无异于私刑。\r\n34.	信仰，他可以与宗教无关，代表自己的精神追求。\r\n35.	人最重要的能力有两个，适应环境，不忘初心。适应环境可以安身，不忘初心可以立命。\r\n36.	维护不在场的人，所言不多于所知。\r\n37.	只有你愿意为之而死的东西，你才可以藉之而生。\r\n38.	你见过树，却没见过森林。\r\n39.	那些杀不死你的最终都会使你更强壮。\r\n40.	是你把你的秘密告诉了风，那就别怪风把他带给树。\r\n41.	似乎大家都这样。自命不凡，却无足轻重。\r\n42.	保安笑着问我：\"你那么小个子，开那么大个车？\"的时候。我傻笑着回答：\"你是当保安，我是当司机的。\"\r\n43.	猪会飞，是因为他站在了风口上，成功的飞起来以后他可以总结起飞技巧，但重要的，是风。\r\n44.	你现在做的每一件事看来并没有什么意义，但他们也许会在未来助你 一臂之力。\r\n45.	唱出本身就是最要不得的态度。当你做某件事的时候，一旦想要求快，就表示你再也不关心他，而是想去做别的事。\r\n46.	命运啊，说是注定，不如说是你在何时做了选择。\r\n47.	在一群出色的人中间，常常误以为自己也是其中一员，然后忘了努力。\r\n48.	只有经历过地狱磨难的人，才有建造天堂的力量。\r\n49.	一个伟大的人往往受到排挤，压抑，甚至被人斥为哗众取宠而陷于孤独中。\r\n50.	与怪物战斗的人，应当小心自己不要成为怪物。当你远远凝视深渊时，深渊也在凝视你。\r\n51.	一个人知道自己为什么而活，就可以忍受任何一种生活。\r\n52.	假如我们不去打仗，敌人用刺刀杀死了我们，还要指着我们的骨头说：看，这是奴隶。\r\n53.	我有一事，生死与之。\r\n54.	我的体内啊，有个器官比心脏还重要，他虽然看不见，但却是在我的体内从脑袋一直贯穿到胯间。就因为他，我才能站着直，坐着正，就算脚步摇晃也能笔直地向前行，在这里退缩的话，那东西就会折断。\r\n55.	不可能这三个字，你说的太多了。\r\n56.	世界上没遇上帝，如果有的话，我无法容忍我不是。－－尼采\r\n57.	剑在英雄手，登台傲王侯。－－比莫干《九州缥缈录》\r\n58.	武士的一生，只相信自己手中可以握住的东西。－－赢无翳《九州缥缈录》\r\n59.	为天地立心，为生民立命，为往圣继绝学，为万世开太平。－－北宋时期张载\r\n60.	为不能作战的人而战。\r\n61.	你的成功标准： 能做自己喜欢做的事，能只做自己喜欢做的事。\r\n62.	如何不招人厌的展现自己的学识：别人问了，你再答。\r\n63.	无论现实如何操蛋，你都能在心里有一个更诗意的世界，那个世界便是情怀。\r\n64.	情怀就是以心灵的满足而不是功利的得失作为自己的行为标准的一种品质。一件没有什么用的事，还是要去做，也许只是因为我喜欢，也许只是因为它看起来很美。\r\n65.	跟优秀的人相处是怎样一种体验：他从不刻意优秀，却总是无意中卓越。\r\n66.	不要跟眼界不一样的人争辩。\r\n67.	人穷尽一生追求另一个人的事，我一直无法理解，或许是因为我自己太有意思，无需他人陪伴，所以我祝你们在对方身上得到的快乐与我给自己的一样多。\r\n68.	一个人需要控制的事情越少，他心理上就越自由。当你企图控制一件事情的时候，你同时也就被这件事情所控制，这永远是个相互的过程。\r\n69.	我们痛恨限制的同时，也依赖限制。\r\n70.	一个能够安住于不确定和不可控制中的人最自由。\r\n71.	大部分的教育工作者都在教人找到工作，而不是寻找人生。\r\n72.	漫画提供给我们的，也许就是这个早以被我们遗忘的世界。但将它看做一个逃避现实，发泄情绪的渠道，还是从中寻找勇气和激励，在现实生活中做一个真正的英雄，决定权在你。\r\n73.	社会衡量一个人的价值，在于他能向外产出什么，至于他吸收了什么，没人在乎。\r\n74.	我发现没有任何一个煤矿工人靠挖煤多又快当上了煤老板。\r\n75.	有的人努力的时候是真的在努力，有的人努力的时候只是为了感动自己，这决定了一个人究竟能变成什么样。\r\n76.	在这残酷的现实面前，除了吃人与被吃，我还有第三种选择，就是努力活下去，并且让这个社会再好一点。知大恶才知大善。知暗夜才知光明。不要低估人性的丑恶，也不要低估人性的光辉。\r\n77.	群众的眼光到底是不是雪亮的？                                                                                  1）群众的智商，呈现非周期性的上升或者下降。                                                        2）其实群众的眼睛就是灯泡，而开关掌控在领导手中，需要时就是雪亮的，不需要时就是不明真相的。 \r\n3）如果让群众挑错，那群众的眼睛无疑是雪亮的，他们最擅长干这个了，但要是问群众什么是对的，那就瞎了。\r\n78.	我一向不太相信离别时的情真意切，我觉得那只是一种情绪渲染。\r\n79.	为什么孩子喜欢看有关恐龙的书？                                                                                恐龙代表过去，宇宙飞船代表未来，我就是不喜欢现在。－－询问一7岁男孩得知\r\n80.	纠正一个错误的方法有很多，而解决一个错误的终极方法就是不给他任何发生的机会。\r\n81.	为什么父母一吵架，小孩就特别懂事？                                                                         小孩的沉默，隐忍，恐惧，以及讨好，在麻木的大人眼中，便是：懂事。\r\n82.	凡我中华之寸土皆洒满我中华儿女之血泪，永世不忘倭寇侵占与残杀之历史。\r\n83.	我相信再有一个妖精大闹天宫，悟空会是去镇压的那个人。\r\n骑士杀死恶龙后，望着满地的财宝，身上长出了鳞片。\r\n84.	只有写鸡汤的人才能从鸡汤中受益。\r\n85.	没有中枪的觉悟，就没有开枪的资格。\r\n86.	什么是人渣？   \r\n浑身都是铠甲，没有一处软肋。\r\n87.	一种人，天天都笑嘻嘻的，好似和谁都合得来，但是从不主动联系朋友，脾气也出奇的好，好像世上没有什么事情能让他们愤怒和悲伤。心中怀着宏伟的梦想，却不愿与现实中的人分担，只是默默的做，以为能用沙砾和泥土堆出山川。\r\n88.	为什么我们愿意把钱捐给身边的乞丐，而不顾那些生活在水深火热之中的欠发达国家的人民呢？                                                                                                                         人类的所有善意都遵循邻避原则。坏的事可以发生，只要别发生在我家后院就行了。－－善意有效辐射范围\r\n89.	后来许多人问我一个人夜晚踟蹰路上的心情，我想起的却不是孤单和路长，而是波澜壮阔的海和天空中闪耀的星光。－－张小砚\r\n90.	当很重要的人寻求更大的世界，却因此不得不离开你的时候，支持还是阻止好？            \r\n他走是因为他想走，他不走是因为他不想走，不要试图去背负别人的人生。\r\n91.	一个人在对另一个人的内心世界做出评判时，最好怀有一定程度的谦逊和宽容。－－《群山回响》\r\n92.	楼下的一个男人病的要死，那间壁的一家唱着留声机，对面是弄孩子，楼上两个人狂笑，还有打鼾声，还有打牌声，河中的船上有女人哭着她失去的母亲。 人类的悲欢并不相通，我只觉得他们吵闹。－－鲁迅\r\n93.	什么样的状态最恐怖？ \r\n忙碌的学习，上班，以为忙碌了，就是充实了。一般还很满足，自以为比别人过得有意义。其实说到底，都是急于活得明白，反倒搞不清楚。\r\n94.	未知的危险性是最恐怖的，而未知来自于你感官能力的丧失。比如说漆黑一片的屋子里你丧失的是视觉，比如说一片静谧的丛林里你丧失的是听觉。当你失去这些采集环境信息的渠道后，你会无法用经验体系构建一个稳定可预测的环境状况。人本能的就希望远离这种不稳定，这就是恐惧的作用了。\r\n95.	我们千山万水来到这，为的也不过是说一声再见。\r\n96.	遇见你所爱的人，时间就会停止。\r\n97.	在遇到她之前，我不怕死，不惧远行，也不曾忧虑悠长岁月，现在却从未如此真切地思虑起将来。－－《平如美棠》\r\n98.	从今往后，咱们只有死别，再无生离。－－《我们仨》\r\n99.	别人的痛苦才是你艺术的源泉，而你去受苦只会成为别人艺术的源泉。\r\n100.	我们大部分人根本谈不上独立的审美，而且美也是随着时代和环境在变化。\r\n101.	无论我告诉你什么道理，当你的心智没有达到这个境界或接近的水平时或经历过一些事情的时候，你是不会理解这个道理的。或者你以为你知道这个道理，其实你不知道。\r\n102.	除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。\r\n103.	别人指责你的事情或批评的你的理由，往往最能伤害你的，是那些你也这样认为的事情。\r\n104.	其实人跟人之间差别其实不大，所以不要与别人去比较，人生就是一场长跑，你可能不会是第一名，但也不不太会是最后一名，和前面比你会有动力，和后面比你会有幸福。但重要的是享受过程。\r\n105.	永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。人生就是一场游戏，懂得你在玩的游戏的游戏规则，然后玩好它。\r\n106.	生活其实是一种运营，时间是你最宝贵的资源，还有钱，关系，都是你的一种投入，自己重视什么，事业，友谊，家庭上，就多投入些，种瓜得瓜，好好平衡各个关系是你要做好的。\r\n107.	人不会死在绝境。却往往栽在十字路口。\r\n108.	编剧是你，我怎么知道结局。\r\n109.	一只船孤独的航行在海上，它既不寻求幸福，也不逃避幸福，它只是向前航行，底下是沉静碧蓝的大海，而头顶是金色的太阳。   --莱蒙托夫\r\n110.	历史学——孤证不成立\r\n111.	新闻无需撒谎，它只需要给出“部分的真相”，就可以达到操纵民意的目的\r\n112.	你所关注的东西，永远都是媒体想让你关注的\r\n113.	很多时候舆论一边倒的声音，未必是大多数人所赞同的，只是不赞同的人以为自己是少数，不愿意发声而已\r\n114.	除非你准备射击，否则不要把枪口对准人或物\r\n115.	把自己不能理解的行为定义为「装」实在是非常不好的习惯，要改。\r\n116.	画家不识渔家苦，好作寒江钓雪图。\r\n117.	我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔\r\n118.	人这一生为什么要努力？\r\n是一种想去体验一个更大的世界的欲望。\r\n119.	子路有闻，未能行之，唯恐有（又）闻。\r\n120.	信任就像一张纸，皱了，即使抚平，也恢复不了原样了。。。 \r\n用水胶带，喷水，绷木板上干后比原先还平。---做不到只是知识不够用。\r\n121.	我第一次感受到时间是一种物质的存在。它就像是一条蠕动的虫子，拖着臃肿皱皮的身躯，从我的血管里缓缓缓缓地爬过，并且留下了一条粘乎乎的痕迹。\r\n122.	原来死亡就是一种消失。不但是肉体，精神和思想的消失，更重要的是在人们的记忆中慢慢成为了空白，就像这个人从没在这个世界上来过一样。\r\n123.	张浩站在他办公室高大的落地窗玻璃前，看着下面的芸芸众生。他说，林岚，你觉得他们生活得辛苦吗？我觉得很辛苦。每个人都很辛苦。这个世界不会符合你所有的想象，甚至连一个你的想象也不符合，可是我们还是得生存下去。\r\n124.	人是为活着本身而活着，而不是为了活着之外的任何事物所活着。\r\n125.	人生的意义是什么？\r\n意义这个词太单薄，太卑微，低落到尘埃里，配不上生命，也承载不起人生。\r\n126.	人生逆旅，一蓑烟雨。\r\n127.	外行看热闹，都不知道别人家的事情，一群吃瓜群众指指点点，哈哈哈哈。。。被媒体玩的像猪一样。\r\n128.	底线之上才有资格说各展所长。\r\n129.	“我寄给你的信，总要送往邮局，不喜欢放在街边的绿色邮筒中，我总疑心那里会慢一点。”	--鲁迅《致许广平》\r\n130.	我不要儿子，我要一个女儿--只要一个，像你的。--钱钟书\r\n131.	孩子不是图画练习册，不要光顾着涂上自己喜欢的颜色。	--《追风筝的人》\r\n132.	生活其实也很简单，喜欢的就争取，得到的就珍惜，失去了就忘记。\r\n133.	有什么事情是游戏从业者不愿意告诉玩家的?\r\n免费玩家也是我们提供给付费玩家的功能之一。\r\n134.	哪有什么岁月静好，不过是有人为你付中负重前行，生活从来都不容易，当你觉得挺容易的时候，一点是有人再替你负重前行。\r\n//好像现在是我人生中最轻松容易的时候了，那么到底有哪些人在为我负重前行呢？\r\n135.	有枪但你没盾，你挡不住别人的子弹。\r\n136.	没有人有义务了解你所尽力的艰辛。\r\n137.	我从来没有想过一个节目会以无解来结尾，一直到明白真实的世界就是如此。 --柴静《双城的创伤》\r\n138.	能够让你后悔的，从来不是你做过的事，而是你想做却没有做过的事。\r\n139.	很多时候，你愿意讲给别人听的，大概是那些很想，却再也没有机会告诉以前的自己的话吧。--《肖申克的救赎》\r\n140.	从童年起，我便独自一人。照顾着历代的星辰。--《孤独》白鹤林\r\n141.	与这世界交手多年，你是否光彩依旧，兴致盎然。\r\n142.	为什么你不让别人看到你善良的一面？因为如果他们看见了，就会期望我一直是善良的。\r\n143. 周围认识的许多情侣，最后都步入了婚姻殿堂，但其中不少人在爱情长跑中都曾不忠。有些故事大家心照不宣，甚至帮他们遮掩。每次婚礼，我看着新人们热泪盈眶地念誓言，从没怀疑过他们在那一刻的真诚，可人性是如此幽深复杂，千帆过尽，我变得什么都能理解，也什么都无法相信。\r\n144. 人生有5%的幸福，5%的痛苦，还有90%的平淡。人们往往被那5%的幸福诱惑着，幻想未来或怀念过去，忍受着5%的痛苦，在90%的平淡中慢慢度过漫长的一生。\r\n145. 记得一个电影里面的女主说过”我不是喜欢钱，但是钱可以带来自由和尊严。我喜欢的是自由和尊严。”\r\n146. 90次的反复下载上传，最后变成了这样，可见你认为最可靠的数据也是会在传播中失去原来的样子，更何况是你从被人嘴里听到的别人。\r\n147. 无论你做的事情多正义，都不能强制我和你一个步调。\r\n148. 既无法忍受现在的状态，又没能力改变这一切，可以像只猪一样懒，却无法像只猪一样心安理得。\r\n149. 我们的祖先是被吃了无数回才走上了食物链的顶端。\r\n150. 尊重粉丝维护偶像，但也请尊重一个人从内心深处鄙视另一个人的自由。\r\n151. 皇帝为什么不多生孩子，最后选择优秀的孩子即位？”长幼”是常量，”优秀”是变量，政治稳定不能有太多的变量。\r\n152. 我们看到的都是别人让我们看到的。\r\n153. 没打出来的牌才是王牌。\r\n154. 市场不一定是去迎合的，而是可以引导和培养的。\r\n155. 后代子孙永远也不会知晓当初战争中零星冲突的悲惨情况；事实上，一无所知反而最好。真正的战争永远会隐没于历史的黑暗面。 ---沃尔特•惠特曼\r\n156. 只有你才知道对你而言什么才是糟糕的生活，什么才是真正的一塌糊涂，这与旁人的教说，旁人的经验并无关系。\r\n1. 这世上真话本就不多，一位女子的脸红胜过一大段对白。-- 老舍\r\n1. 如果说有谁在看到流星的瞬时就能许下愿望，那一定是非常纯熟且迫切的愿望。\r\n1. “我可以尽管向你们这个组合宣泄负面情绪，因为你们是被主流唾弃的，所以无论我说什么都没错，毕竟我是站在道德制高点上的。” --momo的老公\r\n1. 不是返璞归真，转了个圈回到的却不是原处。两个放羊最大的区别，一个是满足物质生活，一个是满足精神生活。曾经的种地放羊是生活的根基，被迫接受的事没有什么美感，结束一天的工作后裹着一身臭汗上炕睡觉第二天周而复始，这种放羊与“舒适的生活”是没有挂钩的。而现在那种有情怀的种地放羊则是一种有钱人的主动选择，把过去的苦事中的精华提取，与其他美好的事相连接，在放羊的生活中也能享受惬意的生活。他们有能力选择和组合生活，这不该被批判。\r\n1. 我看到的多数家庭的教育是颠倒混乱的。生下来到学龄前应当树立家长权威（要有敬畏），他们却去溺爱；小学应当严格培养学习习惯和基础，他们却宽松；青春期个性萌芽，父母应当从权威退到民主，让孩子学会理性和责任时，他们却开始各种着急焦虑和专制严管；到大学应该是退居二线，最多给于建议的时候他们开始对孩子人生规划指手画脚；工作了，父母应当放手让孩子完全独立对自己负责时，他们却最终升级到强迫相亲这种直接干涉。\r\n1. 不愿费心力和别人交流。然而总是被指诘在躲避。内心不坦然，才是孤独者的坟墓。\r\n1. 人生如逆旅，我亦是行人。\r\n1. 你一直耿耿于怀的事事实上相关人物根本早就忘记了 耿耿于怀的果然只有你自己“\r\n1. 当前的环境也许只是一个暂态，也许只是世界的一小面；如果你想要见见更大的世界，那就不要太急着让自己为了适应当前的环境而彻底改变。\r\n1. 当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。——陶杰 《杀鹌鹑的少女》\r\n1. 那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 — —王小波\r\n1. 想要追求自由随性的生活，就一定要先从自律开始。\r\n1. 别人口中越是容易让人得出倾向性结论的问题描述，往往代表他刻意隐瞒了越多关键的细节。\r\n1. 走不进去的世界就不要硬挤了，为难了别人，也作贱了自己。\r\n1. 古龙《多情剑客无情剑》里，提过一个例子：一对厨子，饭馆打烊后，他们在后厨，自己给自己炒了盘菜，找点小酒，很惬意的饮食一番，舒服那一两个时辰。\r\n--古龙还说：他们还活着，就是因为一天还有那么一两个时辰。\r\n1. 从来如此，便对么？——鲁迅《狂人日记》\r\n1. 那……学校不好，难道知识也不好么?\r\n1. 高三毕业的欢送会上，复读班上的五个男生合唱了这首歌，我知道他们都不是第一年参加高考，我也知道那一年他们仍然成绩平平，我们那一届复读班整体都考的很差，但这首歌我记到现在。好像长这么大，见过的最多的无功而返，苦苦挣扎都是在学习的道路上。可苦涩中的温暖最能长存。路漫漫，且行且珍重！\r\n1. 我一直记得刘瑜写给女儿的一段话：愿你被很多人爱，如果没有，愿你在寂寞里学会宽容。\r\n1. 开始并完成一件事，比做好它更重要，因为只要开始了，你就有机会把它做的更好———-一件看上去繁难的事，只要开始做了，就会变得越来越容易。”\r\n1. 张一鸣有一句说的特别对：所谓成功，就是延迟满足。\r\n1. 成长是件残酷的事情，也许久而久之我们活成了别人想要的模样。但世俗跟成熟是两码事：在熙熙攘攘之外学会“我愿意”，不愿将就的你也可以不那么讲究。\r\n1. “秘密的暴力比公开的暴力更令人恐怖，它会使人失去思考能力、道德意识和抵抗意志，因此退化到最低等原始动物保命本能中去。为了保命求生、避免肉体折磨，人会变得全无廉耻、奴性十足、无所不为。秘密统治对政府权力的正当行使和合道德性同样有着严重的腐蚀作用。” ---《布达佩斯往事》\r\n1. 一个成熟的人，他的标准来自他的内心，而大多数的人，却受环境左右。对自己的标准会不由自主的降低以适应这个环境，减少自身与环境的冲突，在一个低标准下，自觉“满意”的度过每一天。 ——《精进》\r\n1. 梦想不一定要马上实现，如果身边的人反对，那就走慢一点，只要你每天确定自己在往那里走就行。\r\n1. 他没有勇气，也没有兴趣使渴望的行动得以一气呵成，因此自己在半途中就会怀疑行动的意义。---夏目漱石\r\n1. 我来不及认真地年轻，待明白过来时，只能选择认真地老去。 —— 三毛\r\n1. 我会以我的标准与方式看待世界，但我并不会以他来要求他人。--清让\r\n1. 时间，只是一个自称能治百病的庸医。\r\n1. 当你能从你认可的人或者事物身上吸取经验与知识，这是大部分人能做到的，但是如果你能从你不认可的人或者事物身上吸取营养，学到东西，那就真的太难得\r\n了。\r\n1. 你想成为什么样的人，那就尽量去向他们靠近。\r\n1. 真正幽默的人，是把快乐给了别人。\r\n1. 人这一生有很多重要的决定，每个决定其实都决定了我未来的人生，是否被动接受做一个幼师、是否转专业、是否升本等等等，做这些所有的选择与决定前，想想自身的优势，结合趋势与实力，看一下自己做这件事的把握有多少，但凡重大的决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是一些人生的重大决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，我最该做的，是在一开始选择前，确定这场仗能打赢，再去打。\r\n1. 面试造飞机，工作扭螺丝。\r\n1. “让忙于务实的人务实，让乐于做梦的人做梦”。\r\n1. 生命是一场华丽的冒险，只是我们永远都跨不过时间的深渊。\r\n1. 曾经的你，以为只要带着那把长剑和赤子之心就可以说服自己不出卖理想的灵魂。在最艰难和不得不流泪的晚上，即使连自己都在笑自己傻，但仍然用长剑刺痛自己，提醒自己，勇往直前，直到将来。\r\n1. 过往不恋，未来不迎，当下不负。\r\n1. 忠言逆耳，良药苦口，可不都是这样吗。但我觉得最重要的是要培养自己的判断力，在兼容并包的基础上一定要有自己的主心骨。善听百家之言，思想上的言论抒发不分对错，要客观结合自己的情况，别人的经验也不全是对的，就算是对的，也不全适合自己，不同的人有不同的性格，脾气，要自己汲取自己认可的观点看法，适合自己才是最好的。\r\n1. 世上最难的事之一，把自己的思想装进别人的脑袋。\r\n1. 这短短的一生，我们最终都会失去。你不妨大胆一些，爱一个人，攀一座山，追一个梦。 ——《大鱼海棠》\r\n1. 有时候遇到瓶颈了，你应该停下来好好想想，是有四年工作经验，还是一个经验用了四年。\r\n1. 这世上唯有病痛和亲人去世是真切的痛楚，其他都是不必要的伤感，是忽略了当下拥有的一切的贪婪。\r\n1. 许多人所谓的成熟， 不过是被习俗磨去了棱角，变得世故而实际了。那不是成熟，而是精神的早衰和个性的消亡。真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。\r\n1. 别嫌读书苦，你现在的气质里，藏着你走过的路，读书不是为了雄辩和驳斥，也不是为了轻信和盲从，而是为了思考和权衡。\r\n1. 真的不要小看父母，不要觉得自己很厉害。以前笑父母遥控器还要套个手机套，其实和现在我们用手机还要贴膜戴手机套是一样的。以前笑父母为了一毛钱还和人家讨价还价，其实和我们现在用着手机在群里抢红包是一样的。以前父母无聊时磕着瓜子看着小说，其实和我们现在拿着手机刷着朋友圈是一样的。以前父母拉几个好友打麻将谈天说地，其实和我们现在拉几个网友王者农药开黑是一样的。以前父母在厂里上班踩着缝纫机，其实和我们现在写字楼里对着电脑写 PPT word 文档是一样的。所有的都没有变，只是时代在变，生活方式升级，换一种方式活着而已。很多年以后，可能会有10后笑着：瞧，我爸以前是在格子间苦逼写代码的工程师，我现在一家未来公司看着机器人帮我干活，公司只有我一个人呢。\r\n1. 有勇气去改变那些可以改变的事，\r\n有肚量去容忍那些无法改变的事，\r\n有智慧去区分上述的事。\r\n1. 识人不必探尽，探尽则多疑。\r\n知人不必言尽，言尽则无友。\r\n责人不必苛尽，苛尽则众远。\r\n敬人不必卑尽，卑尽则少骨。\r\n让人不必退尽，退尽则路寡。\r\n1. 安全感在很多时候是束缚人的枷锁，过度追求会让人生少了很多可能性。\r\n1. 大部分的恐惧，只有在你把它当回事儿的时候才是。\r\n1. 很多时候，没有兴趣并不真的是没有兴趣，而是怕自己做不好。\r\n1. 最好的兴趣就是永远达不到但可以不断精进的那些。\r\n1. 很多时候，成功者是自证的，失败者也是。\r\n1. 阻止大脑用思维定式进行自动加工，夺回大脑的控制权。\r\n1. 努力不是盲目的，是定向的。\r\n1. 要超越心智，首先要能辨别更好的心智与现有心智的区别。\r\n1. 世俗的成功不是人人都可以达成的，按概率也就只有一小部分。\r\n1. 盲目听信成功学故事并模仿，将离成功越来越远。\r\n1. 不管是恋爱还是职场，要选得好就得先小范围尝试和观察，对所谓的“好坏”有个大体了解后，然后再选择，最后全情投入。\r\n1. 完美的职业规划不存在，避免因为规划得太细而失去更多的可能性。\r\n1. 过去的付出只代表过去，沉没成本不是成本。\r\n1. 常认为自己是受害者的人往往真的会成为受害者。\r\n1. 绝对公平并不存在，追求绝对公平只是追求自利。\r\n1. 活在父母的世界跟活在子女的世界一样，都是人格尚未独立出来的婴儿。\r\n1. 在事情没有快速变化的前提下，等待仅仅是无谓的消耗。\r\n1. 要撕掉自己的短处，不要试图掩盖，用更强的标签去替代它。\r\n1. 陷入指定的成功，你就基本不太可能成功了。\r\n1. 握不住的沙，不如扬了它。\r\n1. 优于别人并不高贵，真正的高贵因该是优于过去的自己。-- 海明威《真实的高贵》\r\n1. 顶级组织至情至性，\r\n 一流组织共同信仰，\r\n二流组织共同利益，\r\n三流组织共同规则。\r\n1. 像老大寻求意见时，自己先思考出几套解决方案也就是“香蕉”，让你的老板去做选择而不是让他出想法。如果因为你的”香蕉”没熟透，放心你的老大会给你更好的解决方法，先养成动脑思考的好习惯。 --香蕉法则\r\n1. 善良不是要求别人做什么，而是要求自己做什么。\r\n1. 自己是既得利益者，说这不公平叫「觉悟高」，值得钦佩，自己不是既得利益者，就别眼里只看到不公平，因为这太正常了，如果不理解，或者心生抱怨，该想想自己的问题。\r\n1. 文字传达观点，文字也能误传观点。\r\n1. “检验一流智力的标准，就是看你能不能在头脑中同时存在两种相反的想法，还维持正常行事的能力。”\r\n1. 有时候，鸡汤可能比所谓的干货更有用，很多道理其实大家都懂，我们做出改变缺乏的只是一个推动力。\r\n1. 不自律，无自由：\r\n曾经以为自由就是想做啥做啥，后来才发现自律者才会自由。当一个人缺乏自由的时候，他做的事情总是在受习惯和即时诱惑的影响，要么就是被他人的思想观念所扰，几乎永远不可能去做内心真正渴望的事。\r\n1. 《海上钢琴师》中，1900 为什么最后没有下船？\r\n我们的陆地就是他的海洋。无人愿意一生漂泊。\r\n1. 永生是否是一种酷刑？\r\n凡是能被适应的惩罚都不能算是酷刑。\r\n1. 当有人做一件事并没有伤害到任何人的事情，你却要指手画脚的时候，你才是那个傻逼。\r\n1. 这世上只有一种成功，就是能用自己喜欢的方式度过自己的一生。\r\n1. 只有深入一座城市的边边角角，了解城市里的一花一草一木，才能真正看懂人生百态，品味酸甜苦辣的人生。\r\n1. 信仰是用来约束自己的。\r\n1. 习惯，是扼杀创造力的最大杀手！\r\n当你所掌握的信息不足以帮自己判断的时候，你可以选择观望，但是用这些无比正确的废话来说服别人，就是最大的笑话，就等同于，你自己没有判断力，也要求别人也跟你一样没有判断力。\r\n1. 没有观点的反驳更可怕，有那么一拨人，为了让自己无比正确，总说一大堆永远正确的话。\r\n1. 穷人思维和富人的思维是，穷人花 10 块，总奢望得到 100 块的价值，而富人花 1w 块，只求得到 1000 块的价值就够了，但是即便如此，富人可以轻易获取 1000 块的资源，而穷人即便费劲九牛二虎之力得到 100 块的价值也差距很大。\r\n1. 我自己也做了公众号，尤其是影响力越做越大，关注的人越来越多，当一个群体越来越大的时候，难免鱼龙混杂，什么样的人都有，也就意味着，你的所有观点，总会随着群体越来越大，不认可你的人越来越多，当然，认可你的人其实是更多的，但是认可你的人不会让你糟心，而不认可你的人，或者说一些杠精才会让你最糟心的。\r\n1. 这个世界有几样东西是不能被取代的，第一：亲身感受。我拿着一碗水，告诉你：这个是海洋，你永远不会有感觉。第二：自我成长和努力。没有人可以取代你做事情，应该自己完成的，只能由自己完成。工具的善用，自我的实力，重要性是排在第一位。刘翔跑再快，我开车，轻松超越他。当然，前提是我会开车，四肢还得健全。\r\n1. 吃不了起早贪黑的苦，你丢不起那个街头摆摊的人，你凭什么觉得不公平？\r\n1. 活在当下。我 22 岁的时候从不会去考虑五六年之后的我会是怎样，我只是活在当下，做好当下的事而已。\r\n1. 致正少年的你，愿你所有快乐无需假装，愿你此生尽兴赤诚善良。\r\n',`groups`='Default',`is_show`=1  WHERE  `id` = 32 [ RunTime:0.001754s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000795s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000656s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000348s ]
---------------------------------------------------------------
[ 2018-10-07T13:13:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/32.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002705s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001735s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000790s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000998s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000324s ]
---------------------------------------------------------------
[ 2018-10-07T13:14:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002578s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001256s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
---------------------------------------------------------------
[ 2018-10-07T17:35:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001622s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002736s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002518s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000538s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001026s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000346s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000672s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000971s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000369s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000430s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000329s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000466s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001050s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000259s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001030s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000722s ]
---------------------------------------------------------------
[ 2018-10-07T17:35:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001311s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001667s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000502s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001308s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000281s ]
---------------------------------------------------------------
[ 2018-10-07T17:38:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.003421s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001902s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000674s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001110s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
---------------------------------------------------------------
[ 2018-10-07T18:09:34+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001449s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001717s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%markdown%' OR `content` LIKE '%markdown%' ) ORDER BY date desc [ RunTime:0.007059s ]
---------------------------------------------------------------
[ 2018-10-07T18:09:41+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001300s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001410s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Web Front-end' ORDER BY date desc [ RunTime:0.001483s ]
---------------------------------------------------------------
[ 2018-10-07T18:09:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/196
[ sql ] [ DB ] CONNECT:[ UseTime:0.001172s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001254s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 196 LIMIT 1 [ RunTime:0.000468s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000917s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000316s ]
---------------------------------------------------------------
[ 2018-10-07T18:14:48+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001452s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001720s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 三、如何进行复杂度分析？\n#### 1.大 O 表示法\n1）来源\n算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。\n2）特点\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。\n2.复杂度分析法则\n1）单段代码看高频：比如循环。\n2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。\n3）嵌套代码求乘积：比如递归、多重循环等\n4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。\n>示例\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。可以看出来**，所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\nT(n) = (2n^2+2n+3)*unit_time\n$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n### 四、常用的复杂度级别？\n多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，\nO(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）\n非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，\nO(2^n)（指数阶）、O(n!)（阶乘阶）\n### 五、如何掌握好复杂度分析方法？\n复杂度分析关键在于多练，所谓孰能生巧。\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000708s ]
---------------------------------------------------------------
[ 2018-10-07T18:17:12+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001275s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001511s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000413s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000891s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000471s ]
---------------------------------------------------------------
[ 2018-10-07T18:17:20+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001222s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001701s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000632s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001247s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000423s ]
---------------------------------------------------------------
[ 2018-10-07T18:17:39+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001564s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001960s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000585s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000424s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001410s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000394s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=210,`p_id`=2,`title`='数据结构与算法之美\r',`content`='# 数据结构与算法之美\r\n`数据结构` `算法`\r\n\r\n[TOC]\r\n## 一. 简介\r\n>什么是数据结构？什么是算法？\r\n\r\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\r\n>数据结构和算法有什么关系呢？\r\n\r\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\r\n\r\n>数据结构和算法的知识体系 - 思维导图\r\n\r\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\r\n\r\n>20 个最常用的、最基础数据结构与算法\r\n\r\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\r\n\r\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\r\n\r\n## 二. 复杂度分析\r\n### 1. 什么是复杂度分析？\r\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\r\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\r\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\r\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\r\n### 2. 为什么要进行复杂度分析？\r\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\r\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\r\n### 三、如何进行复杂度分析？\r\n#### 1.大 O 表示法\r\n1）来源\r\n算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。\r\n2）特点\r\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。\r\n2.复杂度分析法则\r\n1）单段代码看高频：比如循环。\r\n2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。\r\n3）嵌套代码求乘积：比如递归、多重循环等\r\n4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。\r\n>示例\r\n\r\n```\r\n//估算一下这段代码的执行时间。\r\nint cal(int n) {\r\n  int sum = 0;\r\n  int i = 1;\r\n  for (; i <= n; ++i) {\r\n    sum = sum + i;\r\n  }\r\n  return sum;\r\n}\r\n```\r\n\r\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？\r\n\r\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。可以看出来**，所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\r\n\r\n```\r\n//估算一下这段代码的执行时间\r\nint cal(int n) {\r\n  int sum = 0;\r\n  int i = 1;\r\n  int j = 1;\r\n  for (; i <= n; ++i) {\r\n    j = 1;\r\n    for (; j <= n; ++j) {\r\n      sum = sum +  i * j;\r\n    }\r\n   }\r\n }\r\n```\r\nT(n) = (2n^2+2n+3)*unit_time\r\n$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\r\n### 四、常用的复杂度级别？\r\n多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，\r\nO(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）\r\n非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，\r\nO(2^n)（指数阶）、O(n!)（阶乘阶）\r\n### 五、如何掌握好复杂度分析方法？\r\n复杂度分析关键在于多练，所谓孰能生巧。\r\n',`groups`='Algorithm',`is_show`=1  WHERE  `id` = 210 [ RunTime:0.000718s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.001785s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=1  WHERE  `groups` = 'Algorithm' [ RunTime:0.000458s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000841s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=1  WHERE  `groups` = 'Algorithm' [ RunTime:0.000339s ]
---------------------------------------------------------------
[ 2018-10-07T18:17:39+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001357s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001584s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000433s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001077s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000311s ]
---------------------------------------------------------------
[ 2018-10-07T18:17:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000921s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001305s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000943s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
---------------------------------------------------------------
[ 2018-10-07T18:17:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001056s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001427s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000552s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001115s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000293s ]
---------------------------------------------------------------
[ 2018-10-07T18:18:51+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000948s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000444s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000915s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000298s ]
---------------------------------------------------------------
[ 2018-10-07T18:19:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000990s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001268s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000392s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000816s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000301s ]
---------------------------------------------------------------
[ 2018-10-07T18:19:22+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000937s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001335s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000431s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000841s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000307s ]
---------------------------------------------------------------
[ 2018-10-07T18:20:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001346s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001382s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001561s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000474s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001093s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000311s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000461s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000959s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000281s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000410s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000373s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000436s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000845s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000231s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001162s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000847s ]
---------------------------------------------------------------
[ 2018-10-07T18:20:58+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001263s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003437s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000547s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002178s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000380s ]
---------------------------------------------------------------
[ 2018-10-07T18:32:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001111s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001478s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 三、如何进行复杂度分析？\n#### 1.大 O 表示法\n1）来源\n算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。\n2）特点\n以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。\n2.复杂度分析法则\n1）单段代码看高频：比如循环。\n2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。\n3）嵌套代码求乘积：比如递归、多重循环等\n4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。\n>示例\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n $$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n### 四、常用的复杂度级别？\n多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，\nO(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）\n非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，\nO(2^n)（指数阶）、O(n!)（阶乘阶）\n### 五、如何掌握好复杂度分析方法？\n复杂度分析关键在于多练，所谓孰能生巧。\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000554s ]
---------------------------------------------------------------
[ 2018-10-07T18:41:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001209s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001593s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 3. 如何进行复杂度分析？\n#### 1.大 O 表示法\n>示例\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\n\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\n\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\n\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000700s ]
---------------------------------------------------------------
[ 2018-10-07T18:41:57+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000931s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001177s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 3. 如何进行复杂度分析？\n#### 1.大 O 表示法\n>示例\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\n\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\n\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\n\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000457s ]
---------------------------------------------------------------
[ 2018-10-07T18:49:24+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001087s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001311s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 3. 如何进行复杂度分析？\n#### 1.大 O 表示法\n>示例\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\n\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\n\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\n\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\n\n>如何分析一段代码的时间复杂度？\n\n1. 只关注循环执行次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n>常见的复杂度量级\n\n![常见的复杂度量级](http://p0tymq1rr.bkt.clouddn.com/daily/181007/3CmEAm6d1d.png)\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000578s ]
---------------------------------------------------------------
[ 2018-10-07T18:52:38+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001640s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002030s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 3. 如何进行复杂度分析？\n#### 1.大 O 表示法\n>示例\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\n\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\n\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\n\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\n\n>如何分析一段代码的时间复杂度？\n\n1. 只关注循环执行次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n>常见的复杂度量级\n\n![常见的复杂度量级](http://p0tymq1rr.bkt.clouddn.com/daily/181007/3CmEAm6d1d.png)\n\n对于刚罗列的复杂度量级，可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：$$O(2^n)$$ 和 $$O(n!)$$。\n\n我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。\n\n当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，**非多项式时间复杂度的算法其实是非常低效的算法**。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000600s ]
---------------------------------------------------------------
[ 2018-10-07T19:19:22+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001844s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002288s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 3. 如何进行复杂度分析？\n#### 1.大 O 表示法\n>示例\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\n\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\n\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\n\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\n\n#### 如何分析一段代码的时间复杂度？\n\n1. 只关注循环执行次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n#### 常见的复杂度量级\n\n![常见的复杂度量级](http://p0tymq1rr.bkt.clouddn.com/daily/181007/3CmEAm6d1d.png)\n\n对于刚罗列的复杂度量级，可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：$$O(2^n)$$ 和 $$O(n!)$$。\n\n我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。\n\n当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，**非多项式时间复杂度的算法其实是非常低效的算法**。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。\n\n#### 常见的多项式时间复杂度\n\n>1.O(1)\n\n首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。\n```\nint i = 8;\nint j = 6\nint sum = i + j;\n```\n我稍微总结一下，**只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)**。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。\n\n>2.O(logn)、O(nlogn)\n\n```\ni=1;\nwhile (i <= n)  {\n  i = i * 2;\n}\n```\n根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。\n\n从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/8FJcBja6lK.png)\n\n即 $$2^x=n$$，所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。\n\n利用换底公式得：$$x=log_2n$$。\n\n所以，这段代码的时间复杂度就是 $$T(n) = O(log_2n)$$。\n\n```\n//这段代码的时间复杂度是多少？\ni=1;\nwhile (i <= n)  {\n  i = i * 3;\n}\n```\n $$O(log_3n)$$\n\n实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 $$O(logn)$$。为什么呢？\n\n我们知道，对数之间是可以互相转换的，$$log_3n$$ 就等于 $$log_32 \\* log_2n$$，所以 $$O(log_3n) = O(C * log_2n)$$，其中 $$C=log_32$$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $$O(Cf(n)) = O(f(n))$$。所以，$$O(log_2n)$$ 就等于 $$O(log_3n)$$。\n\n因此，**在对数阶时间复杂度的表示方法里，我们忽略对数的“底”**，统一表示为 $$O(logn)$$ 。\n\n如果你理解了我前面讲的 $$O(logn)$$，那 $$O(nlogn)$$ 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 $$O(logn)$$，我们循环执行 n 遍，时间复杂度就是 $$O(nlogn)$$ 了。而且，$$O(nlogn)$$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 $$O(nlogn)$$。\n\n>3.O(m+n)、O(m*n)\n\n```\nint cal(int m, int n) {\n  int sum_1 = 0;\n  int i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  int sum_2 = 0;\n  int j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n```\n从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。\n\n针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)\\*T2(n) = O(f(m) * f(n))。\n\n#### 空间复杂度分析\n\n空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001085s ]
---------------------------------------------------------------
[ 2018-10-07T19:19:24+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001229s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001499s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='数据结构与算法之美',`content`='# 数据结构与算法之美\n`数据结构` `算法`\n\n[TOC]\n## 一. 简介\n>什么是数据结构？什么是算法？\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n>数据结构和算法有什么关系呢？\n\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\n\n>数据结构和算法的知识体系 - 思维导图\n\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\n\n>20 个最常用的、最基础数据结构与算法\n\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\n\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\n\n## 二. 复杂度分析\n### 1. 什么是复杂度分析？\n1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。\n2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。\n3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。\n4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。\n### 2. 为什么要进行复杂度分析？\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\n### 3. 如何进行复杂度分析？\n#### 1.大 O 表示法\n>示例\n\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\n\n```\n//估算一下这段代码的执行时间。\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  for (; i <= n; ++i) {\n    sum = sum + i;\n  }\n  return sum;\n}\n```\n\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\n\n```\n//估算一下这段代码的执行时间\nint cal(int n) {\n  int sum = 0;\n  int i = 1;\n  int j = 1;\n  for (; i <= n; ++i) {\n    j = 1;\n    for (; j <= n; ++j) {\n      sum = sum +  i * j;\n    }\n   }\n }\n```\n\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\n\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\n\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\n\n$$T(n) = O(f(n))$$\n\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\n\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\n\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\n\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\n\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\n\n#### 如何分析一段代码的时间复杂度？\n\n1. 只关注循环执行次数最多的一段代码\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n#### 常见的复杂度量级\n\n![常见的复杂度量级](http://p0tymq1rr.bkt.clouddn.com/daily/181007/3CmEAm6d1d.png)\n\n对于刚罗列的复杂度量级，可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：$$O(2^n)$$ 和 $$O(n!)$$。\n\n我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。\n\n当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，**非多项式时间复杂度的算法其实是非常低效的算法**。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。\n\n#### 常见的多项式时间复杂度\n\n>1.O(1)\n\n首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。\n```\nint i = 8;\nint j = 6\nint sum = i + j;\n```\n我稍微总结一下，**只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)**。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。\n\n>2.O(logn)、O(nlogn)\n\n```\ni=1;\nwhile (i <= n)  {\n  i = i * 2;\n}\n```\n根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。\n\n从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/8FJcBja6lK.png)\n\n即 $$2^x=n$$，所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。\n\n利用换底公式得：$$x=log_2n$$。\n\n所以，这段代码的时间复杂度就是 $$T(n) = O(log_2n)$$。\n\n```\n//这段代码的时间复杂度是多少？\ni=1;\nwhile (i <= n)  {\n  i = i * 3;\n}\n```\n $$O(log_3n)$$\n\n实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 $$O(logn)$$。为什么呢？\n\n我们知道，对数之间是可以互相转换的，$$log_3n$$ 就等于 $$log_32 \\* log_2n$$，所以 $$O(log_3n) = O(C * log_2n)$$，其中 $$C=log_32$$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $$O(Cf(n)) = O(f(n))$$。所以，$$O(log_2n)$$ 就等于 $$O(log_3n)$$。\n\n因此，**在对数阶时间复杂度的表示方法里，我们忽略对数的“底”**，统一表示为 $$O(logn)$$ 。\n\n如果你理解了我前面讲的 $$O(logn)$$，那 $$O(nlogn)$$ 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 $$O(logn)$$，我们循环执行 n 遍，时间复杂度就是 $$O(nlogn)$$ 了。而且，$$O(nlogn)$$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 $$O(nlogn)$$。\n\n>3.O(m+n)、O(m*n)\n\n```\nint cal(int m, int n) {\n  int sum_1 = 0;\n  int i = 1;\n  for (; i < m; ++i) {\n    sum_1 = sum_1 + i;\n  }\n\n  int sum_2 = 0;\n  int j = 1;\n  for (; j < n; ++j) {\n    sum_2 = sum_2 + j;\n  }\n\n  return sum_1 + sum_2;\n}\n```\n从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。\n\n针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)\\*T2(n) = O(f(m) * f(n))。\n\n#### 空间复杂度分析\n\n空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000608s ]
---------------------------------------------------------------
[ 2018-10-07T19:27:20+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001089s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001364s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000671s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000325s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000968s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000346s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=210,`p_id`=2,`title`='数据结构与算法之美\r',`content`='# 数据结构与算法之美\r\n`数据结构` `算法`\r\n\r\n[TOC]\r\n## 一. 简介\r\n>什么是数据结构？什么是算法？\r\n\r\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\r\n>数据结构和算法有什么关系呢？\r\n\r\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\r\n\r\n>数据结构和算法的知识体系 - 思维导图\r\n\r\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\r\n\r\n>20 个最常用的、最基础数据结构与算法\r\n\r\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\r\n\r\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\r\n\r\n## 二. 复杂度分析\r\n### 1. 什么是复杂度分析？\r\n数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。可以粗略地表示，越高阶复杂度的算法，执行效率越低。\r\n\r\n常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。\r\n\r\n![常见的复杂度](http://p0tymq1rr.bkt.clouddn.com/daily/181007/29BeCEjAmF.png)\r\n### 2. 为什么要进行复杂度分析？\r\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\r\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\r\n### 3. 如何进行复杂度分析？\r\n#### 1.大 O 表示法\r\n>示例\r\n\r\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\r\n\r\n```\r\n//估算一下这段代码的执行时间。\r\nint cal(int n) {\r\n  int sum = 0;\r\n  int i = 1;\r\n  for (; i <= n; ++i) {\r\n    sum = sum + i;\r\n  }\r\n  return sum;\r\n}\r\n```\r\n\r\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\r\n\r\n```\r\n//估算一下这段代码的执行时间\r\nint cal(int n) {\r\n  int sum = 0;\r\n  int i = 1;\r\n  int j = 1;\r\n  for (; i <= n; ++i) {\r\n    j = 1;\r\n    for (; j <= n; ++j) {\r\n      sum = sum +  i * j;\r\n    }\r\n   }\r\n }\r\n```\r\n\r\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\r\n\r\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\r\n\r\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\r\n\r\n$$T(n) = O(f(n))$$\r\n\r\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\r\n\r\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\r\n\r\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\r\n\r\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\r\n\r\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\r\n\r\n#### 如何分析一段代码的时间复杂度？\r\n\r\n1. 只关注循环执行次数最多的一段代码\r\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\r\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\r\n\r\n#### 常见的复杂度量级\r\n\r\n![常见的复杂度量级](http://p0tymq1rr.bkt.clouddn.com/daily/181007/3CmEAm6d1d.png)\r\n\r\n对于刚罗列的复杂度量级，可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：$$O(2^n)$$ 和 $$O(n!)$$。\r\n\r\n我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。\r\n\r\n当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，**非多项式时间复杂度的算法其实是非常低效的算法**。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。\r\n\r\n#### 常见的多项式时间复杂度\r\n\r\n>1.O(1)\r\n\r\n首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。\r\n```\r\nint i = 8;\r\nint j = 6\r\nint sum = i + j;\r\n```\r\n我稍微总结一下，**只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)**。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。\r\n\r\n>2.O(logn)、O(nlogn)\r\n\r\n```\r\ni=1;\r\nwhile (i <= n)  {\r\n  i = i * 2;\r\n}\r\n```\r\n根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。\r\n\r\n从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/8FJcBja6lK.png)\r\n\r\n即 $$2^x=n$$，所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。\r\n\r\n利用换底公式得：$$x=log_2n$$。\r\n\r\n所以，这段代码的时间复杂度就是 $$T(n) = O(log_2n)$$。\r\n\r\n```\r\n//这段代码的时间复杂度是多少？\r\ni=1;\r\nwhile (i <= n)  {\r\n  i = i * 3;\r\n}\r\n```\r\n $$O(log_3n)$$\r\n\r\n实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 $$O(logn)$$。为什么呢？\r\n\r\n我们知道，对数之间是可以互相转换的，$$log_3n$$ 就等于 $$log_32 \\* log_2n$$，所以 $$O(log_3n) = O(C * log_2n)$$，其中 $$C=log_32$$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $$O(Cf(n)) = O(f(n))$$。所以，$$O(log_2n)$$ 就等于 $$O(log_3n)$$。\r\n\r\n因此，**在对数阶时间复杂度的表示方法里，我们忽略对数的“底”**，统一表示为 $$O(logn)$$ 。\r\n\r\n如果你理解了我前面讲的 $$O(logn)$$，那 $$O(nlogn)$$ 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 $$O(logn)$$，我们循环执行 n 遍，时间复杂度就是 $$O(nlogn)$$ 了。而且，$$O(nlogn)$$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 $$O(nlogn)$$。\r\n\r\n>3.O(m+n)、O(m*n)\r\n\r\n```\r\nint cal(int m, int n) {\r\n  int sum_1 = 0;\r\n  int i = 1;\r\n  for (; i < m; ++i) {\r\n    sum_1 = sum_1 + i;\r\n  }\r\n\r\n  int sum_2 = 0;\r\n  int j = 1;\r\n  for (; j < n; ++j) {\r\n    sum_2 = sum_2 + j;\r\n  }\r\n\r\n  return sum_1 + sum_2;\r\n}\r\n```\r\n从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。\r\n\r\n针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)\\*T2(n) = O(f(m) * f(n))。\r\n\r\n#### 空间复杂度分析\r\n\r\n空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\r\n\r\n>示例\r\n\r\n```\r\nvoid print(int n) {\r\n int i = 0;\r\n int[] a = new int[n];\r\n for (i; i <n; ++i) {\r\n   a[i] = i * i;\r\n }\r\n\r\n for (i = n-1; i >= 0; --i) {\r\n   print out a[i]\r\n }\r\n}\r\n```\r\n\r\n跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。\r\n\r\n我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。',`groups`='Algorithm',`is_show`=1  WHERE  `id` = 210 [ RunTime:0.000849s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.001572s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=1  WHERE  `groups` = 'Algorithm' [ RunTime:0.000573s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000653s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=1  WHERE  `groups` = 'Algorithm' [ RunTime:0.000374s ]
---------------------------------------------------------------
[ 2018-10-07T19:27:20+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001002s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001326s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000496s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000868s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000337s ]
---------------------------------------------------------------
[ 2018-10-07T19:27:50+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001220s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001536s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000650s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001126s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000412s ]
---------------------------------------------------------------
[ 2018-10-07T19:28:44+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001027s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001430s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000477s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000417s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000976s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000347s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000278s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=210,`p_id`=2,`title`='数据结构与算法之美\r',`content`='# 数据结构与算法之美\r\n`数据结构` `算法`\r\n\r\n[TOC]\r\n## 一. 简介\r\n>什么是数据结构？什么是算法？\r\n\r\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\r\n>数据结构和算法有什么关系呢？\r\n\r\n这是因为，数据结构和算法是相辅相成的。数据结构是为算法服务的，算法也需要作用在特定的数据结构之上。\r\n\r\n>数据结构和算法的知识体系 - 思维导图\r\n\r\n![数据结构和算法的知识体系](http://p0tymq1rr.bkt.clouddn.com/daily/180928/A7fFlBkGHG.jpg)\r\n\r\n>20 个最常用的、最基础数据结构与算法\r\n\r\n10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；\r\n\r\n10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。\r\n\r\n## 二. 复杂度分析\r\n### 1. 什么是复杂度分析？\r\n数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。可以粗略地表示，越高阶复杂度的算法，执行效率越低。\r\n\r\n常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。\r\n\r\n![常见的复杂度](http://p0tymq1rr.bkt.clouddn.com/daily/181007/29BeCEjAmF.png)\r\n### 2. 为什么要进行复杂度分析？\r\n1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。\r\n2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。\r\n### 3. 如何进行复杂度分析？\r\n#### 大 O 表示法\r\n>示例\r\n\r\n从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这两段代码的总执行时间是多少呢？\r\n\r\n```\r\n//估算一下这段代码的执行时间。\r\nint cal(int n) {\r\n  int sum = 0;\r\n  int i = 1;\r\n  for (; i <= n; ++i) {\r\n    sum = sum + i;\r\n  }\r\n  return sum;\r\n}\r\n```\r\n\r\n第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n\\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\\*unit_time。\r\n\r\n```\r\n//估算一下这段代码的执行时间\r\nint cal(int n) {\r\n  int sum = 0;\r\n  int i = 1;\r\n  int j = 1;\r\n  for (; i <= n; ++i) {\r\n    j = 1;\r\n    for (; j <= n; ++j) {\r\n      sum = sum +  i * j;\r\n    }\r\n   }\r\n }\r\n```\r\n\r\n执行时间：$$T(n) = (2n^2+2n+3)\\*unit\\\\_time$$\r\n\r\n结合以上两个例子可以看出来：**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。\r\n\r\n我们可以把这个规律总结成一个公式，即，大 O 表示法：\r\n\r\n$$T(n) = O(f(n))$$\r\n\r\nT(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。\r\n\r\n所以，第一个例子中的 $$T(n) = O(2n+2)$$，第二个例子中的 $$T(n) = O(2n^2+2n+3)$$。这就是大 O 时间复杂度表示法。\r\n\r\n**大 O 时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称**时间复杂度**。\r\n\r\n当 n 很大时，你可以把它想象成 10000、100000。而**公式中的低阶、常量、系数三部分并不左右增长趋势**，所以都可以忽略。我们**只需要记录一个最大量级**就可以了。\r\n\r\n如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$$T(n) = O(n)$$； $$T(n) = O(n^2)$$。\r\n\r\n#### 如何分析一段代码的时间复杂度？\r\n\r\n1. 只关注循环执行次数最多的一段代码\r\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度\r\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\r\n\r\n#### 常见的复杂度量级\r\n\r\n![常见的复杂度量级](http://p0tymq1rr.bkt.clouddn.com/daily/181007/3CmEAm6d1d.png)\r\n\r\n对于刚罗列的复杂度量级，可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：$$O(2^n)$$ 和 $$O(n!)$$。\r\n\r\n我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。\r\n\r\n当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，**非多项式时间复杂度的算法其实是非常低效的算法**。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。\r\n\r\n#### 常见的多项式时间复杂度\r\n\r\n>1.O(1)\r\n\r\n首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。\r\n```\r\nint i = 8;\r\nint j = 6\r\nint sum = i + j;\r\n```\r\n我稍微总结一下，**只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)**。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。\r\n\r\n>2.O(logn)、O(nlogn)\r\n\r\n```\r\ni=1;\r\nwhile (i <= n)  {\r\n  i = i * 2;\r\n}\r\n```\r\n根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。\r\n\r\n从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/8FJcBja6lK.png)\r\n\r\n即 $$2^x=n$$，所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。\r\n\r\n利用换底公式得：$$x=log_2n$$。\r\n\r\n所以，这段代码的时间复杂度就是 $$T(n) = O(log_2n)$$。\r\n\r\n```\r\n//这段代码的时间复杂度是多少？\r\ni=1;\r\nwhile (i <= n)  {\r\n  i = i * 3;\r\n}\r\n```\r\n $$O(log_3n)$$\r\n\r\n实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 $$O(logn)$$。为什么呢？\r\n\r\n我们知道，对数之间是可以互相转换的，$$log_3n$$ 就等于 $$log_32 \\* log_2n$$，所以 $$O(log_3n) = O(C * log_2n)$$，其中 $$C=log_32$$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $$O(Cf(n)) = O(f(n))$$。所以，$$O(log_2n)$$ 就等于 $$O(log_3n)$$。\r\n\r\n因此，**在对数阶时间复杂度的表示方法里，我们忽略对数的“底”**，统一表示为 $$O(logn)$$ 。\r\n\r\n如果你理解了我前面讲的 $$O(logn)$$，那 $$O(nlogn)$$ 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 $$O(logn)$$，我们循环执行 n 遍，时间复杂度就是 $$O(nlogn)$$ 了。而且，$$O(nlogn)$$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 $$O(nlogn)$$。\r\n\r\n>3.O(m+n)、O(m*n)\r\n\r\n```\r\nint cal(int m, int n) {\r\n  int sum_1 = 0;\r\n  int i = 1;\r\n  for (; i < m; ++i) {\r\n    sum_1 = sum_1 + i;\r\n  }\r\n\r\n  int sum_2 = 0;\r\n  int j = 1;\r\n  for (; j < n; ++j) {\r\n    sum_2 = sum_2 + j;\r\n  }\r\n\r\n  return sum_1 + sum_2;\r\n}\r\n```\r\n从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。\r\n\r\n针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)\\*T2(n) = O(f(m) * f(n))。\r\n\r\n#### 空间复杂度分析\r\n\r\n空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\r\n\r\n>示例\r\n\r\n```\r\nvoid print(int n) {\r\n int i = 0;\r\n int[] a = new int[n];\r\n for (i; i <n; ++i) {\r\n   a[i] = i * i;\r\n }\r\n\r\n for (i = n-1; i >= 0; --i) {\r\n   print out a[i]\r\n }\r\n}\r\n```\r\n\r\n跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。\r\n\r\n我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。',`groups`='Algorithm',`is_show`=1  WHERE  `id` = 210 [ RunTime:0.000664s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000692s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=1  WHERE  `groups` = 'Algorithm' [ RunTime:0.000357s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Algorithm' LIMIT 1 [ RunTime:0.000719s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=1  WHERE  `groups` = 'Algorithm' [ RunTime:0.000325s ]
---------------------------------------------------------------
[ 2018-10-07T19:28:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001184s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001445s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000531s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001101s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000303s ]
---------------------------------------------------------------
[ 2018-10-07T19:31:14+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001111s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001482s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000484s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001061s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000314s ]
---------------------------------------------------------------
[ 2018-10-07T21:04:04+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001113s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001291s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000479s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001032s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000300s ]
---------------------------------------------------------------
[ 2018-10-07T21:04:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001015s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001308s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000451s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000820s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000289s ]
---------------------------------------------------------------
[ 2018-10-07T21:06:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001290s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001708s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000548s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001263s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000400s ]
---------------------------------------------------------------
[ 2018-10-07T21:06:37+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001087s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001272s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 1. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 2. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 3．多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 4．内部类\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000611s ]
---------------------------------------------------------------
[ 2018-10-07T21:06:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001297s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001830s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000495s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000879s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000462s ]
---------------------------------------------------------------
[ 2018-10-07T21:35:45+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000967s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001591s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 1. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 2. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 3．多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 4．内部类\n## 9. IO\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n#### 1.4 FileReader\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000769s ]
---------------------------------------------------------------
[ 2018-10-07T22:13:45+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001543s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001889s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 1. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 2. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 3．多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 4．内部类\n## 9. IO\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n##### 1.4.1 读取单个字符\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 1.4.2 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 1.4.1 读取单个字符\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001082s ]
---------------------------------------------------------------
[ 2018-10-07T22:20:06+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001118s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001379s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 1. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 2. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 3．多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 4．内部类\n## 9. IO\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n##### 1. 读取单个字符\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000808s ]
---------------------------------------------------------------
[ 2018-10-07T22:20:17+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001160s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002070s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000562s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000379s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001002s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000346s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000351s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE\r',`content`='# Java SE\r\n[TOC]\r\n## 1. 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## 2. JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 3. 单例设计模式\r\n### 1.意义（想要保证对象唯一）\r\neg: 配置文件的使用。\r\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\r\n### 2.使用方法\r\n先按常规方法对事物进行描述，最后再加上这三步内即可:\r\n1.将构造函数私有化。（其他类中无法再创建该类对象）\r\n2.在类中创建一个本类对象。（静态）\r\n3.提供一个方法可以获取到该对象。（静态）\r\n\r\n>Ps: 为什么要使用静态？\r\n\r\n在主函数中需要调用方法（3），方法的调用有两种：\r\n1.通过对象调用\r\n2.通过类名调用\r\n\r\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\r\n\r\n### 3.例子（饿汉式）\r\n```\r\npackage study;\r\n\r\n/**\r\n * 单例设计模式\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class SingletonPattern {\r\n    public static void main(String[] args) {\r\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\r\n        Student stu2 = Student.getStudent();\r\n        stu1.setAge(18);\r\n        System.out.println(\"stu1 age = \" + stu1.getAge());\r\n        System.out.println(\"stu2 age = \" + stu2.getAge());\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int age;\r\n    private Student(){};    //1. 私有构造函数\r\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\r\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\r\n        return stu;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~stu1 age = 18\r\nstu2 age = 18~~\r\n\r\n---\r\n## 3．多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 4．内部类\r\n## 9. IO\r\n>字符流和字节流\r\n\r\n字节流两个基类：\r\nInputStream\r\nOutputStream\r\n\r\n字符流两个基类：\r\nReader\r\nWriter\r\n\r\n### 1. 字符流\r\n#### 1.1 FileWriter\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n#### 1.2 IO 异常处理\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * IO异常处理\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class IOExceptionDemo {\r\n    public static void main(String[] args){\r\n        //在外面建立引用\r\n        FileWriter fw = null;\r\n        try{\r\n            //在里面初始化\r\n            fw = new FileWriter(\"Demo2.txt\");\r\n            fw.write(\"abc\");\r\n        }catch (IOException e){\r\n            System.out.println(\"catch\" + e.toString());\r\n        }finally {\r\n            try {\r\n                /*\r\n                * 防止出现空指针异常，需判断一下，\r\n                * 并单独为 fw.close() try{}catch{}\r\n                * */\r\n                if (fw!=null){\r\n                    fw.close();\r\n                }\r\n            }catch (IOException e){\r\n                System.out.println(e.toString());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 1.3 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### 1.4 FileReader\r\n##### 1. 读取单个字符\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 1.5 Buffered\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.000738s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001392s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000405s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000626s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000336s ]
---------------------------------------------------------------
[ 2018-10-07T22:20:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001140s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001453s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000463s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000931s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000326s ]
---------------------------------------------------------------
[ 2018-10-07T22:20:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001158s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001293s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000565s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001016s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000306s ]
---------------------------------------------------------------
[ 2018-10-07T22:21:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001394s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002633s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000792s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001607s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000370s ]
---------------------------------------------------------------
[ 2018-10-07T22:22:24+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001069s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001281s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000558s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000416s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001072s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000493s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000311s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE\r',`content`='# Java SE\r\n[TOC]\r\n## 1. 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## 2. JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 3. 单例设计模式\r\n### 1.意义（想要保证对象唯一）\r\neg: 配置文件的使用。\r\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\r\n### 2.使用方法\r\n先按常规方法对事物进行描述，最后再加上这三步内即可:\r\n1.将构造函数私有化。（其他类中无法再创建该类对象）\r\n2.在类中创建一个本类对象。（静态）\r\n3.提供一个方法可以获取到该对象。（静态）\r\n\r\n>Ps: 为什么要使用静态？\r\n\r\n在主函数中需要调用方法（3），方法的调用有两种：\r\n1.通过对象调用\r\n2.通过类名调用\r\n\r\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\r\n\r\n### 3.例子（饿汉式）\r\n```\r\npackage study;\r\n\r\n/**\r\n * 单例设计模式\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class SingletonPattern {\r\n    public static void main(String[] args) {\r\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\r\n        Student stu2 = Student.getStudent();\r\n        stu1.setAge(18);\r\n        System.out.println(\"stu1 age = \" + stu1.getAge());\r\n        System.out.println(\"stu2 age = \" + stu2.getAge());\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int age;\r\n    private Student(){};    //1. 私有构造函数\r\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\r\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\r\n        return stu;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~stu1 age = 18\r\nstu2 age = 18~~\r\n\r\n---\r\n## 3．多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 4．内部类\r\n## 9. IO\r\n>字符流和字节流\r\n\r\n字节流两个基类：\r\nInputStream\r\nOutputStream\r\n\r\n字符流两个基类：\r\nReader\r\nWriter\r\n\r\n### 1. 字符流\r\n#### 1.1 FileWriter\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n#### 1.2 IO 异常处理\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * IO异常处理\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class IOExceptionDemo {\r\n    public static void main(String[] args){\r\n        //在外面建立引用\r\n        FileWriter fw = null;\r\n        try{\r\n            //在里面初始化\r\n            fw = new FileWriter(\"Demo2.txt\");\r\n            fw.write(\"abc\");\r\n        }catch (IOException e){\r\n            System.out.println(\"catch\" + e.toString());\r\n        }finally {\r\n            try {\r\n                /*\r\n                * 防止出现空指针异常，需判断一下，\r\n                * 并单独为 fw.close() try{}catch{}\r\n                * */\r\n                if (fw!=null){\r\n                    fw.close();\r\n                }\r\n            }catch (IOException e){\r\n                System.out.println(e.toString());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### 1.3 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### 1.4 FileReader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 1.5 Buffered\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.000788s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001074s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000494s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000783s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000341s ]
---------------------------------------------------------------
[ 2018-10-07T22:22:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001057s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001165s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000426s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000915s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000276s ]
---------------------------------------------------------------
[ 2018-10-07T22:30:40+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001040s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003045s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002075s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000736s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001735s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000517s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000693s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001697s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000517s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000627s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000819s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000874s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001930s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001466s ]
---------------------------------------------------------------
[ 2018-10-07T22:30:48+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001205s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001304s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000526s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000930s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000323s ]
---------------------------------------------------------------
[ 2018-10-07T22:31:07+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001481s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001831s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000642s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001383s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000423s ]
---------------------------------------------------------------
[ 2018-10-07T22:32:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001127s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001349s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000494s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000872s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000276s ]
---------------------------------------------------------------
[ 2018-10-07T22:33:33+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001348s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001546s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000501s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000928s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000339s ]
---------------------------------------------------------------
[ 2018-10-07T22:35:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001030s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001382s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000433s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000835s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
---------------------------------------------------------------
[ 2018-10-07T22:36:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001322s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002140s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000546s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001056s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000359s ]
---------------------------------------------------------------
[ 2018-10-07T22:36:48+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001021s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001233s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000445s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000938s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000304s ]
---------------------------------------------------------------
[ 2018-10-07T22:36:59+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/noteview.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001109s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001318s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 195 LIMIT 1 [ RunTime:0.000397s ]
---------------------------------------------------------------
[ 2018-10-07T22:37:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/195.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001002s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001467s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 195 LIMIT 1 [ RunTime:0.000498s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000970s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000356s ]
