---------------------------------------------------------------
[ 2018-10-12T02:03:27+08:00 ] 74.120.168.12 104.192.74.22 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.043014s][吞吐率：23.25req/s] [内存消耗：1,434.40kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'user-agent' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'accept-language' => 'en-us',
  'accept-charset' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7)',
  'cache-control' => 'no-cache',
  'accept-encoding' => 'gzip,deflate',
  'connection' => 'close',
  'referer' => 'http://qingrang.top/daily',
  'host' => 'qingrang.top',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T02:03:27+08:00 ] 74.120.168.12 104.192.74.22 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.041883s][吞吐率：23.88req/s] [内存消耗：1,432.88kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'accept-encoding' => 'gzip',
  'user-agent' => 'Mozilla',
  'host' => 'qingrang.top',
  'accept' => 'text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2',
  'connection' => 'keep-alive',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T02:03:27+08:00 ] 74.120.168.12 104.192.74.22 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.037739s][吞吐率：26.50req/s] [内存消耗：1,340.13kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'user-agent' => 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'accept-language' => 'en-us',
  'accept-charset' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7)',
  'cache-control' => 'no-cache',
  'accept-encoding' => 'gzip,deflate',
  'connection' => 'close',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'host' => 'qingrang.top',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T02:03:28+08:00 ] 74.120.168.12 104.192.74.22 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.038281s][吞吐率：26.12req/s] [内存消耗：1,338.16kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'accept-encoding' => 'gzip',
  'user-agent' => 'Mozilla',
  'host' => 'qingrang.top',
  'accept' => 'text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2',
  'connection' => 'keep-alive',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T08:33:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.065223s][吞吐率：15.33req/s] [内存消耗：1,339.66kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T08:34:07+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.037548s][吞吐率：26.63req/s] [内存消耗：1,339.66kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T08:34:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.045480s][吞吐率：21.99req/s] [内存消耗：1,339.66kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T08:34:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.051981s][吞吐率：19.24req/s] [内存消耗：1,339.66kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T08:35:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.043873s][吞吐率：22.79req/s] [内存消耗：1,339.66kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T08:35:31+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.061895s][吞吐率：16.16req/s] [内存消耗：1,922.05kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001502s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002430s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000548s ]
---------------------------------------------------------------
[ 2018-10-12T08:35:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.130976s][吞吐率：7.63req/s] [内存消耗：2,208.78kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000633s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001905s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002849s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000892s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.002773s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000693s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000892s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001899s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000681s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000904s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000503s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000836s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001733s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000481s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.002066s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001920s ]
---------------------------------------------------------------
[ 2018-10-12T08:35:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/32.html
[ info ] qingrang.top/daily/admin/note/shownote/id/32.html [运行时间：0.111684s][吞吐率：8.95req/s] [内存消耗：2,048.01kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '32',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000768s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.039933s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 32 LIMIT 1 [ RunTime:0.000947s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001361s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000401s ]
---------------------------------------------------------------
[ 2018-10-12T09:14:37+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ info ] qingrang.top/daily/admin/note/editnote/id/209.html [运行时间：0.062919s][吞吐率：15.89req/s] [内存消耗：2,061.47kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000737s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001690s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000560s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000946s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000330s ]
---------------------------------------------------------------
[ 2018-10-12T09:16:10+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.054182s][吞吐率：18.46req/s] [内存消耗：2,102.98kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '19873',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
```



















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000486s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001483s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000914s ]
---------------------------------------------------------------
[ 2018-10-12T09:18:27+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.061236s][吞吐率：16.33req/s] [内存消耗：2,105.06kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '20379',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer是Number的子类，所以打印true
System.out.println(it instanceof Number);
```
---
~~true~~

---


















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000721s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001400s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer是Number的子类，所以打印true\nSystem.out.println(it instanceof Number);\n```\n---\n~~true~~\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000868s ]
---------------------------------------------------------------
[ 2018-10-12T09:28:37+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.066284s][吞吐率：15.09req/s] [内存消耗：2,112.27kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '22266',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```



















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001381s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002599s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001893s ]
---------------------------------------------------------------
[ 2018-10-12T09:33:38+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.059157s][吞吐率：16.90req/s] [内存消耗：2,118.21kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '24121',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。


















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000641s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001553s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000903s ]
---------------------------------------------------------------
[ 2018-10-12T09:38:49+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.055449s][吞吐率：18.03req/s] [内存消耗：2,122.27kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '25090',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
## \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---



















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000603s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001418s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n## \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000795s ]
---------------------------------------------------------------
[ 2018-10-12T10:04:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.071047s][吞吐率：14.08req/s] [内存消耗：2,030.57kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000647s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001733s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000335s ]
---------------------------------------------------------------
[ 2018-10-12T10:05:01+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ info ] qingrang.top/daily/admin/note/addnote.html [运行时间：0.068243s][吞吐率：14.65req/s] [内存消耗：2,006.25kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'addnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '7194',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
  'content' => '# 随机字符串与穷举法破解
```
package basics;

public class TestDemo {
	public static boolean found = false;
	
    public static void main(String[] args) {
        String password = randomString(3);
        System.out.println("密码是:" + password);
 
        char[] guessPassword = new char[password.length()];
        generatePassword(guessPassword,password);
    }
     
    public static void generatePassword(char[] guessPassword,String password){
        generatePassword(guessPassword,0,password);
    }
     
    public static void generatePassword(char[] guessPassword,int index,String password){
        if(found)
            return;
        for (short i = \'0\'; i <= \'z\'; i++) {
            char c = (char)i;
            if(!Character.isLetterOrDigit(c))
                continue;
            guessPassword[index] = c;
            if(index!=guessPassword.length-1){
                generatePassword(guessPassword,index+1,password);
            }
            else{
                String guess = new String(guessPassword);
//	            System.out.println("穷举出来的秘密是：" + guess);
                if(guess.equals(password)){
                    System.out.println("找到了，密码是" + guess);
                    found =true;
                    return;
                }
            }
        }
    }
 
    /**
     * 随机字符串
     * @param length
     * @return
     */
    private static String randomString(int length) {
        char cs[] = new char[length];
        short start = \'0\';	//48
        short end = \'z\' + 1;	//123
        for (int i = 0; i < cs.length; i++) {
            while (true) {
            	//在 0 到  z 之间取随机数
                char c = (char) (start + (Math.random() * (end - start)));	//48 + [0到75之间的随机数]，即 取 48到123之间的随机数
                //0-z 之间存在特殊字符，需排除
                if (Character.isLetter(c) || Character.isDigit(c)) {
                    cs[i] = c;
                    break;
                }
            }
        }
        String result = new String(cs);
        return result;
    }
}
```',
  'test-editormd-html-code' => '<h1 id="h1-u968Fu673Au5B57u7B26u4E32u4E0Eu7A77u4E3Eu6CD5u7834u89E3"><a name="随机字符串与穷举法破解" class="reference-link"></a><span class="header-link octicon octicon-link"></span>随机字符串与穷举法破解</h1><pre><code>package basics;

public class TestDemo {
    public static boolean found = false;

    public static void main(String[] args) {
        String password = randomString(3);
        System.out.println(&quot;密码是:&quot; + password);

        char[] guessPassword = new char[password.length()];
        generatePassword(guessPassword,password);
    }

    public static void generatePassword(char[] guessPassword,String password){
        generatePassword(guessPassword,0,password);
    }

    public static void generatePassword(char[] guessPassword,int index,String password){
        if(found)
            return;
        for (short i = &#39;0&#39;; i &lt;= &#39;z&#39;; i++) {
            char c = (char)i;
            if(!Character.isLetterOrDigit(c))
                continue;
            guessPassword[index] = c;
            if(index!=guessPassword.length-1){
                generatePassword(guessPassword,index+1,password);
            }
            else{
                String guess = new String(guessPassword);
//                System.out.println(&quot;穷举出来的秘密是：&quot; + guess);
                if(guess.equals(password)){
                    System.out.println(&quot;找到了，密码是&quot; + guess);
                    found =true;
                    return;
                }
            }
        }
    }

    /**
     * 随机字符串
     * @param length
     * @return
     */
    private static String randomString(int length) {
        char cs[] = new char[length];
        short start = &#39;0&#39;;    //48
        short end = &#39;z&#39; + 1;    //123
        for (int i = 0; i &lt; cs.length; i++) {
            while (true) {
                //在 0 到  z 之间取随机数
                char c = (char) (start + (Math.random() * (end - start)));    //48 + [0到75之间的随机数]，即 取 48到123之间的随机数
                //0-z 之间存在特殊字符，需排除
                if (Character.isLetter(c) || Character.isDigit(c)) {
                    cs[i] = c;
                    break;
                }
            }
        }
        String result = new String(cs);
        return result;
    }
}
</code></pre>',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->addNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000801s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001522s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000446s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000336s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001036s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('随机字符串与穷举法破解\r' , '# 随机字符串与穷举法破解\r\n```\r\npackage basics;\r\n\r\npublic class TestDemo {\r\n	public static boolean found = false;\r\n	\r\n    public static void main(String[] args) {\r\n        String password = randomString(3);\r\n        System.out.println(\"密码是:\" + password);\r\n \r\n        char[] guessPassword = new char[password.length()];\r\n        generatePassword(guessPassword,password);\r\n    }\r\n     \r\n    public static void generatePassword(char[] guessPassword,String password){\r\n        generatePassword(guessPassword,0,password);\r\n    }\r\n     \r\n    public static void generatePassword(char[] guessPassword,int index,String password){\r\n        if(found)\r\n            return;\r\n        for (short i = \'0\'; i <= \'z\'; i++) {\r\n            char c = (char)i;\r\n            if(!Character.isLetterOrDigit(c))\r\n                continue;\r\n            guessPassword[index] = c;\r\n            if(index!=guessPassword.length-1){\r\n                generatePassword(guessPassword,index+1,password);\r\n            }\r\n            else{\r\n                String guess = new String(guessPassword);\r\n//	            System.out.println(\"穷举出来的秘密是：\" + guess);\r\n                if(guess.equals(password)){\r\n                    System.out.println(\"找到了，密码是\" + guess);\r\n                    found =true;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n \r\n    /**\r\n     * 随机字符串\r\n     * @param length\r\n     * @return\r\n     */\r\n    private static String randomString(int length) {\r\n        char cs[] = new char[length];\r\n        short start = \'0\';	//48\r\n        short end = \'z\' + 1;	//123\r\n        for (int i = 0; i < cs.length; i++) {\r\n            while (true) {\r\n            	//在 0 到  z 之间取随机数\r\n                char c = (char) (start + (Math.random() * (end - start)));	//48 + [0到75之间的随机数]，即 取 48到123之间的随机数\r\n                //0-z 之间存在特殊字符，需排除\r\n                if (Character.isLetter(c) || Character.isDigit(c)) {\r\n                    cs[i] = c;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        String result = new String(cs);\r\n        return result;\r\n    }\r\n}\r\n```' , 'Java' , 2 , '2018-10-12') [ RunTime:0.000496s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001465s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=6  WHERE  `groups` = 'Java' [ RunTime:0.000414s ]
---------------------------------------------------------------
[ 2018-10-12T10:05:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.076374s][吞吐率：13.09req/s] [内存消耗：2,206.64kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000534s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002218s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000531s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001043s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000453s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000441s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001046s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000367s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000492s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000296s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000546s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000896s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000224s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001154s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000773s ]
---------------------------------------------------------------
[ 2018-10-12T10:33:30+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.128125s][吞吐率：7.80req/s] [内存消耗：2,157.71kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '34660',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`



















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000507s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001255s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 格式控制\n### 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n### \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n## String\n### 概述\n字符串最大特点：一旦被初始化就不可以被改变。\n\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\n```\n//s1 在内存中有一个对象\nString s1 = \"abc\";\n//s2 在内存中有两个对象\nString s2 = new String(\"abc\");\nString s3 = \"abc\";\n\nSystem.out.println(s1==s2);//false\nSystem.out.println(s1==s3);//true\nSystem.out.println(s1.equals(s2));//true\n```\n\n### 常见方法\n#### 获取\n```\nString str = \"aabcbcc\";\n\n//字符串的长度\nSystem.out.println(str.length());\n\n//根据位置获取位置上某个字符\nSystem.out.println(str.charAt(1));\n\n//===== 根据字符获取该字符在字符串中位置 =====\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\n//如果没有找到，返回-1\nSystem.out.println(str.indexOf(\'b\',3));\n//可以用于对指定判断是否包含\nif(str.indexOf(\"aa\")!=-1)\n\n\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\nSystem.out.println(str.lastIndexOf(\'b\'));\n```\n#### 判断\n```\n//判断文件名称是否是Array单词开头。\nsop(str.startsWith(\"Array\"));\n//判断文件名称是否是.java的文件。\nsop(str.endsWith(\".java\"));\n//判断文件中是否包含Demo\nsop(str.contains(\"Demo\"));\n```\n- 字符串中是否包含某一个子串。\n`boolean contains(str):`\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\n所以，也可以用于对指定判断是否包含。\n`if(str.indexOf(\"aa\")!=-1)`\n\n而且该方法既可以判断，又可以获取出现的位置。\n\n- 字符中是否有内容。\n`boolean isEmpty(): 原理就是判断长度是否为0. `\n- 字符串是否是以指定内容开头。\n`boolean startsWith(str);`\n- 字符串是否是以指定内容结尾。\n`boolean endsWith(str);`\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\n`boolean equals(str);`\n- 判断内容是否相同，并忽略大小写。\n`boolean equalsIgnoreCase();`\n\n#### 转换\n```\npublic static void method_trans()\n	{\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n		String s= new String(arr,1,3);//3是个数\n		sop(\"s=\"+s);\n		String s1 = \"zxcvbnm\";\n		char[] chs = s1.toCharArray();\n		for(int x=0; x<chs.length; x++)\n		{\n			sop(\"ch=\"+chs[x]);\n		}\n	}\n```\n- 将字符数组转成字符串。\n构造函数：\n```\nString(char[])\nString(char[],offset,count):将字符数组中的一部分转成字符串。\n```\n静态方法：\n```\nstatic String copyValueOf(char[]);\nstatic String copyValueOf(char[] data, int offset, int count) \nstatic String valueOf(char[]):\n```\n- 将字符串转成字符数组。**\n`char[] toCharArray():`\n\n- 将字节数组转成字符串。\n`String(byte[])`\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\n\n- 将字符串转成字节数组。\n`byte[]  getBytes():`\n\n- 将基本数据类型转成字符串。\n`static String valueOf(int)`\n`static String valueOf(double)`\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\n#### 替换\n`String replace(oldchar,newchar);`\n```\npublic static void method_replace()\n	{\n		String s = \"hello java\";\n	 //String s1 = s.replace(\'q\',\'n\');\n//如果要替换的字符不存在，返回的还是原串。\n		String s1 = s.replace(\"java\",\"world\");\n		sop(\"s=\"+s);\n		sop(\"s1=\"+s1);\n	}\n```\n#### 切割\n`String[] split(regex);`\n```\npublic static void  method_split()\n	{\n		String s = \"zhagnsa,lisi,wangwu\";\n\n		String[] arr  = s.split(\",\");\n\n		for(int x = 0; x<arr.length; x++)\n		{\n			sop(arr[x]);\n		}\n	}	\n```\n#### 子串（获取字符串中的一部分）\n`String substring(begin);`\n`String substring(begin,end);`\n```\npublic static void method_sub()\n	{\n		String s = \"abcdef\";\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\n		sop(s.substring(2,4)); \n 		//包含头，不包含尾。s.substring(0,s.length());\n	}\n```\n#### 转换，去除空格，比较\n- 将字符串转成大写或则小写。\n`String toUpperCase();`\n`String toLowerCase();`\n\n- 将字符串两端的多个空格去除。\n`String trim();`\n\n- 对两个字符串进行自然顺序的比较。\n`int compareTo(string);`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000872s ]
---------------------------------------------------------------
[ 2018-10-12T10:35:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.063408s][吞吐率：15.77req/s] [内存消耗：2,159.43kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '35113',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。



















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000550s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001415s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 格式控制\n### 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n### \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n## String\n### 概述\n字符串最大特点：一旦被初始化就不可以被改变。\n\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\n```\n//s1 在内存中有一个对象\nString s1 = \"abc\";\n//s2 在内存中有两个对象\nString s2 = new String(\"abc\");\nString s3 = \"abc\";\n\nSystem.out.println(s1==s2);//false\nSystem.out.println(s1==s3);//true\nSystem.out.println(s1.equals(s2));//true\n```\n\n### 常见方法\n#### 获取\n```\nString str = \"aabcbcc\";\n\n//字符串的长度\nSystem.out.println(str.length());\n\n//根据位置获取位置上某个字符\nSystem.out.println(str.charAt(1));\n\n//===== 根据字符获取该字符在字符串中位置 =====\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\n//如果没有找到，返回-1\nSystem.out.println(str.indexOf(\'b\',3));\n//可以用于对指定判断是否包含\nif(str.indexOf(\"aa\")!=-1)\n\n\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\nSystem.out.println(str.lastIndexOf(\'b\'));\n```\n#### 判断\n```\n//判断文件名称是否是Array单词开头。\nsop(str.startsWith(\"Array\"));\n//判断文件名称是否是.java的文件。\nsop(str.endsWith(\".java\"));\n//判断文件中是否包含Demo\nsop(str.contains(\"Demo\"));\n```\n- 字符串中是否包含某一个子串。\n`boolean contains(str):`\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\n所以，也可以用于对指定判断是否包含。\n`if(str.indexOf(\"aa\")!=-1)`\n\n而且该方法既可以判断，又可以获取出现的位置。\n\n- 字符中是否有内容。\n`boolean isEmpty(): 原理就是判断长度是否为0. `\n- 字符串是否是以指定内容开头。\n`boolean startsWith(str);`\n- 字符串是否是以指定内容结尾。\n`boolean endsWith(str);`\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\n`boolean equals(str);`\n- 判断内容是否相同，并忽略大小写。\n`boolean equalsIgnoreCase();`\n\n#### 转换\n```\npublic static void method_trans()\n	{\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n		String s= new String(arr,1,3);//3是个数\n		sop(\"s=\"+s);\n		String s1 = \"zxcvbnm\";\n		char[] chs = s1.toCharArray();\n		for(int x=0; x<chs.length; x++)\n		{\n			sop(\"ch=\"+chs[x]);\n		}\n	}\n```\n- 将字符数组转成字符串。\n构造函数：\n```\nString(char[])\nString(char[],offset,count):将字符数组中的一部分转成字符串。\n```\n静态方法：\n```\nstatic String copyValueOf(char[]);\nstatic String copyValueOf(char[] data, int offset, int count) \nstatic String valueOf(char[]):\n```\n- 将字符串转成字符数组。**\n`char[] toCharArray():`\n\n- 将字节数组转成字符串。\n`String(byte[])`\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\n\n- 将字符串转成字节数组。\n`byte[]  getBytes():`\n\n- 将基本数据类型转成字符串。\n`static String valueOf(int)`\n`static String valueOf(double)`\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\n#### 替换\n`String replace(oldchar,newchar);`\n```\npublic static void method_replace()\n	{\n		String s = \"hello java\";\n	 //String s1 = s.replace(\'q\',\'n\');\n//如果要替换的字符不存在，返回的还是原串。\n		String s1 = s.replace(\"java\",\"world\");\n		sop(\"s=\"+s);\n		sop(\"s1=\"+s1);\n	}\n```\n#### 切割\n`String[] split(regex);`\n```\npublic static void  method_split()\n	{\n		String s = \"zhagnsa,lisi,wangwu\";\n\n		String[] arr  = s.split(\",\");\n\n		for(int x = 0; x<arr.length; x++)\n		{\n			sop(arr[x]);\n		}\n	}	\n```\n#### 子串（获取字符串中的一部分）\n`String substring(begin);`\n`String substring(begin,end);`\n```\npublic static void method_sub()\n	{\n		String s = \"abcdef\";\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\n		sop(s.substring(2,4)); \n 		//包含头，不包含尾。s.substring(0,s.length());\n	}\n```\n#### 转换，去除空格，比较\n- 将字符串转成大写或则小写。\n`String toUpperCase();`\n`String toLowerCase();`\n\n- 将字符串两端的多个空格去除。\n`String trim();`\n\n- 对两个字符串进行自然顺序的比较。\n`int compareTo(string);`\n### StringBuffer\n#### 特点\n1. 长度是可变化的。\n2. 可以直接操作多个数据类型。\n3. 最终会通过 toString 方法变成字符串。\n4. 是一个容器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001096s ]
---------------------------------------------------------------
[ 2018-10-12T10:38:09+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.053776s][吞吐率：18.60req/s] [内存消耗：2,166.00kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '36791',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。
### StringBuilder
StringBuffer 是线程同步。
StringBuilder 是线程不同步。
建议使用 StringBuilder
#### 存储。
StringBuffer append():将指定数据作为参数添加到已有数据结尾处。
StringBuffer insert(index,数据):可以将数据插入到指定index位置。
### 删除。
StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。
StringBuffer deleteCharAt(index):删除指定位置的字符。
### 获取。
char charAt(int index) 
int indexOf(String str) 
int lastIndexOf(String str) 
int length() 
String substring(int start, int end)  
### 修改。
StringBuffer replace(start,end,string);
void setCharAt(int index, char ch) ;
### 反转。
StringBuffer reverse(); 
### 将缓冲区中指定数据存储到指定字符数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)




















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000521s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001286s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 格式控制\n### 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n### \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n## String\n### 概述\n字符串最大特点：一旦被初始化就不可以被改变。\n\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\n```\n//s1 在内存中有一个对象\nString s1 = \"abc\";\n//s2 在内存中有两个对象\nString s2 = new String(\"abc\");\nString s3 = \"abc\";\n\nSystem.out.println(s1==s2);//false\nSystem.out.println(s1==s3);//true\nSystem.out.println(s1.equals(s2));//true\n```\n\n### 常见方法\n#### 获取\n```\nString str = \"aabcbcc\";\n\n//字符串的长度\nSystem.out.println(str.length());\n\n//根据位置获取位置上某个字符\nSystem.out.println(str.charAt(1));\n\n//===== 根据字符获取该字符在字符串中位置 =====\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\n//如果没有找到，返回-1\nSystem.out.println(str.indexOf(\'b\',3));\n//可以用于对指定判断是否包含\nif(str.indexOf(\"aa\")!=-1)\n\n\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\nSystem.out.println(str.lastIndexOf(\'b\'));\n```\n#### 判断\n```\n//判断文件名称是否是Array单词开头。\nsop(str.startsWith(\"Array\"));\n//判断文件名称是否是.java的文件。\nsop(str.endsWith(\".java\"));\n//判断文件中是否包含Demo\nsop(str.contains(\"Demo\"));\n```\n- 字符串中是否包含某一个子串。\n`boolean contains(str):`\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\n所以，也可以用于对指定判断是否包含。\n`if(str.indexOf(\"aa\")!=-1)`\n\n而且该方法既可以判断，又可以获取出现的位置。\n\n- 字符中是否有内容。\n`boolean isEmpty(): 原理就是判断长度是否为0. `\n- 字符串是否是以指定内容开头。\n`boolean startsWith(str);`\n- 字符串是否是以指定内容结尾。\n`boolean endsWith(str);`\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\n`boolean equals(str);`\n- 判断内容是否相同，并忽略大小写。\n`boolean equalsIgnoreCase();`\n\n#### 转换\n```\npublic static void method_trans()\n	{\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n		String s= new String(arr,1,3);//3是个数\n		sop(\"s=\"+s);\n		String s1 = \"zxcvbnm\";\n		char[] chs = s1.toCharArray();\n		for(int x=0; x<chs.length; x++)\n		{\n			sop(\"ch=\"+chs[x]);\n		}\n	}\n```\n- 将字符数组转成字符串。\n构造函数：\n```\nString(char[])\nString(char[],offset,count):将字符数组中的一部分转成字符串。\n```\n静态方法：\n```\nstatic String copyValueOf(char[]);\nstatic String copyValueOf(char[] data, int offset, int count) \nstatic String valueOf(char[]):\n```\n- 将字符串转成字符数组。**\n`char[] toCharArray():`\n\n- 将字节数组转成字符串。\n`String(byte[])`\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\n\n- 将字符串转成字节数组。\n`byte[]  getBytes():`\n\n- 将基本数据类型转成字符串。\n`static String valueOf(int)`\n`static String valueOf(double)`\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\n#### 替换\n`String replace(oldchar,newchar);`\n```\npublic static void method_replace()\n	{\n		String s = \"hello java\";\n	 //String s1 = s.replace(\'q\',\'n\');\n//如果要替换的字符不存在，返回的还是原串。\n		String s1 = s.replace(\"java\",\"world\");\n		sop(\"s=\"+s);\n		sop(\"s1=\"+s1);\n	}\n```\n#### 切割\n`String[] split(regex);`\n```\npublic static void  method_split()\n	{\n		String s = \"zhagnsa,lisi,wangwu\";\n\n		String[] arr  = s.split(\",\");\n\n		for(int x = 0; x<arr.length; x++)\n		{\n			sop(arr[x]);\n		}\n	}	\n```\n#### 子串（获取字符串中的一部分）\n`String substring(begin);`\n`String substring(begin,end);`\n```\npublic static void method_sub()\n	{\n		String s = \"abcdef\";\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\n		sop(s.substring(2,4)); \n 		//包含头，不包含尾。s.substring(0,s.length());\n	}\n```\n#### 转换，去除空格，比较\n- 将字符串转成大写或则小写。\n`String toUpperCase();`\n`String toLowerCase();`\n\n- 将字符串两端的多个空格去除。\n`String trim();`\n\n- 对两个字符串进行自然顺序的比较。\n`int compareTo(string);`\n### StringBuffer\n#### 特点\n1. 长度是可变化的。\n2. 可以直接操作多个数据类型。\n3. 最终会通过 toString 方法变成字符串。\n4. 是一个容器。\n### StringBuilder\nStringBuffer 是线程同步。\nStringBuilder 是线程不同步。\n建议使用 StringBuilder\n#### 存储。\nStringBuffer append():将指定数据作为参数添加到已有数据结尾处。\nStringBuffer insert(index,数据):可以将数据插入到指定index位置。\n### 删除。\nStringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。\nStringBuffer deleteCharAt(index):删除指定位置的字符。\n### 获取。\nchar charAt(int index) \nint indexOf(String str) \nint lastIndexOf(String str) \nint length() \nString substring(int start, int end)  \n### 修改。\nStringBuffer replace(start,end,string);\nvoid setCharAt(int index, char ch) ;\n### 反转。\nStringBuffer reverse(); \n### 将缓冲区中指定数据存储到指定字符数组中。\nvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000886s ]
---------------------------------------------------------------
[ 2018-10-12T11:14:05+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.080364s][吞吐率：12.44req/s] [内存消耗：2,186.12kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '41835',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。

>为什么StringBuffer可以变长？

和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。

比如说new StringBuffer("the")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。

如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。

注： 19 这个数量，不同的JDK数量是不一样的
### StringBuilder
StringBuffer 是线程同步。
StringBuilder 是线程不同步。
建议使用 StringBuilder
#### 存储。
StringBuffer append():将指定数据作为参数添加到已有数据结尾处。
StringBuffer insert(index,数据):可以将数据插入到指定index位置。
### 删除。
StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。
StringBuffer deleteCharAt(index):删除指定位置的字符。
### 获取。
char charAt(int index) 
int indexOf(String str) 
int lastIndexOf(String str) 
int length() 
String substring(int start, int end)  
### 修改。
StringBuffer replace(start,end,string);
void setCharAt(int index, char ch) ;
### 反转。
StringBuffer reverse(); 
### 将缓冲区中指定数据存储到指定字符数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
## Date
|字符|含义|
|-|
|y| 代表年|
|M| 代表月|
|d| 代表日|
|H| 代表24进制的小时|
|h| 代表12进制的小时|
|m| 代表分钟|
|s| 代表秒|
|S| 代表毫秒|

```
//时间原点
Date date = new Date(5000);
System.out.println(date);	//Thu Jan 01 08:00:05 CST 1970

//当前时间
Date dateNow = new Date();
System.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018

//时间格式化
SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date d= new Date();
String str = sdf.format(d);
System.out.println(str);	//2018-10-12 11:10:23
```
## Calendar
### Calendar 与 Date 进行转换
```
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateDemo {
	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	 
    public static void main(String[] args) {
    	//采用单例模式获取日历对象Calendar.getInstance();
        Calendar c = Calendar.getInstance();
        
        //通过日历对象得到日期对象
        Date now = c.getTime();
        
        //===== 当前日期 =====
        System.out.println("当前日期：\\t" + format(c.getTime()));
 
        //===== 下个月的今天 =====
        //set方法，直接设置年/月/日
        c.setTime(now);
        //add方法，在原日期上增加年/月/日
        c.add(Calendar.MONTH, 1);
        System.out.println("下个月的今天:\\t" +format(c.getTime()));
 
        //===== 去年的今天 =====
        c.setTime(now);
        c.add(Calendar.YEAR, -1);
        System.out.println("去年的今天:\\t" +format(c.getTime()));
 
        //===== 上个月的第三天 =====
        c.setTime(now);
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DATE, 3);
        System.out.println("上个月的第三天:\\t" +format(c.getTime()));
 
    }
 
    private static String format(Date time) {
        return sdf.format(time);
    }
}
```


















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000799s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001325s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 格式控制\n### 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n### \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n## String\n### 概述\n字符串最大特点：一旦被初始化就不可以被改变。\n\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\n```\n//s1 在内存中有一个对象\nString s1 = \"abc\";\n//s2 在内存中有两个对象\nString s2 = new String(\"abc\");\nString s3 = \"abc\";\n\nSystem.out.println(s1==s2);//false\nSystem.out.println(s1==s3);//true\nSystem.out.println(s1.equals(s2));//true\n```\n\n### 常见方法\n#### 获取\n```\nString str = \"aabcbcc\";\n\n//字符串的长度\nSystem.out.println(str.length());\n\n//根据位置获取位置上某个字符\nSystem.out.println(str.charAt(1));\n\n//===== 根据字符获取该字符在字符串中位置 =====\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\n//如果没有找到，返回-1\nSystem.out.println(str.indexOf(\'b\',3));\n//可以用于对指定判断是否包含\nif(str.indexOf(\"aa\")!=-1)\n\n\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\nSystem.out.println(str.lastIndexOf(\'b\'));\n```\n#### 判断\n```\n//判断文件名称是否是Array单词开头。\nsop(str.startsWith(\"Array\"));\n//判断文件名称是否是.java的文件。\nsop(str.endsWith(\".java\"));\n//判断文件中是否包含Demo\nsop(str.contains(\"Demo\"));\n```\n- 字符串中是否包含某一个子串。\n`boolean contains(str):`\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\n所以，也可以用于对指定判断是否包含。\n`if(str.indexOf(\"aa\")!=-1)`\n\n而且该方法既可以判断，又可以获取出现的位置。\n\n- 字符中是否有内容。\n`boolean isEmpty(): 原理就是判断长度是否为0. `\n- 字符串是否是以指定内容开头。\n`boolean startsWith(str);`\n- 字符串是否是以指定内容结尾。\n`boolean endsWith(str);`\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\n`boolean equals(str);`\n- 判断内容是否相同，并忽略大小写。\n`boolean equalsIgnoreCase();`\n\n#### 转换\n```\npublic static void method_trans()\n	{\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n		String s= new String(arr,1,3);//3是个数\n		sop(\"s=\"+s);\n		String s1 = \"zxcvbnm\";\n		char[] chs = s1.toCharArray();\n		for(int x=0; x<chs.length; x++)\n		{\n			sop(\"ch=\"+chs[x]);\n		}\n	}\n```\n- 将字符数组转成字符串。\n构造函数：\n```\nString(char[])\nString(char[],offset,count):将字符数组中的一部分转成字符串。\n```\n静态方法：\n```\nstatic String copyValueOf(char[]);\nstatic String copyValueOf(char[] data, int offset, int count) \nstatic String valueOf(char[]):\n```\n- 将字符串转成字符数组。**\n`char[] toCharArray():`\n\n- 将字节数组转成字符串。\n`String(byte[])`\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\n\n- 将字符串转成字节数组。\n`byte[]  getBytes():`\n\n- 将基本数据类型转成字符串。\n`static String valueOf(int)`\n`static String valueOf(double)`\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\n#### 替换\n`String replace(oldchar,newchar);`\n```\npublic static void method_replace()\n	{\n		String s = \"hello java\";\n	 //String s1 = s.replace(\'q\',\'n\');\n//如果要替换的字符不存在，返回的还是原串。\n		String s1 = s.replace(\"java\",\"world\");\n		sop(\"s=\"+s);\n		sop(\"s1=\"+s1);\n	}\n```\n#### 切割\n`String[] split(regex);`\n```\npublic static void  method_split()\n	{\n		String s = \"zhagnsa,lisi,wangwu\";\n\n		String[] arr  = s.split(\",\");\n\n		for(int x = 0; x<arr.length; x++)\n		{\n			sop(arr[x]);\n		}\n	}	\n```\n#### 子串（获取字符串中的一部分）\n`String substring(begin);`\n`String substring(begin,end);`\n```\npublic static void method_sub()\n	{\n		String s = \"abcdef\";\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\n		sop(s.substring(2,4)); \n 		//包含头，不包含尾。s.substring(0,s.length());\n	}\n```\n#### 转换，去除空格，比较\n- 将字符串转成大写或则小写。\n`String toUpperCase();`\n`String toLowerCase();`\n\n- 将字符串两端的多个空格去除。\n`String trim();`\n\n- 对两个字符串进行自然顺序的比较。\n`int compareTo(string);`\n### StringBuffer\n#### 特点\n1. 长度是可变化的。\n2. 可以直接操作多个数据类型。\n3. 最终会通过 toString 方法变成字符串。\n4. 是一个容器。\n\n>为什么StringBuffer可以变长？\n\n和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。\n\n比如说new StringBuffer(\"the\")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。\n\n如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。\n\n注： 19 这个数量，不同的JDK数量是不一样的\n### StringBuilder\nStringBuffer 是线程同步。\nStringBuilder 是线程不同步。\n建议使用 StringBuilder\n#### 存储。\nStringBuffer append():将指定数据作为参数添加到已有数据结尾处。\nStringBuffer insert(index,数据):可以将数据插入到指定index位置。\n### 删除。\nStringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。\nStringBuffer deleteCharAt(index):删除指定位置的字符。\n### 获取。\nchar charAt(int index) \nint indexOf(String str) \nint lastIndexOf(String str) \nint length() \nString substring(int start, int end)  \n### 修改。\nStringBuffer replace(start,end,string);\nvoid setCharAt(int index, char ch) ;\n### 反转。\nStringBuffer reverse(); \n### 将缓冲区中指定数据存储到指定字符数组中。\nvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\n## Date\n|字符|含义|\n|-|\n|y| 代表年|\n|M| 代表月|\n|d| 代表日|\n|H| 代表24进制的小时|\n|h| 代表12进制的小时|\n|m| 代表分钟|\n|s| 代表秒|\n|S| 代表毫秒|\n\n```\n//时间原点\nDate date = new Date(5000);\nSystem.out.println(date);	//Thu Jan 01 08:00:05 CST 1970\n\n//当前时间\nDate dateNow = new Date();\nSystem.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018\n\n//时间格式化\nSimpleDateFormat sdf =new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\nDate d= new Date();\nString str = sdf.format(d);\nSystem.out.println(str);	//2018-10-12 11:10:23\n```\n## Calendar\n### Calendar 与 Date 进行转换\n```\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class DateDemo {\n	private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n	 \n    public static void main(String[] args) {\n    	//采用单例模式获取日历对象Calendar.getInstance();\n        Calendar c = Calendar.getInstance();\n        \n        //通过日历对象得到日期对象\n        Date now = c.getTime();\n        \n        //===== 当前日期 =====\n        System.out.println(\"当前日期：\\t\" + format(c.getTime()));\n \n        //===== 下个月的今天 =====\n        //set方法，直接设置年/月/日\n        c.setTime(now);\n        //add方法，在原日期上增加年/月/日\n        c.add(Calendar.MONTH, 1);\n        System.out.println(\"下个月的今天:\\t\" +format(c.getTime()));\n \n        //===== 去年的今天 =====\n        c.setTime(now);\n        c.add(Calendar.YEAR, -1);\n        System.out.println(\"去年的今天:\\t\" +format(c.getTime()));\n \n        //===== 上个月的第三天 =====\n        c.setTime(now);\n        c.add(Calendar.MONTH, -1);\n        c.set(Calendar.DATE, 3);\n        System.out.println(\"上个月的第三天:\\t\" +format(c.getTime()));\n \n    }\n \n    private static String format(Date time) {\n        return sdf.format(time);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001170s ]
---------------------------------------------------------------
[ 2018-10-12T11:14:29+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.055796s][吞吐率：17.92req/s] [内存消耗：2,185.98kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '41762',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。

>为什么StringBuffer可以变长？

和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。

比如说new StringBuffer("the")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。

如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。

注： 19 这个数量，不同的JDK数量是不一样的
### StringBuilder
StringBuffer 是线程同步。
StringBuilder 是线程不同步。
建议使用 StringBuilder
#### 存储。
StringBuffer append():将指定数据作为参数添加到已有数据结尾处。
StringBuffer insert(index,数据):可以将数据插入到指定index位置。
### 删除。
StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。
StringBuffer deleteCharAt(index):删除指定位置的字符。
### 获取。
char charAt(int index) 
int indexOf(String str) 
int lastIndexOf(String str) 
int length() 
String substring(int start, int end)  
### 修改。
StringBuffer replace(start,end,string);
void setCharAt(int index, char ch) ;
### 反转。
StringBuffer reverse(); 
### 将缓冲区中指定数据存储到指定字符数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
## Date
|字符|含义|
|-|
|y| 代表年|
|M| 代表月|
|d| 代表日|
|H| 代表24进制的小时|
|h| 代表12进制的小时|
|m| 代表分钟|
|s| 代表秒|
|S| 代表毫秒|

```
//时间原点
Date date = new Date(5000);
System.out.println(date);	//Thu Jan 01 08:00:05 CST 1970

//当前时间
Date dateNow = new Date();
System.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018

//时间格式化
SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date d= new Date();
String str = sdf.format(d);
System.out.println(str);	//2018-10-12 11:10:23
```
## Calendar
```
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateDemo {
	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	 
    public static void main(String[] args) {
    	//采用单例模式获取日历对象Calendar.getInstance();
        Calendar c = Calendar.getInstance();
        
        //通过日历对象得到日期对象
        Date now = c.getTime();
        
        //===== 当前日期 =====
        System.out.println("当前日期：\\t" + format(c.getTime()));
 
        //===== 下个月的今天 =====
        //set方法，直接设置年/月/日
        c.setTime(now);
        //add方法，在原日期上增加年/月/日
        c.add(Calendar.MONTH, 1);
        System.out.println("下个月的今天:\\t" +format(c.getTime()));
 
        //===== 去年的今天 =====
        c.setTime(now);
        c.add(Calendar.YEAR, -1);
        System.out.println("去年的今天:\\t" +format(c.getTime()));
 
        //===== 上个月的第三天 =====
        c.setTime(now);
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DATE, 3);
        System.out.println("上个月的第三天:\\t" +format(c.getTime()));
 
    }
 
    private static String format(Date time) {
        return sdf.format(time);
    }
}
```


















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000490s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001201s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 格式控制\n### 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n### \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n## String\n### 概述\n字符串最大特点：一旦被初始化就不可以被改变。\n\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\n```\n//s1 在内存中有一个对象\nString s1 = \"abc\";\n//s2 在内存中有两个对象\nString s2 = new String(\"abc\");\nString s3 = \"abc\";\n\nSystem.out.println(s1==s2);//false\nSystem.out.println(s1==s3);//true\nSystem.out.println(s1.equals(s2));//true\n```\n\n### 常见方法\n#### 获取\n```\nString str = \"aabcbcc\";\n\n//字符串的长度\nSystem.out.println(str.length());\n\n//根据位置获取位置上某个字符\nSystem.out.println(str.charAt(1));\n\n//===== 根据字符获取该字符在字符串中位置 =====\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\n//如果没有找到，返回-1\nSystem.out.println(str.indexOf(\'b\',3));\n//可以用于对指定判断是否包含\nif(str.indexOf(\"aa\")!=-1)\n\n\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\nSystem.out.println(str.lastIndexOf(\'b\'));\n```\n#### 判断\n```\n//判断文件名称是否是Array单词开头。\nsop(str.startsWith(\"Array\"));\n//判断文件名称是否是.java的文件。\nsop(str.endsWith(\".java\"));\n//判断文件中是否包含Demo\nsop(str.contains(\"Demo\"));\n```\n- 字符串中是否包含某一个子串。\n`boolean contains(str):`\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\n所以，也可以用于对指定判断是否包含。\n`if(str.indexOf(\"aa\")!=-1)`\n\n而且该方法既可以判断，又可以获取出现的位置。\n\n- 字符中是否有内容。\n`boolean isEmpty(): 原理就是判断长度是否为0. `\n- 字符串是否是以指定内容开头。\n`boolean startsWith(str);`\n- 字符串是否是以指定内容结尾。\n`boolean endsWith(str);`\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\n`boolean equals(str);`\n- 判断内容是否相同，并忽略大小写。\n`boolean equalsIgnoreCase();`\n\n#### 转换\n```\npublic static void method_trans()\n	{\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n		String s= new String(arr,1,3);//3是个数\n		sop(\"s=\"+s);\n		String s1 = \"zxcvbnm\";\n		char[] chs = s1.toCharArray();\n		for(int x=0; x<chs.length; x++)\n		{\n			sop(\"ch=\"+chs[x]);\n		}\n	}\n```\n- 将字符数组转成字符串。\n构造函数：\n```\nString(char[])\nString(char[],offset,count):将字符数组中的一部分转成字符串。\n```\n静态方法：\n```\nstatic String copyValueOf(char[]);\nstatic String copyValueOf(char[] data, int offset, int count) \nstatic String valueOf(char[]):\n```\n- 将字符串转成字符数组。**\n`char[] toCharArray():`\n\n- 将字节数组转成字符串。\n`String(byte[])`\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\n\n- 将字符串转成字节数组。\n`byte[]  getBytes():`\n\n- 将基本数据类型转成字符串。\n`static String valueOf(int)`\n`static String valueOf(double)`\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\n#### 替换\n`String replace(oldchar,newchar);`\n```\npublic static void method_replace()\n	{\n		String s = \"hello java\";\n	 //String s1 = s.replace(\'q\',\'n\');\n//如果要替换的字符不存在，返回的还是原串。\n		String s1 = s.replace(\"java\",\"world\");\n		sop(\"s=\"+s);\n		sop(\"s1=\"+s1);\n	}\n```\n#### 切割\n`String[] split(regex);`\n```\npublic static void  method_split()\n	{\n		String s = \"zhagnsa,lisi,wangwu\";\n\n		String[] arr  = s.split(\",\");\n\n		for(int x = 0; x<arr.length; x++)\n		{\n			sop(arr[x]);\n		}\n	}	\n```\n#### 子串（获取字符串中的一部分）\n`String substring(begin);`\n`String substring(begin,end);`\n```\npublic static void method_sub()\n	{\n		String s = \"abcdef\";\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\n		sop(s.substring(2,4)); \n 		//包含头，不包含尾。s.substring(0,s.length());\n	}\n```\n#### 转换，去除空格，比较\n- 将字符串转成大写或则小写。\n`String toUpperCase();`\n`String toLowerCase();`\n\n- 将字符串两端的多个空格去除。\n`String trim();`\n\n- 对两个字符串进行自然顺序的比较。\n`int compareTo(string);`\n### StringBuffer\n#### 特点\n1. 长度是可变化的。\n2. 可以直接操作多个数据类型。\n3. 最终会通过 toString 方法变成字符串。\n4. 是一个容器。\n\n>为什么StringBuffer可以变长？\n\n和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。\n\n比如说new StringBuffer(\"the\")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。\n\n如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。\n\n注： 19 这个数量，不同的JDK数量是不一样的\n### StringBuilder\nStringBuffer 是线程同步。\nStringBuilder 是线程不同步。\n建议使用 StringBuilder\n#### 存储。\nStringBuffer append():将指定数据作为参数添加到已有数据结尾处。\nStringBuffer insert(index,数据):可以将数据插入到指定index位置。\n### 删除。\nStringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。\nStringBuffer deleteCharAt(index):删除指定位置的字符。\n### 获取。\nchar charAt(int index) \nint indexOf(String str) \nint lastIndexOf(String str) \nint length() \nString substring(int start, int end)  \n### 修改。\nStringBuffer replace(start,end,string);\nvoid setCharAt(int index, char ch) ;\n### 反转。\nStringBuffer reverse(); \n### 将缓冲区中指定数据存储到指定字符数组中。\nvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\n## Date\n|字符|含义|\n|-|\n|y| 代表年|\n|M| 代表月|\n|d| 代表日|\n|H| 代表24进制的小时|\n|h| 代表12进制的小时|\n|m| 代表分钟|\n|s| 代表秒|\n|S| 代表毫秒|\n\n```\n//时间原点\nDate date = new Date(5000);\nSystem.out.println(date);	//Thu Jan 01 08:00:05 CST 1970\n\n//当前时间\nDate dateNow = new Date();\nSystem.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018\n\n//时间格式化\nSimpleDateFormat sdf =new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\nDate d= new Date();\nString str = sdf.format(d);\nSystem.out.println(str);	//2018-10-12 11:10:23\n```\n## Calendar\n```\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class DateDemo {\n	private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n	 \n    public static void main(String[] args) {\n    	//采用单例模式获取日历对象Calendar.getInstance();\n        Calendar c = Calendar.getInstance();\n        \n        //通过日历对象得到日期对象\n        Date now = c.getTime();\n        \n        //===== 当前日期 =====\n        System.out.println(\"当前日期：\\t\" + format(c.getTime()));\n \n        //===== 下个月的今天 =====\n        //set方法，直接设置年/月/日\n        c.setTime(now);\n        //add方法，在原日期上增加年/月/日\n        c.add(Calendar.MONTH, 1);\n        System.out.println(\"下个月的今天:\\t\" +format(c.getTime()));\n \n        //===== 去年的今天 =====\n        c.setTime(now);\n        c.add(Calendar.YEAR, -1);\n        System.out.println(\"去年的今天:\\t\" +format(c.getTime()));\n \n        //===== 上个月的第三天 =====\n        c.setTime(now);\n        c.add(Calendar.MONTH, -1);\n        c.set(Calendar.DATE, 3);\n        System.out.println(\"上个月的第三天:\\t\" +format(c.getTime()));\n \n    }\n \n    private static String format(Date time) {\n        return sdf.format(time);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001001s ]
---------------------------------------------------------------
[ 2018-10-12T11:14:34+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/209.html [运行时间：0.068103s][吞吐率：14.68req/s] [内存消耗：2,201.25kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '45061',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'content' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。

>为什么StringBuffer可以变长？

和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。

比如说new StringBuffer("the")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。

如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。

注： 19 这个数量，不同的JDK数量是不一样的
### StringBuilder
StringBuffer 是线程同步。
StringBuilder 是线程不同步。
建议使用 StringBuilder
#### 存储。
StringBuffer append():将指定数据作为参数添加到已有数据结尾处。
StringBuffer insert(index,数据):可以将数据插入到指定index位置。
### 删除。
StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。
StringBuffer deleteCharAt(index):删除指定位置的字符。
### 获取。
char charAt(int index) 
int indexOf(String str) 
int lastIndexOf(String str) 
int length() 
String substring(int start, int end)  
### 修改。
StringBuffer replace(start,end,string);
void setCharAt(int index, char ch) ;
### 反转。
StringBuffer reverse(); 
### 将缓冲区中指定数据存储到指定字符数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
## Date
|字符|含义|
|-|
|y| 代表年|
|M| 代表月|
|d| 代表日|
|H| 代表24进制的小时|
|h| 代表12进制的小时|
|m| 代表分钟|
|s| 代表秒|
|S| 代表毫秒|

```
//时间原点
Date date = new Date(5000);
System.out.println(date);	//Thu Jan 01 08:00:05 CST 1970

//当前时间
Date dateNow = new Date();
System.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018

//时间格式化
SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date d= new Date();
String str = sdf.format(d);
System.out.println(str);	//2018-10-12 11:10:23
```
## Calendar
```
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateDemo {
	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	 
    public static void main(String[] args) {
    	//采用单例模式获取日历对象Calendar.getInstance();
        Calendar c = Calendar.getInstance();
        
        //通过日历对象得到日期对象
        Date now = c.getTime();
        
        //===== 当前日期 =====
        System.out.println("当前日期：\\t" + format(c.getTime()));
 
        //===== 下个月的今天 =====
        //set方法，直接设置年/月/日
        c.setTime(now);
        //add方法，在原日期上增加年/月/日
        c.add(Calendar.MONTH, 1);
        System.out.println("下个月的今天:\\t" +format(c.getTime()));
 
        //===== 去年的今天 =====
        c.setTime(now);
        c.add(Calendar.YEAR, -1);
        System.out.println("去年的今天:\\t" +format(c.getTime()));
 
        //===== 上个月的第三天 =====
        c.setTime(now);
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DATE, 3);
        System.out.println("上个月的第三天:\\t" +format(c.getTime()));
 
    }
 
    private static String format(Date time) {
        return sdf.format(time);
    }
}
```


















',
  'groups' => 'Java',
  'showsel' => '1',
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000550s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001410s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000542s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001107s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000362s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE - 基础\r',`content`='# Java SE - 基础\r\n[TOC]\r\n## Scanner\r\n```\r\npackage basics;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class ScannerDemo {\r\n	public static void main(String[] args) {\r\n		Scanner scan = new Scanner(System.in);\r\n		int num = scan.nextInt();\r\n		System.out.println(\"输入的整数是：\" + num);\r\n		\r\n		float f = scan.nextFloat();\r\n		System.out.println(\"输入的浮点数是：\" + f);\r\n		\r\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\r\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\r\n		String str = scan.nextLine(); //读取回车换行\r\n		String str2 = scan.nextLine(); //读取真正的字符串\r\n		System.out.println(\"str1是：\" + str);\r\n		System.out.println(\"输入的字符串是：\" + str2);\r\n	}\r\n}\r\n```\r\n## 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 内部类\r\n### 内部类的使用\r\n#### 内部类的访问规则\r\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\r\n2．外部类要访问内部类，必须建立内部类对象。\r\n\r\n```\r\npackage basics;\r\n\r\nimport basics.Outer.StaticInner;\r\n\r\npublic class OutIn{\r\n	public static void main(String[] args) {\r\n		//外部类访问内部类\r\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\r\n		Outer.Inner inner = new Outer().new Inner();\r\n		inner.fun();\r\n		\r\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\r\n		StaticInner inner2 = new Outer.StaticInner();\r\n		inner2.fun();\r\n	}\r\n}\r\n\r\nclass Outer {\r\n	private static int x = 1;\r\n	\r\n	/**\r\n	 * 非静态内部类\r\n	 */\r\n	class Inner{\r\n		int x = 2;\r\n		public void fun(){\r\n			int x = 3;\r\n			System.out.println(x);//内部类方法中的变量\r\n			System.out.println(this.x);//内部类中的变量\r\n			System.out.println(Outer.this.x);//外部类中的变量\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * 静态内部类\r\n	 */\r\n	static class StaticInner{\r\n		public void fun(){\r\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\r\n			System.out.println(\"此为静态内部类方法\" + x);\r\n		}\r\n	}\r\n}\r\n```\r\n#### 访问格式\r\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\r\n格式\r\n```\r\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\r\nOuter.Inner in = new Outer().new Inner();\r\n```\r\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\r\n\r\n比如：\r\n- private：将内部类在外部类中进行封装。\r\n- static:  内部类就具备static的特性。\r\n\r\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\r\n\r\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\r\n\r\nnew Outer.Inner().function();\r\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\r\n\r\nuter.Inner.function();\r\n\r\n注意：\r\n当内部类中定义了静态成员，该内部类必须是static的。\r\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\r\n\r\n### 匿名内部类\r\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\r\n\r\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\r\n\r\n#### 匿名内部类的格式\r\n**new 父类或者接口(){定义子类的内容};**\r\n```\r\nRunnable r = new Runnable(){};\r\n\r\n//多在 Android 中使用，例如监听方法的实现\r\nnew Demo(){	//匿名内部类\r\n	public void show(){\r\n		System.out.println(\"Inner show!\");\r\n	}\r\n}.show();\r\n```\r\n#### 例子\r\n```\r\npackage basics;\r\n\r\n/**\r\n * 接口\r\n */\r\ninterface Inter{\r\n	public void fun();\r\n}\r\n\r\n/**\r\n * 抽象方法\r\n */\r\nabstract class Inter2{\r\n	abstract public void fun();\r\n}\r\n\r\nclass Test{\r\n	//返回  Inter 对象\r\n	public static Inter fun2(){\r\n		return new Inter(){\r\n			public void fun(){\r\n				System.out.println(\"fun2 running!\");\r\n			}\r\n		};\r\n	}\r\n	\r\n	public static void fun3(){\r\n		//对象.方法();\r\n		new Inter2(){\r\n			public void fun(){\r\n				System.out.println(\"fun3 running!\");\r\n			}\r\n		}.fun();\r\n	}\r\n}\r\n\r\npublic class AnonymousInnerClass {\r\n	public static void main(String[] args) {\r\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\r\n		Test.fun2().fun();\r\n		\r\n		Test.fun3();\r\n	}\r\n}\r\n```\r\n## 默认方法\r\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\r\n```\r\npackage basics;\r\n\r\npublic interface Person {\r\n	public void eat();\r\n	\r\n	//默认方法，有实现体\r\n	default public void die(){\r\n		System.out.println(\"Game Over!\");\r\n	}\r\n}\r\n```\r\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\r\n\r\n>为什么会有默认方法\r\n\r\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\r\n\r\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\r\n\r\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\r\n\r\n```\r\npackage basics;\r\n\r\npublic class DefaultFunction implements Person{\r\n\r\n	@Override\r\n	public void eat() {\r\n		// TODO Auto-generated method stub\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		//不需要做任何改动，直接得到这个默认方法\r\n		new DefaultFunction().die();\r\n	}\r\n}\r\n```\r\n## 装箱和拆箱\r\n### 封装类\r\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\r\n### 自动装箱和自动拆箱\r\n```\r\nint i = 5;\r\n\r\n//把一个基本类型的变量,转换为 Integer 对象\r\nInteger it = new Integer(i);\r\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\r\nInteger it2 = i;\r\n\r\n//把一个 Integer 对象，转换为一个基本类型的 int\r\nint i2 = it.intValue();\r\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\r\nint i3 = it;\r\n```\r\n### Number 类\r\n数字封装类有：Byte,Short,Integer,Long,Float,Double\r\n这些类都是抽象类 Number 的子类\r\n```\r\nint i = 5;\r\n\r\nInteger it = new Integer(i);\r\n//Integer 是 Number 的子类，所以打印 true\r\nSystem.out.println(it instanceof Number);\r\n```\r\n## Math\r\n```\r\nfloat f1 = 5.4f;\r\n\r\n//四舍五入\r\nSystem.out.println(Math.round(f1));\r\n\r\n//得到一个 0-1 之间的随机浮点数（取不到1）\r\nSystem.out.println(Math.random());\r\n\r\n//得到一个 0-10 之间的随机整数 （取不到10）\r\nSystem.out.println((int)( Math.random()*10));\r\n\r\n//大于指定数据的最小整数\r\nSystem.out.println(Math.ceil(f1));	//6.0\r\n\r\n//小于指定数据的最大整数\r\nSystem.out.println(Math.floor(f1));	//5.0\r\n\r\n//开方\r\nSystem.out.println(Math.sqrt(9));\r\n\r\n//次方（2的4次方）\r\nSystem.out.println(Math.pow(2,4));\r\n\r\n//π\r\nSystem.out.println(Math.PI);\r\n\r\n//自然常数\r\nSystem.out.println(Math.E);\r\n```\r\n## 格式控制\r\n### 换行符和回车符\r\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\r\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\r\n\r\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\r\n\r\n然而在不同的操作系统，换行符是不一样的\r\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\r\n- Linux系统里，每行结尾只有 “\\n”；\r\n- Mac系统里，每行结尾是只有 \"\\r\"。\r\n\r\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\r\n### \\\\t 空格对齐\r\n```\r\nSystem.out.println(\"使用空格无法达到对齐的效果\");\r\nSystem.out.println(\"abc def\");\r\nSystem.out.println(\"ab def\");\r\nSystem.out.println(\"a def\");\r\n\r\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\r\nSystem.out.println(\"abc\\tdef\");\r\nSystem.out.println(\"ab\\tdef\");\r\nSystem.out.println(\"a\\tdef\");\r\n```\r\n---\r\n~~使用空格无法达到对齐的效果\r\nabc def\r\nab def\r\na def\r\n使用 \\t 制表符可以达到对齐的效果\r\nabc	def\r\nab	def\r\na	def~~\r\n\r\n---\r\n## String\r\n### 概述\r\n字符串最大特点：一旦被初始化就不可以被改变。\r\n\r\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\r\n```\r\n//s1 在内存中有一个对象\r\nString s1 = \"abc\";\r\n//s2 在内存中有两个对象\r\nString s2 = new String(\"abc\");\r\nString s3 = \"abc\";\r\n\r\nSystem.out.println(s1==s2);//false\r\nSystem.out.println(s1==s3);//true\r\nSystem.out.println(s1.equals(s2));//true\r\n```\r\n\r\n### 常见方法\r\n#### 获取\r\n```\r\nString str = \"aabcbcc\";\r\n\r\n//字符串的长度\r\nSystem.out.println(str.length());\r\n\r\n//根据位置获取位置上某个字符\r\nSystem.out.println(str.charAt(1));\r\n\r\n//===== 根据字符获取该字符在字符串中位置 =====\r\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\r\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\r\n//如果没有找到，返回-1\r\nSystem.out.println(str.indexOf(\'b\',3));\r\n//可以用于对指定判断是否包含\r\nif(str.indexOf(\"aa\")!=-1)\r\n\r\n\r\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\r\nSystem.out.println(str.lastIndexOf(\'b\'));\r\n```\r\n#### 判断\r\n```\r\n//判断文件名称是否是Array单词开头。\r\nsop(str.startsWith(\"Array\"));\r\n//判断文件名称是否是.java的文件。\r\nsop(str.endsWith(\".java\"));\r\n//判断文件中是否包含Demo\r\nsop(str.contains(\"Demo\"));\r\n```\r\n- 字符串中是否包含某一个子串。\r\n`boolean contains(str):`\r\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\r\n所以，也可以用于对指定判断是否包含。\r\n`if(str.indexOf(\"aa\")!=-1)`\r\n\r\n而且该方法既可以判断，又可以获取出现的位置。\r\n\r\n- 字符中是否有内容。\r\n`boolean isEmpty(): 原理就是判断长度是否为0. `\r\n- 字符串是否是以指定内容开头。\r\n`boolean startsWith(str);`\r\n- 字符串是否是以指定内容结尾。\r\n`boolean endsWith(str);`\r\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\r\n`boolean equals(str);`\r\n- 判断内容是否相同，并忽略大小写。\r\n`boolean equalsIgnoreCase();`\r\n\r\n#### 转换\r\n```\r\npublic static void method_trans()\r\n	{\r\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\r\n		String s= new String(arr,1,3);//3是个数\r\n		sop(\"s=\"+s);\r\n		String s1 = \"zxcvbnm\";\r\n		char[] chs = s1.toCharArray();\r\n		for(int x=0; x<chs.length; x++)\r\n		{\r\n			sop(\"ch=\"+chs[x]);\r\n		}\r\n	}\r\n```\r\n- 将字符数组转成字符串。\r\n构造函数：\r\n```\r\nString(char[])\r\nString(char[],offset,count):将字符数组中的一部分转成字符串。\r\n```\r\n静态方法：\r\n```\r\nstatic String copyValueOf(char[]);\r\nstatic String copyValueOf(char[] data, int offset, int count) \r\nstatic String valueOf(char[]):\r\n```\r\n- 将字符串转成字符数组。**\r\n`char[] toCharArray():`\r\n\r\n- 将字节数组转成字符串。\r\n`String(byte[])`\r\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\r\n\r\n- 将字符串转成字节数组。\r\n`byte[]  getBytes():`\r\n\r\n- 将基本数据类型转成字符串。\r\n`static String valueOf(int)`\r\n`static String valueOf(double)`\r\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\r\n#### 替换\r\n`String replace(oldchar,newchar);`\r\n```\r\npublic static void method_replace()\r\n	{\r\n		String s = \"hello java\";\r\n	 //String s1 = s.replace(\'q\',\'n\');\r\n//如果要替换的字符不存在，返回的还是原串。\r\n		String s1 = s.replace(\"java\",\"world\");\r\n		sop(\"s=\"+s);\r\n		sop(\"s1=\"+s1);\r\n	}\r\n```\r\n#### 切割\r\n`String[] split(regex);`\r\n```\r\npublic static void  method_split()\r\n	{\r\n		String s = \"zhagnsa,lisi,wangwu\";\r\n\r\n		String[] arr  = s.split(\",\");\r\n\r\n		for(int x = 0; x<arr.length; x++)\r\n		{\r\n			sop(arr[x]);\r\n		}\r\n	}	\r\n```\r\n#### 子串（获取字符串中的一部分）\r\n`String substring(begin);`\r\n`String substring(begin,end);`\r\n```\r\npublic static void method_sub()\r\n	{\r\n		String s = \"abcdef\";\r\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\r\n		sop(s.substring(2,4)); \r\n 		//包含头，不包含尾。s.substring(0,s.length());\r\n	}\r\n```\r\n#### 转换，去除空格，比较\r\n- 将字符串转成大写或则小写。\r\n`String toUpperCase();`\r\n`String toLowerCase();`\r\n\r\n- 将字符串两端的多个空格去除。\r\n`String trim();`\r\n\r\n- 对两个字符串进行自然顺序的比较。\r\n`int compareTo(string);`\r\n### StringBuffer\r\n#### 特点\r\n1. 长度是可变化的。\r\n2. 可以直接操作多个数据类型。\r\n3. 最终会通过 toString 方法变成字符串。\r\n4. 是一个容器。\r\n\r\n>为什么StringBuffer可以变长？\r\n\r\n和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。\r\n\r\n比如说new StringBuffer(\"the\")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。\r\n\r\n如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。\r\n\r\n注： 19 这个数量，不同的JDK数量是不一样的\r\n### StringBuilder\r\nStringBuffer 是线程同步。\r\nStringBuilder 是线程不同步。\r\n建议使用 StringBuilder\r\n#### 存储。\r\nStringBuffer append():将指定数据作为参数添加到已有数据结尾处。\r\nStringBuffer insert(index,数据):可以将数据插入到指定index位置。\r\n### 删除。\r\nStringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。\r\nStringBuffer deleteCharAt(index):删除指定位置的字符。\r\n### 获取。\r\nchar charAt(int index) \r\nint indexOf(String str) \r\nint lastIndexOf(String str) \r\nint length() \r\nString substring(int start, int end)  \r\n### 修改。\r\nStringBuffer replace(start,end,string);\r\nvoid setCharAt(int index, char ch) ;\r\n### 反转。\r\nStringBuffer reverse(); \r\n### 将缓冲区中指定数据存储到指定字符数组中。\r\nvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\r\n## Date\r\n|字符|含义|\r\n|-|\r\n|y| 代表年|\r\n|M| 代表月|\r\n|d| 代表日|\r\n|H| 代表24进制的小时|\r\n|h| 代表12进制的小时|\r\n|m| 代表分钟|\r\n|s| 代表秒|\r\n|S| 代表毫秒|\r\n\r\n```\r\n//时间原点\r\nDate date = new Date(5000);\r\nSystem.out.println(date);	//Thu Jan 01 08:00:05 CST 1970\r\n\r\n//当前时间\r\nDate dateNow = new Date();\r\nSystem.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018\r\n\r\n//时间格式化\r\nSimpleDateFormat sdf =new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\nDate d= new Date();\r\nString str = sdf.format(d);\r\nSystem.out.println(str);	//2018-10-12 11:10:23\r\n```\r\n## Calendar\r\n```\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\n\r\npublic class DateDemo {\r\n	private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n	 \r\n    public static void main(String[] args) {\r\n    	//采用单例模式获取日历对象Calendar.getInstance();\r\n        Calendar c = Calendar.getInstance();\r\n        \r\n        //通过日历对象得到日期对象\r\n        Date now = c.getTime();\r\n        \r\n        //===== 当前日期 =====\r\n        System.out.println(\"当前日期：\\t\" + format(c.getTime()));\r\n \r\n        //===== 下个月的今天 =====\r\n        //set方法，直接设置年/月/日\r\n        c.setTime(now);\r\n        //add方法，在原日期上增加年/月/日\r\n        c.add(Calendar.MONTH, 1);\r\n        System.out.println(\"下个月的今天:\\t\" +format(c.getTime()));\r\n \r\n        //===== 去年的今天 =====\r\n        c.setTime(now);\r\n        c.add(Calendar.YEAR, -1);\r\n        System.out.println(\"去年的今天:\\t\" +format(c.getTime()));\r\n \r\n        //===== 上个月的第三天 =====\r\n        c.setTime(now);\r\n        c.add(Calendar.MONTH, -1);\r\n        c.set(Calendar.DATE, 3);\r\n        System.out.println(\"上个月的第三天:\\t\" +format(c.getTime()));\r\n \r\n    }\r\n \r\n    private static String format(Date time) {\r\n        return sdf.format(time);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.001011s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000835s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=6  WHERE  `groups` = 'Java' [ RunTime:0.000339s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000731s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=6  WHERE  `groups` = 'Java' [ RunTime:0.000342s ]
---------------------------------------------------------------
[ 2018-10-12T11:14:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ info ] qingrang.top/daily/admin/note/shownote/id/209.html [运行时间：0.053149s][吞吐率：18.82req/s] [内存消耗：2,024.32kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000548s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001307s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000664s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000873s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000322s ]
---------------------------------------------------------------
[ 2018-10-12T11:14:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.111158s][吞吐率：9.00req/s] [内存消耗：2,225.09kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000578s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001275s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001328s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000515s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000910s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000298s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000459s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000881s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000312s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000424s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000284s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000355s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000857s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000222s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001341s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000659s ]
---------------------------------------------------------------
[ 2018-10-12T11:14:50+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ info ] qingrang.top/daily/admin/note/shownote/id/209.html [运行时间：0.049251s][吞吐率：20.30req/s] [内存消耗：2,023.87kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000459s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001430s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000557s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000865s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000276s ]
---------------------------------------------------------------
[ 2018-10-12T11:16:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ info ] qingrang.top/daily/admin/note/editnote/id/209.html [运行时间：0.056079s][吞吐率：17.83req/s] [内存消耗：2,072.18kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000526s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001341s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000569s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000976s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000377s ]
---------------------------------------------------------------
[ 2018-10-12T11:16:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.065455s][吞吐率：15.28req/s] [内存消耗：2,185.97kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '41787',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。

>为什么StringBuffer可以变长？

和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。

比如说new StringBuffer("the")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。

如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。

注： 19 这个数量，不同的JDK数量是不一样的
### StringBuilder
StringBuffer 是线程同步。
StringBuilder 是线程不同步。
建议使用 StringBuilder
#### 存储。
StringBuffer append():将指定数据作为参数添加到已有数据结尾处。
StringBuffer insert(index,数据):可以将数据插入到指定index位置。
### 删除。
StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。
StringBuffer deleteCharAt(index):删除指定位置的字符。
### 获取。
char charAt(int index) 
int indexOf(String str) 
int lastIndexOf(String str) 
int length() 
String substring(int start, int end)  
### 修改。
StringBuffer replace(start,end,string);
void setCharAt(int index, char ch) ;
### 反转。
StringBuffer reverse(); 
### 将缓冲区中指定数据存储到指定字符数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
## Date
|字符|含义|
|-|
|y| 代表年|
|M| 代表月|
|d| 代表日|
|H| 代表24进制的小时|
|h| 代表12进制的小时|
|m| 代表分钟|
|s| 代表秒|
|S| 代表毫秒|

```
//时间原点
Date date = new Date(5000);
System.out.println(date);	//Thu Jan 01 08:00:05 CST 1970

//当前时间
Date dateNow = new Date();
System.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018

//时间格式化
SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date d= new Date();
String str = sdf.format(d);
System.out.println(str);	//2018-10-12 11:10:23
```
## Calendar
```
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateDemo {
	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	 
    public static void main(String[] args) {
    	//采用单例模式获取日历对象Calendar.getInstance();
        Calendar c = Calendar.getInstance();
        
        //通过日历对象得到日期对象
        Date now = c.getTime();
        
        //===== 当前日期 =====
        System.out.println("当前日期：\\t" + format(c.getTime()));
 
        //===== 下个月的今天 =====
        //set方法，直接设置年/月/日
        c.setTime(now);
        //add方法，在原日期上增加年/月/日
        c.add(Calendar.MONTH, 1);
        System.out.println("下个月的今天:\\t" +format(c.getTime()));
 
        //===== 去年的今天 =====
        c.setTime(now);
        c.add(Calendar.YEAR, -1);
        System.out.println("去年的今天:\\t" +format(c.getTime()));
 
        //===== 上个月的第三天 =====
        c.setTime(now);
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DATE, 3);
        System.out.println("上个月的第三天:\\t" +format(c.getTime()));
 
    }
 
    private static String format(Date time) {
        return sdf.format(time);
    }
}
```
## 异常

















',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000522s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001265s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE - 基础',`content`='# Java SE - 基础\n[TOC]\n## Scanner\n```\npackage basics;\n\nimport java.util.Scanner;\n\npublic class ScannerDemo {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int num = scan.nextInt();\n		System.out.println(\"输入的整数是：\" + num);\n		\n		float f = scan.nextFloat();\n		System.out.println(\"输入的浮点数是：\" + f);\n		\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\n		String str = scan.nextLine(); //读取回车换行\n		String str2 = scan.nextLine(); //读取真正的字符串\n		System.out.println(\"str1是：\" + str);\n		System.out.println(\"输入的字符串是：\" + str2);\n	}\n}\n```\n## 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 内部类\n### 内部类的使用\n#### 内部类的访问规则\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\n2．外部类要访问内部类，必须建立内部类对象。\n\n```\npackage basics;\n\nimport basics.Outer.StaticInner;\n\npublic class OutIn{\n	public static void main(String[] args) {\n		//外部类访问内部类\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\n		Outer.Inner inner = new Outer().new Inner();\n		inner.fun();\n		\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\n		StaticInner inner2 = new Outer.StaticInner();\n		inner2.fun();\n	}\n}\n\nclass Outer {\n	private static int x = 1;\n	\n	/**\n	 * 非静态内部类\n	 */\n	class Inner{\n		int x = 2;\n		public void fun(){\n			int x = 3;\n			System.out.println(x);//内部类方法中的变量\n			System.out.println(this.x);//内部类中的变量\n			System.out.println(Outer.this.x);//外部类中的变量\n		}\n	}\n	\n	/**\n	 * 静态内部类\n	 */\n	static class StaticInner{\n		public void fun(){\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\n			System.out.println(\"此为静态内部类方法\" + x);\n		}\n	}\n}\n```\n#### 访问格式\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\n格式\n```\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\nOuter.Inner in = new Outer().new Inner();\n```\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\n\n比如：\n- private：将内部类在外部类中进行封装。\n- static:  内部类就具备static的特性。\n\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\n\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\n\nnew Outer.Inner().function();\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\n\nuter.Inner.function();\n\n注意：\n当内部类中定义了静态成员，该内部类必须是static的。\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\n\n### 匿名内部类\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\n\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\n\n#### 匿名内部类的格式\n**new 父类或者接口(){定义子类的内容};**\n```\nRunnable r = new Runnable(){};\n\n//多在 Android 中使用，例如监听方法的实现\nnew Demo(){	//匿名内部类\n	public void show(){\n		System.out.println(\"Inner show!\");\n	}\n}.show();\n```\n#### 例子\n```\npackage basics;\n\n/**\n * 接口\n */\ninterface Inter{\n	public void fun();\n}\n\n/**\n * 抽象方法\n */\nabstract class Inter2{\n	abstract public void fun();\n}\n\nclass Test{\n	//返回  Inter 对象\n	public static Inter fun2(){\n		return new Inter(){\n			public void fun(){\n				System.out.println(\"fun2 running!\");\n			}\n		};\n	}\n	\n	public static void fun3(){\n		//对象.方法();\n		new Inter2(){\n			public void fun(){\n				System.out.println(\"fun3 running!\");\n			}\n		}.fun();\n	}\n}\n\npublic class AnonymousInnerClass {\n	public static void main(String[] args) {\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\n		Test.fun2().fun();\n		\n		Test.fun3();\n	}\n}\n```\n## 默认方法\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\n```\npackage basics;\n\npublic interface Person {\n	public void eat();\n	\n	//默认方法，有实现体\n	default public void die(){\n		System.out.println(\"Game Over!\");\n	}\n}\n```\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\n\n>为什么会有默认方法\n\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\n\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\n\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\n\n```\npackage basics;\n\npublic class DefaultFunction implements Person{\n\n	@Override\n	public void eat() {\n		// TODO Auto-generated method stub\n	}\n	\n	public static void main(String[] args) {\n		//不需要做任何改动，直接得到这个默认方法\n		new DefaultFunction().die();\n	}\n}\n```\n## 装箱和拆箱\n### 封装类\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\n### 自动装箱和自动拆箱\n```\nint i = 5;\n\n//把一个基本类型的变量,转换为 Integer 对象\nInteger it = new Integer(i);\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\nInteger it2 = i;\n\n//把一个 Integer 对象，转换为一个基本类型的 int\nint i2 = it.intValue();\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\nint i3 = it;\n```\n### Number 类\n数字封装类有：Byte,Short,Integer,Long,Float,Double\n这些类都是抽象类 Number 的子类\n```\nint i = 5;\n\nInteger it = new Integer(i);\n//Integer 是 Number 的子类，所以打印 true\nSystem.out.println(it instanceof Number);\n```\n## Math\n```\nfloat f1 = 5.4f;\n\n//四舍五入\nSystem.out.println(Math.round(f1));\n\n//得到一个 0-1 之间的随机浮点数（取不到1）\nSystem.out.println(Math.random());\n\n//得到一个 0-10 之间的随机整数 （取不到10）\nSystem.out.println((int)( Math.random()*10));\n\n//大于指定数据的最小整数\nSystem.out.println(Math.ceil(f1));	//6.0\n\n//小于指定数据的最大整数\nSystem.out.println(Math.floor(f1));	//5.0\n\n//开方\nSystem.out.println(Math.sqrt(9));\n\n//次方（2的4次方）\nSystem.out.println(Math.pow(2,4));\n\n//π\nSystem.out.println(Math.PI);\n\n//自然常数\nSystem.out.println(Math.E);\n```\n## 格式控制\n### 换行符和回车符\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\n\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\n\n然而在不同的操作系统，换行符是不一样的\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\n- Linux系统里，每行结尾只有 “\\n”；\n- Mac系统里，每行结尾是只有 \"\\r\"。\n\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\n### \\\\t 空格对齐\n```\nSystem.out.println(\"使用空格无法达到对齐的效果\");\nSystem.out.println(\"abc def\");\nSystem.out.println(\"ab def\");\nSystem.out.println(\"a def\");\n\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\nSystem.out.println(\"abc\\tdef\");\nSystem.out.println(\"ab\\tdef\");\nSystem.out.println(\"a\\tdef\");\n```\n---\n~~使用空格无法达到对齐的效果\nabc def\nab def\na def\n使用 \\t 制表符可以达到对齐的效果\nabc	def\nab	def\na	def~~\n\n---\n## String\n### 概述\n字符串最大特点：一旦被初始化就不可以被改变。\n\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\n```\n//s1 在内存中有一个对象\nString s1 = \"abc\";\n//s2 在内存中有两个对象\nString s2 = new String(\"abc\");\nString s3 = \"abc\";\n\nSystem.out.println(s1==s2);//false\nSystem.out.println(s1==s3);//true\nSystem.out.println(s1.equals(s2));//true\n```\n\n### 常见方法\n#### 获取\n```\nString str = \"aabcbcc\";\n\n//字符串的长度\nSystem.out.println(str.length());\n\n//根据位置获取位置上某个字符\nSystem.out.println(str.charAt(1));\n\n//===== 根据字符获取该字符在字符串中位置 =====\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\n//如果没有找到，返回-1\nSystem.out.println(str.indexOf(\'b\',3));\n//可以用于对指定判断是否包含\nif(str.indexOf(\"aa\")!=-1)\n\n\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\nSystem.out.println(str.lastIndexOf(\'b\'));\n```\n#### 判断\n```\n//判断文件名称是否是Array单词开头。\nsop(str.startsWith(\"Array\"));\n//判断文件名称是否是.java的文件。\nsop(str.endsWith(\".java\"));\n//判断文件中是否包含Demo\nsop(str.contains(\"Demo\"));\n```\n- 字符串中是否包含某一个子串。\n`boolean contains(str):`\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\n所以，也可以用于对指定判断是否包含。\n`if(str.indexOf(\"aa\")!=-1)`\n\n而且该方法既可以判断，又可以获取出现的位置。\n\n- 字符中是否有内容。\n`boolean isEmpty(): 原理就是判断长度是否为0. `\n- 字符串是否是以指定内容开头。\n`boolean startsWith(str);`\n- 字符串是否是以指定内容结尾。\n`boolean endsWith(str);`\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\n`boolean equals(str);`\n- 判断内容是否相同，并忽略大小写。\n`boolean equalsIgnoreCase();`\n\n#### 转换\n```\npublic static void method_trans()\n	{\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\n		String s= new String(arr,1,3);//3是个数\n		sop(\"s=\"+s);\n		String s1 = \"zxcvbnm\";\n		char[] chs = s1.toCharArray();\n		for(int x=0; x<chs.length; x++)\n		{\n			sop(\"ch=\"+chs[x]);\n		}\n	}\n```\n- 将字符数组转成字符串。\n构造函数：\n```\nString(char[])\nString(char[],offset,count):将字符数组中的一部分转成字符串。\n```\n静态方法：\n```\nstatic String copyValueOf(char[]);\nstatic String copyValueOf(char[] data, int offset, int count) \nstatic String valueOf(char[]):\n```\n- 将字符串转成字符数组。**\n`char[] toCharArray():`\n\n- 将字节数组转成字符串。\n`String(byte[])`\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\n\n- 将字符串转成字节数组。\n`byte[]  getBytes():`\n\n- 将基本数据类型转成字符串。\n`static String valueOf(int)`\n`static String valueOf(double)`\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\n#### 替换\n`String replace(oldchar,newchar);`\n```\npublic static void method_replace()\n	{\n		String s = \"hello java\";\n	 //String s1 = s.replace(\'q\',\'n\');\n//如果要替换的字符不存在，返回的还是原串。\n		String s1 = s.replace(\"java\",\"world\");\n		sop(\"s=\"+s);\n		sop(\"s1=\"+s1);\n	}\n```\n#### 切割\n`String[] split(regex);`\n```\npublic static void  method_split()\n	{\n		String s = \"zhagnsa,lisi,wangwu\";\n\n		String[] arr  = s.split(\",\");\n\n		for(int x = 0; x<arr.length; x++)\n		{\n			sop(arr[x]);\n		}\n	}	\n```\n#### 子串（获取字符串中的一部分）\n`String substring(begin);`\n`String substring(begin,end);`\n```\npublic static void method_sub()\n	{\n		String s = \"abcdef\";\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\n		sop(s.substring(2,4)); \n 		//包含头，不包含尾。s.substring(0,s.length());\n	}\n```\n#### 转换，去除空格，比较\n- 将字符串转成大写或则小写。\n`String toUpperCase();`\n`String toLowerCase();`\n\n- 将字符串两端的多个空格去除。\n`String trim();`\n\n- 对两个字符串进行自然顺序的比较。\n`int compareTo(string);`\n### StringBuffer\n#### 特点\n1. 长度是可变化的。\n2. 可以直接操作多个数据类型。\n3. 最终会通过 toString 方法变成字符串。\n4. 是一个容器。\n\n>为什么StringBuffer可以变长？\n\n和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。\n\n比如说new StringBuffer(\"the\")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。\n\n如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。\n\n注： 19 这个数量，不同的JDK数量是不一样的\n### StringBuilder\nStringBuffer 是线程同步。\nStringBuilder 是线程不同步。\n建议使用 StringBuilder\n#### 存储。\nStringBuffer append():将指定数据作为参数添加到已有数据结尾处。\nStringBuffer insert(index,数据):可以将数据插入到指定index位置。\n### 删除。\nStringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。\nStringBuffer deleteCharAt(index):删除指定位置的字符。\n### 获取。\nchar charAt(int index) \nint indexOf(String str) \nint lastIndexOf(String str) \nint length() \nString substring(int start, int end)  \n### 修改。\nStringBuffer replace(start,end,string);\nvoid setCharAt(int index, char ch) ;\n### 反转。\nStringBuffer reverse(); \n### 将缓冲区中指定数据存储到指定字符数组中。\nvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\n## Date\n|字符|含义|\n|-|\n|y| 代表年|\n|M| 代表月|\n|d| 代表日|\n|H| 代表24进制的小时|\n|h| 代表12进制的小时|\n|m| 代表分钟|\n|s| 代表秒|\n|S| 代表毫秒|\n\n```\n//时间原点\nDate date = new Date(5000);\nSystem.out.println(date);	//Thu Jan 01 08:00:05 CST 1970\n\n//当前时间\nDate dateNow = new Date();\nSystem.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018\n\n//时间格式化\nSimpleDateFormat sdf =new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\nDate d= new Date();\nString str = sdf.format(d);\nSystem.out.println(str);	//2018-10-12 11:10:23\n```\n## Calendar\n```\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class DateDemo {\n	private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n	 \n    public static void main(String[] args) {\n    	//采用单例模式获取日历对象Calendar.getInstance();\n        Calendar c = Calendar.getInstance();\n        \n        //通过日历对象得到日期对象\n        Date now = c.getTime();\n        \n        //===== 当前日期 =====\n        System.out.println(\"当前日期：\\t\" + format(c.getTime()));\n \n        //===== 下个月的今天 =====\n        //set方法，直接设置年/月/日\n        c.setTime(now);\n        //add方法，在原日期上增加年/月/日\n        c.add(Calendar.MONTH, 1);\n        System.out.println(\"下个月的今天:\\t\" +format(c.getTime()));\n \n        //===== 去年的今天 =====\n        c.setTime(now);\n        c.add(Calendar.YEAR, -1);\n        System.out.println(\"去年的今天:\\t\" +format(c.getTime()));\n \n        //===== 上个月的第三天 =====\n        c.setTime(now);\n        c.add(Calendar.MONTH, -1);\n        c.set(Calendar.DATE, 3);\n        System.out.println(\"上个月的第三天:\\t\" +format(c.getTime()));\n \n    }\n \n    private static String format(Date time) {\n        return sdf.format(time);\n    }\n}\n```\n## 异常\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000881s ]
---------------------------------------------------------------
[ 2018-10-12T12:53:15+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/209.html [运行时间：0.067765s][吞吐率：14.76req/s] [内存消耗：2,201.35kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '45086',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'content' => '# Java SE - 基础
[TOC]
## Scanner
```
package basics;

import java.util.Scanner;

public class ScannerDemo {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		System.out.println("输入的整数是：" + num);
		
		float f = scan.nextFloat();
		System.out.println("输入的浮点数是：" + f);
		
//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:"\\r\\n",因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\\r\\n".
//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串
		String str = scan.nextLine(); //读取回车换行
		String str2 = scan.nextLine(); //读取真正的字符串
		System.out.println("str1是：" + str);
		System.out.println("输入的字符串是：" + str2);
	}
}
```
## 匿名对象
### 1.1 使用方式
```
package study;

/**
 * 匿名对象
 * Created by CaptainQR on 2018/9/26.
 */
public class AnonymousObject {
    public static void main(String[] args) {
        new Car().age = 5;
        new Car().color = "blue";
        new Car().show();   //每一次 new 都是一个新的对象
    }
}

class Car{
    String color = "red";
    int age = 4;
    public void show(){
        System.out.println("Car color = " + this.color + ", Car age = " + this.age);
    }
}
```

---
~~Car color = red, Car age = 4~~

---

1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。

1. 可以将匿名对象作为实际参数进行传递。
`Show(new Car());`

## JAVA 的默认修饰符
### 1.default
只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。

## 多态
### 1. 简单应用
```
package study;

/**
 * 多态
 * Created by CaptainQR on 2018/9/26.
 */
public class Polymorphism {
    public static void main(String[] args) {
        function(new Cat());
        function(new Dog());
    }

    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象
        a.eat();
//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员
    }
}

/**
 * 抽象类
 */
abstract class Animale{
    abstract public void eat();
}

/**
 * 猫类 实现 抽象的 动物类
 */
class Cat extends Animale{
    public void eat() {
        System.out.println("Cat eat finish");
    }

    public void catMouse(){
        System.out.println("Cat catch mouse");
    }
}

/**
 * 狗类 实现 抽象的 动物类
 */
class Dog extends Animale{
    public void eat() {
        System.out.println("Dog eat bone");
    }

    public void seeHome(){
        System.out.println("Dog see Home");
    }
}
```
---
~~Cat eat finish
Dog eat bone~~

---
### 2.向上转型和向下转型
```
package study;

/**
 * 向上转型和向下转型
 * Created by CaptainQR on 2018/9/26.
 */
public class Transformation {
    public static void main(String[] args) {
        Animale2 a = new Cat2();    //向上转型
        a.eat();    //此时不能调用子类的特有方法
        Cat2 c = (Cat2)a;   //向下转型
        c.catchMouse(); //此时才能调用子类的特有方法
    }
}

abstract class Animale2{
    abstract public void eat();
}

class Cat2 extends Animale2{
    public void eat(){
        System.out.println("Cat eat finish");
    }
    public void catchMouse(){
        System.out.println("Cat cat mouse");
    }
}
```
---
~~Cat eat finish
Cat cat mouse~~

---
**千万不能出现这样的操作：就是将父类对象转成子类类型**

```
Animale a = new Animale();
Cat c = (Cat)a;
```
## 内部类
### 内部类的使用
#### 内部类的访问规则
1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）
2．外部类要访问内部类，必须建立内部类对象。

```
package basics;

import basics.Outer.StaticInner;

public class OutIn{
	public static void main(String[] args) {
		//外部类访问内部类
		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()
		Outer.Inner inner = new Outer().new Inner();
		inner.fun();
		
		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()
		StaticInner inner2 = new Outer.StaticInner();
		inner2.fun();
	}
}

class Outer {
	private static int x = 1;
	
	/**
	 * 非静态内部类
	 */
	class Inner{
		int x = 2;
		public void fun(){
			int x = 3;
			System.out.println(x);//内部类方法中的变量
			System.out.println(this.x);//内部类中的变量
			System.out.println(Outer.this.x);//外部类中的变量
		}
	}
	
	/**
	 * 静态内部类
	 */
	static class StaticInner{
		public void fun(){
			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。
			System.out.println("此为静态内部类方法" + x);
		}
	}
}
```
#### 访问格式
1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。
格式
```
外部类名.内部类名  变量名 = 外部类对象.内部类对象;
Outer.Inner in = new Outer().new Inner();
```
2．当内部类在成员位置上，就可以被成员修饰符所修饰。

比如：
- private：将内部类在外部类中进行封装。
- static:  内部类就具备static的特性。

当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

>在外部其他类中，如何直接访问static内部类的非静态成员呢？

new Outer.Inner().function();
>在外部其他类中，如何直接访问static内部类的静态成员呢？

uter.Inner.function();

注意：
当内部类中定义了静态成员，该内部类必须是static的。
当外部类中的静态方法访问内部类时，内部类也必须是static的。

### 匿名内部类
匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。

#### 匿名内部类的格式
**new 父类或者接口(){定义子类的内容};**
```
Runnable r = new Runnable(){};

//多在 Android 中使用，例如监听方法的实现
new Demo(){	//匿名内部类
	public void show(){
		System.out.println("Inner show!");
	}
}.show();
```
#### 例子
```
package basics;

/**
 * 接口
 */
interface Inter{
	public void fun();
}

/**
 * 抽象方法
 */
abstract class Inter2{
	abstract public void fun();
}

class Test{
	//返回  Inter 对象
	public static Inter fun2(){
		return new Inter(){
			public void fun(){
				System.out.println("fun2 running!");
			}
		};
	}
	
	public static void fun3(){
		//对象.方法();
		new Inter2(){
			public void fun(){
				System.out.println("fun3 running!");
			}
		}.fun();
	}
}

public class AnonymousInnerClass {
	public static void main(String[] args) {
		//Test.fun2() 返回的是  Inter 对象，对象.方法
		Test.fun2().fun();
		
		Test.fun3();
	}
}
```
## 默认方法
默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。
```
package basics;

public interface Person {
	public void eat();
	
	//默认方法，有实现体
	default public void die(){
		System.out.println("Game Over!");
	}
}
```
Person 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default

>为什么会有默认方法

假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。

但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。

通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。

```
package basics;

public class DefaultFunction implements Person{

	@Override
	public void eat() {
		// TODO Auto-generated method stub
	}
	
	public static void main(String[] args) {
		//不需要做任何改动，直接得到这个默认方法
		new DefaultFunction().die();
	}
}
```
## 装箱和拆箱
### 封装类
所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。
### 自动装箱和自动拆箱
```
int i = 5;

//把一个基本类型的变量,转换为 Integer 对象
Integer it = new Integer(i);
//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱
Integer it2 = i;

//把一个 Integer 对象，转换为一个基本类型的 int
int i2 = it.intValue();
//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱
int i3 = it;
```
### Number 类
数字封装类有：Byte,Short,Integer,Long,Float,Double
这些类都是抽象类 Number 的子类
```
int i = 5;

Integer it = new Integer(i);
//Integer 是 Number 的子类，所以打印 true
System.out.println(it instanceof Number);
```
## Math
```
float f1 = 5.4f;

//四舍五入
System.out.println(Math.round(f1));

//得到一个 0-1 之间的随机浮点数（取不到1）
System.out.println(Math.random());

//得到一个 0-10 之间的随机整数 （取不到10）
System.out.println((int)( Math.random()*10));

//大于指定数据的最小整数
System.out.println(Math.ceil(f1));	//6.0

//小于指定数据的最大整数
System.out.println(Math.floor(f1));	//5.0

//开方
System.out.println(Math.sqrt(9));

//次方（2的4次方）
System.out.println(Math.pow(2,4));

//π
System.out.println(Math.PI);

//自然常数
System.out.println(Math.E);
```
## 格式控制
### 换行符和回车符
- 换行符就是另起一行 --- \'\\n\' 换行（newline）
- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）

在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。

然而在不同的操作系统，换行符是不一样的
- 在DOS和Windows中，每行结尾是 “\\r\\n”；
- Linux系统里，每行结尾只有 “\\n”；
- Mac系统里，每行结尾是只有 "\\r"。

为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。
### \\\\t 空格对齐
```
System.out.println("使用空格无法达到对齐的效果");
System.out.println("abc def");
System.out.println("ab def");
System.out.println("a def");

System.out.println("使用\\\\t制表符可以达到对齐的效果");
System.out.println("abc\\tdef");
System.out.println("ab\\tdef");
System.out.println("a\\tdef");
```
---
~~使用空格无法达到对齐的效果
abc def
ab def
a def
使用 \\t 制表符可以达到对齐的效果
abc	def
ab	def
a	def~~

---
## String
### 概述
字符串最大特点：一旦被初始化就不可以被改变。

String 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。
```
//s1 在内存中有一个对象
String s1 = "abc";
//s2 在内存中有两个对象
String s2 = new String("abc");
String s3 = "abc";

System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1.equals(s2));//true
```

### 常见方法
#### 获取
```
String str = "aabcbcc";

//字符串的长度
System.out.println(str.length());

//根据位置获取位置上某个字符
System.out.println(str.charAt(1));

//===== 根据字符获取该字符在字符串中位置 =====
//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。
//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。
//如果没有找到，返回-1
System.out.println(str.indexOf(\'b\',3));
//可以用于对指定判断是否包含
if(str.indexOf("aa")!=-1)


//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变
System.out.println(str.lastIndexOf(\'b\'));
```
#### 判断
```
//判断文件名称是否是Array单词开头。
sop(str.startsWith("Array"));
//判断文件名称是否是.java的文件。
sop(str.endsWith(".java"));
//判断文件中是否包含Demo
sop(str.contains("Demo"));
```
- 字符串中是否包含某一个子串。
`boolean contains(str):`
特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。
所以，也可以用于对指定判断是否包含。
`if(str.indexOf("aa")!=-1)`

而且该方法既可以判断，又可以获取出现的位置。

- 字符中是否有内容。
`boolean isEmpty(): 原理就是判断长度是否为0. `
- 字符串是否是以指定内容开头。
`boolean startsWith(str);`
- 字符串是否是以指定内容结尾。
`boolean endsWith(str);`
- 判断字符串内容是否相同。复写了Object类中的equals方法。
`boolean equals(str);`
- 判断内容是否相同，并忽略大小写。
`boolean equalsIgnoreCase();`

#### 转换
```
public static void method_trans()
	{
		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};
		String s= new String(arr,1,3);//3是个数
		sop("s="+s);
		String s1 = "zxcvbnm";
		char[] chs = s1.toCharArray();
		for(int x=0; x<chs.length; x++)
		{
			sop("ch="+chs[x]);
		}
	}
```
- 将字符数组转成字符串。
构造函数：
```
String(char[])
String(char[],offset,count):将字符数组中的一部分转成字符串。
```
静态方法：
```
static String copyValueOf(char[]);
static String copyValueOf(char[] data, int offset, int count) 
static String valueOf(char[]):
```
- 将字符串转成字符数组。**
`char[] toCharArray():`

- 将字节数组转成字符串。
`String(byte[])`
`String(byte[],offset,count):将字节数组中的一部分转成字符串。`

- 将字符串转成字节数组。
`byte[]  getBytes():`

- 将基本数据类型转成字符串。
`static String valueOf(int)`
`static String valueOf(double)`
特殊：字符串和字节数组在转换过程中，是可以指定编码表的。
#### 替换
`String replace(oldchar,newchar);`
```
public static void method_replace()
	{
		String s = "hello java";
	 //String s1 = s.replace(\'q\',\'n\');
//如果要替换的字符不存在，返回的还是原串。
		String s1 = s.replace("java","world");
		sop("s="+s);
		sop("s1="+s1);
	}
```
#### 切割
`String[] split(regex);`
```
public static void  method_split()
	{
		String s = "zhagnsa,lisi,wangwu";

		String[] arr  = s.split(",");

		for(int x = 0; x<arr.length; x++)
		{
			sop(arr[x]);
		}
	}	
```
#### 子串（获取字符串中的一部分）
`String substring(begin);`
`String substring(begin,end);`
```
public static void method_sub()
	{
		String s = "abcdef";
		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。
		sop(s.substring(2,4)); 
 		//包含头，不包含尾。s.substring(0,s.length());
	}
```
#### 转换，去除空格，比较
- 将字符串转成大写或则小写。
`String toUpperCase();`
`String toLowerCase();`

- 将字符串两端的多个空格去除。
`String trim();`

- 对两个字符串进行自然顺序的比较。
`int compareTo(string);`
### StringBuffer
#### 特点
1. 长度是可变化的。
2. 可以直接操作多个数据类型。
3. 最终会通过 toString 方法变成字符串。
4. 是一个容器。

>为什么StringBuffer可以变长？

和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。

比如说new StringBuffer("the")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。

如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。

注： 19 这个数量，不同的JDK数量是不一样的
### StringBuilder
StringBuffer 是线程同步。
StringBuilder 是线程不同步。
建议使用 StringBuilder
#### 存储。
StringBuffer append():将指定数据作为参数添加到已有数据结尾处。
StringBuffer insert(index,数据):可以将数据插入到指定index位置。
### 删除。
StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。
StringBuffer deleteCharAt(index):删除指定位置的字符。
### 获取。
char charAt(int index) 
int indexOf(String str) 
int lastIndexOf(String str) 
int length() 
String substring(int start, int end)  
### 修改。
StringBuffer replace(start,end,string);
void setCharAt(int index, char ch) ;
### 反转。
StringBuffer reverse(); 
### 将缓冲区中指定数据存储到指定字符数组中。
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
## Date
|字符|含义|
|-|
|y| 代表年|
|M| 代表月|
|d| 代表日|
|H| 代表24进制的小时|
|h| 代表12进制的小时|
|m| 代表分钟|
|s| 代表秒|
|S| 代表毫秒|

```
//时间原点
Date date = new Date(5000);
System.out.println(date);	//Thu Jan 01 08:00:05 CST 1970

//当前时间
Date dateNow = new Date();
System.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018

//时间格式化
SimpleDateFormat sdf =new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date d= new Date();
String str = sdf.format(d);
System.out.println(str);	//2018-10-12 11:10:23
```
## Calendar
```
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateDemo {
	private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	 
    public static void main(String[] args) {
    	//采用单例模式获取日历对象Calendar.getInstance();
        Calendar c = Calendar.getInstance();
        
        //通过日历对象得到日期对象
        Date now = c.getTime();
        
        //===== 当前日期 =====
        System.out.println("当前日期：\\t" + format(c.getTime()));
 
        //===== 下个月的今天 =====
        //set方法，直接设置年/月/日
        c.setTime(now);
        //add方法，在原日期上增加年/月/日
        c.add(Calendar.MONTH, 1);
        System.out.println("下个月的今天:\\t" +format(c.getTime()));
 
        //===== 去年的今天 =====
        c.setTime(now);
        c.add(Calendar.YEAR, -1);
        System.out.println("去年的今天:\\t" +format(c.getTime()));
 
        //===== 上个月的第三天 =====
        c.setTime(now);
        c.add(Calendar.MONTH, -1);
        c.set(Calendar.DATE, 3);
        System.out.println("上个月的第三天:\\t" +format(c.getTime()));
 
    }
 
    private static String format(Date time) {
        return sdf.format(time);
    }
}
```
## 异常

















',
  'groups' => 'Java',
  'showsel' => '1',
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000771s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001603s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000603s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000349s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000890s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000299s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE - 基础\r',`content`='# Java SE - 基础\r\n[TOC]\r\n## Scanner\r\n```\r\npackage basics;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class ScannerDemo {\r\n	public static void main(String[] args) {\r\n		Scanner scan = new Scanner(System.in);\r\n		int num = scan.nextInt();\r\n		System.out.println(\"输入的整数是：\" + num);\r\n		\r\n		float f = scan.nextFloat();\r\n		System.out.println(\"输入的浮点数是：\" + f);\r\n		\r\n//		如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:\"\\r\\n\",因为 nextInt 仅仅读取数字信息，而不会读取回车换行\"\\r\\n\".\r\n//		所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次 nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串\r\n		String str = scan.nextLine(); //读取回车换行\r\n		String str2 = scan.nextLine(); //读取真正的字符串\r\n		System.out.println(\"str1是：\" + str);\r\n		System.out.println(\"输入的字符串是：\" + str2);\r\n	}\r\n}\r\n```\r\n## 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 内部类\r\n### 内部类的使用\r\n#### 内部类的访问规则\r\n1．内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中默认持有了一个外部类的引用，（外部类名.this --> Outer.this.x ）\r\n2．外部类要访问内部类，必须建立内部类对象。\r\n\r\n```\r\npackage basics;\r\n\r\nimport basics.Outer.StaticInner;\r\n\r\npublic class OutIn{\r\n	public static void main(String[] args) {\r\n		//外部类访问内部类\r\n		//非静态内部类	外部类名.内部类名 变量名 = new 外部类().new 内部类()\r\n		Outer.Inner inner = new Outer().new Inner();\r\n		inner.fun();\r\n		\r\n		//静态内部类	内部类名 变量名 = new 外部类.静态内部类()\r\n		StaticInner inner2 = new Outer.StaticInner();\r\n		inner2.fun();\r\n	}\r\n}\r\n\r\nclass Outer {\r\n	private static int x = 1;\r\n	\r\n	/**\r\n	 * 非静态内部类\r\n	 */\r\n	class Inner{\r\n		int x = 2;\r\n		public void fun(){\r\n			int x = 3;\r\n			System.out.println(x);//内部类方法中的变量\r\n			System.out.println(this.x);//内部类中的变量\r\n			System.out.println(Outer.this.x);//外部类中的变量\r\n		}\r\n	}\r\n	\r\n	/**\r\n	 * 静态内部类\r\n	 */\r\n	static class StaticInner{\r\n		public void fun(){\r\n			//当内部类被 static 修饰后，只能直接访问外部类中的 static 成员,出现了访问局限。\r\n			System.out.println(\"此为静态内部类方法\" + x);\r\n		}\r\n	}\r\n}\r\n```\r\n#### 访问格式\r\n1．当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。可以直接建立内部类对象。\r\n格式\r\n```\r\n外部类名.内部类名  变量名 = 外部类对象.内部类对象;\r\nOuter.Inner in = new Outer().new Inner();\r\n```\r\n2．当内部类在成员位置上，就可以被成员修饰符所修饰。\r\n\r\n比如：\r\n- private：将内部类在外部类中进行封装。\r\n- static:  内部类就具备static的特性。\r\n\r\n当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。\r\n\r\n>在外部其他类中，如何直接访问static内部类的非静态成员呢？\r\n\r\nnew Outer.Inner().function();\r\n>在外部其他类中，如何直接访问static内部类的静态成员呢？\r\n\r\nuter.Inner.function();\r\n\r\n注意：\r\n当内部类中定义了静态成员，该内部类必须是static的。\r\n当外部类中的静态方法访问内部类时，内部类也必须是static的。\r\n\r\n### 匿名内部类\r\n匿名类指的是**在声明一个类的同时实例化它**，使代码更加简洁精练。通常情况下，要使用一个接口或者抽象类，都必须创建一个子类\r\n\r\n有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类。\r\n\r\n#### 匿名内部类的格式\r\n**new 父类或者接口(){定义子类的内容};**\r\n```\r\nRunnable r = new Runnable(){};\r\n\r\n//多在 Android 中使用，例如监听方法的实现\r\nnew Demo(){	//匿名内部类\r\n	public void show(){\r\n		System.out.println(\"Inner show!\");\r\n	}\r\n}.show();\r\n```\r\n#### 例子\r\n```\r\npackage basics;\r\n\r\n/**\r\n * 接口\r\n */\r\ninterface Inter{\r\n	public void fun();\r\n}\r\n\r\n/**\r\n * 抽象方法\r\n */\r\nabstract class Inter2{\r\n	abstract public void fun();\r\n}\r\n\r\nclass Test{\r\n	//返回  Inter 对象\r\n	public static Inter fun2(){\r\n		return new Inter(){\r\n			public void fun(){\r\n				System.out.println(\"fun2 running!\");\r\n			}\r\n		};\r\n	}\r\n	\r\n	public static void fun3(){\r\n		//对象.方法();\r\n		new Inter2(){\r\n			public void fun(){\r\n				System.out.println(\"fun3 running!\");\r\n			}\r\n		}.fun();\r\n	}\r\n}\r\n\r\npublic class AnonymousInnerClass {\r\n	public static void main(String[] args) {\r\n		//Test.fun2() 返回的是  Inter 对象，对象.方法\r\n		Test.fun2().fun();\r\n		\r\n		Test.fun3();\r\n	}\r\n}\r\n```\r\n## 默认方法\r\n默认方法是 JDK8 新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。\r\n```\r\npackage basics;\r\n\r\npublic interface Person {\r\n	public void eat();\r\n	\r\n	//默认方法，有实现体\r\n	default public void die(){\r\n		System.out.println(\"Game Over!\");\r\n	}\r\n}\r\n```\r\nPerson 这个接口，增加了一个默认方法 die，这个方法有实现体，并且被声明为了 default\r\n\r\n>为什么会有默认方法\r\n\r\n假设没有默认方法这种机制，那么如果要为 Person 增加一个新的方法 die ,那么所有实现了 Person 接口的类，都需要做改动。\r\n\r\n但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法。\r\n\r\n通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类。\r\n\r\n```\r\npackage basics;\r\n\r\npublic class DefaultFunction implements Person{\r\n\r\n	@Override\r\n	public void eat() {\r\n		// TODO Auto-generated method stub\r\n	}\r\n	\r\n	public static void main(String[] args) {\r\n		//不需要做任何改动，直接得到这个默认方法\r\n		new DefaultFunction().die();\r\n	}\r\n}\r\n```\r\n## 装箱和拆箱\r\n### 封装类\r\n所有的基本类型，都有对应的类类型，比如 int 对应的类是 Integer，这种类就叫做封装类。\r\n### 自动装箱和自动拆箱\r\n```\r\nint i = 5;\r\n\r\n//把一个基本类型的变量,转换为 Integer 对象\r\nInteger it = new Integer(i);\r\n//不需要调用构造方法，通过 = 符号自动把 基本类型 转换为 类类型 就叫装箱\r\nInteger it2 = i;\r\n\r\n//把一个 Integer 对象，转换为一个基本类型的 int\r\nint i2 = it.intValue();\r\n//不需要调用 Integer 的 intValue 方法，通过 = 就自动转换成 int 类型，就叫拆箱\r\nint i3 = it;\r\n```\r\n### Number 类\r\n数字封装类有：Byte,Short,Integer,Long,Float,Double\r\n这些类都是抽象类 Number 的子类\r\n```\r\nint i = 5;\r\n\r\nInteger it = new Integer(i);\r\n//Integer 是 Number 的子类，所以打印 true\r\nSystem.out.println(it instanceof Number);\r\n```\r\n## Math\r\n```\r\nfloat f1 = 5.4f;\r\n\r\n//四舍五入\r\nSystem.out.println(Math.round(f1));\r\n\r\n//得到一个 0-1 之间的随机浮点数（取不到1）\r\nSystem.out.println(Math.random());\r\n\r\n//得到一个 0-10 之间的随机整数 （取不到10）\r\nSystem.out.println((int)( Math.random()*10));\r\n\r\n//大于指定数据的最小整数\r\nSystem.out.println(Math.ceil(f1));	//6.0\r\n\r\n//小于指定数据的最大整数\r\nSystem.out.println(Math.floor(f1));	//5.0\r\n\r\n//开方\r\nSystem.out.println(Math.sqrt(9));\r\n\r\n//次方（2的4次方）\r\nSystem.out.println(Math.pow(2,4));\r\n\r\n//π\r\nSystem.out.println(Math.PI);\r\n\r\n//自然常数\r\nSystem.out.println(Math.E);\r\n```\r\n## 格式控制\r\n### 换行符和回车符\r\n- 换行符就是另起一行 --- \'\\n\' 换行（newline）\r\n- 回车符就是回到一行的开头 --- \'\\r\' 回车（return）\r\n\r\n在 eclipse 里敲一个回车，实际上是回车换行符，Java 是跨平台的编程语言，同样的代码，可以在不同的平台使用，比如 Windows,Linux,Mac。\r\n\r\n然而在不同的操作系统，换行符是不一样的\r\n- 在DOS和Windows中，每行结尾是 “\\r\\n”；\r\n- Linux系统里，每行结尾只有 “\\n”；\r\n- Mac系统里，每行结尾是只有 \"\\r\"。\r\n\r\n为了使得同一个 java 程序的换行符在所有的操作系统中都有一样的表现，使用 **%n**，就可以做到平台无关的换行。\r\n### \\\\t 空格对齐\r\n```\r\nSystem.out.println(\"使用空格无法达到对齐的效果\");\r\nSystem.out.println(\"abc def\");\r\nSystem.out.println(\"ab def\");\r\nSystem.out.println(\"a def\");\r\n\r\nSystem.out.println(\"使用\\\\t制表符可以达到对齐的效果\");\r\nSystem.out.println(\"abc\\tdef\");\r\nSystem.out.println(\"ab\\tdef\");\r\nSystem.out.println(\"a\\tdef\");\r\n```\r\n---\r\n~~使用空格无法达到对齐的效果\r\nabc def\r\nab def\r\na def\r\n使用 \\t 制表符可以达到对齐的效果\r\nabc	def\r\nab	def\r\na	def~~\r\n\r\n---\r\n## String\r\n### 概述\r\n字符串最大特点：一旦被初始化就不可以被改变。\r\n\r\nString 类复写了 Object 类中 equals 方法，该方法用于判断字符串是否相同。\r\n```\r\n//s1 在内存中有一个对象\r\nString s1 = \"abc\";\r\n//s2 在内存中有两个对象\r\nString s2 = new String(\"abc\");\r\nString s3 = \"abc\";\r\n\r\nSystem.out.println(s1==s2);//false\r\nSystem.out.println(s1==s3);//true\r\nSystem.out.println(s1.equals(s2));//true\r\n```\r\n\r\n### 常见方法\r\n#### 获取\r\n```\r\nString str = \"aabcbcc\";\r\n\r\n//字符串的长度\r\nSystem.out.println(str.length());\r\n\r\n//根据位置获取位置上某个字符\r\nSystem.out.println(str.charAt(1));\r\n\r\n//===== 根据字符获取该字符在字符串中位置 =====\r\n//int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。\r\n//int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。\r\n//如果没有找到，返回-1\r\nSystem.out.println(str.indexOf(\'b\',3));\r\n//可以用于对指定判断是否包含\r\nif(str.indexOf(\"aa\")!=-1)\r\n\r\n\r\n//int lastIndexOf(int ch) ：反向索引一个字符出现位置，角标并不会变\r\nSystem.out.println(str.lastIndexOf(\'b\'));\r\n```\r\n#### 判断\r\n```\r\n//判断文件名称是否是Array单词开头。\r\nsop(str.startsWith(\"Array\"));\r\n//判断文件名称是否是.java的文件。\r\nsop(str.endsWith(\".java\"));\r\n//判断文件中是否包含Demo\r\nsop(str.contains(\"Demo\"));\r\n```\r\n- 字符串中是否包含某一个子串。\r\n`boolean contains(str):`\r\n特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该字符串中不存在str。\r\n所以，也可以用于对指定判断是否包含。\r\n`if(str.indexOf(\"aa\")!=-1)`\r\n\r\n而且该方法既可以判断，又可以获取出现的位置。\r\n\r\n- 字符中是否有内容。\r\n`boolean isEmpty(): 原理就是判断长度是否为0. `\r\n- 字符串是否是以指定内容开头。\r\n`boolean startsWith(str);`\r\n- 字符串是否是以指定内容结尾。\r\n`boolean endsWith(str);`\r\n- 判断字符串内容是否相同。复写了Object类中的equals方法。\r\n`boolean equals(str);`\r\n- 判断内容是否相同，并忽略大小写。\r\n`boolean equalsIgnoreCase();`\r\n\r\n#### 转换\r\n```\r\npublic static void method_trans()\r\n	{\r\n		char[] arr = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'};\r\n		String s= new String(arr,1,3);//3是个数\r\n		sop(\"s=\"+s);\r\n		String s1 = \"zxcvbnm\";\r\n		char[] chs = s1.toCharArray();\r\n		for(int x=0; x<chs.length; x++)\r\n		{\r\n			sop(\"ch=\"+chs[x]);\r\n		}\r\n	}\r\n```\r\n- 将字符数组转成字符串。\r\n构造函数：\r\n```\r\nString(char[])\r\nString(char[],offset,count):将字符数组中的一部分转成字符串。\r\n```\r\n静态方法：\r\n```\r\nstatic String copyValueOf(char[]);\r\nstatic String copyValueOf(char[] data, int offset, int count) \r\nstatic String valueOf(char[]):\r\n```\r\n- 将字符串转成字符数组。**\r\n`char[] toCharArray():`\r\n\r\n- 将字节数组转成字符串。\r\n`String(byte[])`\r\n`String(byte[],offset,count):将字节数组中的一部分转成字符串。`\r\n\r\n- 将字符串转成字节数组。\r\n`byte[]  getBytes():`\r\n\r\n- 将基本数据类型转成字符串。\r\n`static String valueOf(int)`\r\n`static String valueOf(double)`\r\n特殊：字符串和字节数组在转换过程中，是可以指定编码表的。\r\n#### 替换\r\n`String replace(oldchar,newchar);`\r\n```\r\npublic static void method_replace()\r\n	{\r\n		String s = \"hello java\";\r\n	 //String s1 = s.replace(\'q\',\'n\');\r\n//如果要替换的字符不存在，返回的还是原串。\r\n		String s1 = s.replace(\"java\",\"world\");\r\n		sop(\"s=\"+s);\r\n		sop(\"s1=\"+s1);\r\n	}\r\n```\r\n#### 切割\r\n`String[] split(regex);`\r\n```\r\npublic static void  method_split()\r\n	{\r\n		String s = \"zhagnsa,lisi,wangwu\";\r\n\r\n		String[] arr  = s.split(\",\");\r\n\r\n		for(int x = 0; x<arr.length; x++)\r\n		{\r\n			sop(arr[x]);\r\n		}\r\n	}	\r\n```\r\n#### 子串（获取字符串中的一部分）\r\n`String substring(begin);`\r\n`String substring(begin,end);`\r\n```\r\npublic static void method_sub()\r\n	{\r\n		String s = \"abcdef\";\r\n		sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。\r\n		sop(s.substring(2,4)); \r\n 		//包含头，不包含尾。s.substring(0,s.length());\r\n	}\r\n```\r\n#### 转换，去除空格，比较\r\n- 将字符串转成大写或则小写。\r\n`String toUpperCase();`\r\n`String toLowerCase();`\r\n\r\n- 将字符串两端的多个空格去除。\r\n`String trim();`\r\n\r\n- 对两个字符串进行自然顺序的比较。\r\n`int compareTo(string);`\r\n### StringBuffer\r\n#### 特点\r\n1. 长度是可变化的。\r\n2. 可以直接操作多个数据类型。\r\n3. 最终会通过 toString 方法变成字符串。\r\n4. 是一个容器。\r\n\r\n>为什么StringBuffer可以变长？\r\n\r\n和String内部是一个字符数组一样，StringBuffer 也维护了一个字符数组。 但是，这个字符数组，留有冗余长度。\r\n\r\n比如说new StringBuffer(\"the\")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。\r\n\r\n如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。\r\n\r\n注： 19 这个数量，不同的JDK数量是不一样的\r\n### StringBuilder\r\nStringBuffer 是线程同步。\r\nStringBuilder 是线程不同步。\r\n建议使用 StringBuilder\r\n#### 存储。\r\nStringBuffer append():将指定数据作为参数添加到已有数据结尾处。\r\nStringBuffer insert(index,数据):可以将数据插入到指定index位置。\r\n### 删除。\r\nStringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。\r\nStringBuffer deleteCharAt(index):删除指定位置的字符。\r\n### 获取。\r\nchar charAt(int index) \r\nint indexOf(String str) \r\nint lastIndexOf(String str) \r\nint length() \r\nString substring(int start, int end)  \r\n### 修改。\r\nStringBuffer replace(start,end,string);\r\nvoid setCharAt(int index, char ch) ;\r\n### 反转。\r\nStringBuffer reverse(); \r\n### 将缓冲区中指定数据存储到指定字符数组中。\r\nvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\r\n## Date\r\n|字符|含义|\r\n|-|\r\n|y| 代表年|\r\n|M| 代表月|\r\n|d| 代表日|\r\n|H| 代表24进制的小时|\r\n|h| 代表12进制的小时|\r\n|m| 代表分钟|\r\n|s| 代表秒|\r\n|S| 代表毫秒|\r\n\r\n```\r\n//时间原点\r\nDate date = new Date(5000);\r\nSystem.out.println(date);	//Thu Jan 01 08:00:05 CST 1970\r\n\r\n//当前时间\r\nDate dateNow = new Date();\r\nSystem.out.println(dateNow);	//Fri Oct 12 11:10:23 CST 2018\r\n\r\n//时间格式化\r\nSimpleDateFormat sdf =new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\nDate d= new Date();\r\nString str = sdf.format(d);\r\nSystem.out.println(str);	//2018-10-12 11:10:23\r\n```\r\n## Calendar\r\n```\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\n\r\npublic class DateDemo {\r\n	private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n	 \r\n    public static void main(String[] args) {\r\n    	//采用单例模式获取日历对象Calendar.getInstance();\r\n        Calendar c = Calendar.getInstance();\r\n        \r\n        //通过日历对象得到日期对象\r\n        Date now = c.getTime();\r\n        \r\n        //===== 当前日期 =====\r\n        System.out.println(\"当前日期：\\t\" + format(c.getTime()));\r\n \r\n        //===== 下个月的今天 =====\r\n        //set方法，直接设置年/月/日\r\n        c.setTime(now);\r\n        //add方法，在原日期上增加年/月/日\r\n        c.add(Calendar.MONTH, 1);\r\n        System.out.println(\"下个月的今天:\\t\" +format(c.getTime()));\r\n \r\n        //===== 去年的今天 =====\r\n        c.setTime(now);\r\n        c.add(Calendar.YEAR, -1);\r\n        System.out.println(\"去年的今天:\\t\" +format(c.getTime()));\r\n \r\n        //===== 上个月的第三天 =====\r\n        c.setTime(now);\r\n        c.add(Calendar.MONTH, -1);\r\n        c.set(Calendar.DATE, 3);\r\n        System.out.println(\"上个月的第三天:\\t\" +format(c.getTime()));\r\n \r\n    }\r\n \r\n    private static String format(Date time) {\r\n        return sdf.format(time);\r\n    }\r\n}\r\n```\r\n## 异常\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.000967s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001521s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=6  WHERE  `groups` = 'Java' [ RunTime:0.000377s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000741s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=6  WHERE  `groups` = 'Java' [ RunTime:0.000316s ]
---------------------------------------------------------------
[ 2018-10-12T12:53:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ info ] qingrang.top/daily/admin/note/shownote/id/209.html [运行时间：0.066779s][吞吐率：14.97req/s] [内存消耗：2,024.33kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/209.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=i4poil6cbgur64gd9gq7d558p0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000588s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001285s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000688s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000928s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000278s ]
---------------------------------------------------------------
[ 2018-10-12T12:54:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.036878s][吞吐率：27.12req/s] [内存消耗：1,339.37kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T12:54:34+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.055656s][吞吐率：17.97req/s] [内存消耗：1,922.05kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000586s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001157s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000380s ]
---------------------------------------------------------------
[ 2018-10-12T12:54:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.076081s][吞吐率：13.14req/s] [内存消耗：2,225.09kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=0p1skfl2gvru5q3r5uql9nivb5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000556s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001504s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001718s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000541s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000957s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000297s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000561s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001148s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000466s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000370s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000809s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000242s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001244s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000711s ]
---------------------------------------------------------------
[ 2018-10-12T12:54:38+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.062736s][吞吐率：15.94req/s] [内存消耗：2,030.57kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=0p1skfl2gvru5q3r5uql9nivb5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000545s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002472s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000456s ]
---------------------------------------------------------------
[ 2018-10-12T12:55:49+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ info ] qingrang.top/daily/admin/note/addnote.html [运行时间：0.058881s][吞吐率：16.98req/s] [内存消耗：1,992.07kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'addnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '3240',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=0p1skfl2gvru5q3r5uql9nivb5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Basics',
  'content' => '# Windows 批处理
>自动改 IP

```
@echo off 
rem eth //eth 为网卡名称，可在网络连接中查询，如Win7为"本地链接"，Win10为"以太网" 
set eth="以太网"
rem ip //ip 为你想更改的IP 
set ip=192.168.1.101
rem wg //wg 为网关地址 
set wg=192.168.1.254
rem netmasks //netmasks 为子网掩码 
set netmasks=255.255.255.0

echo 正在将本机IP更改到: %ip% 
rem 
if %wg%==none netsh interface ip set address %eth% static %ip% %netmasks% %wg% > nul 
if not %wg%==none netsh interface ip set address %eth% static %ip% %netmasks% %wg% 1 > nul 
echo......................... 
echo 检查当前本机IP： 
ipconfig 
echo......................... 
echo 成功将本机IP更改为%ip%！ 
pause 
close 
```
',
  'test-editormd-html-code' => '<h1 id="h1-windows-"><a name="Windows 批处理" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Windows 批处理</h1><blockquote>
<p>自动改 IP</p>
</blockquote>
<pre><code>@echo off 
rem eth //eth 为网卡名称，可在网络连接中查询，如Win7为&quot;本地链接&quot;，Win10为&quot;以太网&quot; 
set eth=&quot;以太网&quot;
rem ip //ip 为你想更改的IP 
set ip=192.168.1.101
rem wg //wg 为网关地址 
set wg=192.168.1.254
rem netmasks //netmasks 为子网掩码 
set netmasks=255.255.255.0

echo 正在将本机IP更改到: %ip% 
rem 
if %wg%==none netsh interface ip set address %eth% static %ip% %netmasks% %wg% &gt; nul 
if not %wg%==none netsh interface ip set address %eth% static %ip% %netmasks% %wg% 1 &gt; nul 
echo......................... 
echo 检查当前本机IP： 
ipconfig 
echo......................... 
echo 成功将本机IP更改为%ip%！ 
pause 
close
</code></pre>',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->addNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000567s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001360s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000397s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001045s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('Windows 批处理\r' , '# Windows 批处理\r\n>自动改 IP\r\n\r\n```\r\n@echo off \r\nrem eth //eth 为网卡名称，可在网络连接中查询，如Win7为\"本地链接\"，Win10为\"以太网\" \r\nset eth=\"以太网\"\r\nrem ip //ip 为你想更改的IP \r\nset ip=192.168.1.101\r\nrem wg //wg 为网关地址 \r\nset wg=192.168.1.254\r\nrem netmasks //netmasks 为子网掩码 \r\nset netmasks=255.255.255.0\r\n\r\necho 正在将本机IP更改到: %ip% \r\nrem \r\nif %wg%==none netsh interface ip set address %eth% static %ip% %netmasks% %wg% > nul \r\nif not %wg%==none netsh interface ip set address %eth% static %ip% %netmasks% %wg% 1 > nul \r\necho......................... \r\necho 检查当前本机IP： \r\nipconfig \r\necho......................... \r\necho 成功将本机IP更改为%ip%！ \r\npause \r\nclose \r\n```\r\n' , 'Basics' , 2 , '2018-10-12') [ RunTime:0.000403s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000979s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=17  WHERE  `groups` = 'Basics' [ RunTime:0.000432s ]
---------------------------------------------------------------
[ 2018-10-12T12:55:51+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.068109s][吞吐率：14.68req/s] [内存消耗：2,225.84kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=0p1skfl2gvru5q3r5uql9nivb5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000539s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001170s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001316s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000533s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000943s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000509s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000907s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000269s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000455s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000276s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000397s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000738s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000243s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001069s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000625s ]
---------------------------------------------------------------
[ 2018-10-12T15:38:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.052883s][吞吐率：18.91req/s] [内存消耗：1,339.37kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T15:40:33+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.058266s][吞吐率：17.16req/s] [内存消耗：1,922.05kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001538s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002479s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000556s ]
---------------------------------------------------------------
[ 2018-10-12T15:40:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.091179s][吞吐率：10.97req/s] [内存消耗：2,225.84kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9',
  'cookie' => 'PHPSESSID=ncbo564iat22pc2imlv8opt2l3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000735s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001840s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003305s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000674s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001133s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000362s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000813s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001696s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000403s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000636s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000358s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000615s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001281s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000230s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001483s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000820s ]
---------------------------------------------------------------
[ 2018-10-12T18:59:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ info ] qingrang.top/daily/admin/note/shownote/id/210.html [运行时间：0.086957s][吞吐率：11.50req/s] [内存消耗：1,998.11kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7',
  'cookie' => 'PHPSESSID=ncbo564iat22pc2imlv8opt2l3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '210',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002001s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003705s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000890s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001632s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000520s ]
---------------------------------------------------------------
[ 2018-10-12T18:59:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ info ] qingrang.top/daily/admin/note/shownote/id/209.html [运行时间：0.062574s][吞吐率：15.98req/s] [内存消耗：2,024.18kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7',
  'cookie' => 'PHPSESSID=ncbo564iat22pc2imlv8opt2l3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '209',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000636s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001293s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000595s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000947s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000371s ]
---------------------------------------------------------------
[ 2018-10-12T20:23:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.058589s][吞吐率：17.07req/s] [内存消耗：2,030.43kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=ncbo564iat22pc2imlv8opt2l3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000671s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001387s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000409s ]
---------------------------------------------------------------
[ 2018-10-12T20:24:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.090763s][吞吐率：11.02req/s] [内存消耗：2,225.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=ncbo564iat22pc2imlv8opt2l3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000836s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001962s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001642s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000469s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001115s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000355s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000517s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000992s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000398s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000286s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000402s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001008s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000246s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000607s ]
---------------------------------------------------------------
[ 2018-10-12T20:45:37+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.078298s][吞吐率：12.77req/s] [内存消耗：2,226.01kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'PHPSESSID=ncbo564iat22pc2imlv8opt2l3',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000622s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001336s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001441s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000520s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000978s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000558s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000858s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000413s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000414s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000456s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000375s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000771s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000232s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001187s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000645s ]
---------------------------------------------------------------
[ 2018-10-12T21:58:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.049442s][吞吐率：20.23req/s] [内存消耗：1,339.47kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-10-12T22:56:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.061041s][吞吐率：16.38req/s] [内存消耗：1,339.47kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
