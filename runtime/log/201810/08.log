---------------------------------------------------------------
[ 2018-10-08T02:22:28+08:00 ] 74.120.168.12 66.249.75.207 GET /daily/admin/login/passdaily.html
[ error ] [8]未定义数组索引: password
---------------------------------------------------------------
[ 2018-10-08T02:23:04+08:00 ] 74.120.168.12 66.249.75.211 GET /daily/admin/login/passessay.html
[ error ] [8]未定义数组索引: password
---------------------------------------------------------------
[ 2018-10-08T13:10:14+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002915s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.004280s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000890s ]
---------------------------------------------------------------
[ 2018-10-08T13:10:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001561s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001985s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003524s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000798s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001430s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000440s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000681s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001466s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000445s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000617s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000408s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000502s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001216s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000351s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001598s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001082s ]
---------------------------------------------------------------
[ 2018-10-08T13:10:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001791s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001795s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000751s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001098s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
---------------------------------------------------------------
[ 2018-10-08T13:43:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001535s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001641s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000525s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001028s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000313s ]
---------------------------------------------------------------
[ 2018-10-08T13:44:46+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001321s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002248s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Code 自定义快捷键',`content`='# Code 自定义快捷键\n## Sublime Text 3\n```\n[\n	// 删除当前行\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\n	\n	// 与上行互换\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\n	// 与下行互换\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\n\n	// 向下复制行\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\n	\n	// 自动提示、补全\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\n	[\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\n	]\n	},\n\n	//移动光标到行首或行末\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\n	//移动光标到行首或行末并选择内容\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\n\n]\n```\n\n## 主流自定义\n### 行操作\n|含义|按键|\n|-|-|\n|删除行|Ctrl + d|\n|向下复制行|Ctrl + b|\n|移动行|Alt + Up/Down|\n|上开新行|Ctrl + up|\n|下开新行|Ctrl + down|\n### 注释\n>行注释\n\nCtrl + /\n\n>块注释\n\nCtrl + Shift + /\n### 其他常用操作\n>提示\n\nalt + /\n\n>添加getter、setter方法\n\nalt + insert\n\n>替换文本\n\nCtrl + R\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000935s ]
---------------------------------------------------------------
[ 2018-10-08T13:44:58+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001514s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002055s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Code 自定义快捷键',`content`='# Code 自定义快捷键\n## 主流自定义\n### 行操作\n|含义|按键|\n|-|-|\n|删除行|Ctrl + d|\n|向下复制行|Ctrl + b|\n|移动行|Alt + Up/Down|\n|上开新行|Ctrl + up|\n|下开新行|Ctrl + down|\n### 注释\n>行注释\n\nCtrl + /\n\n>块注释\n\nCtrl + Shift + /\n### 其他常用操作\n>提示\n\nalt + /\n\n>添加getter、setter方法\n\nalt + insert\n\n>替换文本\n\nCtrl + R\n\n## Sublime Text 3\n```\n[\n	// 删除当前行\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\n	\n	// 与上行互换\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\n	// 与下行互换\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\n\n	// 向下复制行\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\n	\n	// 自动提示、补全\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\n	[\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\n	]\n	},\n\n	//移动光标到行首或行末\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\n	//移动光标到行首或行末并选择内容\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\n\n]\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000851s ]
---------------------------------------------------------------
[ 2018-10-08T13:45:07+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001055s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001312s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000398s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000288s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000876s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000345s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000281s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=208,`p_id`=2,`title`='Code 自定义快捷键\r',`content`='# Code 自定义快捷键\r\n## 主流自定义\r\n### 行操作\r\n|含义|按键|\r\n|-|-|\r\n|删除行|Ctrl + d|\r\n|向下复制行|Ctrl + b|\r\n|移动行|Alt + Up/Down|\r\n|上开新行|Ctrl + up|\r\n|下开新行|Ctrl + down|\r\n### 注释\r\n>行注释\r\n\r\nCtrl + /\r\n\r\n>块注释\r\n\r\nCtrl + Shift + /\r\n### 其他常用操作\r\n>提示\r\n\r\nalt + /\r\n\r\n>添加getter、setter方法\r\n\r\nalt + insert\r\n\r\n>替换文本\r\n\r\nCtrl + R\r\n\r\n## Sublime Text 3\r\n```\r\n[\r\n	// 删除当前行\r\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\r\n	\r\n	// 与上行互换\r\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\r\n	// 与下行互换\r\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\r\n\r\n	// 向下复制行\r\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\r\n	\r\n	// 自动提示、补全\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\r\n	[\r\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\r\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\r\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\r\n	]\r\n	},\r\n\r\n	//移动光标到行首或行末\r\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\r\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\r\n	//移动光标到行首或行末并选择内容\r\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\r\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\r\n\r\n]\r\n```',`groups`='Basics',`is_show`=0  WHERE  `id` = 208 [ RunTime:0.000478s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000857s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000319s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000573s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000309s ]
---------------------------------------------------------------
[ 2018-10-08T13:45:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000900s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001306s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000496s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001111s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000283s ]
---------------------------------------------------------------
[ 2018-10-08T13:45:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001292s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000460s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000968s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000354s ]
---------------------------------------------------------------
[ 2018-10-08T13:45:26+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001050s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001233s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000417s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000318s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000835s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000285s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000286s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=208,`p_id`=2,`title`='Code 自定义快捷键\r',`content`='# Code 自定义快捷键\r\n[TOC]\r\n## 主流自定义\r\n### 行操作\r\n|含义|按键|\r\n|-|-|\r\n|删除行|Ctrl + d|\r\n|向下复制行|Ctrl + b|\r\n|移动行|Alt + Up/Down|\r\n|上开新行|Ctrl + up|\r\n|下开新行|Ctrl + down|\r\n### 注释\r\n>行注释\r\n\r\nCtrl + /\r\n\r\n>块注释\r\n\r\nCtrl + Shift + /\r\n### 其他常用操作\r\n>提示\r\n\r\nalt + /\r\n\r\n>添加getter、setter方法\r\n\r\nalt + insert\r\n\r\n>替换文本\r\n\r\nCtrl + R\r\n\r\n## Sublime Text 3\r\n```\r\n[\r\n	// 删除当前行\r\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\r\n	\r\n	// 与上行互换\r\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\r\n	// 与下行互换\r\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\r\n\r\n	// 向下复制行\r\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\r\n	\r\n	// 自动提示、补全\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\r\n	[\r\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\r\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\r\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\r\n	]\r\n	},\r\n\r\n	//移动光标到行首或行末\r\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\r\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\r\n	//移动光标到行首或行末并选择内容\r\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\r\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\r\n\r\n]\r\n```',`groups`='Basics',`is_show`=1  WHERE  `id` = 208 [ RunTime:0.000491s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000866s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000325s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000588s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000326s ]
---------------------------------------------------------------
[ 2018-10-08T13:45:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000964s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001193s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000483s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000960s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000309s ]
---------------------------------------------------------------
[ 2018-10-08T13:45:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001438s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002597s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001955s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000691s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001515s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000433s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000528s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001163s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000326s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000437s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000892s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000253s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001158s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000581s ]
---------------------------------------------------------------
[ 2018-10-08T13:48:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001169s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001478s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000495s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000923s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000325s ]
---------------------------------------------------------------
[ 2018-10-08T13:50:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000982s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001554s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000475s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000849s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000457s ]
---------------------------------------------------------------
[ 2018-10-08T13:51:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001191s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001446s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000470s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000972s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000324s ]
---------------------------------------------------------------
[ 2018-10-08T13:52:00+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000957s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001359s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000574s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000321s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000879s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000321s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000409s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=208,`p_id`=2,`title`='Code 自定义快捷键\r',`content`='# Code 自定义快捷键\r\n[TOC]\r\n## 主流自定义\r\n### 行操作\r\n|含义|按键|\r\n|-|-|\r\n|删除行|Ctrl + d|\r\n|向下复制行|Ctrl + b|\r\n|移动行|Alt + Up/Down|\r\n|上开新行|Ctrl + up|\r\n|下开新行|Ctrl + down|\r\n### 注释\r\n>行注释\r\n\r\nCtrl + /\r\n\r\n>块注释\r\n\r\nCtrl + Shift + /\r\n### 其他常用操作\r\n>提示\r\n\r\nalt + /\r\n\r\n>添加getter、setter方法\r\n\r\nalt + insert\r\n\r\n>替换文本\r\n\r\nCtrl + R\r\n\r\n## Sublime Text 3\r\nhttps://blog.csdn.net/u010994304/article/details/50866634\r\n```\r\n[\r\n	// 删除当前行\r\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\r\n	\r\n	// 与上行互换\r\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\r\n	// 与下行互换\r\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\r\n\r\n	// 向下复制行\r\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\r\n	\r\n	// 自动提示、补全\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\r\n	[\r\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\r\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\r\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\r\n	]\r\n	},\r\n\r\n	//移动光标到行首或行末\r\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\r\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\r\n	//移动光标到行首或行末并选择内容\r\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\r\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\r\n\r\n]\r\n```',`groups`='Basics',`is_show`=1  WHERE  `id` = 208 [ RunTime:0.000616s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000890s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000339s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000589s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000521s ]
---------------------------------------------------------------
[ 2018-10-08T13:52:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001307s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001670s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000424s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000943s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000322s ]
---------------------------------------------------------------
[ 2018-10-08T13:53:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.003424s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002987s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.001043s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002630s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000549s ]
---------------------------------------------------------------
[ 2018-10-08T13:54:20+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001096s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001664s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000402s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000491s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001262s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000374s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000381s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=208,`p_id`=2,`title`='Code 自定义快捷键\r',`content`='# Code 自定义快捷键\r\n[TOC]\r\n## 主流自定义\r\n### 行操作\r\n|含义|按键|\r\n|-|-|\r\n|删除行|Ctrl + d|\r\n|向下复制行|Ctrl + b|\r\n|移动行|Alt + Up/Down|\r\n|上开新行|Ctrl + up|\r\n|下开新行|Ctrl + down|\r\n### 注释\r\n>行注释\r\n\r\nCtrl + /\r\n\r\n>块注释\r\n\r\nCtrl + Shift + /\r\n### 其他常用操作\r\n>提示\r\n\r\nalt + /\r\n\r\n>添加getter、setter方法\r\n\r\nalt + insert\r\n\r\n>替换文本\r\n\r\nCtrl + R\r\n\r\n## Sublime Text 3\r\nhttps://blog.csdn.net/u010994304/article/details/50866634\r\n\r\n// Ctrl+Enter\r\n// 插入行后\r\n\r\n// Ctrl+Shift Enter\r\n// 插入行前\r\n\r\n// Shift+Tab\r\n// 去除缩进\r\n\r\n// Tab\r\n// 缩进\r\n\r\n// Ctrl+KK\r\n// 从光标处删除至行尾\r\n```\r\n[\r\n	// 删除当前行\r\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\r\n	\r\n	// 与上行互换\r\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\r\n	// 与下行互换\r\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\r\n\r\n	// 向下复制行\r\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\r\n	\r\n	// 自动提示、补全\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\r\n	[\r\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\r\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\r\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\r\n	]\r\n	},\r\n\r\n	//移动光标到行首或行末\r\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\r\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\r\n	//移动光标到行首或行末并选择内容\r\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\r\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\r\n\r\n]\r\n```',`groups`='Basics',`is_show`=1  WHERE  `id` = 208 [ RunTime:0.000598s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.001370s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000417s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000854s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=15  WHERE  `groups` = 'Basics' [ RunTime:0.000434s ]
---------------------------------------------------------------
[ 2018-10-08T13:54:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/208.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001020s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001222s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000423s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000933s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000326s ]
---------------------------------------------------------------
[ 2018-10-08T14:05:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/158.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000948s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 158 LIMIT 1 [ RunTime:0.000363s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000934s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000362s ]
---------------------------------------------------------------
[ 2018-10-08T14:05:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/165.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001001s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001182s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 165 LIMIT 1 [ RunTime:0.000411s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000841s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
---------------------------------------------------------------
[ 2018-10-08T14:05:42+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/158.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001431s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001968s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 158 LIMIT 1 [ RunTime:0.000578s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 158 LIMIT 1 [ RunTime:0.000471s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001500s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000481s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000509s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000401s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=158,`p_id`=1,`title`='Daily 更新记录与使用指南\r',`content`='# Daily 更新记录与使用指南\r\n>定位地址替换\r\n\r\nStringUtils -> replaceLocation(String str)\r\n\r\n>更改桌面控件 大小\r\n\r\nxml -> to_do_list_widget_info.xml\r\n\r\n>手动更改服务器IP（X）\r\n\r\n本地文件操作',`groups`='Default',`is_show`=0  WHERE  `id` = 158 [ RunTime:0.000714s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001089s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000519s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000960s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Default' [ RunTime:0.000542s ]
---------------------------------------------------------------
[ 2018-10-08T14:05:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/158.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001038s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001201s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 158 LIMIT 1 [ RunTime:0.000393s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000885s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000295s ]
---------------------------------------------------------------
[ 2018-10-08T14:06:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001077s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001581s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001221s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000446s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000946s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000358s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000508s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001020s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000276s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000422s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000286s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000578s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000826s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000305s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001086s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000590s ]
---------------------------------------------------------------
[ 2018-10-08T14:06:48+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001028s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001231s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Linux' ORDER BY date desc [ RunTime:0.000954s ]
---------------------------------------------------------------
[ 2018-10-08T14:06:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001108s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001552s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001348s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000652s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001142s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000390s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000460s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001019s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000301s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000454s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000315s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000441s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001046s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000277s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001208s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000624s ]
---------------------------------------------------------------
[ 2018-10-08T14:07:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001045s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001186s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000347s ]
---------------------------------------------------------------
[ 2018-10-08T14:07:40+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001015s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001331s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000341s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000354s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.000951s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('Linux 编程' , '# Linux 编程' , 'Linux' , 2 , '2018-10-08') [ RunTime:0.000544s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000760s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=10  WHERE  `groups` = 'Linux' [ RunTime:0.000535s ]
---------------------------------------------------------------
[ 2018-10-08T14:07:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.000873s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001159s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001142s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000467s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000969s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000318s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.054781s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001015s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000412s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000510s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000313s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000352s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000700s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000240s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000999s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000637s ]
---------------------------------------------------------------
[ 2018-10-08T14:49:12+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001694s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002490s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000762s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001371s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000424s ]
---------------------------------------------------------------
[ 2018-10-08T14:49:37+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001177s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001420s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 1. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 2. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 3．多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 4．内部类\n## 9. IO\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001146s ]
---------------------------------------------------------------
[ 2018-10-08T14:49:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001144s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001809s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000504s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000958s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000443s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000952s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000314s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000414s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000277s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000388s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000900s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000235s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001431s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000634s ]
---------------------------------------------------------------
[ 2018-10-08T14:49:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001143s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001319s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000552s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000872s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000284s ]
---------------------------------------------------------------
[ 2018-10-08T14:50:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001242s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001421s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000516s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000979s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000307s ]
---------------------------------------------------------------
[ 2018-10-08T14:51:06+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001236s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001396s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 1. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 2. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 3．多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 4. 内部类\n## 9. IO\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000985s ]
---------------------------------------------------------------
[ 2018-10-08T14:54:44+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001180s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001134s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000377s ]
---------------------------------------------------------------
[ 2018-10-08T14:54:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001272s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001631s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001394s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000458s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001057s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000321s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000397s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000997s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000268s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000379s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000758s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000215s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000982s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000707s ]
---------------------------------------------------------------
[ 2018-10-08T14:56:16+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001962s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001337s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000345s ]
---------------------------------------------------------------
[ 2018-10-08T14:56:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001778s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001802s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001769s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000714s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001554s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000465s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000616s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001473s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000453s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000622s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000433s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000568s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001058s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000330s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001665s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001013s ]
---------------------------------------------------------------
[ 2018-10-08T15:02:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001048s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001240s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001008s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000504s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000870s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000385s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000644s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001107s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000326s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000587s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000594s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000485s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000775s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000254s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001070s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000647s ]
---------------------------------------------------------------
[ 2018-10-08T15:02:14+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.000955s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001656s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001252s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000477s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000946s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000316s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000399s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000931s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000277s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000413s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000296s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000399s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000673s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000224s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001010s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000641s ]
---------------------------------------------------------------
[ 2018-10-08T15:02:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.001014s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001409s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001327s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000488s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001032s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000299s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000416s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001198s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000286s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000426s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000323s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000389s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000727s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000232s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001138s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000788s ]
---------------------------------------------------------------
[ 2018-10-08T15:02:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001009s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001317s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000518s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001016s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000290s ]
---------------------------------------------------------------
[ 2018-10-08T15:02:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000965s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002304s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000455s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000886s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000351s ]
---------------------------------------------------------------
[ 2018-10-08T15:15:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001062s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001702s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000404s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000976s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
---------------------------------------------------------------
[ 2018-10-08T15:18:33+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001474s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001826s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000521s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001259s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000418s ]
---------------------------------------------------------------
[ 2018-10-08T15:18:51+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001484s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001737s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000527s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001256s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000415s ]
---------------------------------------------------------------
[ 2018-10-08T15:18:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/210.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000959s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001839s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.000477s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000866s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-10-08T15:20:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002112s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002788s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000832s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000954s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000343s ]
---------------------------------------------------------------
[ 2018-10-08T15:21:12+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001449s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001640s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000635s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000965s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000459s ]
---------------------------------------------------------------
[ 2018-10-08T15:23:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001092s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001756s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000495s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000994s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000314s ]
---------------------------------------------------------------
[ 2018-10-08T15:23:48+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000956s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001481s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000437s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000885s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000295s ]
---------------------------------------------------------------
[ 2018-10-08T15:23:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001482s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002198s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000610s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001563s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000459s ]
---------------------------------------------------------------
[ 2018-10-08T15:27:44+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001039s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001345s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000490s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000828s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000291s ]
---------------------------------------------------------------
[ 2018-10-08T15:28:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001043s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001285s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000409s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000953s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000309s ]
---------------------------------------------------------------
[ 2018-10-08T15:30:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001019s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001262s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000481s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000879s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000329s ]
---------------------------------------------------------------
[ 2018-10-08T15:31:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001065s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001308s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000422s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001040s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000372s ]
---------------------------------------------------------------
[ 2018-10-08T15:31:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001386s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001353s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000437s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000954s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000283s ]
---------------------------------------------------------------
[ 2018-10-08T15:34:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001432s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001779s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000590s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001287s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000412s ]
---------------------------------------------------------------
[ 2018-10-08T15:35:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000945s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001206s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000442s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000848s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000321s ]
---------------------------------------------------------------
[ 2018-10-08T15:35:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001427s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002133s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000614s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001473s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000432s ]
---------------------------------------------------------------
[ 2018-10-08T15:36:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001249s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001847s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000563s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001006s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000313s ]
---------------------------------------------------------------
[ 2018-10-08T15:36:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001453s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002065s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000858s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001310s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000407s ]
---------------------------------------------------------------
[ 2018-10-08T15:36:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001021s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001234s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000474s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000870s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000370s ]
---------------------------------------------------------------
[ 2018-10-08T15:38:20+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001354s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001454s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000443s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000916s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000322s ]
---------------------------------------------------------------
[ 2018-10-08T15:38:22+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000919s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001193s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000449s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000919s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000285s ]
---------------------------------------------------------------
[ 2018-10-08T15:39:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001040s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002031s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000430s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000831s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000329s ]
---------------------------------------------------------------
[ 2018-10-08T15:39:49+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000954s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001395s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001007s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000426s ]
---------------------------------------------------------------
[ 2018-10-08T15:48:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000952s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001375s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000477s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000882s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000286s ]
---------------------------------------------------------------
[ 2018-10-08T15:53:47+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001020s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001443s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000411s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000838s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000278s ]
---------------------------------------------------------------
[ 2018-10-08T15:53:52+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/211.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000989s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001205s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 211 LIMIT 1 [ RunTime:0.000424s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000915s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000318s ]
---------------------------------------------------------------
[ 2018-10-08T15:56:49+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001193s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001783s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000572s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001347s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000427s ]
---------------------------------------------------------------
[ 2018-10-08T15:59:22+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001167s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001332s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. IO\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001120s ]
---------------------------------------------------------------
[ 2018-10-08T15:59:38+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001009s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001378s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000539s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001112s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000389s ]
---------------------------------------------------------------
[ 2018-10-08T15:59:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001118s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001277s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000508s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001288s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
---------------------------------------------------------------
[ 2018-10-08T16:25:26+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001180s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001336s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO\n### 文件\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000950s ]
---------------------------------------------------------------
[ 2018-10-08T16:27:04+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001421s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001748s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n---\n\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001231s ]
---------------------------------------------------------------
[ 2018-10-08T16:27:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001059s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001266s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000520s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001013s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000330s ]
---------------------------------------------------------------
[ 2018-10-08T16:27:27+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001102s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001406s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000826s ]
---------------------------------------------------------------
[ 2018-10-08T16:28:00+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001144s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001294s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000849s ]
---------------------------------------------------------------
[ 2018-10-08T16:38:38+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001327s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001416s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000908s ]
---------------------------------------------------------------
[ 2018-10-08T16:38:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001109s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001173s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000521s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001085s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000405s ]
---------------------------------------------------------------
[ 2018-10-08T16:39:08+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001429s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001727s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001216s ]
---------------------------------------------------------------
[ 2018-10-08T16:56:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001107s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001526s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000675s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000942s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000317s ]
---------------------------------------------------------------
[ 2018-10-08T16:58:30+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001158s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001272s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n>字符流和字节流\n\n字节流两个基类：\nInputStream\nOutputStream\n\n字符流两个基类：\nReader\nWriter\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001336s ]
---------------------------------------------------------------
[ 2018-10-08T17:05:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001125s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001667s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001030s ]
---------------------------------------------------------------
[ 2018-10-08T17:07:44+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001437s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001720s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 1. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001410s ]
---------------------------------------------------------------
[ 2018-10-08T17:10:32+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001691s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001255s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n### 4. 字符流\n#### 1.1 FileWriter\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001214s ]
---------------------------------------------------------------
[ 2018-10-08T17:30:45+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001196s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001322s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n#### 1.2 IO 异常处理\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * IO异常处理\n * Created by CaptainQR on 2018/10/7.\n */\npublic class IOExceptionDemo {\n    public static void main(String[] args){\n        //在外面建立引用\n        FileWriter fw = null;\n        try{\n            //在里面初始化\n            fw = new FileWriter(\"Demo2.txt\");\n            fw.write(\"abc\");\n        }catch (IOException e){\n            System.out.println(\"catch\" + e.toString());\n        }finally {\n            try {\n                /*\n                * 防止出现空指针异常，需判断一下，\n                * 并单独为 fw.close() try{}catch{}\n                * */\n                if (fw!=null){\n                    fw.close();\n                }\n            }catch (IOException e){\n                System.out.println(e.toString());\n            }\n        }\n    }\n}\n```\n#### 1.3 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### 1.4 FileReader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001100s ]
---------------------------------------------------------------
[ 2018-10-08T17:30:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001283s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000789s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001055s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000286s ]
---------------------------------------------------------------
[ 2018-10-08T17:32:40+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001428s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001465s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n#### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### 1.5 Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001124s ]
---------------------------------------------------------------
[ 2018-10-08T17:33:17+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001004s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001365s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n#### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001024s ]
---------------------------------------------------------------
[ 2018-10-08T17:33:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.000909s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001392s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000643s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000954s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000361s ]
---------------------------------------------------------------
[ 2018-10-08T17:33:59+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001055s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001291s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000914s ]
---------------------------------------------------------------
[ 2018-10-08T17:34:09+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001310s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001517s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001093s ]
---------------------------------------------------------------
[ 2018-10-08T18:40:28+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.002437s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002706s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001543s ]
---------------------------------------------------------------
[ 2018-10-08T18:53:04+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001843s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002150s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001616s ]
---------------------------------------------------------------
[ 2018-10-08T18:53:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001171s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001384s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000989s ]
---------------------------------------------------------------
[ 2018-10-08T19:20:47+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001340s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001468s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001218s ]
---------------------------------------------------------------
[ 2018-10-08T19:23:36+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001753s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001802s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001332s ]
---------------------------------------------------------------
[ 2018-10-08T19:23:40+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001167s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001242s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000619s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000996s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000357s ]
---------------------------------------------------------------
[ 2018-10-08T19:30:21+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001414s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001696s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Java SE',`content`='# Java SE\n[TOC]\n## 一. 匿名对象\n### 1.1 使用方式\n```\npackage study;\n\n/**\n * 匿名对象\n * Created by CaptainQR on 2018/9/26.\n */\npublic class AnonymousObject {\n    public static void main(String[] args) {\n        new Car().age = 5;\n        new Car().color = \"blue\";\n        new Car().show();   //每一次 new 都是一个新的对象\n    }\n}\n\nclass Car{\n    String color = \"red\";\n    int age = 4;\n    public void show(){\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\n    }\n}\n```\n\n---\n~~Car color = red, Car age = 4~~\n\n---\n\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\n\n1. 可以将匿名对象作为实际参数进行传递。\n`Show(new Car());`\n\n## 二. JAVA 的默认修饰符\n### 1.default\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\n\n## 3. 单例设计模式\n### 1.意义（想要保证对象唯一）\neg: 配置文件的使用。\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\n### 2.使用方法\n先按常规方法对事物进行描述，最后再加上这三步内即可:\n1.将构造函数私有化。（其他类中无法再创建该类对象）\n2.在类中创建一个本类对象。（静态）\n3.提供一个方法可以获取到该对象。（静态）\n\n>Ps: 为什么要使用静态？\n\n在主函数中需要调用方法（3），方法的调用有两种：\n1.通过对象调用\n2.通过类名调用\n\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\n\n### 3.例子（饿汉式）\n```\npackage study;\n\n/**\n * 单例设计模式\n * Created by CaptainQR on 2018/9/26.\n */\npublic class SingletonPattern {\n    public static void main(String[] args) {\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\n        Student stu2 = Student.getStudent();\n        stu1.setAge(18);\n        System.out.println(\"stu1 age = \" + stu1.getAge());\n        System.out.println(\"stu2 age = \" + stu2.getAge());\n    }\n}\n\nclass Student{\n    private int age;\n    private Student(){};    //1. 私有构造函数\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\n        return stu;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n---\n~~stu1 age = 18\nstu2 age = 18~~\n\n---\n## 三. 多态\n### 1. 简单应用\n```\npackage study;\n\n/**\n * 多态\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Polymorphism {\n    public static void main(String[] args) {\n        function(new Cat());\n        function(new Dog());\n    }\n\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\n        a.eat();\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\n    }\n}\n\n/**\n * 抽象类\n */\nabstract class Animale{\n    abstract public void eat();\n}\n\n/**\n * 猫类 实现 抽象的 动物类\n */\nclass Cat extends Animale{\n    public void eat() {\n        System.out.println(\"Cat eat finish\");\n    }\n\n    public void catMouse(){\n        System.out.println(\"Cat catch mouse\");\n    }\n}\n\n/**\n * 狗类 实现 抽象的 动物类\n */\nclass Dog extends Animale{\n    public void eat() {\n        System.out.println(\"Dog eat bone\");\n    }\n\n    public void seeHome(){\n        System.out.println(\"Dog see Home\");\n    }\n}\n```\n---\n~~Cat eat finish\nDog eat bone~~\n\n---\n### 2.向上转型和向下转型\n```\npackage study;\n\n/**\n * 向上转型和向下转型\n * Created by CaptainQR on 2018/9/26.\n */\npublic class Transformation {\n    public static void main(String[] args) {\n        Animale2 a = new Cat2();    //向上转型\n        a.eat();    //此时不能调用子类的特有方法\n        Cat2 c = (Cat2)a;   //向下转型\n        c.catchMouse(); //此时才能调用子类的特有方法\n    }\n}\n\nabstract class Animale2{\n    abstract public void eat();\n}\n\nclass Cat2 extends Animale2{\n    public void eat(){\n        System.out.println(\"Cat eat finish\");\n    }\n    public void catchMouse(){\n        System.out.println(\"Cat cat mouse\");\n    }\n}\n```\n---\n~~Cat eat finish\nCat cat mouse~~\n\n---\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\n\n```\nAnimale a = new Animale();\nCat c = (Cat)a;\n```\n## 四. 内部类\n## 九. 文件和 IO流\n### 1. 文件\n#### File\n```\npackage io;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class FileDemo {\n    public static void main(String[] args) {\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\n        File file = new File(\".\");\n        // 直接获取文件名，输出\".\"\n        System.out.println(file.getName());\n        // 获取相对路径的父路径可能出错，下面代码输出 null\n        System.out.println(file.getParent());\n        // 获取绝对路径\n        System.out.println(file.getAbsoluteFile());\n        // 获取上一级路径\n        System.out.println(file.getAbsoluteFile().getParent());\n\n        // 以指定的文件名创建 File 对象\n        File newFile = new File(\"D:\\\\qst.txt\");\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\n        try {\n            // 以指定newFile对象来创建一个文件\n            newFile.createNewFile();\n            System.out.println(newFile.getName());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\n        // 所以下面方法返回 false，即无法创建该目录\n        System.out.println(\"创建目录：\" + newFile.mkdir());\n\n        // 使用list()方法来列出当前路径下的所有文件和路径\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\n        String[] fileList = file.list();\n        for (String fileName : fileList) {\n            System.out.println(fileName);\n        }\n\n        // listRoots()静态方法列出所有的磁盘根路径。\n        System.out.println(\"====系统所有根路径如下====\");\n        File[] roots = File.listRoots();\n        for (File root : roots) {\n            System.out.println(root);\n        }\n    }\n}\n```\n---\n~~.\nnull\nG:\\Java\\Study2\\JavaSE\\.\nG:\\Java\\Study2\\JavaSE\nnewFile 对象是否存在：true\nqst.txt\n创建目录：false\n====当前路径下所有文件和路径如下====\n.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n====系统所有根路径如下====\nC:\\\nD:\\\nE:\\\nF:\\\nG:\\\nH:\\\nI:\\~~\n\n---\n#### FilenameFilter 接口\n文件过滤器接口，提供 accept 方法\n```\npackage io;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 根据路径名称创建 File 对象\n        File file = new File(\".\");\n        // 得到文件名列表\n        if (file.exists() && file.isDirectory()) {\n            // 显示该目录下所有文件列表\n            String[] allFileNames = file.list();\n\n            for (String name : allFileNames) {\n                System.out.println(name);\n            }\n            System.out.println(\"--------------------\");\n\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\n            String[] filterFileNames = file.list(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\n                }\n            });\n            System.out.println(\"过滤后的文件列表：\");\n            for (String name : filterFileNames) {\n                System.out.println(name);\n            }\n        }\n    }\n}\n```\n---\n~~.idea\nDemo.txt\nDemo2.txt\nJavaSE.iml\nout\nsrc\n\\--------------------\n过滤后的文件列表：\nDemo.txt\nDemo2.txt~~\n\n---\n### 2. IO 流\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\n\n计算机中的文件常被分为二进制文件和文本文件两大类。\n\n字节流处理的最基本单位为单个字节\n字符流处理的最基本的单元是 Unicode 码元\n\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\n\n### 3. 字节流\n#### InputStream\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class FileInputStreamDemo {\n    public static void main(String[] args) {\n        // 声明文件字节输入流\n        FileInputStream fis = null;\n        try {\n            // 实例化文件字节输入流\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\n            // 创建一个长度为1024的字节数组作为缓冲区\n            byte[] bbuf = new byte[1024];\n            // 用于保存实际读取的字节数\n            int hasRead = 0;\n            // 使用循环重复读文件中的数据\n            while ((hasRead = fis.read(bbuf)) > 0) {\n                // 将缓冲区中的数据转换成字符串输出\n                System.out.print(new String(bbuf, 0, hasRead));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输入流\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n#### OutputStream\n>控制台输入内容，保存到文件\n\n```\npackage io;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileOutputStreamDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        // 声明文件字节输出流\n        FileOutputStream fos = null;\n        try {\n            // 实例化文件字节输出流\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fos.write(str.getBytes());\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                // 关闭文件输出流\n                fos.close();\n                scanner.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n}\n```\n\n### 4. 字符流\n#### Writer\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\n\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\n\n需求:在硬盘上，创建一个文件并写入一些文字数据。\n\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\n/**\n * 字符流\n *  在硬盘上，创建一个文件并写入一些文字数据\n * Created by CaptainQR on 2018/10/7.\n */\npublic class FileWriterDemo {\n    public static void main(String[] args) throws IOException{\n        /*\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\n        *   其实该步就是在明确数据要存放的目的地。\n        * */\n        FileWriter fw = new FileWriter(\"Demo.txt\");\n\n        //2. 调用 write 方法，将字符串写入到流中\n        fw.write(\"abc\");\n\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\n        fw.flush();\n        fw.write(\"--def\");\n\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\n        fw.close();\n    }\n}\n```\n\n##### 续写\n>构造函数\n\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\n\n```\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\n```\n#### Reader\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\n##### 1. 读取单个字符\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            // 创建一个文件读取对象，和指定名称的文件相关联\n            fr = new FileReader(\"Demo.txt\");\n            int ch = 0;\n            /*\n            * 调用读取流对象的 read 方法\n            *   read()：一次读一个字符，而且会自动往下读\n            * */\n            while ((ch = fr.read()) != -1){\n                System.out.println((char)ch);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 2. 读取字符数组\n>读取一个 .java 文件，并打印在控制台上\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\n            char[] buf = new char[1024];\n            int num = 0;\n            // read(char[]) 返回的是读到的字符个数\n            while ((num = fr.read(buf)) != -1){\n                // String 类，String(char value[], int offset, int count)\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\n                System.out.println(new String(buf,0,num));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 3. 将C盘一个文本文件复制到D盘\n复制的原理：\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\n\n步骤：\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\n2，定义读取流和 C 盘文件关联。\n3，通过不断的读写完成数据存储。\n4，关闭资源。\n\n```\npackage io;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args){\n        FileWriter fw = null;\n        FileReader fr = null;\n        try {\n            fr = new FileReader(\"Demo.txt\");\n            // 写入 H 盘\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\n\n            char[] buf = new char[1024];\n            int len = 0;\n            while ((len = fr.read(buf)) != -1){\n                fw.write(buf,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            // 需要对每一个流进行处理\n            if(fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n##### 控制台输入，文件输出\n```\npackage io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class WriterDemo {\n    public static void main(String[] args) {\n        // 建立一个从键盘接收数据的扫描器\n        Scanner scanner = new Scanner(System.in);\n\n        try (\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\n                ) {\n            System.out.println(\"请输入内容：\");\n            String str = scanner.nextLine();\n            // 将数据写入文件中\n            fw.write(str);\n            System.out.println(\"已保存！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n#### Buffered\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\n##### BufferedWriter\n```\npackage io;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class BufferedWriterDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个字符写入流对象\n        FileWriter fw = new FileWriter(\"buf.txt\");\n\n        //为了提高字符写入流效率，加入了缓冲技术\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\n        BufferedWriter bufw = new BufferedWriter(fw);\n\n        for (int x=1;x<5;x++){\n            bufw.write(\"abc\" + x);\n            bufw.newLine(); //换行\n            bufw.flush();   //刷新\n        }\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\n    }\n}\n```\n##### BufferedReader\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException{\n        //创建一个读取流对象和文件相关联\n        FileReader fr = new FileReader(\"buf.txt\");\n\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\n        BufferedReader bufr = new BufferedReader(fr);\n\n        //readLine 一次读一行\n        String line = null;\n        while ((line = bufr.readLine()) != null){\n            System.out.println(line);\n        }\n        bufr.close();\n    }\n}\n```\n>通过缓冲区复制文件\n\n```\npackage io;\n\nimport java.io.*;\n\npublic class BufferCopy {\n    public static void main(String[] args){\n        try (\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\n                ){\n            String line = null;\n            while ((line = bufr.readLine()) != null){\n                bufw.write(line);\n                bufw.newLine();\n                bufw.flush();\n            }\n        }catch (IOException e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001544s ]
---------------------------------------------------------------
[ 2018-10-08T19:30:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001009s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001339s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000602s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001081s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000281s ]
---------------------------------------------------------------
[ 2018-10-08T22:06:33+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001232s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001712s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000673s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000350s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001215s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000415s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000310s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=209,`p_id`=2,`title`='Java SE\r',`content`='# Java SE\r\n[TOC]\r\n## 一. 匿名对象\r\n### 1.1 使用方式\r\n```\r\npackage study;\r\n\r\n/**\r\n * 匿名对象\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class AnonymousObject {\r\n    public static void main(String[] args) {\r\n        new Car().age = 5;\r\n        new Car().color = \"blue\";\r\n        new Car().show();   //每一次 new 都是一个新的对象\r\n    }\r\n}\r\n\r\nclass Car{\r\n    String color = \"red\";\r\n    int age = 4;\r\n    public void show(){\r\n        System.out.println(\"Car color = \" + this.color + \", Car age = \" + this.age);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~Car color = red, Car age = 4~~\r\n\r\n---\r\n\r\n1. **当对对象的方法只调用一次时，可以用匿名对象来完成**，这样写比较简化。如果对一个对象进行多个成员调用，必须给这个对象起个名字。\r\n\r\n1. 可以将匿名对象作为实际参数进行传递。\r\n`Show(new Car());`\r\n\r\n## 二. JAVA 的默认修饰符\r\n### 1.default\r\n只能由跟这个类在同一个包中的类来访问，比 private 限制更少，但比 protected 限制更多。\r\n\r\n## 3. 单例设计模式\r\n### 1.意义（想要保证对象唯一）\r\neg: 配置文件的使用。\r\n第一次修改后，希望下一次打开后是同样的配置，这是需要修改与访问的是同一个对象。\r\n### 2.使用方法\r\n先按常规方法对事物进行描述，最后再加上这三步内即可:\r\n1.将构造函数私有化。（其他类中无法再创建该类对象）\r\n2.在类中创建一个本类对象。（静态）\r\n3.提供一个方法可以获取到该对象。（静态）\r\n\r\n>Ps: 为什么要使用静态？\r\n\r\n在主函数中需要调用方法（3），方法的调用有两种：\r\n1.通过对象调用\r\n2.通过类名调用\r\n\r\n但是在主函数中并不能建立该类的对象，所以需要通过类名调用，要想可以通过类名调用方法，就需要定义静态。\r\n\r\n### 3.例子（饿汉式）\r\n```\r\npackage study;\r\n\r\n/**\r\n * 单例设计模式\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class SingletonPattern {\r\n    public static void main(String[] args) {\r\n        Student stu1 = Student.getStudent();    //通过类名调取方法获取到该对象，单例\r\n        Student stu2 = Student.getStudent();\r\n        stu1.setAge(18);\r\n        System.out.println(\"stu1 age = \" + stu1.getAge());\r\n        System.out.println(\"stu2 age = \" + stu2.getAge());\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int age;\r\n    private Student(){};    //1. 私有构造函数\r\n    private static Student stu = new Student(); //2. 在类中创建一个本类对象，私有\r\n    public static Student getStudent() {    //3. 提供一个方法可以获取到该对象\r\n        return stu;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n~~stu1 age = 18\r\nstu2 age = 18~~\r\n\r\n---\r\n## 三. 多态\r\n### 1. 简单应用\r\n```\r\npackage study;\r\n\r\n/**\r\n * 多态\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Polymorphism {\r\n    public static void main(String[] args) {\r\n        function(new Cat());\r\n        function(new Dog());\r\n    }\r\n\r\n    public static void function(Animale a){ //Animale a = new Cat(); 向上转型,父类引用指向子类对象\r\n        a.eat();\r\n//        a.seeHome();    //没有为类型 Animale 定义 seeHome() 方法，只能使用父类的引用访问父类的成员\r\n    }\r\n}\r\n\r\n/**\r\n * 抽象类\r\n */\r\nabstract class Animale{\r\n    abstract public void eat();\r\n}\r\n\r\n/**\r\n * 猫类 实现 抽象的 动物类\r\n */\r\nclass Cat extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n\r\n    public void catMouse(){\r\n        System.out.println(\"Cat catch mouse\");\r\n    }\r\n}\r\n\r\n/**\r\n * 狗类 实现 抽象的 动物类\r\n */\r\nclass Dog extends Animale{\r\n    public void eat() {\r\n        System.out.println(\"Dog eat bone\");\r\n    }\r\n\r\n    public void seeHome(){\r\n        System.out.println(\"Dog see Home\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nDog eat bone~~\r\n\r\n---\r\n### 2.向上转型和向下转型\r\n```\r\npackage study;\r\n\r\n/**\r\n * 向上转型和向下转型\r\n * Created by CaptainQR on 2018/9/26.\r\n */\r\npublic class Transformation {\r\n    public static void main(String[] args) {\r\n        Animale2 a = new Cat2();    //向上转型\r\n        a.eat();    //此时不能调用子类的特有方法\r\n        Cat2 c = (Cat2)a;   //向下转型\r\n        c.catchMouse(); //此时才能调用子类的特有方法\r\n    }\r\n}\r\n\r\nabstract class Animale2{\r\n    abstract public void eat();\r\n}\r\n\r\nclass Cat2 extends Animale2{\r\n    public void eat(){\r\n        System.out.println(\"Cat eat finish\");\r\n    }\r\n    public void catchMouse(){\r\n        System.out.println(\"Cat cat mouse\");\r\n    }\r\n}\r\n```\r\n---\r\n~~Cat eat finish\r\nCat cat mouse~~\r\n\r\n---\r\n**千万不能出现这样的操作：就是将父类对象转成子类类型**\r\n\r\n```\r\nAnimale a = new Animale();\r\nCat c = (Cat)a;\r\n```\r\n## 四. 内部类\r\n## 九. 文件和 IO流\r\n### 1. 文件\r\n#### File\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class FileDemo {\r\n    public static void main(String[] args) {\r\n        // 以当前路径来创建一个File对象,\".\"代表当前路径\r\n        File file = new File(\".\");\r\n        // 直接获取文件名，输出\".\"\r\n        System.out.println(file.getName());\r\n        // 获取相对路径的父路径可能出错，下面代码输出 null\r\n        System.out.println(file.getParent());\r\n        // 获取绝对路径\r\n        System.out.println(file.getAbsoluteFile());\r\n        // 获取上一级路径\r\n        System.out.println(file.getAbsoluteFile().getParent());\r\n\r\n        // 以指定的文件名创建 File 对象\r\n        File newFile = new File(\"D:\\\\qst.txt\");\r\n        System.out.println(\"newFile 对象是否存在：\" + newFile.exists());\r\n        try {\r\n            // 以指定newFile对象来创建一个文件\r\n            newFile.createNewFile();\r\n            System.out.println(newFile.getName());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 以 newFile 对象来创建一个目录，因为 newFile 已经存在\r\n        // 所以下面方法返回 false，即无法创建该目录\r\n        System.out.println(\"创建目录：\" + newFile.mkdir());\r\n\r\n        // 使用list()方法来列出当前路径下的所有文件和路径\r\n        System.out.println(\"====当前路径下所有文件和路径如下====\");\r\n        String[] fileList = file.list();\r\n        for (String fileName : fileList) {\r\n            System.out.println(fileName);\r\n        }\r\n\r\n        // listRoots()静态方法列出所有的磁盘根路径。\r\n        System.out.println(\"====系统所有根路径如下====\");\r\n        File[] roots = File.listRoots();\r\n        for (File root : roots) {\r\n            System.out.println(root);\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.\r\nnull\r\nG:\\Java\\Study2\\JavaSE\\.\r\nG:\\Java\\Study2\\JavaSE\r\nnewFile 对象是否存在：true\r\nqst.txt\r\n创建目录：false\r\n====当前路径下所有文件和路径如下====\r\n.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n====系统所有根路径如下====\r\nC:\\\r\nD:\\\r\nE:\\\r\nF:\\\r\nG:\\\r\nH:\\\r\nI:\\~~\r\n\r\n---\r\n#### FilenameFilter 接口\r\n文件过滤器接口，提供 accept 方法\r\n```\r\npackage io;\r\n\r\nimport java.io.File;\r\nimport java.io.FilenameFilter;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 根据路径名称创建 File 对象\r\n        File file = new File(\".\");\r\n        // 得到文件名列表\r\n        if (file.exists() && file.isDirectory()) {\r\n            // 显示该目录下所有文件列表\r\n            String[] allFileNames = file.list();\r\n\r\n            for (String name : allFileNames) {\r\n                System.out.println(name);\r\n            }\r\n            System.out.println(\"--------------------\");\r\n\r\n            // 创建FileNameFilter类型的匿名类，并作为参数传入到list()方法中\r\n            String[] filterFileNames = file.list(new FilenameFilter() {\r\n                public boolean accept(File dir, String name) {\r\n                    // 对文件名进行过滤，文件名的后缀为.zip或.txt\r\n                    return (name.endsWith(\".zip\") || name.endsWith(\".txt\"));\r\n                }\r\n            });\r\n            System.out.println(\"过滤后的文件列表：\");\r\n            for (String name : filterFileNames) {\r\n                System.out.println(name);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n---\r\n~~.idea\r\nDemo.txt\r\nDemo2.txt\r\nJavaSE.iml\r\nout\r\nsrc\r\n\\--------------------\r\n过滤后的文件列表：\r\nDemo.txt\r\nDemo2.txt~~\r\n\r\n---\r\n### 2. IO 流\r\nJava 的 IO 流都是由以下 4 个抽象基类派生的。\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181008/11HKL57cGk.png)\r\n\r\n计算机中的文件常被分为二进制文件和文本文件两大类。\r\n\r\n字节流处理的最基本单位为单个字节\r\n字符流处理的最基本的单元是 Unicode 码元\r\n\r\n**如果进行输入输出的内容是文本，则使用字符流，若是二进制，则使用字节流。**\r\n\r\n### 3. 字节流\r\n#### InputStream\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 声明文件字节输入流\r\n        FileInputStream fis = null;\r\n        try {\r\n            // 实例化文件字节输入流\r\n            fis = new FileInputStream(\"src\\\\io\\\\FileInputStreamDemo.java\");\r\n            // 创建一个长度为1024的字节数组作为缓冲区\r\n            byte[] bbuf = new byte[1024];\r\n            // 用于保存实际读取的字节数\r\n            int hasRead = 0;\r\n            // 使用循环重复读文件中的数据\r\n            while ((hasRead = fis.read(bbuf)) > 0) {\r\n                // 将缓冲区中的数据转换成字符串输出\r\n                System.out.print(new String(bbuf, 0, hasRead));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输入流\r\n                fis.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n#### OutputStream\r\n>控制台输入内容，保存到文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class FileOutputStreamDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 声明文件字节输出流\r\n        FileOutputStream fos = null;\r\n        try {\r\n            // 实例化文件字节输出流\r\n            fos = new FileOutputStream(\"D:\\\\mytest.txt\");\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fos.write(str.getBytes());\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                // 关闭文件输出流\r\n                fos.close();\r\n                scanner.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4. 字符流\r\n#### Writer\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/kI45gfiJa6.png)\r\n\r\n既然 IO 流是用于操作数据的，那么数据的最常见体现形式是：文件。\r\n\r\n需求:在硬盘上，创建一个文件并写入一些文字数据。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * 字符流\r\n *  在硬盘上，创建一个文件并写入一些文字数据\r\n * Created by CaptainQR on 2018/10/7.\r\n */\r\npublic class FileWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        /*\r\n        * 1. 创建一个 FileWriter 对象，该对象一被初始化就必须要明确被操作的文件\r\n        *   而且该文件会被创建到指定目录下，如果该目录下有同名文件，将被覆盖。\r\n        *   其实该步就是在明确数据要存放的目的地。\r\n        * */\r\n        FileWriter fw = new FileWriter(\"Demo.txt\");\r\n\r\n        //2. 调用 write 方法，将字符串写入到流中\r\n        fw.write(\"abc\");\r\n\r\n        //3. 刷新流对象中的缓冲数据，将数据刷到目的地中\r\n        fw.flush();\r\n        fw.write(\"--def\");\r\n\r\n        //4. 关闭流资源，但是关闭之前会刷新一次内部的缓冲中的数据，将数据刷到目的地中\r\n        //   和 flush 的区别：flush 刷新后，流可以继续使用，close 刷新后，会将流关闭\r\n        fw.close();\r\n    }\r\n}\r\n```\r\n\r\n##### 续写\r\n>构造函数\r\n\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/9I9JbDBkE7.png)\r\n\r\n```\r\n//传递一个 true 参数，代表不覆盖已有的文件，在末尾追加\r\nFileWriter fw2 = new FileWriter(\"Demo.txt\",true);\r\n```\r\n#### Reader\r\n![mark](http://p0tymq1rr.bkt.clouddn.com/daily/181007/e3a8ecdEH0.png)\r\n##### 1. 读取单个字符\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            // 创建一个文件读取对象，和指定名称的文件相关联\r\n            fr = new FileReader(\"Demo.txt\");\r\n            int ch = 0;\r\n            /*\r\n            * 调用读取流对象的 read 方法\r\n            *   read()：一次读一个字符，而且会自动往下读\r\n            * */\r\n            while ((ch = fr.read()) != -1){\r\n                System.out.println((char)ch);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 2. 读取字符数组\r\n>读取一个 .java 文件，并打印在控制台上\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"G:\\\\Java\\\\Study2\\\\JavaSE\\\\src\\\\io\\\\FileWriterDemo.java\");\r\n            // 存储读到的字符，一般定义大小为 1024 即为 1k\r\n            char[] buf = new char[1024];\r\n            int num = 0;\r\n            // read(char[]) 返回的是读到的字符个数\r\n            while ((num = fr.read(buf)) != -1){\r\n                // String 类，String(char value[], int offset, int count)\r\n                // 分配一个新的 String，它包含取 自字符数组一个子数组(num)的字符\r\n                System.out.println(new String(buf,0,num));\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 3. 将C盘一个文本文件复制到D盘\r\n复制的原理：\r\n其实就是将C盘下的文件数据存储到D盘的一个文件中。\r\n\r\n步骤：\r\n1，在 D 盘创建一个文件。用于存储 C 盘文件中的数据。\r\n2，定义读取流和 C 盘文件关联。\r\n3，通过不断的读写完成数据存储。\r\n4，关闭资源。\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        FileWriter fw = null;\r\n        FileReader fr = null;\r\n        try {\r\n            fr = new FileReader(\"Demo.txt\");\r\n            // 写入 H 盘\r\n            fw = new FileWriter(\"H:\\\\DemoCopy.txt\");\r\n\r\n            char[] buf = new char[1024];\r\n            int len = 0;\r\n            while ((len = fr.read(buf)) != -1){\r\n                fw.write(buf,0,len);\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }finally {\r\n            // 需要对每一个流进行处理\r\n            if(fr != null){\r\n                try {\r\n                    fr.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(fw != null){\r\n                try {\r\n                    fw.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n##### 控制台输入，文件输出\r\n```\r\npackage io;\r\n\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.Scanner;\r\n\r\npublic class WriterDemo {\r\n    public static void main(String[] args) {\r\n        // 建立一个从键盘接收数据的扫描器\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        try (\r\n                FileWriter fw = new FileWriter(\"H:\\\\WriterDemo.txt\");\r\n                ) {\r\n            System.out.println(\"请输入内容：\");\r\n            String str = scanner.nextLine();\r\n            // 将数据写入文件中\r\n            fw.write(str);\r\n            System.out.println(\"已保存！\");\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n#### Buffered\r\n缓冲区的出现是为了提高流的操作效率，所以在创建缓冲区之前，必须要先有流对象\r\n##### BufferedWriter\r\n```\r\npackage io;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class BufferedWriterDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个字符写入流对象\r\n        FileWriter fw = new FileWriter(\"buf.txt\");\r\n\r\n        //为了提高字符写入流效率，加入了缓冲技术\r\n        //只要将需要被提高效率的流对象作为参数传递给缓冲区的构造函数即可\r\n        BufferedWriter bufw = new BufferedWriter(fw);\r\n\r\n        for (int x=1;x<5;x++){\r\n            bufw.write(\"abc\" + x);\r\n            bufw.newLine(); //换行\r\n            bufw.flush();   //刷新\r\n        }\r\n        bufw.close();   //其实关闭缓冲流就是渣关闭缓冲区中的流对象\r\n    }\r\n}\r\n```\r\n##### BufferedReader\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferedReaderDemo {\r\n    public static void main(String[] args) throws IOException{\r\n        //创建一个读取流对象和文件相关联\r\n        FileReader fr = new FileReader(\"buf.txt\");\r\n\r\n        //为了提高效率，加入了缓冲技术，将字符读取对象作为参数传递给缓冲对象的构造函数\r\n        BufferedReader bufr = new BufferedReader(fr);\r\n\r\n        //readLine 一次读一行\r\n        String line = null;\r\n        while ((line = bufr.readLine()) != null){\r\n            System.out.println(line);\r\n        }\r\n        bufr.close();\r\n    }\r\n}\r\n```\r\n>通过缓冲区复制文件\r\n\r\n```\r\npackage io;\r\n\r\nimport java.io.*;\r\n\r\npublic class BufferCopy {\r\n    public static void main(String[] args){\r\n        try (\r\n                BufferedReader bufr = new BufferedReader(new FileReader(\"Demo.txt\"));\r\n                BufferedWriter bufw = new BufferedWriter(new FileWriter(\"H:\\\\BufferCopy.txt\"));\r\n                ){\r\n            String line = null;\r\n            while ((line = bufr.readLine()) != null){\r\n                bufw.write(line);\r\n                bufw.newLine();\r\n                bufw.flush();\r\n            }\r\n        }catch (IOException e){\r\n            System.out.println(\"Error\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Java',`is_show`=1  WHERE  `id` = 209 [ RunTime:0.001320s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.002143s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000982s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=3  WHERE  `groups` = 'Java' [ RunTime:0.000457s ]
---------------------------------------------------------------
[ 2018-10-08T22:06:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001019s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001470s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000589s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000873s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000305s ]
---------------------------------------------------------------
[ 2018-10-08T23:15:07+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001764s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002235s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000573s ]
---------------------------------------------------------------
[ 2018-10-08T23:15:11+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ sql ] [ DB ] CONNECT:[ UseTime:0.002729s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002224s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002432s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Essay' ORDER BY id desc LIMIT 5 [ RunTime:0.000792s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001516s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000547s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000771s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001957s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000452s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000742s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000439s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000607s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001324s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000354s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.002191s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001173s ]
---------------------------------------------------------------
[ 2018-10-08T23:16:42+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/209.html
[ sql ] [ DB ] CONNECT:[ UseTime:0.001324s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001641s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 209 LIMIT 1 [ RunTime:0.000594s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001090s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000306s ]
