---------------------------------------------------------------
[ 2018-11-18T10:13:12+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.093180s][吞吐率：10.73req/s] [内存消耗：2,159.08kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541138671,1541151758,1541298048,1542089916',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.003812s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002803s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000942s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.003073s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000742s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001183s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000518s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000314s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000345s ]
---------------------------------------------------------------
[ 2018-11-18T10:13:38+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/note
[ info ] qingrang.top/daily/note [运行时间：0.047771s][吞吐率：20.93req/s] [内存消耗：1,124.75kb] [文件加载：40]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'note',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541151758,1541298048,1542089916,1542507578; Hm_lpvt_1769181352e9adc950166aada465644e=1542507578',
)
[ info ] [ PARAM ] array (
)
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-18T10:14:03+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.081340s][吞吐率：12.29req/s] [内存消耗：2,158.89kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541151758,1541298048,1542089916,1542507578; Hm_lpvt_1769181352e9adc950166aada465644e=1542507578',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002391s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001796s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000708s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001491s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000721s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001346s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000357s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000506s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000370s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000470s ]
---------------------------------------------------------------
[ 2018-11-18T10:14:07+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/admin/show/notelst/groups/Java.html
[ info ] qingrang.top/daily/admin/show/notelst/groups/Java.html [运行时间：0.089985s][吞吐率：11.11req/s] [内存消耗：2,187.54kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'notelst',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541151758,1541298048,1542089916,1542507578; Hm_lpvt_1769181352e9adc950166aada465644e=1542507627',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002523s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001754s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000718s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.002028s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000827s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Java' )  AND `publish` = 1 LIMIT 1 [ RunTime:0.001420s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Java' )  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000991s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001244s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000382s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000538s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000375s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000353s ]
---------------------------------------------------------------
[ 2018-11-18T10:14:15+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/admin/show/shownote/id/247.html
[ info ] qingrang.top/daily/admin/show/shownote/id/247.html [运行时间：0.069427s][吞吐率：14.40req/s] [内存消耗：1,976.34kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Java.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541151758,1541298048,1542089916,1542507578; Hm_lpvt_1769181352e9adc950166aada465644e=1542507632',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002035s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001472s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000617s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000896s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000302s ]
---------------------------------------------------------------
[ 2018-11-18T11:09:03+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.069907s][吞吐率：14.30req/s] [内存消耗：2,158.79kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1542210648,1542261202,1542265291',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001223s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002449s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000743s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001521s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000670s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000940s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000469s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000513s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000346s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000347s ]
---------------------------------------------------------------
[ 2018-11-18T11:09:14+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/admin/show/notelst/groups/Java.html
[ info ] qingrang.top/daily/admin/show/notelst/groups/Java.html [运行时间：0.084209s][吞吐率：11.88req/s] [内存消耗：2,187.87kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'notelst',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1542210648,1542261202,1542265291,1542510929; Hm_lpvt_1769181352e9adc950166aada465644e=1542510929',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002574s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001757s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000784s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001155s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000670s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Java' )  AND `publish` = 1 LIMIT 1 [ RunTime:0.001011s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Java' )  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.001021s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001095s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000319s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000430s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000331s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000356s ]
---------------------------------------------------------------
[ 2018-11-18T11:09:17+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/admin/show/shownote/id/247.html
[ info ] qingrang.top/daily/admin/show/shownote/id/247.html [运行时间：0.066844s][吞吐率：14.96req/s] [内存消耗：1,976.41kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Java.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1542210648,1542261202,1542265291,1542510929; Hm_lpvt_1769181352e9adc950166aada465644e=1542510940',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002276s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001455s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000623s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001079s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000406s ]
---------------------------------------------------------------
[ 2018-11-18T11:20:55+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.067664s][吞吐率：14.78req/s] [内存消耗：2,158.86kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541151758,1541298048,1542089916,1542507578',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000627s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001609s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000727s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001292s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000641s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001193s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000344s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000534s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000403s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000370s ]
---------------------------------------------------------------
[ 2018-11-18T11:20:59+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/admin/show/notelst/groups/Java.html
[ info ] qingrang.top/daily/admin/show/notelst/groups/Java.html [运行时间：0.086590s][吞吐率：11.55req/s] [内存消耗：2,187.73kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'notelst',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541298048,1542089916,1542507578,1542511640; Hm_lpvt_1769181352e9adc950166aada465644e=1542511640',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002111s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001548s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000660s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001128s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000665s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Java' )  AND `publish` = 1 LIMIT 1 [ RunTime:0.001073s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `groups` <> 'Personal' AND `groups` = 'Java' )  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000982s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001089s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000316s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000392s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000298s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000504s ]
---------------------------------------------------------------
[ 2018-11-18T11:21:01+08:00 ] 74.120.168.12 117.136.65.193 GET /daily/admin/show/shownote/id/247.html
[ info ] qingrang.top/daily/admin/show/shownote/id/247.html [运行时间：0.057492s][吞吐率：17.39req/s] [内存消耗：1,976.43kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Java.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541298048,1542089916,1542507578,1542511640; Hm_lpvt_1769181352e9adc950166aada465644e=1542511644',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000593s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001665s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000483s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001469s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-11-18T11:47:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.037436s][吞吐率：26.71req/s] [内存消耗：1,340.50kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-18T12:15:05+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.077557s][吞吐率：12.89req/s] [内存消耗：1,922.64kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002986s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001917s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000407s ]
---------------------------------------------------------------
[ 2018-11-18T12:15:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.086493s][吞吐率：11.56req/s] [内存消耗：2,245.32kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000676s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001948s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003750s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000582s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001223s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000500s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000520s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001122s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000436s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000504s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000316s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000445s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001083s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000349s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001430s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000742s ]
---------------------------------------------------------------
[ 2018-11-18T12:15:22+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.059941s][吞吐率：16.68req/s] [内存消耗：2,018.27kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000622s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001679s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000558s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000962s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000333s ]
---------------------------------------------------------------
[ 2018-11-18T12:17:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.067780s][吞吐率：14.75req/s] [内存消耗：2,066.02kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002317s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001620s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000580s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000972s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000292s ]
---------------------------------------------------------------
[ 2018-11-18T12:25:24+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.063805s][吞吐率：15.67req/s] [内存消耗：2,209.38kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '44715',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 getBean()方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。


#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。

代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
#### 注入分类
##### 设值注入
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入
和 `setter` 方法没有关系，和构造方法有关系。



#### 集合属性注入
*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools;
	private String[] myStrs;
	private List<String> myList;
	private Set<String> mySet;
	private Map<String, Object> myMap;
	private Properties myPros;

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>
    
    <!-- 注册Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>


		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000694s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001632s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\n#### 默认装配方式\n代码通过 getBean()方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	public SomeServiceImpl() {\n		System.out.println(\"执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service -->\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 动态工厂 Bean\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n\n#### Bean 后处理器\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\n\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。\n\n代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\n\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\n\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\n\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	String doSome();\n	String doOther();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public String doSome() {\n		System.out.println(\"执行doSome()方法\");\n		return \"doSome() - abc\";\n	}\n	\n	@Override\n	public String doOther() {\n		System.out.println(\"执行doOther()方法\");\n		return \"doOther() - def\";\n	}\n}\n```\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\n	// bean：表示当前正在进行初始化的Bean对象\n	// beanName：表示当前正在进行初始化的Bean对象的id\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- before() ---方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- after() ---方法\");\n		//判断 SomeServiceImpl 对象\n		if (\"myService\".equals(beanName)) {\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\n					bean.getClass().getInterfaces(),\n					new InvocationHandler() {\n						@Override\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n							Object invoke = method.invoke(bean, args);\n							//判断具体方法\n							if (\"doSome\".equals(method.getName())) {\n								return ((String) invoke).toUpperCase();\n							}\n							return invoke;\n						}\n					});\n			return obj;\n		}\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n\n    <!-- 注册 Bean 后处理器 -->\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	System.out.println(service.doSome());\n	System.out.println(service.doOther());\n\n	System.out.println(\"======================\");\n\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\n	System.out.println(service2.doSome());\n	System.out.println(service2.doOther());\n}\n```\n\n*输出结果*\n```\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行doSome()方法\nDOSOME() - ABC\n执行doOther()方法\ndoOther() - def\n======================\n执行doSome()方法\ndoSome() - abc\n执行doOther()方法\ndoOther() - def\n```\n\n\n#### Bean 的生命周期\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\n	private String adao;\n	private String bdao;\n\n	public void setAdao(String adao) {\n		this.adao = adao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public void setBdao(String bdao) {\n		this.bdao = bdao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public SomeServiceImpl() {\n		System.out.println(\"Step1：执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"Step9：执行 doSome() 方法\");\n	}\n\n	public void setUp() {\n		System.out.println(\"Step7：初始化完毕之后\");\n	}\n\n	public void tearDown() {\n		System.out.println(\"Step11：销毁之前\");\n	}\n\n	@Override\n	public void setBeanName(String name) {\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\n	}\n\n	@Override\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\n	}\n\n	@Override\n	public void afterPropertiesSet() throws Exception {\n		System.out.println(\"Step6：Bean 初始化完毕了\");\n	}\n\n	@Override\n	public void destroy() throws Exception {\n		System.out.println(\"Step10：实现接口的销毁之前\");\n	}\n}\n```\n*MyBeanPostProcessor.java - Bean 后处理器*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\n    	<property name=\"adao\" value=\"aaa\"/>\n    	<property name=\"bdao\" value=\"bbb\"/>\n   	</bean>\n\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n	// 对于销毁方法的执行，有两个条件：\n	// 1)当前的Bean需要是singleton的\n	// 2)要手工关闭容器\n	((ClassPathXmlApplicationContext)ac).close();\n}\n```\n\n*输出信息*\n```\nStep1：执行无参构造器\nStep2：执行 setter\nStep2：执行 setter\nStep3：获取到 bean 的 id = myService\nStep4：获取到 BeanFactory 容器\nStep5：MyBeanPostProcessor - 执行 before() 方法\nStep6：Bean 初始化完毕了\nStep7：初始化完毕之后\nStep8：MyBeanPostProcessor - 执行 after() 方法\nStep9：执行 doSome() 方法\nStep10：实现接口的销毁之前\nStep11：销毁之前\n```\n### 基于 XML 的 DI\n#### 注入分类\n##### 设值注入\n和 `setter` 方法有关系。\n\n*School.java*\n```\npublic class School {\n	private String name;\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n	\n	public void setName(String name) {\n		System.out.println(\"执行setName()\");\n		this.name = name;\n	}\n	public void setAge(int age) {\n		System.out.println(\"执行setAge()\");\n		this.age = age;\n	}\n	public void setSchool(School school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\n				+ \"]\";\n	}\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\n    	<property name=\"name\" value=\"张三\"/>\n    	<property name=\"age\" value=\"23\"/>\n        <!-- 对于对象的注入要用 ref -->\n    	<property name=\"school\" ref=\"mySchool\"/>\n    </bean>\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n</beans>\n```\n\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n\n*输出信息*\n```\n执行setName()\n执行setAge()\nStudent [name=张三, age=23, school=School [name=清华大学]]\n```\n##### 构造注入\n和 `setter` 方法没有关系，和构造方法有关系。\n\n\n\n#### 集合属性注入\n*School.java*\n```\npublic class School {\n	private String name;\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n*Some.java*\n```\npublic class Some {\n	private School[] schools;\n	private String[] myStrs;\n	private List<String> myList;\n	private Set<String> mySet;\n	private Map<String, Object> myMap;\n	private Properties myPros;\n\n	public void setSchools(School[] schools) {\n		this.schools = schools;\n	}\n	public void setMyStrs(String[] myStrs) {\n		this.myStrs = myStrs;\n	}\n	public void setMyList(List<String> myList) {\n		this.myList = myList;\n	}\n	public void setMySet(Set<String> mySet) {\n		this.mySet = mySet;\n	}\n	public void setMyMap(Map<String, Object> myMap) {\n		this.myMap = myMap;\n	}\n	public void setMyPros(Properties myPros) {\n		this.myPros = myPros;\n	}\n\n	@Override\n	public String toString() {\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\n	}\n}\n```\n*applicationContext.xml*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"北京大学\"/>\n    </bean>\n    \n    <!-- 注册Student -->\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\n		<!-- 数组 -->\n    	<property name=\"schools\">\n    		<array>\n    			<ref bean=\"mySchool\"/>\n    			<ref bean=\"mySchool2\"/>\n    		</array>\n    	</property>\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个不行 -->\n		<property name=\"schools\" value=\"mySchool\"/>\n\n		<!-- 数组 -->\n    	<property name=\"myStrs\">\n    		<array>\n    			<value>中国</value>\n    			<value>北京</value>\n    		</array>\n    	</property>\n		<!-- 数组：简写 -->\n		<property name=\"myStrs\" value=\"中国,北京\"/>\n\n\n		<!-- List<String> -->\n    	<property name=\"myList\">\n    		<list>\n    			<value>大兴</value>\n    			<value>亦庄</value>\n    		</list>\n    	</property>\n		<!-- List<String>：简写 -->\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\n\n		<!-- Set<String> -->\n    	<property name=\"mySet\">\n    		<set>\n    			<value>大族企业湾</value>\n    			<value>10号楼</value>\n    		</set>\n    	</property>\n		<!-- Set<String>：简写 -->\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\n\n		<!-- Map<String, Object>，Map 的键值都是 object -->\n    	<property name=\"myMap\">\n    		<map>\n    			<entry key=\"mobile\" value=\"1234567\"/>\n    			<entry key=\"QQ\" value=\"7654321\"/>\n    		</map>\n    	</property>\n\n		<!-- Properties，Properties 的键值都是字符串 -->\n    	<property name=\"myPros\">\n    		<props>\n    			<prop key=\"education\">大学</prop>\n    			<prop key=\"gender\">男</prop>\n    		</props>\n    	</property>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Some some = (Some) ac.getBean(\"mySome\");\n	System.out.println(some);\n}\n```\n#### 对于域属性(对象)的自动注入\n##### byName 方式自动注入\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\n##### byType 方式自动注入\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001271s ]
---------------------------------------------------------------
[ 2018-11-18T12:25:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ info ] qingrang.top/daily/admin/note/shownote/id/1.html [运行时间：0.068352s][吞吐率：14.63req/s] [内存消耗：2,019.12kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000654s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001894s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000668s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000977s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000379s ]
---------------------------------------------------------------
[ 2018-11-18T13:27:42+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.068028s][吞吐率：14.70req/s] [内存消耗：2,225.22kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '49322',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。


#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。

代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
#### 注入分类
##### 设值注入
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入
和 `setter` 方法没有关系，和构造方法有关系。



#### 集合属性注入
*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools;
	private String[] myStrs;
	private List<String> myList;
	private Set<String> mySet;
	private Map<String, Object> myMap;
	private Properties myPros;

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>
    
    <!-- 注册Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>


		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000813s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001439s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000612s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000326s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001204s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000378s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000278s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring\r',`content`='# Spring\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC（控制反转）\r\n### 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n\r\n\r\n### 第一个 Spring 程序\r\n#### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n#### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n### Bean 的装配\r\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\r\n#### 默认装配方式\r\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\r\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 动态工厂 Bean\r\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 静态工厂 Bean\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	//静态方法\r\n	public static ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n#### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n\r\n#### Bean 后处理器\r\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\r\n\r\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。\r\n\r\n代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\r\n\r\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\r\n\r\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\r\n\r\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	String doSome();\r\n	String doOther();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public String doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n		return \"doSome() - abc\";\r\n	}\r\n	\r\n	@Override\r\n	public String doOther() {\r\n		System.out.println(\"执行doOther()方法\");\r\n		return \"doOther() - def\";\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n\r\n	// bean：表示当前正在进行初始化的Bean对象\r\n	// beanName：表示当前正在进行初始化的Bean对象的id\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- before() ---方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- after() ---方法\");\r\n		//判断 SomeServiceImpl 对象\r\n		if (\"myService\".equals(beanName)) {\r\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\r\n					bean.getClass().getInterfaces(),\r\n					new InvocationHandler() {\r\n						@Override\r\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n							Object invoke = method.invoke(bean, args);\r\n							//判断具体方法\r\n							if (\"doSome\".equals(method.getName())) {\r\n								return ((String) invoke).toUpperCase();\r\n							}\r\n							return invoke;\r\n						}\r\n					});\r\n			return obj;\r\n		}\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册 Bean 后处理器 -->\r\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	System.out.println(service.doSome());\r\n	System.out.println(service.doOther());\r\n\r\n	System.out.println(\"======================\");\r\n\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\r\n	System.out.println(service2.doSome());\r\n	System.out.println(service2.doOther());\r\n}\r\n```\r\n\r\n*输出结果*\r\n```\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行doSome()方法\r\nDOSOME() - ABC\r\n执行doOther()方法\r\ndoOther() - def\r\n======================\r\n执行doSome()方法\r\ndoSome() - abc\r\n执行doOther()方法\r\ndoOther() - def\r\n```\r\n\r\n\r\n#### Bean 的生命周期\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\r\n	private String adao;\r\n	private String bdao;\r\n\r\n	public void setAdao(String adao) {\r\n		this.adao = adao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public void setBdao(String bdao) {\r\n		this.bdao = bdao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"Step1：执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"Step9：执行 doSome() 方法\");\r\n	}\r\n\r\n	public void setUp() {\r\n		System.out.println(\"Step7：初始化完毕之后\");\r\n	}\r\n\r\n	public void tearDown() {\r\n		System.out.println(\"Step11：销毁之前\");\r\n	}\r\n\r\n	@Override\r\n	public void setBeanName(String name) {\r\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\r\n	}\r\n\r\n	@Override\r\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\r\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\r\n	}\r\n\r\n	@Override\r\n	public void afterPropertiesSet() throws Exception {\r\n		System.out.println(\"Step6：Bean 初始化完毕了\");\r\n	}\r\n\r\n	@Override\r\n	public void destroy() throws Exception {\r\n		System.out.println(\"Step10：实现接口的销毁之前\");\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - Bean 后处理器*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\r\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\r\n    	<property name=\"adao\" value=\"aaa\"/>\r\n    	<property name=\"bdao\" value=\"bbb\"/>\r\n   	</bean>\r\n\r\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n	// 对于销毁方法的执行，有两个条件：\r\n	// 1)当前的Bean需要是singleton的\r\n	// 2)要手工关闭容器\r\n	((ClassPathXmlApplicationContext)ac).close();\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\nStep1：执行无参构造器\r\nStep2：执行 setter\r\nStep2：执行 setter\r\nStep3：获取到 bean 的 id = myService\r\nStep4：获取到 BeanFactory 容器\r\nStep5：MyBeanPostProcessor - 执行 before() 方法\r\nStep6：Bean 初始化完毕了\r\nStep7：初始化完毕之后\r\nStep8：MyBeanPostProcessor - 执行 after() 方法\r\nStep9：执行 doSome() 方法\r\nStep10：实现接口的销毁之前\r\nStep11：销毁之前\r\n```\r\n### 基于 XML 的 DI\r\n#### 注入分类\r\n##### 设值注入\r\n和 `setter` 方法有关系。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"age\" value=\"23\"/>\r\n        <!-- 对于对象的注入要用 ref -->\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\n执行setName()\r\n执行setAge()\r\nStudent [name=张三, age=23, school=School [name=清华大学]]\r\n```\r\n##### 构造注入\r\n和 `setter` 方法没有关系，和构造方法有关系。\r\n\r\n\r\n\r\n#### 集合属性注入\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Some.java*\r\n```\r\npublic class Some {\r\n	private School[] schools;\r\n	private String[] myStrs;\r\n	private List<String> myList;\r\n	private Set<String> mySet;\r\n	private Map<String, Object> myMap;\r\n	private Properties myPros;\r\n\r\n	public void setSchools(School[] schools) {\r\n		this.schools = schools;\r\n	}\r\n	public void setMyStrs(String[] myStrs) {\r\n		this.myStrs = myStrs;\r\n	}\r\n	public void setMyList(List<String> myList) {\r\n		this.myList = myList;\r\n	}\r\n	public void setMySet(Set<String> mySet) {\r\n		this.mySet = mySet;\r\n	}\r\n	public void setMyMap(Map<String, Object> myMap) {\r\n		this.myMap = myMap;\r\n	}\r\n	public void setMyPros(Properties myPros) {\r\n		this.myPros = myPros;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\r\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\r\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.xml*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"北京大学\"/>\r\n    </bean>\r\n    \r\n    <!-- 注册Student -->\r\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\r\n		<!-- 数组 -->\r\n    	<property name=\"schools\">\r\n    		<array>\r\n    			<ref bean=\"mySchool\"/>\r\n    			<ref bean=\"mySchool2\"/>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个不行 -->\r\n		<property name=\"schools\" value=\"mySchool\"/>\r\n\r\n		<!-- 数组 -->\r\n    	<property name=\"myStrs\">\r\n    		<array>\r\n    			<value>中国</value>\r\n    			<value>北京</value>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写 -->\r\n		<property name=\"myStrs\" value=\"中国,北京\"/>\r\n\r\n\r\n		<!-- List<String> -->\r\n    	<property name=\"myList\">\r\n    		<list>\r\n    			<value>大兴</value>\r\n    			<value>亦庄</value>\r\n    		</list>\r\n    	</property>\r\n		<!-- List<String>：简写 -->\r\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\r\n\r\n		<!-- Set<String> -->\r\n    	<property name=\"mySet\">\r\n    		<set>\r\n    			<value>大族企业湾</value>\r\n    			<value>10号楼</value>\r\n    		</set>\r\n    	</property>\r\n		<!-- Set<String>：简写 -->\r\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\r\n\r\n		<!-- Map<String, Object>，Map 的键值都是 object -->\r\n    	<property name=\"myMap\">\r\n    		<map>\r\n    			<entry key=\"mobile\" value=\"1234567\"/>\r\n    			<entry key=\"QQ\" value=\"7654321\"/>\r\n    		</map>\r\n    	</property>\r\n\r\n		<!-- Properties，Properties 的键值都是字符串 -->\r\n    	<property name=\"myPros\">\r\n    		<props>\r\n    			<prop key=\"education\">大学</prop>\r\n    			<prop key=\"gender\">男</prop>\r\n    		</props>\r\n    	</property>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Some some = (Some) ac.getBean(\"mySome\");\r\n	System.out.println(some);\r\n}\r\n```\r\n#### 对于域属性(对象)的自动注入\r\n##### byName 方式自动注入\r\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\r\n##### byType 方式自动注入\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.001221s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001340s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000395s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000908s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000396s ]
---------------------------------------------------------------
[ 2018-11-18T13:27:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.059803s][吞吐率：16.72req/s] [内存消耗：2,020.66kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=3dqac7voekoa53pr01rd2kip01',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000535s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001339s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000732s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001270s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
---------------------------------------------------------------
[ 2018-11-18T17:20:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.049824s][吞吐率：20.07req/s] [内存消耗：1,339.90kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-18T18:24:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.050650s][吞吐率：19.74req/s] [内存消耗：1,428.32kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-18T18:24:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.040065s][吞吐率：24.96req/s] [内存消耗：1,340.77kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-18T18:24:41+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.060859s][吞吐率：16.43req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001452s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002735s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000537s ]
---------------------------------------------------------------
[ 2018-11-18T18:24:42+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.084342s][吞吐率：11.86req/s] [内存消耗：2,273.14kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000653s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001602s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003794s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000732s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001297s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000443s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000665s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001067s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000341s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000502s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000404s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000431s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001214s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000268s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001392s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000812s ]
---------------------------------------------------------------
[ 2018-11-18T18:24:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.065967s][吞吐率：15.16req/s] [内存消耗：2,020.58kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000717s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001895s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000776s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002190s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000369s ]
---------------------------------------------------------------
[ 2018-11-18T18:34:48+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.083814s][吞吐率：11.93req/s] [内存消耗：2,272.50kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000578s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001718s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002125s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000606s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001120s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000356s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000534s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001070s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000430s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000364s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000366s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001106s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000242s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001265s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000662s ]
---------------------------------------------------------------
[ 2018-11-18T18:39:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.064837s][吞吐率：15.42req/s] [内存消耗：2,072.61kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000660s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001387s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000585s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000938s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000278s ]
---------------------------------------------------------------
[ 2018-11-18T18:39:47+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ info ] qingrang.top/daily/admin/note/shownote/id/1.html [运行时间：0.069022s][吞吐率：14.49req/s] [内存消耗：2,019.18kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002404s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001348s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000610s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001086s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000420s ]
---------------------------------------------------------------
[ 2018-11-18T19:05:16+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.055510s][吞吐率：18.01req/s] [内存消耗：2,229.26kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '49615',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
#### 注入分类
##### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
#### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>


		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000658s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001824s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\n#### 默认装配方式\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	public SomeServiceImpl() {\n		System.out.println(\"执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 动态工厂 Bean\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	//静态方法\n	public static ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n#### Bean 后处理器\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\n\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\n\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\n\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\n\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\n\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	String doSome();\n	String doOther();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public String doSome() {\n		System.out.println(\"执行doSome()方法\");\n		return \"doSome() - abc\";\n	}\n	\n	@Override\n	public String doOther() {\n		System.out.println(\"执行doOther()方法\");\n		return \"doOther() - def\";\n	}\n}\n```\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\n	// bean：表示当前正在进行初始化的Bean对象\n	// beanName：表示当前正在进行初始化的Bean对象的id\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- before() ---方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- after() ---方法\");\n		//判断 SomeServiceImpl 对象\n		if (\"myService\".equals(beanName)) {\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\n					bean.getClass().getInterfaces(),\n					new InvocationHandler() {\n						@Override\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n							Object invoke = method.invoke(bean, args);\n							//判断具体方法\n							if (\"doSome\".equals(method.getName())) {\n								return ((String) invoke).toUpperCase();\n							}\n							return invoke;\n						}\n					});\n			return obj;\n		}\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n\n    <!-- 注册 Bean 后处理器 -->\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	System.out.println(service.doSome());\n	System.out.println(service.doOther());\n\n	System.out.println(\"======================\");\n\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\n	System.out.println(service2.doSome());\n	System.out.println(service2.doOther());\n}\n```\n\n*输出结果*\n```\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行doSome()方法\nDOSOME() - ABC\n执行doOther()方法\ndoOther() - def\n======================\n执行doSome()方法\ndoSome() - abc\n执行doOther()方法\ndoOther() - def\n```\n\n\n#### Bean 的生命周期\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\n	private String adao;\n	private String bdao;\n\n	public void setAdao(String adao) {\n		this.adao = adao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public void setBdao(String bdao) {\n		this.bdao = bdao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public SomeServiceImpl() {\n		System.out.println(\"Step1：执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"Step9：执行 doSome() 方法\");\n	}\n\n	public void setUp() {\n		System.out.println(\"Step7：初始化完毕之后\");\n	}\n\n	public void tearDown() {\n		System.out.println(\"Step11：销毁之前\");\n	}\n\n	@Override\n	public void setBeanName(String name) {\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\n	}\n\n	@Override\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\n	}\n\n	@Override\n	public void afterPropertiesSet() throws Exception {\n		System.out.println(\"Step6：Bean 初始化完毕了\");\n	}\n\n	@Override\n	public void destroy() throws Exception {\n		System.out.println(\"Step10：实现接口的销毁之前\");\n	}\n}\n```\n*MyBeanPostProcessor.java - Bean 后处理器*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\n    	<property name=\"adao\" value=\"aaa\"/>\n    	<property name=\"bdao\" value=\"bbb\"/>\n   	</bean>\n\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n	// 对于销毁方法的执行，有两个条件：\n	// 1)当前的Bean需要是singleton的\n	// 2)要手工关闭容器\n	((ClassPathXmlApplicationContext)ac).close();\n}\n```\n\n*输出信息*\n```\nStep1：执行无参构造器\nStep2：执行 setter\nStep2：执行 setter\nStep3：获取到 bean 的 id = myService\nStep4：获取到 BeanFactory 容器\nStep5：MyBeanPostProcessor - 执行 before() 方法\nStep6：Bean 初始化完毕了\nStep7：初始化完毕之后\nStep8：MyBeanPostProcessor - 执行 after() 方法\nStep9：执行 doSome() 方法\nStep10：实现接口的销毁之前\nStep11：销毁之前\n```\n### 基于 XML 的 DI\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\n#### 注入分类\n##### 设值注入(常用)\n和 `setter` 方法有关系。\n\n*School.java*\n```\npublic class School {\n	private String name;\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n	\n	public void setName(String name) {\n		System.out.println(\"执行setName()\");\n		this.name = name;\n	}\n	public void setAge(int age) {\n		System.out.println(\"执行setAge()\");\n		this.age = age;\n	}\n	public void setSchool(School school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\n				+ \"]\";\n	}\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\n    	<property name=\"name\" value=\"张三\"/>\n    	<property name=\"age\" value=\"23\"/>\n        <!-- 对于对象的注入要用 ref -->\n    	<property name=\"school\" ref=\"mySchool\"/>\n    </bean>\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n</beans>\n```\n\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n\n*输出信息*\n```\n执行setName()\n执行setAge()\nStudent [name=张三, age=23, school=School [name=清华大学]]\n```\n##### 构造注入(很少用)\n和 `setter` 方法没有关系，和构造方法有关系。\n\n*Student.java - 为 Student 增加带参构造器*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n\n	/**\n	 * 带参数的构造方法\n	 */\n	public Student(String name, int age, School school) {\n		super();\n		this.name = name;\n		this.age = age;\n		this.school = school;\n	}\n	...\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n    <!-- 注册Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\n        <!-- 构造器参数，指定 name -->\n    	<constructor-arg name=\"name\" value=\"李四\"/>\n    	<constructor-arg name=\"age\" value=\"24\"/>\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\n\n        <!-- 构造器参数，使用索引 -->\n    	<!--\n    	<constructor-arg index=\"0\" value=\"李四\"/>\n    	<constructor-arg index=\"1\" value=\"24\"/>\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\n    	 -->\n\n        <!-- 构造器参数，默认索引 -->\n    	<!--\n    	<constructor-arg value=\"李四\"/>\n    	<constructor-arg value=\"24\"/>\n    	<constructor-arg ref=\"mySchool\"/>\n    	 -->\n    </bean>\n</beans>\n```\n#### 集合属性注入\n基本类型数组，对象数组，List，Set，Map，Properties 等。\n\n*School.java*\n```\npublic class School {\n	private String name;\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n*Some.java*\n```\npublic class Some {\n	private School[] schools; // 对象数组\n	private String[] myStrs; // 字符串数组\n	private List<String> myList; // List\n	private Set<String> mySet; // Set\n	private Map<String, Object> myMap; // Map\n	private Properties myPros; // Properties\n\n	public void setSchools(School[] schools) {\n		this.schools = schools;\n	}\n	public void setMyStrs(String[] myStrs) {\n		this.myStrs = myStrs;\n	}\n	public void setMyList(List<String> myList) {\n		this.myList = myList;\n	}\n	public void setMySet(Set<String> mySet) {\n		this.mySet = mySet;\n	}\n	public void setMyMap(Map<String, Object> myMap) {\n		this.myMap = myMap;\n	}\n	public void setMyPros(Properties myPros) {\n		this.myPros = myPros;\n	}\n\n	@Override\n	public String toString() {\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\n	}\n}\n```\n*applicationContext.xml*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"北京大学\"/>\n    </bean>\n\n    <!-- 注册 Student -->\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\n		<!-- 对象数组 -->\n    	<property name=\"schools\">\n    		<array>\n    			<ref bean=\"mySchool\"/>\n    			<ref bean=\"mySchool2\"/>\n    		</array>\n    	</property>\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\n		<property name=\"schools\" value=\"mySchool\"/>\n\n		<!-- 基本类型数组 -->\n    	<property name=\"myStrs\">\n    		<array>\n    			<value>中国</value>\n    			<value>北京</value>\n    		</array>\n    	</property>\n		<!-- 数组：简写 -->\n		<property name=\"myStrs\" value=\"中国,北京\"/>\n\n\n		<!-- List<String> -->\n    	<property name=\"myList\">\n    		<list>\n    			<value>大兴</value>\n    			<value>亦庄</value>\n    		</list>\n    	</property>\n		<!-- List<String>：简写 -->\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\n\n		<!-- Set<String> -->\n    	<property name=\"mySet\">\n    		<set>\n    			<value>大族企业湾</value>\n    			<value>10号楼</value>\n    		</set>\n    	</property>\n		<!-- Set<String>：简写 -->\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\n\n		<!-- Map<String, Object>，Map 的键值都是 object -->\n    	<property name=\"myMap\">\n    		<map>\n    			<entry key=\"mobile\" value=\"1234567\"/>\n    			<entry key=\"QQ\" value=\"7654321\"/>\n    		</map>\n    	</property>\n\n		<!-- Properties，Properties 的键值都是字符串 -->\n    	<property name=\"myPros\">\n    		<props>\n    			<prop key=\"education\">大学</prop>\n    			<prop key=\"gender\">男</prop>\n    		</props>\n    	</property>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Some some = (Some) ac.getBean(\"mySome\");\n	System.out.println(some);\n}\n```\n#### 对于域属性(对象)的自动注入\n##### byName 方式自动注入\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\n##### byType 方式自动注入\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001300s ]
---------------------------------------------------------------
[ 2018-11-18T19:05:25+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.058917s][吞吐率：16.97req/s] [内存消耗：2,229.23kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '49615',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
#### 注入分类
##### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
#### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>


		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000512s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001886s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\n#### 默认装配方式\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	public SomeServiceImpl() {\n		System.out.println(\"执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 动态工厂 Bean\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	//静态方法\n	public static ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n#### Bean 后处理器\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\n\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\n\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\n\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\n\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\n\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	String doSome();\n	String doOther();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public String doSome() {\n		System.out.println(\"执行doSome()方法\");\n		return \"doSome() - abc\";\n	}\n	\n	@Override\n	public String doOther() {\n		System.out.println(\"执行doOther()方法\");\n		return \"doOther() - def\";\n	}\n}\n```\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\n	// bean：表示当前正在进行初始化的Bean对象\n	// beanName：表示当前正在进行初始化的Bean对象的id\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- before() ---方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- after() ---方法\");\n		//判断 SomeServiceImpl 对象\n		if (\"myService\".equals(beanName)) {\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\n					bean.getClass().getInterfaces(),\n					new InvocationHandler() {\n						@Override\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n							Object invoke = method.invoke(bean, args);\n							//判断具体方法\n							if (\"doSome\".equals(method.getName())) {\n								return ((String) invoke).toUpperCase();\n							}\n							return invoke;\n						}\n					});\n			return obj;\n		}\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n\n    <!-- 注册 Bean 后处理器 -->\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	System.out.println(service.doSome());\n	System.out.println(service.doOther());\n\n	System.out.println(\"======================\");\n\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\n	System.out.println(service2.doSome());\n	System.out.println(service2.doOther());\n}\n```\n\n*输出结果*\n```\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行doSome()方法\nDOSOME() - ABC\n执行doOther()方法\ndoOther() - def\n======================\n执行doSome()方法\ndoSome() - abc\n执行doOther()方法\ndoOther() - def\n```\n\n\n#### Bean 的生命周期\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\n	private String adao;\n	private String bdao;\n\n	public void setAdao(String adao) {\n		this.adao = adao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public void setBdao(String bdao) {\n		this.bdao = bdao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public SomeServiceImpl() {\n		System.out.println(\"Step1：执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"Step9：执行 doSome() 方法\");\n	}\n\n	public void setUp() {\n		System.out.println(\"Step7：初始化完毕之后\");\n	}\n\n	public void tearDown() {\n		System.out.println(\"Step11：销毁之前\");\n	}\n\n	@Override\n	public void setBeanName(String name) {\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\n	}\n\n	@Override\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\n	}\n\n	@Override\n	public void afterPropertiesSet() throws Exception {\n		System.out.println(\"Step6：Bean 初始化完毕了\");\n	}\n\n	@Override\n	public void destroy() throws Exception {\n		System.out.println(\"Step10：实现接口的销毁之前\");\n	}\n}\n```\n*MyBeanPostProcessor.java - Bean 后处理器*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\n    	<property name=\"adao\" value=\"aaa\"/>\n    	<property name=\"bdao\" value=\"bbb\"/>\n   	</bean>\n\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n	// 对于销毁方法的执行，有两个条件：\n	// 1)当前的Bean需要是singleton的\n	// 2)要手工关闭容器\n	((ClassPathXmlApplicationContext)ac).close();\n}\n```\n\n*输出信息*\n```\nStep1：执行无参构造器\nStep2：执行 setter\nStep2：执行 setter\nStep3：获取到 bean 的 id = myService\nStep4：获取到 BeanFactory 容器\nStep5：MyBeanPostProcessor - 执行 before() 方法\nStep6：Bean 初始化完毕了\nStep7：初始化完毕之后\nStep8：MyBeanPostProcessor - 执行 after() 方法\nStep9：执行 doSome() 方法\nStep10：实现接口的销毁之前\nStep11：销毁之前\n```\n### 基于 XML 的 DI\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\n#### 注入分类\n##### 设值注入(常用)\n和 `setter` 方法有关系。\n\n*School.java*\n```\npublic class School {\n	private String name;\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n	\n	public void setName(String name) {\n		System.out.println(\"执行setName()\");\n		this.name = name;\n	}\n	public void setAge(int age) {\n		System.out.println(\"执行setAge()\");\n		this.age = age;\n	}\n	public void setSchool(School school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\n				+ \"]\";\n	}\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\n    	<property name=\"name\" value=\"张三\"/>\n    	<property name=\"age\" value=\"23\"/>\n        <!-- 对于对象的注入要用 ref -->\n    	<property name=\"school\" ref=\"mySchool\"/>\n    </bean>\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n</beans>\n```\n\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n\n*输出信息*\n```\n执行setName()\n执行setAge()\nStudent [name=张三, age=23, school=School [name=清华大学]]\n```\n##### 构造注入(很少用)\n和 `setter` 方法没有关系，和构造方法有关系。\n\n*Student.java - 为 Student 增加带参构造器*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n\n	/**\n	 * 带参数的构造方法\n	 */\n	public Student(String name, int age, School school) {\n		super();\n		this.name = name;\n		this.age = age;\n		this.school = school;\n	}\n	...\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n    <!-- 注册Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\n        <!-- 构造器参数，指定 name -->\n    	<constructor-arg name=\"name\" value=\"李四\"/>\n    	<constructor-arg name=\"age\" value=\"24\"/>\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\n\n        <!-- 构造器参数，使用索引 -->\n    	<!--\n    	<constructor-arg index=\"0\" value=\"李四\"/>\n    	<constructor-arg index=\"1\" value=\"24\"/>\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\n    	 -->\n\n        <!-- 构造器参数，默认索引 -->\n    	<!--\n    	<constructor-arg value=\"李四\"/>\n    	<constructor-arg value=\"24\"/>\n    	<constructor-arg ref=\"mySchool\"/>\n    	 -->\n    </bean>\n</beans>\n```\n#### 集合属性注入\n基本类型数组，对象数组，List，Set，Map，Properties 等。\n\n*School.java*\n```\npublic class School {\n	private String name;\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n*Some.java*\n```\npublic class Some {\n	private School[] schools; // 对象数组\n	private String[] myStrs; // 字符串数组\n	private List<String> myList; // List\n	private Set<String> mySet; // Set\n	private Map<String, Object> myMap; // Map\n	private Properties myPros; // Properties\n\n	public void setSchools(School[] schools) {\n		this.schools = schools;\n	}\n	public void setMyStrs(String[] myStrs) {\n		this.myStrs = myStrs;\n	}\n	public void setMyList(List<String> myList) {\n		this.myList = myList;\n	}\n	public void setMySet(Set<String> mySet) {\n		this.mySet = mySet;\n	}\n	public void setMyMap(Map<String, Object> myMap) {\n		this.myMap = myMap;\n	}\n	public void setMyPros(Properties myPros) {\n		this.myPros = myPros;\n	}\n\n	@Override\n	public String toString() {\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\n	}\n}\n```\n*applicationContext.xml*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"北京大学\"/>\n    </bean>\n\n    <!-- 注册 Student -->\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\n		<!-- 对象数组 -->\n    	<property name=\"schools\">\n    		<array>\n    			<ref bean=\"mySchool\"/>\n    			<ref bean=\"mySchool2\"/>\n    		</array>\n    	</property>\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\n		<property name=\"schools\" value=\"mySchool\"/>\n\n		<!-- 基本类型数组 -->\n    	<property name=\"myStrs\">\n    		<array>\n    			<value>中国</value>\n    			<value>北京</value>\n    		</array>\n    	</property>\n		<!-- 数组：简写 -->\n		<property name=\"myStrs\" value=\"中国,北京\"/>\n\n\n		<!-- List<String> -->\n    	<property name=\"myList\">\n    		<list>\n    			<value>大兴</value>\n    			<value>亦庄</value>\n    		</list>\n    	</property>\n		<!-- List<String>：简写 -->\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\n\n		<!-- Set<String> -->\n    	<property name=\"mySet\">\n    		<set>\n    			<value>大族企业湾</value>\n    			<value>10号楼</value>\n    		</set>\n    	</property>\n		<!-- Set<String>：简写 -->\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\n\n		<!-- Map<String, Object>，Map 的键值都是 object -->\n    	<property name=\"myMap\">\n    		<map>\n    			<entry key=\"mobile\" value=\"1234567\"/>\n    			<entry key=\"QQ\" value=\"7654321\"/>\n    		</map>\n    	</property>\n\n		<!-- Properties，Properties 的键值都是字符串 -->\n    	<property name=\"myPros\">\n    		<props>\n    			<prop key=\"education\">大学</prop>\n    			<prop key=\"gender\">男</prop>\n    		</props>\n    	</property>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Some some = (Some) ac.getBean(\"mySome\");\n	System.out.println(some);\n}\n```\n#### 对于域属性(对象)的自动注入\n##### byName 方式自动注入\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\n##### byType 方式自动注入\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001357s ]
---------------------------------------------------------------
[ 2018-11-18T20:17:02+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.067912s][吞吐率：14.72req/s] [内存消耗：2,288.13kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '62778',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
#### 注入分类
##### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
#### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>

		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)
#### 使用 SPEL 注入
SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。
*Person.java*
```
public class Person {
	private String pname;
	private int page;

	public void setPname(String pname) {
		this.pname = pname;
	}
	public void setPage(int page) {
		this.page = page;
	}
	public String getPname() {
		return pname;
	}
	public int getPage() {
		return page;
	}

	@Override
	public String toString() {
		return "Person [pname=" + pname + ", page=" + page + "]";
	}
	
	public int computeAge() {
		return page > 25 ? 25 : page;
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="myPerson" class="top.qingrang.di09.Person">
    	<property name="pname" value="李四"/>
    	<property name="page" value="#{T(java.lang.Math).random() * 50}"/>   
    </bean>
    
    <bean id="myStudent" class="top.qingrang.di09.Student">
    	<property name="name" value="#{myPerson.pname}"/>
    	<!-- <property name="age" value="#{myPerson.page > 25 ? 25 : myPerson.page}"/> -->
    	<property name="age" value="#{myPerson.computeAge() }"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Person person = (Person) ac.getBean("myPerson");
	System.out.println(person);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
#### 使用内部 Bean 注入
若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。

*applicationContext.mxl*
```
<!-- 注册 Student -->
<bean id="myStudent" class="top.qingrang.di10.Student">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
	<property name="school">
		<!-- 内部 Bean -->
	    <bean class="top.qingrang.di10.School">
	    	<property name="name" value="清华大学"/>
	    </bean>
	</property>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di10/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	
	// 不能访问，会报错
	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined
	School school = (School) ac.getBean("mySchool");
	System.out.println(school);
}
```


#### 使用同类抽象 Bean 注入
当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。

抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private String school; // 学校

	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setSchool(String school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<!-- 同类抽象 Bean，abstract="true" -->
<bean id="baseStudent" class="top.qingrang.di11.Student" abstract="true">
	<property name="school" value="清华大学"/>
</bean>
<!-- 利用 parent 实现继承 -->
<bean id="myStudent" parent="baseStudent">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
</bean>
<bean id="myStudent2" parent="baseStudent">
	<property name="name" value="李四"/>
	<property name="age" value="24"/>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Student student2 = (Student) ac.getBean("myStudent2");
	System.out.println(student2);
}
```
#### 使用异类抽象 Bean 注入
当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。
![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)
#### 为应用指定多个 Spring 配置文件
在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。
##### 平等关系的配置文件
假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`
```
@Test
public void test01() {
	// 可变参数
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);
	// 参数数组
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	String[] resources = {resource, resource2};
	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);
	// 通配符
	String resource = "top/qingrang/di13/spring-*.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Teacher teacher = (Teacher) ac.getBean("myTeacher");
	System.out.println(teacher);
}
```
##### 包含关系的配置文件
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!-- 
	<import resource="classpath:top/qingrang/di14/spring-base.xml"/>
	<import resource="classpath:top/qingrang/di14/spring-beans.xml"/>
	 -->

	<!-- 使用通配符 -->
	<import resource="classpath:top/qingrang/di14/spring-*.xml"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di14/springTotal.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	...
}
```
### 基于注解的 DI
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001908s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002391s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\n#### 默认装配方式\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	public SomeServiceImpl() {\n		System.out.println(\"执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 动态工厂 Bean\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	//静态方法\n	public static ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n#### Bean 后处理器\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\n\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\n\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\n\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\n\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\n\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	String doSome();\n	String doOther();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public String doSome() {\n		System.out.println(\"执行doSome()方法\");\n		return \"doSome() - abc\";\n	}\n	\n	@Override\n	public String doOther() {\n		System.out.println(\"执行doOther()方法\");\n		return \"doOther() - def\";\n	}\n}\n```\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\n	// bean：表示当前正在进行初始化的Bean对象\n	// beanName：表示当前正在进行初始化的Bean对象的id\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- before() ---方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- after() ---方法\");\n		//判断 SomeServiceImpl 对象\n		if (\"myService\".equals(beanName)) {\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\n					bean.getClass().getInterfaces(),\n					new InvocationHandler() {\n						@Override\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n							Object invoke = method.invoke(bean, args);\n							//判断具体方法\n							if (\"doSome\".equals(method.getName())) {\n								return ((String) invoke).toUpperCase();\n							}\n							return invoke;\n						}\n					});\n			return obj;\n		}\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n\n    <!-- 注册 Bean 后处理器 -->\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	System.out.println(service.doSome());\n	System.out.println(service.doOther());\n\n	System.out.println(\"======================\");\n\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\n	System.out.println(service2.doSome());\n	System.out.println(service2.doOther());\n}\n```\n\n*输出结果*\n```\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行doSome()方法\nDOSOME() - ABC\n执行doOther()方法\ndoOther() - def\n======================\n执行doSome()方法\ndoSome() - abc\n执行doOther()方法\ndoOther() - def\n```\n\n\n#### Bean 的生命周期\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\n	private String adao;\n	private String bdao;\n\n	public void setAdao(String adao) {\n		this.adao = adao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public void setBdao(String bdao) {\n		this.bdao = bdao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public SomeServiceImpl() {\n		System.out.println(\"Step1：执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"Step9：执行 doSome() 方法\");\n	}\n\n	public void setUp() {\n		System.out.println(\"Step7：初始化完毕之后\");\n	}\n\n	public void tearDown() {\n		System.out.println(\"Step11：销毁之前\");\n	}\n\n	@Override\n	public void setBeanName(String name) {\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\n	}\n\n	@Override\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\n	}\n\n	@Override\n	public void afterPropertiesSet() throws Exception {\n		System.out.println(\"Step6：Bean 初始化完毕了\");\n	}\n\n	@Override\n	public void destroy() throws Exception {\n		System.out.println(\"Step10：实现接口的销毁之前\");\n	}\n}\n```\n*MyBeanPostProcessor.java - Bean 后处理器*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\n    	<property name=\"adao\" value=\"aaa\"/>\n    	<property name=\"bdao\" value=\"bbb\"/>\n   	</bean>\n\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n	// 对于销毁方法的执行，有两个条件：\n	// 1)当前的Bean需要是singleton的\n	// 2)要手工关闭容器\n	((ClassPathXmlApplicationContext)ac).close();\n}\n```\n\n*输出信息*\n```\nStep1：执行无参构造器\nStep2：执行 setter\nStep2：执行 setter\nStep3：获取到 bean 的 id = myService\nStep4：获取到 BeanFactory 容器\nStep5：MyBeanPostProcessor - 执行 before() 方法\nStep6：Bean 初始化完毕了\nStep7：初始化完毕之后\nStep8：MyBeanPostProcessor - 执行 after() 方法\nStep9：执行 doSome() 方法\nStep10：实现接口的销毁之前\nStep11：销毁之前\n```\n### 基于 XML 的 DI\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\n#### 注入分类\n##### 设值注入(常用)\n和 `setter` 方法有关系。\n\n*School.java*\n```\npublic class School {\n	private String name;\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n	\n	public void setName(String name) {\n		System.out.println(\"执行setName()\");\n		this.name = name;\n	}\n	public void setAge(int age) {\n		System.out.println(\"执行setAge()\");\n		this.age = age;\n	}\n	public void setSchool(School school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\n				+ \"]\";\n	}\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\n    	<property name=\"name\" value=\"张三\"/>\n    	<property name=\"age\" value=\"23\"/>\n        <!-- 对于对象的注入要用 ref -->\n    	<property name=\"school\" ref=\"mySchool\"/>\n    </bean>\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n</beans>\n```\n\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n\n*输出信息*\n```\n执行setName()\n执行setAge()\nStudent [name=张三, age=23, school=School [name=清华大学]]\n```\n##### 构造注入(很少用)\n和 `setter` 方法没有关系，和构造方法有关系。\n\n*Student.java - 为 Student 增加带参构造器*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n\n	/**\n	 * 带参数的构造方法\n	 */\n	public Student(String name, int age, School school) {\n		super();\n		this.name = name;\n		this.age = age;\n		this.school = school;\n	}\n	...\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n    <!-- 注册Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\n        <!-- 构造器参数，指定 name -->\n    	<constructor-arg name=\"name\" value=\"李四\"/>\n    	<constructor-arg name=\"age\" value=\"24\"/>\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\n\n        <!-- 构造器参数，使用索引 -->\n    	<!--\n    	<constructor-arg index=\"0\" value=\"李四\"/>\n    	<constructor-arg index=\"1\" value=\"24\"/>\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\n    	 -->\n\n        <!-- 构造器参数，默认索引 -->\n    	<!--\n    	<constructor-arg value=\"李四\"/>\n    	<constructor-arg value=\"24\"/>\n    	<constructor-arg ref=\"mySchool\"/>\n    	 -->\n    </bean>\n</beans>\n```\n#### 集合属性注入\n基本类型数组，对象数组，List，Set，Map，Properties 等。\n\n*School.java*\n```\npublic class School {\n	private String name;\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n*Some.java*\n```\npublic class Some {\n	private School[] schools; // 对象数组\n	private String[] myStrs; // 字符串数组\n	private List<String> myList; // List\n	private Set<String> mySet; // Set\n	private Map<String, Object> myMap; // Map\n	private Properties myPros; // Properties\n\n	public void setSchools(School[] schools) {\n		this.schools = schools;\n	}\n	public void setMyStrs(String[] myStrs) {\n		this.myStrs = myStrs;\n	}\n	public void setMyList(List<String> myList) {\n		this.myList = myList;\n	}\n	public void setMySet(Set<String> mySet) {\n		this.mySet = mySet;\n	}\n	public void setMyMap(Map<String, Object> myMap) {\n		this.myMap = myMap;\n	}\n	public void setMyPros(Properties myPros) {\n		this.myPros = myPros;\n	}\n\n	@Override\n	public String toString() {\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\n	}\n}\n```\n*applicationContext.xml*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"北京大学\"/>\n    </bean>\n\n    <!-- 注册 Student -->\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\n		<!-- 对象数组 -->\n    	<property name=\"schools\">\n    		<array>\n    			<ref bean=\"mySchool\"/>\n    			<ref bean=\"mySchool2\"/>\n    		</array>\n    	</property>\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\n		<property name=\"schools\" value=\"mySchool\"/>\n\n		<!-- 基本类型数组 -->\n    	<property name=\"myStrs\">\n    		<array>\n    			<value>中国</value>\n    			<value>北京</value>\n    		</array>\n    	</property>\n		<!-- 数组：简写 -->\n		<property name=\"myStrs\" value=\"中国,北京\"/>\n\n		<!-- List<String> -->\n    	<property name=\"myList\">\n    		<list>\n    			<value>大兴</value>\n    			<value>亦庄</value>\n    		</list>\n    	</property>\n		<!-- List<String>：简写 -->\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\n\n		<!-- Set<String> -->\n    	<property name=\"mySet\">\n    		<set>\n    			<value>大族企业湾</value>\n    			<value>10号楼</value>\n    		</set>\n    	</property>\n		<!-- Set<String>：简写 -->\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\n\n		<!-- Map<String, Object>，Map 的键值都是 object -->\n    	<property name=\"myMap\">\n    		<map>\n    			<entry key=\"mobile\" value=\"1234567\"/>\n    			<entry key=\"QQ\" value=\"7654321\"/>\n    		</map>\n    	</property>\n\n		<!-- Properties，Properties 的键值都是字符串 -->\n    	<property name=\"myPros\">\n    		<props>\n    			<prop key=\"education\">大学</prop>\n    			<prop key=\"gender\">男</prop>\n    		</props>\n    	</property>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载 Spring 配置文件\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Some some = (Some) ac.getBean(\"mySome\");\n	System.out.println(some);\n}\n```\n#### 对于域属性(对象)的自动注入\n##### byName 方式自动注入\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\n##### byType 方式自动注入\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)\n#### 使用 SPEL 注入\nSPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。\n*Person.java*\n```\npublic class Person {\n	private String pname;\n	private int page;\n\n	public void setPname(String pname) {\n		this.pname = pname;\n	}\n	public void setPage(int page) {\n		this.page = page;\n	}\n	public String getPname() {\n		return pname;\n	}\n	public int getPage() {\n		return page;\n	}\n\n	@Override\n	public String toString() {\n		return \"Person [pname=\" + pname + \", page=\" + page + \"]\";\n	}\n	\n	public int computeAge() {\n		return page > 25 ? 25 : page;\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	\n	public void setName(String name) {\n		this.name = name;\n	}\n	public void setAge(int age) {\n		this.age = age;\n	}\n	\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \"]\";\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"myPerson\" class=\"top.qingrang.di09.Person\">\n    	<property name=\"pname\" value=\"李四\"/>\n    	<property name=\"page\" value=\"#{T(java.lang.Math).random() * 50}\"/>   \n    </bean>\n    \n    <bean id=\"myStudent\" class=\"top.qingrang.di09.Student\">\n    	<property name=\"name\" value=\"#{myPerson.pname}\"/>\n    	<!-- <property name=\"age\" value=\"#{myPerson.page > 25 ? 25 : myPerson.page}\"/> -->\n    	<property name=\"age\" value=\"#{myPerson.computeAge() }\"/>\n    </bean>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di09/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	\n	Person person = (Person) ac.getBean(\"myPerson\");\n	System.out.println(person);\n	\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n#### 使用内部 Bean 注入\n若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。\n\n*applicationContext.mxl*\n```\n<!-- 注册 Student -->\n<bean id=\"myStudent\" class=\"top.qingrang.di10.Student\">\n	<property name=\"name\" value=\"张三\"/>\n	<property name=\"age\" value=\"23\"/>\n	<property name=\"school\">\n		<!-- 内部 Bean -->\n	    <bean class=\"top.qingrang.di10.School\">\n	    	<property name=\"name\" value=\"清华大学\"/>\n	    </bean>\n	</property>\n</bean>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di10/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n	\n	// 不能访问，会报错\n	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined\n	School school = (School) ac.getBean(\"mySchool\");\n	System.out.println(school);\n}\n```\n\n\n#### 使用同类抽象 Bean 注入\n当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。\n\n抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private String school; // 学校\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public void setAge(int age) {\n		this.age = age;\n	}\n\n	public void setSchool(String school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school + \"]\";\n	}\n}\n```\n*applicationContext.mxl*\n```\n<!-- 同类抽象 Bean，abstract=\"true\" -->\n<bean id=\"baseStudent\" class=\"top.qingrang.di11.Student\" abstract=\"true\">\n	<property name=\"school\" value=\"清华大学\"/>\n</bean>\n<!-- 利用 parent 实现继承 -->\n<bean id=\"myStudent\" parent=\"baseStudent\">\n	<property name=\"name\" value=\"张三\"/>\n	<property name=\"age\" value=\"23\"/>\n</bean>\n<bean id=\"myStudent2\" parent=\"baseStudent\">\n	<property name=\"name\" value=\"李四\"/>\n	<property name=\"age\" value=\"24\"/>\n</bean>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di11/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n	Student student2 = (Student) ac.getBean(\"myStudent2\");\n	System.out.println(student2);\n}\n```\n#### 使用异类抽象 Bean 注入\n当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。\n![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)\n#### 为应用指定多个 Spring 配置文件\n在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。\n##### 平等关系的配置文件\n假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`\n```\n@Test\npublic void test01() {\n	// 可变参数\n	String resource = \"top/qingrang/di13/spring-base.xml\";\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);\n	// 参数数组\n	String resource = \"top/qingrang/di13/spring-base.xml\";\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\n	String[] resources = {resource, resource2};\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);\n	// 通配符\n	String resource = \"top/qingrang/di13/spring-*.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n	Teacher teacher = (Teacher) ac.getBean(\"myTeacher\");\n	System.out.println(teacher);\n}\n```\n##### 包含关系的配置文件\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n	<!-- \n	<import resource=\"classpath:top/qingrang/di14/spring-base.xml\"/>\n	<import resource=\"classpath:top/qingrang/di14/spring-beans.xml\"/>\n	 -->\n\n	<!-- 使用通配符 -->\n	<import resource=\"classpath:top/qingrang/di14/spring-*.xml\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	String resource = \"top/qingrang/di14/springTotal.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	...\n}\n```\n### 基于注解的 DI\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001978s ]
---------------------------------------------------------------
[ 2018-11-18T20:17:12+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.067952s][吞吐率：14.72req/s] [内存消耗：2,288.10kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '62778',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
#### 注入分类
##### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
#### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>

		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)
#### 使用 SPEL 注入
SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。
*Person.java*
```
public class Person {
	private String pname;
	private int page;

	public void setPname(String pname) {
		this.pname = pname;
	}
	public void setPage(int page) {
		this.page = page;
	}
	public String getPname() {
		return pname;
	}
	public int getPage() {
		return page;
	}

	@Override
	public String toString() {
		return "Person [pname=" + pname + ", page=" + page + "]";
	}
	
	public int computeAge() {
		return page > 25 ? 25 : page;
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="myPerson" class="top.qingrang.di09.Person">
    	<property name="pname" value="李四"/>
    	<property name="page" value="#{T(java.lang.Math).random() * 50}"/>   
    </bean>
    
    <bean id="myStudent" class="top.qingrang.di09.Student">
    	<property name="name" value="#{myPerson.pname}"/>
    	<!-- <property name="age" value="#{myPerson.page > 25 ? 25 : myPerson.page}"/> -->
    	<property name="age" value="#{myPerson.computeAge() }"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Person person = (Person) ac.getBean("myPerson");
	System.out.println(person);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
#### 使用内部 Bean 注入
若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。

*applicationContext.mxl*
```
<!-- 注册 Student -->
<bean id="myStudent" class="top.qingrang.di10.Student">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
	<property name="school">
		<!-- 内部 Bean -->
	    <bean class="top.qingrang.di10.School">
	    	<property name="name" value="清华大学"/>
	    </bean>
	</property>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di10/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	
	// 不能访问，会报错
	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined
	School school = (School) ac.getBean("mySchool");
	System.out.println(school);
}
```


#### 使用同类抽象 Bean 注入
当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。

抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private String school; // 学校

	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setSchool(String school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<!-- 同类抽象 Bean，abstract="true" -->
<bean id="baseStudent" class="top.qingrang.di11.Student" abstract="true">
	<property name="school" value="清华大学"/>
</bean>
<!-- 利用 parent 实现继承 -->
<bean id="myStudent" parent="baseStudent">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
</bean>
<bean id="myStudent2" parent="baseStudent">
	<property name="name" value="李四"/>
	<property name="age" value="24"/>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Student student2 = (Student) ac.getBean("myStudent2");
	System.out.println(student2);
}
```
#### 使用异类抽象 Bean 注入
当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。
![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)
#### 为应用指定多个 Spring 配置文件
在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。
##### 平等关系的配置文件
假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`
```
@Test
public void test01() {
	// 可变参数
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);
	// 参数数组
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	String[] resources = {resource, resource2};
	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);
	// 通配符
	String resource = "top/qingrang/di13/spring-*.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Teacher teacher = (Teacher) ac.getBean("myTeacher");
	System.out.println(teacher);
}
```
##### 包含关系的配置文件
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!-- 
	<import resource="classpath:top/qingrang/di14/spring-base.xml"/>
	<import resource="classpath:top/qingrang/di14/spring-beans.xml"/>
	 -->

	<!-- 使用通配符 -->
	<import resource="classpath:top/qingrang/di14/spring-*.xml"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di14/springTotal.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	...
}
```
### 基于注解的 DI
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000785s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001577s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\n#### 默认装配方式\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	public SomeServiceImpl() {\n		System.out.println(\"执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 动态工厂 Bean\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	//静态方法\n	public static ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n#### Bean 后处理器\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\n\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\n\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\n\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\n\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\n\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\n\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\n\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	String doSome();\n	String doOther();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public String doSome() {\n		System.out.println(\"执行doSome()方法\");\n		return \"doSome() - abc\";\n	}\n	\n	@Override\n	public String doOther() {\n		System.out.println(\"执行doOther()方法\");\n		return \"doOther() - def\";\n	}\n}\n```\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n\n	// bean：表示当前正在进行初始化的Bean对象\n	// beanName：表示当前正在进行初始化的Bean对象的id\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- before() ---方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\n		System.out.println(\"执行 ---- after() ---方法\");\n		//判断 SomeServiceImpl 对象\n		if (\"myService\".equals(beanName)) {\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\n					bean.getClass().getInterfaces(),\n					new InvocationHandler() {\n						@Override\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n							Object invoke = method.invoke(bean, args);\n							//判断具体方法\n							if (\"doSome\".equals(method.getName())) {\n								return ((String) invoke).toUpperCase();\n							}\n							return invoke;\n						}\n					});\n			return obj;\n		}\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\n\n    <!-- 注册 Bean 后处理器 -->\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	System.out.println(service.doSome());\n	System.out.println(service.doOther());\n\n	System.out.println(\"======================\");\n\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\n	System.out.println(service2.doSome());\n	System.out.println(service2.doOther());\n}\n```\n\n*输出结果*\n```\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行 ---- before() ---方法\n执行 ---- after() ---方法\n执行doSome()方法\nDOSOME() - ABC\n执行doOther()方法\ndoOther() - def\n======================\n执行doSome()方法\ndoSome() - abc\n执行doOther()方法\ndoOther() - def\n```\n\n\n#### Bean 的生命周期\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\n	private String adao;\n	private String bdao;\n\n	public void setAdao(String adao) {\n		this.adao = adao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public void setBdao(String bdao) {\n		this.bdao = bdao;\n		System.out.println(\"Step2：执行 setter\");\n	}\n\n	public SomeServiceImpl() {\n		System.out.println(\"Step1：执行无参构造器\");\n	}\n\n	@Override\n	public void doSome() {\n		System.out.println(\"Step9：执行 doSome() 方法\");\n	}\n\n	public void setUp() {\n		System.out.println(\"Step7：初始化完毕之后\");\n	}\n\n	public void tearDown() {\n		System.out.println(\"Step11：销毁之前\");\n	}\n\n	@Override\n	public void setBeanName(String name) {\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\n	}\n\n	@Override\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\n	}\n\n	@Override\n	public void afterPropertiesSet() throws Exception {\n		System.out.println(\"Step6：Bean 初始化完毕了\");\n	}\n\n	@Override\n	public void destroy() throws Exception {\n		System.out.println(\"Step10：实现接口的销毁之前\");\n	}\n}\n```\n*MyBeanPostProcessor.java - Bean 后处理器*\n```\npublic class MyBeanPostProcessor implements BeanPostProcessor {\n	@Override\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\n		return bean;\n	}\n\n	@Override\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\n			throws BeansException {\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\n		return bean;\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册Service -->\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\n    	<property name=\"adao\" value=\"aaa\"/>\n    	<property name=\"bdao\" value=\"bbb\"/>\n   	</bean>\n\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n	// 对于销毁方法的执行，有两个条件：\n	// 1)当前的Bean需要是singleton的\n	// 2)要手工关闭容器\n	((ClassPathXmlApplicationContext)ac).close();\n}\n```\n\n*输出信息*\n```\nStep1：执行无参构造器\nStep2：执行 setter\nStep2：执行 setter\nStep3：获取到 bean 的 id = myService\nStep4：获取到 BeanFactory 容器\nStep5：MyBeanPostProcessor - 执行 before() 方法\nStep6：Bean 初始化完毕了\nStep7：初始化完毕之后\nStep8：MyBeanPostProcessor - 执行 after() 方法\nStep9：执行 doSome() 方法\nStep10：实现接口的销毁之前\nStep11：销毁之前\n```\n### 基于 XML 的 DI\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\n#### 注入分类\n##### 设值注入(常用)\n和 `setter` 方法有关系。\n\n*School.java*\n```\npublic class School {\n	private String name;\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n	\n	public void setName(String name) {\n		System.out.println(\"执行setName()\");\n		this.name = name;\n	}\n	public void setAge(int age) {\n		System.out.println(\"执行setAge()\");\n		this.age = age;\n	}\n	public void setSchool(School school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\n				+ \"]\";\n	}\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\n    	<property name=\"name\" value=\"张三\"/>\n    	<property name=\"age\" value=\"23\"/>\n        <!-- 对于对象的注入要用 ref -->\n    	<property name=\"school\" ref=\"mySchool\"/>\n    </bean>\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n</beans>\n```\n\n*Test.java - 测试*\n```\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n\n*输出信息*\n```\n执行setName()\n执行setAge()\nStudent [name=张三, age=23, school=School [name=清华大学]]\n```\n##### 构造注入(很少用)\n和 `setter` 方法没有关系，和构造方法有关系。\n\n*Student.java - 为 Student 增加带参构造器*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private School school;   // 对象属性，域属性\n\n	/**\n	 * 带参数的构造方法\n	 */\n	public Student(String name, int age, School school) {\n		super();\n		this.name = name;\n		this.age = age;\n		this.school = school;\n	}\n	...\n}\n```\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n\n    <!-- 注册Student -->\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\n        <!-- 构造器参数，指定 name -->\n    	<constructor-arg name=\"name\" value=\"李四\"/>\n    	<constructor-arg name=\"age\" value=\"24\"/>\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\n\n        <!-- 构造器参数，使用索引 -->\n    	<!--\n    	<constructor-arg index=\"0\" value=\"李四\"/>\n    	<constructor-arg index=\"1\" value=\"24\"/>\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\n    	 -->\n\n        <!-- 构造器参数，默认索引 -->\n    	<!--\n    	<constructor-arg value=\"李四\"/>\n    	<constructor-arg value=\"24\"/>\n    	<constructor-arg ref=\"mySchool\"/>\n    	 -->\n    </bean>\n</beans>\n```\n#### 集合属性注入\n基本类型数组，对象数组，List，Set，Map，Properties 等。\n\n*School.java*\n```\npublic class School {\n	private String name;\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	@Override\n	public String toString() {\n		return \"School [name=\" + name + \"]\";\n	}\n}\n```\n*Some.java*\n```\npublic class Some {\n	private School[] schools; // 对象数组\n	private String[] myStrs; // 字符串数组\n	private List<String> myList; // List\n	private Set<String> mySet; // Set\n	private Map<String, Object> myMap; // Map\n	private Properties myPros; // Properties\n\n	public void setSchools(School[] schools) {\n		this.schools = schools;\n	}\n	public void setMyStrs(String[] myStrs) {\n		this.myStrs = myStrs;\n	}\n	public void setMyList(List<String> myList) {\n		this.myList = myList;\n	}\n	public void setMySet(Set<String> mySet) {\n		this.mySet = mySet;\n	}\n	public void setMyMap(Map<String, Object> myMap) {\n		this.myMap = myMap;\n	}\n	public void setMyPros(Properties myPros) {\n		this.myPros = myPros;\n	}\n\n	@Override\n	public String toString() {\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\n	}\n}\n```\n*applicationContext.xml*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 School -->\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"清华大学\"/>\n    </bean>\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\n    	<property name=\"name\" value=\"北京大学\"/>\n    </bean>\n\n    <!-- 注册 Student -->\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\n		<!-- 对象数组 -->\n    	<property name=\"schools\">\n    		<array>\n    			<ref bean=\"mySchool\"/>\n    			<ref bean=\"mySchool2\"/>\n    		</array>\n    	</property>\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\n		<property name=\"schools\" value=\"mySchool\"/>\n\n		<!-- 基本类型数组 -->\n    	<property name=\"myStrs\">\n    		<array>\n    			<value>中国</value>\n    			<value>北京</value>\n    		</array>\n    	</property>\n		<!-- 数组：简写 -->\n		<property name=\"myStrs\" value=\"中国,北京\"/>\n\n		<!-- List<String> -->\n    	<property name=\"myList\">\n    		<list>\n    			<value>大兴</value>\n    			<value>亦庄</value>\n    		</list>\n    	</property>\n		<!-- List<String>：简写 -->\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\n\n		<!-- Set<String> -->\n    	<property name=\"mySet\">\n    		<set>\n    			<value>大族企业湾</value>\n    			<value>10号楼</value>\n    		</set>\n    	</property>\n		<!-- Set<String>：简写 -->\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\n\n		<!-- Map<String, Object>，Map 的键值都是 object -->\n    	<property name=\"myMap\">\n    		<map>\n    			<entry key=\"mobile\" value=\"1234567\"/>\n    			<entry key=\"QQ\" value=\"7654321\"/>\n    		</map>\n    	</property>\n\n		<!-- Properties，Properties 的键值都是字符串 -->\n    	<property name=\"myPros\">\n    		<props>\n    			<prop key=\"education\">大学</prop>\n    			<prop key=\"gender\">男</prop>\n    		</props>\n    	</property>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载 Spring 配置文件\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	Some some = (Some) ac.getBean(\"mySome\");\n	System.out.println(some);\n}\n```\n#### 对于域属性(对象)的自动注入\n##### byName 方式自动注入\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\n##### byType 方式自动注入\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)\n#### 使用 SPEL 注入\nSPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。\n*Person.java*\n```\npublic class Person {\n	private String pname;\n	private int page;\n\n	public void setPname(String pname) {\n		this.pname = pname;\n	}\n	public void setPage(int page) {\n		this.page = page;\n	}\n	public String getPname() {\n		return pname;\n	}\n	public int getPage() {\n		return page;\n	}\n\n	@Override\n	public String toString() {\n		return \"Person [pname=\" + pname + \", page=\" + page + \"]\";\n	}\n	\n	public int computeAge() {\n		return page > 25 ? 25 : page;\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	\n	public void setName(String name) {\n		this.name = name;\n	}\n	public void setAge(int age) {\n		this.age = age;\n	}\n	\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \"]\";\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册School -->\n    <bean id=\"myPerson\" class=\"top.qingrang.di09.Person\">\n    	<property name=\"pname\" value=\"李四\"/>\n    	<property name=\"page\" value=\"#{T(java.lang.Math).random() * 50}\"/>   \n    </bean>\n    \n    <bean id=\"myStudent\" class=\"top.qingrang.di09.Student\">\n    	<property name=\"name\" value=\"#{myPerson.pname}\"/>\n    	<!-- <property name=\"age\" value=\"#{myPerson.page > 25 ? 25 : myPerson.page}\"/> -->\n    	<property name=\"age\" value=\"#{myPerson.computeAge() }\"/>\n    </bean>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di09/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	\n	Person person = (Person) ac.getBean(\"myPerson\");\n	System.out.println(person);\n	\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n}\n```\n#### 使用内部 Bean 注入\n若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。\n\n*applicationContext.mxl*\n```\n<!-- 注册 Student -->\n<bean id=\"myStudent\" class=\"top.qingrang.di10.Student\">\n	<property name=\"name\" value=\"张三\"/>\n	<property name=\"age\" value=\"23\"/>\n	<property name=\"school\">\n		<!-- 内部 Bean -->\n	    <bean class=\"top.qingrang.di10.School\">\n	    	<property name=\"name\" value=\"清华大学\"/>\n	    </bean>\n	</property>\n</bean>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di10/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n	\n	// 不能访问，会报错\n	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined\n	School school = (School) ac.getBean(\"mySchool\");\n	System.out.println(school);\n}\n```\n\n\n#### 使用同类抽象 Bean 注入\n当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。\n\n抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。\n\n*Student.java*\n```\npublic class Student {\n	private String name;\n	private int age;\n	private String school; // 学校\n\n	public void setName(String name) {\n		this.name = name;\n	}\n\n	public void setAge(int age) {\n		this.age = age;\n	}\n\n	public void setSchool(String school) {\n		this.school = school;\n	}\n\n	@Override\n	public String toString() {\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school + \"]\";\n	}\n}\n```\n*applicationContext.mxl*\n```\n<!-- 同类抽象 Bean，abstract=\"true\" -->\n<bean id=\"baseStudent\" class=\"top.qingrang.di11.Student\" abstract=\"true\">\n	<property name=\"school\" value=\"清华大学\"/>\n</bean>\n<!-- 利用 parent 实现继承 -->\n<bean id=\"myStudent\" parent=\"baseStudent\">\n	<property name=\"name\" value=\"张三\"/>\n	<property name=\"age\" value=\"23\"/>\n</bean>\n<bean id=\"myStudent2\" parent=\"baseStudent\">\n	<property name=\"name\" value=\"李四\"/>\n	<property name=\"age\" value=\"24\"/>\n</bean>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/di11/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n	Student student2 = (Student) ac.getBean(\"myStudent2\");\n	System.out.println(student2);\n}\n```\n#### 使用异类抽象 Bean 注入\n当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。\n![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)\n#### 为应用指定多个 Spring 配置文件\n在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。\n##### 平等关系的配置文件\n假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`\n```\n@Test\npublic void test01() {\n	// 可变参数\n	String resource = \"top/qingrang/di13/spring-base.xml\";\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);\n	// 参数数组\n	String resource = \"top/qingrang/di13/spring-base.xml\";\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\n	String[] resources = {resource, resource2};\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);\n	// 通配符\n	String resource = \"top/qingrang/di13/spring-*.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n\n	Student student = (Student) ac.getBean(\"myStudent\");\n	System.out.println(student);\n	Teacher teacher = (Teacher) ac.getBean(\"myTeacher\");\n	System.out.println(teacher);\n}\n```\n##### 包含关系的配置文件\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n	<!-- \n	<import resource=\"classpath:top/qingrang/di14/spring-base.xml\"/>\n	<import resource=\"classpath:top/qingrang/di14/spring-beans.xml\"/>\n	 -->\n\n	<!-- 使用通配符 -->\n	<import resource=\"classpath:top/qingrang/di14/spring-*.xml\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	String resource = \"top/qingrang/di14/springTotal.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	...\n}\n```\n### 基于注解的 DI\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001424s ]
---------------------------------------------------------------
[ 2018-11-18T22:04:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/208.html
[ info ] qingrang.top/daily/admin/note/editnote/id/208.html [运行时间：0.064980s][吞吐率：15.39req/s] [内存消耗：2,031.16kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '208',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000950s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001413s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000453s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000904s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000292s ]
---------------------------------------------------------------
[ 2018-11-18T22:05:16+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/208.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/208.html [运行时间：0.073711s][吞吐率：13.57req/s] [内存消耗：2,071.16kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '7051',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/208.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Code 自定义快捷键
[TOC]
## 常用
### 删除行 `Ctrl + d`
### 向下复制行 `Ctrl + b`
### 移动行 `Alt + Up/Down`
### 上开新行 `Ctrl + shift + enter`
### 下开新行 `Ctrl + enter`
### 行注释 `Ctrl + /`
### 块注释 `Ctrl + Shift + /`
### 提示 `alt + /`
### 添加 getter、setter 方法 `alt + insert`
### 替换文本 `Ctrl + R`
### 格式化代码 `ctrl + alt + l`
### 抽取局部变量 `ctrl + alt + v`
### 用if、while、try catch来围绕选中的代码行 `Ctrl + Alt + T`
### Generate 菜单 `alt + a`
### 抽取方法 `Ctrl + M`

## Eclipse
### 批量修改 ALT+SHIFT+R
### 快速输入
- 主方法
1. 敲入main
2. alt+/
- System.out.println
1. 敲入syso
2. alt+/
- 快速输入for
1. 敲入for
2. alt+/
### 代码格式化 ctrl+shift+f
### import类 ctrl+shift+o
### 快速注释 选中一行或者多行代码 ctrl+shift+c
### 快速解决办法提示 ctrl+1
在出错误的行，使用ctrl+1。 比如忘记导入类了，就可以用这个解决
### 方法的快速生成 shift+alt+s

---

## Sublime Text 3
### 键盘快捷键
https://blog.csdn.net/u010994304/article/details/50866634

// Ctrl+Enter
// 插入行后

// Ctrl+Shift Enter
// 插入行前

// Shift+Tab
// 去除缩进

// Tab
// 缩进

// Ctrl+KK
// 从光标处删除至行尾
```
[
	// 删除当前行
	{ "keys": ["ctrl+d"], "command":"run_macro_file", "args": {"file":"Packages/Default/Delete Line.sublime-macro"} },
	
	// 与上行互换
	{ "keys": ["alt+up"], "command":"swap_line_up" },
	// 与下行互换
	{ "keys": ["alt+down"], "command":"swap_line_down" },

	// 向下复制行
	{ "keys": ["ctrl+alt+down"], "command":"duplicate_line" },
	
	// 自动提示、补全
	{ "keys": ["alt+/"], "command":"auto_complete" },
	{ "keys": ["alt+/"], "command":"replace_completion_with_auto_complete", "context":
	[
	{ "key": "last_command", "operator":"equal", "operand": "insert_best_completion" },
	{ "key": "auto_complete_visible", "operator":"equal", "operand": false },
	{ "key": "setting.tab_completion", "operator":"equal", "operand": true }
	]
	},

	//移动光标到行首或行末
	{ "keys": ["alt+b"], "command":"move_to", "args": {"to": "bol","extend": false} },
	{ "keys": ["alt+e"], "command":"move_to", "args": {"to": "eol","extend": false} },
	//移动光标到行首或行末并选择内容
	{ "keys": ["shift+alt+b"], "command":"move_to", "args": {"to": "bol","extend": true} },
	{ "keys": ["shift+alt+e"], "command":"move_to", "args": {"to": "eol","extend": true} },

]
```
### 配置 ctrl + 鼠标左键 进行函数跳转
点击 Preferences->Browse Packages 进入 Packages 目录，然后打开 User 目录，查看User目录里面有没有`Default (Windows).sublime-mousemap`文件，如果没有则创建一个。这个文件是用来配置 sublime 的鼠标操作的。在文件中输入如下内容：
```
[
{
"button": "button2",
"count": 1,
"modifiers": ["ctrl"],
"command": "jump_back"
},


{
"button": "button1",
"count": 1,
"modifiers": ["ctrl"],
"press_command": "drag_select",
"command": "goto_definition"
}
]
```
点击保存即可。

ctrl+鼠标左键跳转到函数定义处；

ctrl+鼠标右键跳回来。
',
  'groups' => 'Basics',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '208',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000736s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001344s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000490s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000307s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001106s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.000361s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000340s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=208,`p_id`=2,`title`='Code 自定义快捷键\r',`content`='# Code 自定义快捷键\r\n[TOC]\r\n## 常用\r\n### 删除行 `Ctrl + d`\r\n### 向下复制行 `Ctrl + b`\r\n### 移动行 `Alt + Up/Down`\r\n### 上开新行 `Ctrl + shift + enter`\r\n### 下开新行 `Ctrl + enter`\r\n### 行注释 `Ctrl + /`\r\n### 块注释 `Ctrl + Shift + /`\r\n### 提示 `alt + /`\r\n### 添加 getter、setter 方法 `alt + insert`\r\n### 替换文本 `Ctrl + R`\r\n### 格式化代码 `ctrl + alt + l`\r\n### 抽取局部变量 `ctrl + alt + v`\r\n### 用if、while、try catch来围绕选中的代码行 `Ctrl + Alt + T`\r\n### Generate 菜单 `alt + a`\r\n### 抽取方法 `Ctrl + M`\r\n\r\n## Eclipse\r\n### 批量修改 ALT+SHIFT+R\r\n### 快速输入\r\n- 主方法\r\n1. 敲入main\r\n2. alt+/\r\n- System.out.println\r\n1. 敲入syso\r\n2. alt+/\r\n- 快速输入for\r\n1. 敲入for\r\n2. alt+/\r\n### 代码格式化 ctrl+shift+f\r\n### import类 ctrl+shift+o\r\n### 快速注释 选中一行或者多行代码 ctrl+shift+c\r\n### 快速解决办法提示 ctrl+1\r\n在出错误的行，使用ctrl+1。 比如忘记导入类了，就可以用这个解决\r\n### 方法的快速生成 shift+alt+s\r\n\r\n---\r\n\r\n## Sublime Text 3\r\n### 键盘快捷键\r\nhttps://blog.csdn.net/u010994304/article/details/50866634\r\n\r\n// Ctrl+Enter\r\n// 插入行后\r\n\r\n// Ctrl+Shift Enter\r\n// 插入行前\r\n\r\n// Shift+Tab\r\n// 去除缩进\r\n\r\n// Tab\r\n// 缩进\r\n\r\n// Ctrl+KK\r\n// 从光标处删除至行尾\r\n```\r\n[\r\n	// 删除当前行\r\n	{ \"keys\": [\"ctrl+d\"], \"command\":\"run_macro_file\", \"args\": {\"file\":\"Packages/Default/Delete Line.sublime-macro\"} },\r\n	\r\n	// 与上行互换\r\n	{ \"keys\": [\"alt+up\"], \"command\":\"swap_line_up\" },\r\n	// 与下行互换\r\n	{ \"keys\": [\"alt+down\"], \"command\":\"swap_line_down\" },\r\n\r\n	// 向下复制行\r\n	{ \"keys\": [\"ctrl+alt+down\"], \"command\":\"duplicate_line\" },\r\n	\r\n	// 自动提示、补全\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"auto_complete\" },\r\n	{ \"keys\": [\"alt+/\"], \"command\":\"replace_completion_with_auto_complete\", \"context\":\r\n	[\r\n	{ \"key\": \"last_command\", \"operator\":\"equal\", \"operand\": \"insert_best_completion\" },\r\n	{ \"key\": \"auto_complete_visible\", \"operator\":\"equal\", \"operand\": false },\r\n	{ \"key\": \"setting.tab_completion\", \"operator\":\"equal\", \"operand\": true }\r\n	]\r\n	},\r\n\r\n	//移动光标到行首或行末\r\n	{ \"keys\": [\"alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": false} },\r\n	{ \"keys\": [\"alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": false} },\r\n	//移动光标到行首或行末并选择内容\r\n	{ \"keys\": [\"shift+alt+b\"], \"command\":\"move_to\", \"args\": {\"to\": \"bol\",\"extend\": true} },\r\n	{ \"keys\": [\"shift+alt+e\"], \"command\":\"move_to\", \"args\": {\"to\": \"eol\",\"extend\": true} },\r\n\r\n]\r\n```\r\n### 配置 ctrl + 鼠标左键 进行函数跳转\r\n点击 Preferences->Browse Packages 进入 Packages 目录，然后打开 User 目录，查看User目录里面有没有`Default (Windows).sublime-mousemap`文件，如果没有则创建一个。这个文件是用来配置 sublime 的鼠标操作的。在文件中输入如下内容：\r\n```\r\n[\r\n{\r\n\"button\": \"button2\",\r\n\"count\": 1,\r\n\"modifiers\": [\"ctrl\"],\r\n\"command\": \"jump_back\"\r\n},\r\n\r\n\r\n{\r\n\"button\": \"button1\",\r\n\"count\": 1,\r\n\"modifiers\": [\"ctrl\"],\r\n\"press_command\": \"drag_select\",\r\n\"command\": \"goto_definition\"\r\n}\r\n]\r\n```\r\n点击保存即可。\r\n\r\nctrl+鼠标左键跳转到函数定义处；\r\n\r\nctrl+鼠标右键跳回来。\r\n',`groups`='Basics',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 208 [ RunTime:0.000639s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.001836s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Basics' [ RunTime:0.000338s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Basics' LIMIT 1 [ RunTime:0.001042s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Basics' [ RunTime:0.000306s ]
---------------------------------------------------------------
[ 2018-11-18T22:05:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/208.html
[ info ] qingrang.top/daily/admin/note/shownote/id/208.html [运行时间：0.062448s][吞吐率：16.01req/s] [内存消耗：1,983.05kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/208.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '208',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002270s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001349s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 208 LIMIT 1 [ RunTime:0.000461s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000920s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000281s ]
---------------------------------------------------------------
[ 2018-11-18T22:07:42+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.064623s][吞吐率：15.47req/s] [内存消耗：2,020.94kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000629s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001895s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000465s ]
---------------------------------------------------------------
[ 2018-11-18T22:07:47+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.080007s][吞吐率：12.50req/s] [内存消耗：2,364.98kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '86640',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring - IOC（控制反转）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
#### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
### 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
#### 注入分类
##### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
##### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
#### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>

		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
#### 对于域属性(对象)的自动注入
##### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
##### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)
#### 使用 SPEL 注入
SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。
*Person.java*
```
public class Person {
	private String pname;
	private int page;

	public void setPname(String pname) {
		this.pname = pname;
	}
	public void setPage(int page) {
		this.page = page;
	}
	public String getPname() {
		return pname;
	}
	public int getPage() {
		return page;
	}

	@Override
	public String toString() {
		return "Person [pname=" + pname + ", page=" + page + "]";
	}
	
	public int computeAge() {
		return page > 25 ? 25 : page;
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="myPerson" class="top.qingrang.di09.Person">
    	<property name="pname" value="李四"/>
    	<property name="page" value="#{T(java.lang.Math).random() * 50}"/>   
    </bean>
    
    <bean id="myStudent" class="top.qingrang.di09.Student">
    	<property name="name" value="#{myPerson.pname}"/>
    	<!-- <property name="age" value="#{myPerson.page > 25 ? 25 : myPerson.page}"/> -->
    	<property name="age" value="#{myPerson.computeAge() }"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Person person = (Person) ac.getBean("myPerson");
	System.out.println(person);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
#### 使用内部 Bean 注入
若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。

*applicationContext.mxl*
```
<!-- 注册 Student -->
<bean id="myStudent" class="top.qingrang.di10.Student">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
	<property name="school">
		<!-- 内部 Bean -->
	    <bean class="top.qingrang.di10.School">
	    	<property name="name" value="清华大学"/>
	    </bean>
	</property>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di10/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	
	// 不能访问，会报错
	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined
	School school = (School) ac.getBean("mySchool");
	System.out.println(school);
}
```


#### 使用同类抽象 Bean 注入
当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。

抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private String school; // 学校

	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setSchool(String school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<!-- 同类抽象 Bean，abstract="true" -->
<bean id="baseStudent" class="top.qingrang.di11.Student" abstract="true">
	<property name="school" value="清华大学"/>
</bean>
<!-- 利用 parent 实现继承 -->
<bean id="myStudent" parent="baseStudent">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
</bean>
<bean id="myStudent2" parent="baseStudent">
	<property name="name" value="李四"/>
	<property name="age" value="24"/>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Student student2 = (Student) ac.getBean("myStudent2");
	System.out.println(student2);
}
```
#### 使用异类抽象 Bean 注入
当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。
![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)
#### 为应用指定多个 Spring 配置文件
在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。
##### 平等关系的配置文件
假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`
```
@Test
public void test01() {
	// 可变参数
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);
	// 参数数组
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	String[] resources = {resource, resource2};
	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);
	// 通配符
	String resource = "top/qingrang/di13/spring-*.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Teacher teacher = (Teacher) ac.getBean("myTeacher");
	System.out.println(teacher);
}
```
##### 包含关系的配置文件
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!-- 
	<import resource="classpath:top/qingrang/di14/spring-base.xml"/>
	<import resource="classpath:top/qingrang/di14/spring-beans.xml"/>
	 -->

	<!-- 使用通配符 -->
	<import resource="classpath:top/qingrang/di14/spring-*.xml"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di14/springTotal.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	...
}
```
### 基于注解的 DI
对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。
#### 定义 Bean `@Component`
- 与 `@Component` 注解功能相同，但意义不同的注解还有三个：
	- `@Repository`：注解在 Dao 实现类上
	- `@Service`：注解在 Service 实现类上
	- `@Controller`：注解在 SpringMVC 的处理器上

#### Bean 的作用域 `@Scope`
#### 基本类型属性注入 `@Value`
#### 按类型注入域属性 `@Autowired`
需要在域属性上使用注解 `@Autowired`，该注解默认使用按类型自动装配 Bean 的方式。使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。
#### 按名称注入域属性 `@Autowired` 与 `@Qualifier`
需要在域属性上联合使用注解 `@Autowired` 与 `@Qualifier`。 `@Qualifier` 的 value 属性用于指定要匹配的 Bean 的 id 值。同样类中无需 setter，也可加到 setter 上。
#### 域属性注解 `@Resource`
Spring 提供了对 JSR-250 规范中定义 `@Resource` 标准注解的支持。 `@Resource` 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。
#### Bean 的生命始末 `@PostConstruct` 与 `@PreDestroy`
在方法上使用 `@PostConstruct`，与原来的 `init-method` 等效。在方法上使 `@PreDestroy`，与 `destroy-method` 等效。

*School.java*
```
// 组件，表示当前类被 Spring 容器所管理
@Component("mySchool")
public class School {
	@Value("清华大学")
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
// @Scope("prototype")   // 默认也是 singleton
@Component("myStudent")
public class Student {
	@Value("张三")
	private String name;
	@Value("23")
	private int age;

// ------------------- byType 方式的注解式注入 -------------------
//	@Autowired
//	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

// ----- byName 方式的注解式注入，要求 @Autowired 与 @Qualifier 联合使用 ----
//	@Autowired
//	@Qualifier("mySchool")
//	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

// -------------------- 域属性注解 @Resource --------------------
	// @Resource(name="mySchool")   // byName 方式的注解式注入
	@Resource   // byType 方式的注解式注入
	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}

	// Bean 的生命始 @PostConstruct
	@PostConstruct
	public void initAfter() {
		System.out.println("当前Bean初始化刚完毕");
	}

	// Bean 的生命末 @PreDestroy
	@PreDestroy
	public void preDestroy() {
		System.out.println("当前Bean即将被销毁");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">
        
	<!-- 组件扫描 top.qingrang 这个包及其子包 -->
	<!--<context:component-scan base-package="top.qingrang"/> -->
	
	<!-- 组件扫描 top.qingrang 这个包的子包 -->
	<!--<context:component-scan base-package="top.qingrang.*"/> -->
	
	<context:component-scan base-package="top.qingrang.di01"/>
	
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
#### 使用 JavaConfig 进行配置
JavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。
JavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML文件，而是由程序员使用 Java 自己编写的 Java 类。

*School.java*
```
public class School {
	private String name;

	public School() {
		super();
		// TODO Auto-generated constructor stub
	}

	public School(String name) {
		super();
		this.name = name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school; // 对象属性，域属性

	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}

	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}

	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```
*MyJavaConfig.java*
```
@Configuration    // 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建
public class MyJavaConfig {
	
	@Bean(name="school")
	public School mySchoolCreator() {
		return new School("北京大学");
	}
	
	// autowire=Autowire.BY_TYPE 指从当前类这个容器中查找与域属性的类型具有is-a关系的Bean
	/*
	@Bean(name="myStudent", autowire=Autowire.BY_TYPE)
	public Student myStudentCreator() {
		return new Student("张三", 23);
	}
	*/
	
	// autowire=Autowire.BY_NAME 指从当前类这个容器中查找与域属性同名的Bean
	@Bean(name="myStudent", autowire=Autowire.BY_NAME)
	public Student myStudentCreator() {
		return new Student("张三", 23);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 扫描组件 -->
	<context:component-scan base-package="top.qingrang.di05"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
#### 使用 Spring 的 JUnit4 测试 Spring
使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，及从 Spring 容器中通过 getBean() 获取对象了。这些工作将由 JUnit4 注解，配合着域属性的自动注入注解共同完成。
*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		this.name = name;
	}

	public void setSchool(School school) {
		this.school = school;
	}
	@Override
	public String toString() {
		return "Student [name=" + name + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di06.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di06.Student">
    	<property name="name" value="张三"/>
    	<property name="school" ref="mySchool"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@RunWith(SpringJUnit4ClassRunner.class)	// 指定运行环境
@ContextConfiguration(locations="classpath:top/qingrang/di06/applicationContext.xml") // 指定配置文件位置
public class MyTest {

	//对于需要从容器中获取的 Bean 对象，使用 byType 或 byName 方式，将其自动注入.
	@Autowired
	private Student student;

	@Autowired
	private School school;

	//然后就可以直接测试对象了.
	@Test
	public void test01() {
		System.out.println(student);
	}
	
	@Test
	public void test02() {
		System.out.println(school);
	}
}
```

#### 注解与 XML 共同使用
注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。
XML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。
若注解与 XML 同用， **XML 的优先级要高于注解**。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000838s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001939s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000708s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000352s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001033s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000340s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000317s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring - IOC（控制反转）\r',`content`='# Spring - IOC（控制反转）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC（控制反转）\r\n### 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n\r\n\r\n### 第一个 Spring 程序\r\n#### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n#### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n### Bean 的装配\r\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\r\n#### 默认装配方式\r\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\r\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 动态工厂 Bean\r\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 静态工厂 Bean\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	//静态方法\r\n	public static ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n#### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n#### Bean 后处理器\r\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\r\n\r\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\r\n\r\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\r\n\r\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\r\n\r\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\r\n\r\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	String doSome();\r\n	String doOther();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public String doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n		return \"doSome() - abc\";\r\n	}\r\n	\r\n	@Override\r\n	public String doOther() {\r\n		System.out.println(\"执行doOther()方法\");\r\n		return \"doOther() - def\";\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n\r\n	// bean：表示当前正在进行初始化的Bean对象\r\n	// beanName：表示当前正在进行初始化的Bean对象的id\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- before() ---方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- after() ---方法\");\r\n		//判断 SomeServiceImpl 对象\r\n		if (\"myService\".equals(beanName)) {\r\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\r\n					bean.getClass().getInterfaces(),\r\n					new InvocationHandler() {\r\n						@Override\r\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n							Object invoke = method.invoke(bean, args);\r\n							//判断具体方法\r\n							if (\"doSome\".equals(method.getName())) {\r\n								return ((String) invoke).toUpperCase();\r\n							}\r\n							return invoke;\r\n						}\r\n					});\r\n			return obj;\r\n		}\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册 Bean 后处理器 -->\r\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	System.out.println(service.doSome());\r\n	System.out.println(service.doOther());\r\n\r\n	System.out.println(\"======================\");\r\n\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\r\n	System.out.println(service2.doSome());\r\n	System.out.println(service2.doOther());\r\n}\r\n```\r\n\r\n*输出结果*\r\n```\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行doSome()方法\r\nDOSOME() - ABC\r\n执行doOther()方法\r\ndoOther() - def\r\n======================\r\n执行doSome()方法\r\ndoSome() - abc\r\n执行doOther()方法\r\ndoOther() - def\r\n```\r\n\r\n\r\n#### Bean 的生命周期\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\r\n	private String adao;\r\n	private String bdao;\r\n\r\n	public void setAdao(String adao) {\r\n		this.adao = adao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public void setBdao(String bdao) {\r\n		this.bdao = bdao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"Step1：执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"Step9：执行 doSome() 方法\");\r\n	}\r\n\r\n	public void setUp() {\r\n		System.out.println(\"Step7：初始化完毕之后\");\r\n	}\r\n\r\n	public void tearDown() {\r\n		System.out.println(\"Step11：销毁之前\");\r\n	}\r\n\r\n	@Override\r\n	public void setBeanName(String name) {\r\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\r\n	}\r\n\r\n	@Override\r\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\r\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\r\n	}\r\n\r\n	@Override\r\n	public void afterPropertiesSet() throws Exception {\r\n		System.out.println(\"Step6：Bean 初始化完毕了\");\r\n	}\r\n\r\n	@Override\r\n	public void destroy() throws Exception {\r\n		System.out.println(\"Step10：实现接口的销毁之前\");\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - Bean 后处理器*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\r\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\r\n    	<property name=\"adao\" value=\"aaa\"/>\r\n    	<property name=\"bdao\" value=\"bbb\"/>\r\n   	</bean>\r\n\r\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n	// 对于销毁方法的执行，有两个条件：\r\n	// 1)当前的Bean需要是singleton的\r\n	// 2)要手工关闭容器\r\n	((ClassPathXmlApplicationContext)ac).close();\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\nStep1：执行无参构造器\r\nStep2：执行 setter\r\nStep2：执行 setter\r\nStep3：获取到 bean 的 id = myService\r\nStep4：获取到 BeanFactory 容器\r\nStep5：MyBeanPostProcessor - 执行 before() 方法\r\nStep6：Bean 初始化完毕了\r\nStep7：初始化完毕之后\r\nStep8：MyBeanPostProcessor - 执行 after() 方法\r\nStep9：执行 doSome() 方法\r\nStep10：实现接口的销毁之前\r\nStep11：销毁之前\r\n```\r\n### 基于 XML 的 DI\r\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\r\n#### 注入分类\r\n##### 设值注入(常用)\r\n和 `setter` 方法有关系。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"age\" value=\"23\"/>\r\n        <!-- 对于对象的注入要用 ref -->\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\n执行setName()\r\n执行setAge()\r\nStudent [name=张三, age=23, school=School [name=清华大学]]\r\n```\r\n##### 构造注入(很少用)\r\n和 `setter` 方法没有关系，和构造方法有关系。\r\n\r\n*Student.java - 为 Student 增加带参构造器*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n\r\n	/**\r\n	 * 带参数的构造方法\r\n	 */\r\n	public Student(String name, int age, School school) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n		this.school = school;\r\n	}\r\n	...\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\r\n        <!-- 构造器参数，指定 name -->\r\n    	<constructor-arg name=\"name\" value=\"李四\"/>\r\n    	<constructor-arg name=\"age\" value=\"24\"/>\r\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\r\n\r\n        <!-- 构造器参数，使用索引 -->\r\n    	<!--\r\n    	<constructor-arg index=\"0\" value=\"李四\"/>\r\n    	<constructor-arg index=\"1\" value=\"24\"/>\r\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\r\n    	 -->\r\n\r\n        <!-- 构造器参数，默认索引 -->\r\n    	<!--\r\n    	<constructor-arg value=\"李四\"/>\r\n    	<constructor-arg value=\"24\"/>\r\n    	<constructor-arg ref=\"mySchool\"/>\r\n    	 -->\r\n    </bean>\r\n</beans>\r\n```\r\n#### 集合属性注入\r\n基本类型数组，对象数组，List，Set，Map，Properties 等。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Some.java*\r\n```\r\npublic class Some {\r\n	private School[] schools; // 对象数组\r\n	private String[] myStrs; // 字符串数组\r\n	private List<String> myList; // List\r\n	private Set<String> mySet; // Set\r\n	private Map<String, Object> myMap; // Map\r\n	private Properties myPros; // Properties\r\n\r\n	public void setSchools(School[] schools) {\r\n		this.schools = schools;\r\n	}\r\n	public void setMyStrs(String[] myStrs) {\r\n		this.myStrs = myStrs;\r\n	}\r\n	public void setMyList(List<String> myList) {\r\n		this.myList = myList;\r\n	}\r\n	public void setMySet(Set<String> mySet) {\r\n		this.mySet = mySet;\r\n	}\r\n	public void setMyMap(Map<String, Object> myMap) {\r\n		this.myMap = myMap;\r\n	}\r\n	public void setMyPros(Properties myPros) {\r\n		this.myPros = myPros;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\r\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\r\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.xml*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"北京大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\r\n		<!-- 对象数组 -->\r\n    	<property name=\"schools\">\r\n    		<array>\r\n    			<ref bean=\"mySchool\"/>\r\n    			<ref bean=\"mySchool2\"/>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\r\n		<property name=\"schools\" value=\"mySchool\"/>\r\n\r\n		<!-- 基本类型数组 -->\r\n    	<property name=\"myStrs\">\r\n    		<array>\r\n    			<value>中国</value>\r\n    			<value>北京</value>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写 -->\r\n		<property name=\"myStrs\" value=\"中国,北京\"/>\r\n\r\n		<!-- List<String> -->\r\n    	<property name=\"myList\">\r\n    		<list>\r\n    			<value>大兴</value>\r\n    			<value>亦庄</value>\r\n    		</list>\r\n    	</property>\r\n		<!-- List<String>：简写 -->\r\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\r\n\r\n		<!-- Set<String> -->\r\n    	<property name=\"mySet\">\r\n    		<set>\r\n    			<value>大族企业湾</value>\r\n    			<value>10号楼</value>\r\n    		</set>\r\n    	</property>\r\n		<!-- Set<String>：简写 -->\r\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\r\n\r\n		<!-- Map<String, Object>，Map 的键值都是 object -->\r\n    	<property name=\"myMap\">\r\n    		<map>\r\n    			<entry key=\"mobile\" value=\"1234567\"/>\r\n    			<entry key=\"QQ\" value=\"7654321\"/>\r\n    		</map>\r\n    	</property>\r\n\r\n		<!-- Properties，Properties 的键值都是字符串 -->\r\n    	<property name=\"myPros\">\r\n    		<props>\r\n    			<prop key=\"education\">大学</prop>\r\n    			<prop key=\"gender\">男</prop>\r\n    		</props>\r\n    	</property>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载 Spring 配置文件\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Some some = (Some) ac.getBean(\"mySome\");\r\n	System.out.println(some);\r\n}\r\n```\r\n#### 对于域属性(对象)的自动注入\r\n##### byName 方式自动注入\r\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\r\n##### byType 方式自动注入\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)\r\n#### 使用 SPEL 注入\r\nSPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。\r\n*Person.java*\r\n```\r\npublic class Person {\r\n	private String pname;\r\n	private int page;\r\n\r\n	public void setPname(String pname) {\r\n		this.pname = pname;\r\n	}\r\n	public void setPage(int page) {\r\n		this.page = page;\r\n	}\r\n	public String getPname() {\r\n		return pname;\r\n	}\r\n	public int getPage() {\r\n		return page;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Person [pname=\" + pname + \", page=\" + page + \"]\";\r\n	}\r\n	\r\n	public int computeAge() {\r\n		return page > 25 ? 25 : page;\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"myPerson\" class=\"top.qingrang.di09.Person\">\r\n    	<property name=\"pname\" value=\"李四\"/>\r\n    	<property name=\"page\" value=\"#{T(java.lang.Math).random() * 50}\"/>   \r\n    </bean>\r\n    \r\n    <bean id=\"myStudent\" class=\"top.qingrang.di09.Student\">\r\n    	<property name=\"name\" value=\"#{myPerson.pname}\"/>\r\n    	<!-- <property name=\"age\" value=\"#{myPerson.page > 25 ? 25 : myPerson.page}\"/> -->\r\n    	<property name=\"age\" value=\"#{myPerson.computeAge() }\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di09/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Person person = (Person) ac.getBean(\"myPerson\");\r\n	System.out.println(person);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n#### 使用内部 Bean 注入\r\n若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。\r\n\r\n*applicationContext.mxl*\r\n```\r\n<!-- 注册 Student -->\r\n<bean id=\"myStudent\" class=\"top.qingrang.di10.Student\">\r\n	<property name=\"name\" value=\"张三\"/>\r\n	<property name=\"age\" value=\"23\"/>\r\n	<property name=\"school\">\r\n		<!-- 内部 Bean -->\r\n	    <bean class=\"top.qingrang.di10.School\">\r\n	    	<property name=\"name\" value=\"清华大学\"/>\r\n	    </bean>\r\n	</property>\r\n</bean>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di10/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	\r\n	// 不能访问，会报错\r\n	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined\r\n	School school = (School) ac.getBean(\"mySchool\");\r\n	System.out.println(school);\r\n}\r\n```\r\n\r\n\r\n#### 使用同类抽象 Bean 注入\r\n当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。\r\n\r\n抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private String school; // 学校\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n\r\n	public void setSchool(String school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<!-- 同类抽象 Bean，abstract=\"true\" -->\r\n<bean id=\"baseStudent\" class=\"top.qingrang.di11.Student\" abstract=\"true\">\r\n	<property name=\"school\" value=\"清华大学\"/>\r\n</bean>\r\n<!-- 利用 parent 实现继承 -->\r\n<bean id=\"myStudent\" parent=\"baseStudent\">\r\n	<property name=\"name\" value=\"张三\"/>\r\n	<property name=\"age\" value=\"23\"/>\r\n</bean>\r\n<bean id=\"myStudent2\" parent=\"baseStudent\">\r\n	<property name=\"name\" value=\"李四\"/>\r\n	<property name=\"age\" value=\"24\"/>\r\n</bean>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di11/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	Student student2 = (Student) ac.getBean(\"myStudent2\");\r\n	System.out.println(student2);\r\n}\r\n```\r\n#### 使用异类抽象 Bean 注入\r\n当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。\r\n![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)\r\n#### 为应用指定多个 Spring 配置文件\r\n在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。\r\n##### 平等关系的配置文件\r\n假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 可变参数\r\n	String resource = \"top/qingrang/di13/spring-base.xml\";\r\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);\r\n	// 参数数组\r\n	String resource = \"top/qingrang/di13/spring-base.xml\";\r\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\r\n	String[] resources = {resource, resource2};\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);\r\n	// 通配符\r\n	String resource = \"top/qingrang/di13/spring-*.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	Teacher teacher = (Teacher) ac.getBean(\"myTeacher\");\r\n	System.out.println(teacher);\r\n}\r\n```\r\n##### 包含关系的配置文件\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n	<!-- \r\n	<import resource=\"classpath:top/qingrang/di14/spring-base.xml\"/>\r\n	<import resource=\"classpath:top/qingrang/di14/spring-beans.xml\"/>\r\n	 -->\r\n\r\n	<!-- 使用通配符 -->\r\n	<import resource=\"classpath:top/qingrang/di14/spring-*.xml\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/di14/springTotal.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	...\r\n}\r\n```\r\n### 基于注解的 DI\r\n对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。\r\n#### 定义 Bean `@Component`\r\n- 与 `@Component` 注解功能相同，但意义不同的注解还有三个：\r\n	- `@Repository`：注解在 Dao 实现类上\r\n	- `@Service`：注解在 Service 实现类上\r\n	- `@Controller`：注解在 SpringMVC 的处理器上\r\n\r\n#### Bean 的作用域 `@Scope`\r\n#### 基本类型属性注入 `@Value`\r\n#### 按类型注入域属性 `@Autowired`\r\n需要在域属性上使用注解 `@Autowired`，该注解默认使用按类型自动装配 Bean 的方式。使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。\r\n#### 按名称注入域属性 `@Autowired` 与 `@Qualifier`\r\n需要在域属性上联合使用注解 `@Autowired` 与 `@Qualifier`。 `@Qualifier` 的 value 属性用于指定要匹配的 Bean 的 id 值。同样类中无需 setter，也可加到 setter 上。\r\n#### 域属性注解 `@Resource`\r\nSpring 提供了对 JSR-250 规范中定义 `@Resource` 标准注解的支持。 `@Resource` 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。\r\n#### Bean 的生命始末 `@PostConstruct` 与 `@PreDestroy`\r\n在方法上使用 `@PostConstruct`，与原来的 `init-method` 等效。在方法上使 `@PreDestroy`，与 `destroy-method` 等效。\r\n\r\n*School.java*\r\n```\r\n// 组件，表示当前类被 Spring 容器所管理\r\n@Component(\"mySchool\")\r\npublic class School {\r\n	@Value(\"清华大学\")\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\n// @Scope(\"prototype\")   // 默认也是 singleton\r\n@Component(\"myStudent\")\r\npublic class Student {\r\n	@Value(\"张三\")\r\n	private String name;\r\n	@Value(\"23\")\r\n	private int age;\r\n\r\n// ------------------- byType 方式的注解式注入 -------------------\r\n//	@Autowired\r\n//	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n// ----- byName 方式的注解式注入，要求 @Autowired 与 @Qualifier 联合使用 ----\r\n//	@Autowired\r\n//	@Qualifier(\"mySchool\")\r\n//	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n// -------------------- 域属性注解 @Resource --------------------\r\n	// @Resource(name=\"mySchool\")   // byName 方式的注解式注入\r\n	@Resource   // byType 方式的注解式注入\r\n	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n\r\n	// Bean 的生命始 @PostConstruct\r\n	@PostConstruct\r\n	public void initAfter() {\r\n		System.out.println(\"当前Bean初始化刚完毕\");\r\n	}\r\n\r\n	// Bean 的生命末 @PreDestroy\r\n	@PreDestroy\r\n	public void preDestroy() {\r\n		System.out.println(\"当前Bean即将被销毁\");\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n        \r\n	<!-- 组件扫描 top.qingrang 这个包及其子包 -->\r\n	<!--<context:component-scan base-package=\"top.qingrang\"/> -->\r\n	\r\n	<!-- 组件扫描 top.qingrang 这个包的子包 -->\r\n	<!--<context:component-scan base-package=\"top.qingrang.*\"/> -->\r\n	\r\n	<context:component-scan base-package=\"top.qingrang.di01\"/>\r\n	\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载 Spring 配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n#### 使用 JavaConfig 进行配置\r\nJavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。\r\nJavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML文件，而是由程序员使用 Java 自己编写的 Java 类。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public School() {\r\n		super();\r\n		// TODO Auto-generated constructor stub\r\n	}\r\n\r\n	public School(String name) {\r\n		super();\r\n		this.name = name;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school; // 对象属性，域属性\r\n\r\n	public Student() {\r\n		super();\r\n		// TODO Auto-generated constructor stub\r\n	}\r\n\r\n	public Student(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n*MyJavaConfig.java*\r\n```\r\n@Configuration    // 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建\r\npublic class MyJavaConfig {\r\n	\r\n	@Bean(name=\"school\")\r\n	public School mySchoolCreator() {\r\n		return new School(\"北京大学\");\r\n	}\r\n	\r\n	// autowire=Autowire.BY_TYPE 指从当前类这个容器中查找与域属性的类型具有is-a关系的Bean\r\n	/*\r\n	@Bean(name=\"myStudent\", autowire=Autowire.BY_TYPE)\r\n	public Student myStudentCreator() {\r\n		return new Student(\"张三\", 23);\r\n	}\r\n	*/\r\n	\r\n	// autowire=Autowire.BY_NAME 指从当前类这个容器中查找与域属性同名的Bean\r\n	@Bean(name=\"myStudent\", autowire=Autowire.BY_NAME)\r\n	public Student myStudentCreator() {\r\n		return new Student(\"张三\", 23);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n	<!-- 扫描组件 -->\r\n	<context:component-scan base-package=\"top.qingrang.di05\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n#### 使用 Spring 的 JUnit4 测试 Spring\r\n使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，及从 Spring 容器中通过 getBean() 获取对象了。这些工作将由 JUnit4 注解，配合着域属性的自动注入注解共同完成。\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", school=\" + school + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di06.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di06.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@RunWith(SpringJUnit4ClassRunner.class)	// 指定运行环境\r\n@ContextConfiguration(locations=\"classpath:top/qingrang/di06/applicationContext.xml\") // 指定配置文件位置\r\npublic class MyTest {\r\n\r\n	//对于需要从容器中获取的 Bean 对象，使用 byType 或 byName 方式，将其自动注入.\r\n	@Autowired\r\n	private Student student;\r\n\r\n	@Autowired\r\n	private School school;\r\n\r\n	//然后就可以直接测试对象了.\r\n	@Test\r\n	public void test01() {\r\n		System.out.println(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test02() {\r\n		System.out.println(school);\r\n	}\r\n}\r\n```\r\n\r\n#### 注解与 XML 共同使用\r\n注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。\r\nXML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。\r\n若注解与 XML 同用， **XML 的优先级要高于注解**。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.001802s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001599s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000356s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000949s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000337s ]
---------------------------------------------------------------
[ 2018-11-18T22:07:47+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.051758s][吞吐率：19.32req/s] [内存消耗：2,056.39kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000531s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001195s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000676s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000968s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000347s ]
---------------------------------------------------------------
[ 2018-11-18T22:08:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.137463s][吞吐率：7.27req/s] [内存消耗：2,112.08kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000506s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000576s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000875s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000277s ]
---------------------------------------------------------------
[ 2018-11-18T22:12:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.105635s][吞吐率：9.47req/s] [内存消耗：2,364.33kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '86427',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring - IOC（控制反转）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。

## 第一个 Spring 程序
### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

## Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```
### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
## 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
### 注入分类
#### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
#### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>

		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
### 对于域属性(对象)的自动注入
#### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
#### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)
### 使用 SPEL 注入
SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。
*Person.java*
```
public class Person {
	private String pname;
	private int page;

	public void setPname(String pname) {
		this.pname = pname;
	}
	public void setPage(int page) {
		this.page = page;
	}
	public String getPname() {
		return pname;
	}
	public int getPage() {
		return page;
	}

	@Override
	public String toString() {
		return "Person [pname=" + pname + ", page=" + page + "]";
	}
	
	public int computeAge() {
		return page > 25 ? 25 : page;
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="myPerson" class="top.qingrang.di09.Person">
    	<property name="pname" value="李四"/>
    	<property name="page" value="#{T(java.lang.Math).random() * 50}"/>   
    </bean>
    
    <bean id="myStudent" class="top.qingrang.di09.Student">
    	<property name="name" value="#{myPerson.pname}"/>
    	<!-- <property name="age" value="#{myPerson.page > 25 ? 25 : myPerson.page}"/> -->
    	<property name="age" value="#{myPerson.computeAge() }"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Person person = (Person) ac.getBean("myPerson");
	System.out.println(person);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
### 使用内部 Bean 注入
若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。

*applicationContext.mxl*
```
<!-- 注册 Student -->
<bean id="myStudent" class="top.qingrang.di10.Student">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
	<property name="school">
		<!-- 内部 Bean -->
	    <bean class="top.qingrang.di10.School">
	    	<property name="name" value="清华大学"/>
	    </bean>
	</property>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di10/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	
	// 不能访问，会报错
	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined
	School school = (School) ac.getBean("mySchool");
	System.out.println(school);
}
```
### 使用同类抽象 Bean 注入
当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。

抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private String school; // 学校

	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setSchool(String school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<!-- 同类抽象 Bean，abstract="true" -->
<bean id="baseStudent" class="top.qingrang.di11.Student" abstract="true">
	<property name="school" value="清华大学"/>
</bean>
<!-- 利用 parent 实现继承 -->
<bean id="myStudent" parent="baseStudent">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
</bean>
<bean id="myStudent2" parent="baseStudent">
	<property name="name" value="李四"/>
	<property name="age" value="24"/>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Student student2 = (Student) ac.getBean("myStudent2");
	System.out.println(student2);
}
```
### 使用异类抽象 Bean 注入
当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。
![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)
### 为应用指定多个 Spring 配置文件
在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。
#### 平等关系的配置文件
假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`
```
@Test
public void test01() {
	// 可变参数
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);
	// 参数数组
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	String[] resources = {resource, resource2};
	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);
	// 通配符
	String resource = "top/qingrang/di13/spring-*.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Teacher teacher = (Teacher) ac.getBean("myTeacher");
	System.out.println(teacher);
}
```
#### 包含关系的配置文件
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!-- 
	<import resource="classpath:top/qingrang/di14/spring-base.xml"/>
	<import resource="classpath:top/qingrang/di14/spring-beans.xml"/>
	 -->

	<!-- 使用通配符 -->
	<import resource="classpath:top/qingrang/di14/spring-*.xml"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di14/springTotal.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	...
}
```
## 基于注解的 DI
对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。
### 定义 Bean `@Component`
- 与 `@Component` 注解功能相同，但意义不同的注解还有三个：
	- `@Repository`：注解在 Dao 实现类上
	- `@Service`：注解在 Service 实现类上
	- `@Controller`：注解在 SpringMVC 的处理器上

### Bean 的作用域 `@Scope`
### 基本类型属性注入 `@Value`
### 按类型注入域属性 `@Autowired`
需要在域属性上使用注解 `@Autowired`，该注解默认使用按类型自动装配 Bean 的方式。使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。
### 按名称注入域属性 `@Autowired` 与 `@Qualifier`
需要在域属性上联合使用注解 `@Autowired` 与 `@Qualifier`。 `@Qualifier` 的 value 属性用于指定要匹配的 Bean 的 id 值。同样类中无需 setter，也可加到 setter 上。
### 域属性注解 `@Resource`
Spring 提供了对 JSR-250 规范中定义 `@Resource` 标准注解的支持。 `@Resource` 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。
### Bean 的生命始末 `@PostConstruct` 与 `@PreDestroy`
在方法上使用 `@PostConstruct`，与原来的 `init-method` 等效。在方法上使 `@PreDestroy`，与 `destroy-method` 等效。

*School.java*
```
// 组件，表示当前类被 Spring 容器所管理
@Component("mySchool")
public class School {
	@Value("清华大学")
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
// @Scope("prototype")   // 默认也是 singleton
@Component("myStudent")
public class Student {
	@Value("张三")
	private String name;
	@Value("23")
	private int age;

// ------------------- byType 方式的注解式注入 -------------------
//	@Autowired
//	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

// ----- byName 方式的注解式注入，要求 @Autowired 与 @Qualifier 联合使用 ----
//	@Autowired
//	@Qualifier("mySchool")
//	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

// -------------------- 域属性注解 @Resource --------------------
	// @Resource(name="mySchool")   // byName 方式的注解式注入
	@Resource   // byType 方式的注解式注入
	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}

	// Bean 的生命始 @PostConstruct
	@PostConstruct
	public void initAfter() {
		System.out.println("当前Bean初始化刚完毕");
	}

	// Bean 的生命末 @PreDestroy
	@PreDestroy
	public void preDestroy() {
		System.out.println("当前Bean即将被销毁");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">
        
	<!-- 组件扫描 top.qingrang 这个包及其子包 -->
	<!--<context:component-scan base-package="top.qingrang"/> -->
	
	<!-- 组件扫描 top.qingrang 这个包的子包 -->
	<!--<context:component-scan base-package="top.qingrang.*"/> -->
	
	<context:component-scan base-package="top.qingrang.di01"/>
	
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
### 使用 JavaConfig 进行配置
JavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。
JavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML文件，而是由程序员使用 Java 自己编写的 Java 类。

*School.java*
```
public class School {
	private String name;

	public School() {
		super();
		// TODO Auto-generated constructor stub
	}

	public School(String name) {
		super();
		this.name = name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school; // 对象属性，域属性

	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}

	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}

	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```
*MyJavaConfig.java*
```
@Configuration    // 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建
public class MyJavaConfig {
	
	@Bean(name="school")
	public School mySchoolCreator() {
		return new School("北京大学");
	}
	
	// autowire=Autowire.BY_TYPE 指从当前类这个容器中查找与域属性的类型具有is-a关系的Bean
	/*
	@Bean(name="myStudent", autowire=Autowire.BY_TYPE)
	public Student myStudentCreator() {
		return new Student("张三", 23);
	}
	*/
	
	// autowire=Autowire.BY_NAME 指从当前类这个容器中查找与域属性同名的Bean
	@Bean(name="myStudent", autowire=Autowire.BY_NAME)
	public Student myStudentCreator() {
		return new Student("张三", 23);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 扫描组件 -->
	<context:component-scan base-package="top.qingrang.di05"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
### 使用 Spring 的 JUnit4 测试 Spring
使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，及从 Spring 容器中通过 getBean() 获取对象了。这些工作将由 JUnit4 注解，配合着域属性的自动注入注解共同完成。
*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		this.name = name;
	}

	public void setSchool(School school) {
		this.school = school;
	}
	@Override
	public String toString() {
		return "Student [name=" + name + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di06.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di06.Student">
    	<property name="name" value="张三"/>
    	<property name="school" ref="mySchool"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@RunWith(SpringJUnit4ClassRunner.class)	// 指定运行环境
@ContextConfiguration(locations="classpath:top/qingrang/di06/applicationContext.xml") // 指定配置文件位置
public class MyTest {

	//对于需要从容器中获取的 Bean 对象，使用 byType 或 byName 方式，将其自动注入.
	@Autowired
	private Student student;

	@Autowired
	private School school;

	//然后就可以直接测试对象了.
	@Test
	public void test01() {
		System.out.println(student);
	}
	
	@Test
	public void test02() {
		System.out.println(school);
	}
}
```

### 注解与 XML 共同使用
注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。
XML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。
若注解与 XML 同用， **XML 的优先级要高于注解**。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000751s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002171s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000984s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000542s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001737s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000475s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000445s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring - IOC（控制反转）\r',`content`='# Spring - IOC（控制反转）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n## 第一个 Spring 程序\r\n### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n## Bean 的装配\r\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\r\n### 默认装配方式\r\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\r\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n### 动态工厂 Bean\r\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n### 静态工厂 Bean\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	//静态方法\r\n	public static ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n### Bean 后处理器\r\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\r\n\r\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\r\n\r\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\r\n\r\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\r\n\r\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\r\n\r\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	String doSome();\r\n	String doOther();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public String doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n		return \"doSome() - abc\";\r\n	}\r\n	\r\n	@Override\r\n	public String doOther() {\r\n		System.out.println(\"执行doOther()方法\");\r\n		return \"doOther() - def\";\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n\r\n	// bean：表示当前正在进行初始化的Bean对象\r\n	// beanName：表示当前正在进行初始化的Bean对象的id\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- before() ---方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- after() ---方法\");\r\n		//判断 SomeServiceImpl 对象\r\n		if (\"myService\".equals(beanName)) {\r\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\r\n					bean.getClass().getInterfaces(),\r\n					new InvocationHandler() {\r\n						@Override\r\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n							Object invoke = method.invoke(bean, args);\r\n							//判断具体方法\r\n							if (\"doSome\".equals(method.getName())) {\r\n								return ((String) invoke).toUpperCase();\r\n							}\r\n							return invoke;\r\n						}\r\n					});\r\n			return obj;\r\n		}\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册 Bean 后处理器 -->\r\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	System.out.println(service.doSome());\r\n	System.out.println(service.doOther());\r\n\r\n	System.out.println(\"======================\");\r\n\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\r\n	System.out.println(service2.doSome());\r\n	System.out.println(service2.doOther());\r\n}\r\n```\r\n\r\n*输出结果*\r\n```\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行doSome()方法\r\nDOSOME() - ABC\r\n执行doOther()方法\r\ndoOther() - def\r\n======================\r\n执行doSome()方法\r\ndoSome() - abc\r\n执行doOther()方法\r\ndoOther() - def\r\n```\r\n### Bean 的生命周期\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\r\n	private String adao;\r\n	private String bdao;\r\n\r\n	public void setAdao(String adao) {\r\n		this.adao = adao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public void setBdao(String bdao) {\r\n		this.bdao = bdao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"Step1：执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"Step9：执行 doSome() 方法\");\r\n	}\r\n\r\n	public void setUp() {\r\n		System.out.println(\"Step7：初始化完毕之后\");\r\n	}\r\n\r\n	public void tearDown() {\r\n		System.out.println(\"Step11：销毁之前\");\r\n	}\r\n\r\n	@Override\r\n	public void setBeanName(String name) {\r\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\r\n	}\r\n\r\n	@Override\r\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\r\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\r\n	}\r\n\r\n	@Override\r\n	public void afterPropertiesSet() throws Exception {\r\n		System.out.println(\"Step6：Bean 初始化完毕了\");\r\n	}\r\n\r\n	@Override\r\n	public void destroy() throws Exception {\r\n		System.out.println(\"Step10：实现接口的销毁之前\");\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - Bean 后处理器*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\r\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\r\n    	<property name=\"adao\" value=\"aaa\"/>\r\n    	<property name=\"bdao\" value=\"bbb\"/>\r\n   	</bean>\r\n\r\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n	// 对于销毁方法的执行，有两个条件：\r\n	// 1)当前的Bean需要是singleton的\r\n	// 2)要手工关闭容器\r\n	((ClassPathXmlApplicationContext)ac).close();\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\nStep1：执行无参构造器\r\nStep2：执行 setter\r\nStep2：执行 setter\r\nStep3：获取到 bean 的 id = myService\r\nStep4：获取到 BeanFactory 容器\r\nStep5：MyBeanPostProcessor - 执行 before() 方法\r\nStep6：Bean 初始化完毕了\r\nStep7：初始化完毕之后\r\nStep8：MyBeanPostProcessor - 执行 after() 方法\r\nStep9：执行 doSome() 方法\r\nStep10：实现接口的销毁之前\r\nStep11：销毁之前\r\n```\r\n## 基于 XML 的 DI\r\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\r\n### 注入分类\r\n#### 设值注入(常用)\r\n和 `setter` 方法有关系。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"age\" value=\"23\"/>\r\n        <!-- 对于对象的注入要用 ref -->\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\n执行setName()\r\n执行setAge()\r\nStudent [name=张三, age=23, school=School [name=清华大学]]\r\n```\r\n#### 构造注入(很少用)\r\n和 `setter` 方法没有关系，和构造方法有关系。\r\n\r\n*Student.java - 为 Student 增加带参构造器*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n\r\n	/**\r\n	 * 带参数的构造方法\r\n	 */\r\n	public Student(String name, int age, School school) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n		this.school = school;\r\n	}\r\n	...\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\r\n        <!-- 构造器参数，指定 name -->\r\n    	<constructor-arg name=\"name\" value=\"李四\"/>\r\n    	<constructor-arg name=\"age\" value=\"24\"/>\r\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\r\n\r\n        <!-- 构造器参数，使用索引 -->\r\n    	<!--\r\n    	<constructor-arg index=\"0\" value=\"李四\"/>\r\n    	<constructor-arg index=\"1\" value=\"24\"/>\r\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\r\n    	 -->\r\n\r\n        <!-- 构造器参数，默认索引 -->\r\n    	<!--\r\n    	<constructor-arg value=\"李四\"/>\r\n    	<constructor-arg value=\"24\"/>\r\n    	<constructor-arg ref=\"mySchool\"/>\r\n    	 -->\r\n    </bean>\r\n</beans>\r\n```\r\n### 集合属性注入\r\n基本类型数组，对象数组，List，Set，Map，Properties 等。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Some.java*\r\n```\r\npublic class Some {\r\n	private School[] schools; // 对象数组\r\n	private String[] myStrs; // 字符串数组\r\n	private List<String> myList; // List\r\n	private Set<String> mySet; // Set\r\n	private Map<String, Object> myMap; // Map\r\n	private Properties myPros; // Properties\r\n\r\n	public void setSchools(School[] schools) {\r\n		this.schools = schools;\r\n	}\r\n	public void setMyStrs(String[] myStrs) {\r\n		this.myStrs = myStrs;\r\n	}\r\n	public void setMyList(List<String> myList) {\r\n		this.myList = myList;\r\n	}\r\n	public void setMySet(Set<String> mySet) {\r\n		this.mySet = mySet;\r\n	}\r\n	public void setMyMap(Map<String, Object> myMap) {\r\n		this.myMap = myMap;\r\n	}\r\n	public void setMyPros(Properties myPros) {\r\n		this.myPros = myPros;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\r\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\r\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.xml*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"北京大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\r\n		<!-- 对象数组 -->\r\n    	<property name=\"schools\">\r\n    		<array>\r\n    			<ref bean=\"mySchool\"/>\r\n    			<ref bean=\"mySchool2\"/>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\r\n		<property name=\"schools\" value=\"mySchool\"/>\r\n\r\n		<!-- 基本类型数组 -->\r\n    	<property name=\"myStrs\">\r\n    		<array>\r\n    			<value>中国</value>\r\n    			<value>北京</value>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写 -->\r\n		<property name=\"myStrs\" value=\"中国,北京\"/>\r\n\r\n		<!-- List<String> -->\r\n    	<property name=\"myList\">\r\n    		<list>\r\n    			<value>大兴</value>\r\n    			<value>亦庄</value>\r\n    		</list>\r\n    	</property>\r\n		<!-- List<String>：简写 -->\r\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\r\n\r\n		<!-- Set<String> -->\r\n    	<property name=\"mySet\">\r\n    		<set>\r\n    			<value>大族企业湾</value>\r\n    			<value>10号楼</value>\r\n    		</set>\r\n    	</property>\r\n		<!-- Set<String>：简写 -->\r\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\r\n\r\n		<!-- Map<String, Object>，Map 的键值都是 object -->\r\n    	<property name=\"myMap\">\r\n    		<map>\r\n    			<entry key=\"mobile\" value=\"1234567\"/>\r\n    			<entry key=\"QQ\" value=\"7654321\"/>\r\n    		</map>\r\n    	</property>\r\n\r\n		<!-- Properties，Properties 的键值都是字符串 -->\r\n    	<property name=\"myPros\">\r\n    		<props>\r\n    			<prop key=\"education\">大学</prop>\r\n    			<prop key=\"gender\">男</prop>\r\n    		</props>\r\n    	</property>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载 Spring 配置文件\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Some some = (Some) ac.getBean(\"mySome\");\r\n	System.out.println(some);\r\n}\r\n```\r\n### 对于域属性(对象)的自动注入\r\n#### byName 方式自动注入\r\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\r\n#### byType 方式自动注入\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)\r\n### 使用 SPEL 注入\r\nSPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。\r\n*Person.java*\r\n```\r\npublic class Person {\r\n	private String pname;\r\n	private int page;\r\n\r\n	public void setPname(String pname) {\r\n		this.pname = pname;\r\n	}\r\n	public void setPage(int page) {\r\n		this.page = page;\r\n	}\r\n	public String getPname() {\r\n		return pname;\r\n	}\r\n	public int getPage() {\r\n		return page;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Person [pname=\" + pname + \", page=\" + page + \"]\";\r\n	}\r\n	\r\n	public int computeAge() {\r\n		return page > 25 ? 25 : page;\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"myPerson\" class=\"top.qingrang.di09.Person\">\r\n    	<property name=\"pname\" value=\"李四\"/>\r\n    	<property name=\"page\" value=\"#{T(java.lang.Math).random() * 50}\"/>   \r\n    </bean>\r\n    \r\n    <bean id=\"myStudent\" class=\"top.qingrang.di09.Student\">\r\n    	<property name=\"name\" value=\"#{myPerson.pname}\"/>\r\n    	<!-- <property name=\"age\" value=\"#{myPerson.page > 25 ? 25 : myPerson.page}\"/> -->\r\n    	<property name=\"age\" value=\"#{myPerson.computeAge() }\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di09/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Person person = (Person) ac.getBean(\"myPerson\");\r\n	System.out.println(person);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n### 使用内部 Bean 注入\r\n若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。\r\n\r\n*applicationContext.mxl*\r\n```\r\n<!-- 注册 Student -->\r\n<bean id=\"myStudent\" class=\"top.qingrang.di10.Student\">\r\n	<property name=\"name\" value=\"张三\"/>\r\n	<property name=\"age\" value=\"23\"/>\r\n	<property name=\"school\">\r\n		<!-- 内部 Bean -->\r\n	    <bean class=\"top.qingrang.di10.School\">\r\n	    	<property name=\"name\" value=\"清华大学\"/>\r\n	    </bean>\r\n	</property>\r\n</bean>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di10/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	\r\n	// 不能访问，会报错\r\n	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined\r\n	School school = (School) ac.getBean(\"mySchool\");\r\n	System.out.println(school);\r\n}\r\n```\r\n### 使用同类抽象 Bean 注入\r\n当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。\r\n\r\n抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private String school; // 学校\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n\r\n	public void setSchool(String school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<!-- 同类抽象 Bean，abstract=\"true\" -->\r\n<bean id=\"baseStudent\" class=\"top.qingrang.di11.Student\" abstract=\"true\">\r\n	<property name=\"school\" value=\"清华大学\"/>\r\n</bean>\r\n<!-- 利用 parent 实现继承 -->\r\n<bean id=\"myStudent\" parent=\"baseStudent\">\r\n	<property name=\"name\" value=\"张三\"/>\r\n	<property name=\"age\" value=\"23\"/>\r\n</bean>\r\n<bean id=\"myStudent2\" parent=\"baseStudent\">\r\n	<property name=\"name\" value=\"李四\"/>\r\n	<property name=\"age\" value=\"24\"/>\r\n</bean>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di11/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	Student student2 = (Student) ac.getBean(\"myStudent2\");\r\n	System.out.println(student2);\r\n}\r\n```\r\n### 使用异类抽象 Bean 注入\r\n当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。\r\n![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)\r\n### 为应用指定多个 Spring 配置文件\r\n在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。\r\n#### 平等关系的配置文件\r\n假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 可变参数\r\n	String resource = \"top/qingrang/di13/spring-base.xml\";\r\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);\r\n	// 参数数组\r\n	String resource = \"top/qingrang/di13/spring-base.xml\";\r\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\r\n	String[] resources = {resource, resource2};\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);\r\n	// 通配符\r\n	String resource = \"top/qingrang/di13/spring-*.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	Teacher teacher = (Teacher) ac.getBean(\"myTeacher\");\r\n	System.out.println(teacher);\r\n}\r\n```\r\n#### 包含关系的配置文件\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n	<!-- \r\n	<import resource=\"classpath:top/qingrang/di14/spring-base.xml\"/>\r\n	<import resource=\"classpath:top/qingrang/di14/spring-beans.xml\"/>\r\n	 -->\r\n\r\n	<!-- 使用通配符 -->\r\n	<import resource=\"classpath:top/qingrang/di14/spring-*.xml\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/di14/springTotal.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	...\r\n}\r\n```\r\n## 基于注解的 DI\r\n对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。\r\n### 定义 Bean `@Component`\r\n- 与 `@Component` 注解功能相同，但意义不同的注解还有三个：\r\n	- `@Repository`：注解在 Dao 实现类上\r\n	- `@Service`：注解在 Service 实现类上\r\n	- `@Controller`：注解在 SpringMVC 的处理器上\r\n\r\n### Bean 的作用域 `@Scope`\r\n### 基本类型属性注入 `@Value`\r\n### 按类型注入域属性 `@Autowired`\r\n需要在域属性上使用注解 `@Autowired`，该注解默认使用按类型自动装配 Bean 的方式。使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。\r\n### 按名称注入域属性 `@Autowired` 与 `@Qualifier`\r\n需要在域属性上联合使用注解 `@Autowired` 与 `@Qualifier`。 `@Qualifier` 的 value 属性用于指定要匹配的 Bean 的 id 值。同样类中无需 setter，也可加到 setter 上。\r\n### 域属性注解 `@Resource`\r\nSpring 提供了对 JSR-250 规范中定义 `@Resource` 标准注解的支持。 `@Resource` 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。\r\n### Bean 的生命始末 `@PostConstruct` 与 `@PreDestroy`\r\n在方法上使用 `@PostConstruct`，与原来的 `init-method` 等效。在方法上使 `@PreDestroy`，与 `destroy-method` 等效。\r\n\r\n*School.java*\r\n```\r\n// 组件，表示当前类被 Spring 容器所管理\r\n@Component(\"mySchool\")\r\npublic class School {\r\n	@Value(\"清华大学\")\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\n// @Scope(\"prototype\")   // 默认也是 singleton\r\n@Component(\"myStudent\")\r\npublic class Student {\r\n	@Value(\"张三\")\r\n	private String name;\r\n	@Value(\"23\")\r\n	private int age;\r\n\r\n// ------------------- byType 方式的注解式注入 -------------------\r\n//	@Autowired\r\n//	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n// ----- byName 方式的注解式注入，要求 @Autowired 与 @Qualifier 联合使用 ----\r\n//	@Autowired\r\n//	@Qualifier(\"mySchool\")\r\n//	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n// -------------------- 域属性注解 @Resource --------------------\r\n	// @Resource(name=\"mySchool\")   // byName 方式的注解式注入\r\n	@Resource   // byType 方式的注解式注入\r\n	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n\r\n	// Bean 的生命始 @PostConstruct\r\n	@PostConstruct\r\n	public void initAfter() {\r\n		System.out.println(\"当前Bean初始化刚完毕\");\r\n	}\r\n\r\n	// Bean 的生命末 @PreDestroy\r\n	@PreDestroy\r\n	public void preDestroy() {\r\n		System.out.println(\"当前Bean即将被销毁\");\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n        \r\n	<!-- 组件扫描 top.qingrang 这个包及其子包 -->\r\n	<!--<context:component-scan base-package=\"top.qingrang\"/> -->\r\n	\r\n	<!-- 组件扫描 top.qingrang 这个包的子包 -->\r\n	<!--<context:component-scan base-package=\"top.qingrang.*\"/> -->\r\n	\r\n	<context:component-scan base-package=\"top.qingrang.di01\"/>\r\n	\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载 Spring 配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n### 使用 JavaConfig 进行配置\r\nJavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。\r\nJavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML文件，而是由程序员使用 Java 自己编写的 Java 类。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public School() {\r\n		super();\r\n		// TODO Auto-generated constructor stub\r\n	}\r\n\r\n	public School(String name) {\r\n		super();\r\n		this.name = name;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school; // 对象属性，域属性\r\n\r\n	public Student() {\r\n		super();\r\n		// TODO Auto-generated constructor stub\r\n	}\r\n\r\n	public Student(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n*MyJavaConfig.java*\r\n```\r\n@Configuration    // 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建\r\npublic class MyJavaConfig {\r\n	\r\n	@Bean(name=\"school\")\r\n	public School mySchoolCreator() {\r\n		return new School(\"北京大学\");\r\n	}\r\n	\r\n	// autowire=Autowire.BY_TYPE 指从当前类这个容器中查找与域属性的类型具有is-a关系的Bean\r\n	/*\r\n	@Bean(name=\"myStudent\", autowire=Autowire.BY_TYPE)\r\n	public Student myStudentCreator() {\r\n		return new Student(\"张三\", 23);\r\n	}\r\n	*/\r\n	\r\n	// autowire=Autowire.BY_NAME 指从当前类这个容器中查找与域属性同名的Bean\r\n	@Bean(name=\"myStudent\", autowire=Autowire.BY_NAME)\r\n	public Student myStudentCreator() {\r\n		return new Student(\"张三\", 23);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n	<!-- 扫描组件 -->\r\n	<context:component-scan base-package=\"top.qingrang.di05\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n### 使用 Spring 的 JUnit4 测试 Spring\r\n使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，及从 Spring 容器中通过 getBean() 获取对象了。这些工作将由 JUnit4 注解，配合着域属性的自动注入注解共同完成。\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", school=\" + school + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di06.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di06.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@RunWith(SpringJUnit4ClassRunner.class)	// 指定运行环境\r\n@ContextConfiguration(locations=\"classpath:top/qingrang/di06/applicationContext.xml\") // 指定配置文件位置\r\npublic class MyTest {\r\n\r\n	//对于需要从容器中获取的 Bean 对象，使用 byType 或 byName 方式，将其自动注入.\r\n	@Autowired\r\n	private Student student;\r\n\r\n	@Autowired\r\n	private School school;\r\n\r\n	//然后就可以直接测试对象了.\r\n	@Test\r\n	public void test01() {\r\n		System.out.println(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test02() {\r\n		System.out.println(school);\r\n	}\r\n}\r\n```\r\n\r\n### 注解与 XML 共同使用\r\n注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。\r\nXML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。\r\n若注解与 XML 同用， **XML 的优先级要高于注解**。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.002537s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001881s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000551s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001697s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000537s ]
---------------------------------------------------------------
[ 2018-11-18T22:12:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.057771s][吞吐率：17.31req/s] [内存消耗：2,056.32kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000475s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000841s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001099s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000332s ]
---------------------------------------------------------------
[ 2018-11-18T22:13:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.067312s][吞吐率：14.86req/s] [内存消耗：2,112.00kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000739s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001749s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000701s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000876s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000295s ]
---------------------------------------------------------------
[ 2018-11-18T22:14:06+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.071545s][吞吐率：13.98req/s] [内存消耗：2,364.50kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '86442',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(一) - IOC（控制反转）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。

## 第一个 Spring 程序
### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

## Bean 的装配
Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。
### 默认装配方式
代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	public SomeServiceImpl() {
		System.out.println("执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->
    <bean id="myService" class="com.bjpowernode.ba01.SomeServiceImpl"/>
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "com/bjpowernode/ba01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
### 动态工厂 Bean
有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
### 静态工厂 Bean
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	//静态方法
	public static ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。

代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```
### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```
## 基于 XML 的 DI
Bean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。
### 注入分类
#### 设值注入(常用)
和 `setter` 方法有关系。

*School.java*
```
public class School {
	private String name;
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}
	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}
	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di01.Student">
    	<property name="name" value="张三"/>
    	<property name="age" value="23"/>
        <!-- 对于对象的注入要用 ref -->
    	<property name="school" ref="mySchool"/>
    </bean>

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di01.School">
    	<property name="name" value="清华大学"/>
    </bean>

</beans>
```

*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```

*输出信息*
```
执行setName()
执行setAge()
Student [name=张三, age=23, school=School [name=清华大学]]
```
#### 构造注入(很少用)
和 `setter` 方法没有关系，和构造方法有关系。

*Student.java - 为 Student 增加带参构造器*
```
public class Student {
	private String name;
	private int age;
	private School school;   // 对象属性，域属性

	/**
	 * 带参数的构造方法
	 */
	public Student(String name, int age, School school) {
		super();
		this.name = name;
		this.age = age;
		this.school = school;
	}
	...
}
```

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="mySchool" class="top.qingrang.di02.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册Student -->
    <bean id="myStudent" class="top.qingrang.di02.Student">
        <!-- 构造器参数，指定 name -->
    	<constructor-arg name="name" value="李四"/>
    	<constructor-arg name="age" value="24"/>
    	<constructor-arg name="school" ref="mySchool"/>

        <!-- 构造器参数，使用索引 -->
    	<!--
    	<constructor-arg index="0" value="李四"/>
    	<constructor-arg index="1" value="24"/>
    	<constructor-arg index="2" ref="mySchool"/>
    	 -->

        <!-- 构造器参数，默认索引 -->
    	<!--
    	<constructor-arg value="李四"/>
    	<constructor-arg value="24"/>
    	<constructor-arg ref="mySchool"/>
    	 -->
    </bean>
</beans>
```
### 集合属性注入
基本类型数组，对象数组，List，Set，Map，Properties 等。

*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Some.java*
```
public class Some {
	private School[] schools; // 对象数组
	private String[] myStrs; // 字符串数组
	private List<String> myList; // List
	private Set<String> mySet; // Set
	private Map<String, Object> myMap; // Map
	private Properties myPros; // Properties

	public void setSchools(School[] schools) {
		this.schools = schools;
	}
	public void setMyStrs(String[] myStrs) {
		this.myStrs = myStrs;
	}
	public void setMyList(List<String> myList) {
		this.myList = myList;
	}
	public void setMySet(Set<String> mySet) {
		this.mySet = mySet;
	}
	public void setMyMap(Map<String, Object> myMap) {
		this.myMap = myMap;
	}
	public void setMyPros(Properties myPros) {
		this.myPros = myPros;
	}

	@Override
	public String toString() {
		return "Some [schools=" + Arrays.toString(schools) + ", myStrs="
				+ Arrays.toString(myStrs) + ", myList=" + myList + ", mySet="
				+ mySet + ", myMap=" + myMap + ", myPros=" + myPros + "]";
	}
}
```
*applicationContext.xml*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di05.School">
    	<property name="name" value="清华大学"/>
    </bean>
    <bean id="mySchool2" class="top.qingrang.di05.School">
    	<property name="name" value="北京大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="mySome" class="top.qingrang.di05.Some">
		<!-- 对象数组 -->
    	<property name="schools">
    		<array>
    			<ref bean="mySchool"/>
    			<ref bean="mySchool2"/>
    		</array>
    	</property>
		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->
		<property name="schools" value="mySchool"/>

		<!-- 基本类型数组 -->
    	<property name="myStrs">
    		<array>
    			<value>中国</value>
    			<value>北京</value>
    		</array>
    	</property>
		<!-- 数组：简写 -->
		<property name="myStrs" value="中国,北京"/>

		<!-- List<String> -->
    	<property name="myList">
    		<list>
    			<value>大兴</value>
    			<value>亦庄</value>
    		</list>
    	</property>
		<!-- List<String>：简写 -->
		<property name="myList" value="大兴,亦庄"/>

		<!-- Set<String> -->
    	<property name="mySet">
    		<set>
    			<value>大族企业湾</value>
    			<value>10号楼</value>
    		</set>
    	</property>
		<!-- Set<String>：简写 -->
		<property name="mySet" value="大族企业湾,10号楼"/>

		<!-- Map<String, Object>，Map 的键值都是 object -->
    	<property name="myMap">
    		<map>
    			<entry key="mobile" value="1234567"/>
    			<entry key="QQ" value="7654321"/>
    		</map>
    	</property>

		<!-- Properties，Properties 的键值都是字符串 -->
    	<property name="myPros">
    		<props>
    			<prop key="education">大学</prop>
    			<prop key="gender">男</prop>
    		</props>
    	</property>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Some some = (Some) ac.getBean("mySome");
	System.out.println(some);
}
```
### 对于域属性(对象)的自动注入
#### byName 方式自动注入
![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)
#### byType 方式自动注入
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)
### 使用 SPEL 注入
SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。
*Person.java*
```
public class Person {
	private String pname;
	private int page;

	public void setPname(String pname) {
		this.pname = pname;
	}
	public void setPage(int page) {
		this.page = page;
	}
	public String getPname() {
		return pname;
	}
	public int getPage() {
		return page;
	}

	@Override
	public String toString() {
		return "Person [pname=" + pname + ", page=" + page + "]";
	}
	
	public int computeAge() {
		return page > 25 ? 25 : page;
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册School -->
    <bean id="myPerson" class="top.qingrang.di09.Person">
    	<property name="pname" value="李四"/>
    	<property name="page" value="#{T(java.lang.Math).random() * 50}"/>   
    </bean>
    
    <bean id="myStudent" class="top.qingrang.di09.Student">
    	<property name="name" value="#{myPerson.pname}"/>
    	<!-- <property name="age" value="#{myPerson.page > 25 ? 25 : myPerson.page}"/> -->
    	<property name="age" value="#{myPerson.computeAge() }"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Person person = (Person) ac.getBean("myPerson");
	System.out.println(person);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
### 使用内部 Bean 注入
若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。

*applicationContext.mxl*
```
<!-- 注册 Student -->
<bean id="myStudent" class="top.qingrang.di10.Student">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
	<property name="school">
		<!-- 内部 Bean -->
	    <bean class="top.qingrang.di10.School">
	    	<property name="name" value="清华大学"/>
	    </bean>
	</property>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di10/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	
	// 不能访问，会报错
	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined
	School school = (School) ac.getBean("mySchool");
	System.out.println(school);
}
```
### 使用同类抽象 Bean 注入
当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。

抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。

*Student.java*
```
public class Student {
	private String name;
	private int age;
	private String school; // 学校

	public void setName(String name) {
		this.name = name;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public void setSchool(String school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<!-- 同类抽象 Bean，abstract="true" -->
<bean id="baseStudent" class="top.qingrang.di11.Student" abstract="true">
	<property name="school" value="清华大学"/>
</bean>
<!-- 利用 parent 实现继承 -->
<bean id="myStudent" parent="baseStudent">
	<property name="name" value="张三"/>
	<property name="age" value="23"/>
</bean>
<bean id="myStudent2" parent="baseStudent">
	<property name="name" value="李四"/>
	<property name="age" value="24"/>
</bean>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/di11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Student student2 = (Student) ac.getBean("myStudent2");
	System.out.println(student2);
}
```
### 使用异类抽象 Bean 注入
当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。
![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)
### 为应用指定多个 Spring 配置文件
在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。
#### 平等关系的配置文件
假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`
```
@Test
public void test01() {
	// 可变参数
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);
	// 参数数组
	String resource = "top/qingrang/di13/spring-base.xml";
	String resource2 = "top/qingrang/di13/spring-beans.xml";
	String[] resources = {resource, resource2};
	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);
	// 通配符
	String resource = "top/qingrang/di13/spring-*.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
	Teacher teacher = (Teacher) ac.getBean("myTeacher");
	System.out.println(teacher);
}
```
#### 包含关系的配置文件
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!-- 
	<import resource="classpath:top/qingrang/di14/spring-base.xml"/>
	<import resource="classpath:top/qingrang/di14/spring-beans.xml"/>
	 -->

	<!-- 使用通配符 -->
	<import resource="classpath:top/qingrang/di14/spring-*.xml"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di14/springTotal.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	...
}
```
## 基于注解的 DI
对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。
### 定义 Bean `@Component`
- 与 `@Component` 注解功能相同，但意义不同的注解还有三个：
	- `@Repository`：注解在 Dao 实现类上
	- `@Service`：注解在 Service 实现类上
	- `@Controller`：注解在 SpringMVC 的处理器上

### Bean 的作用域 `@Scope`
### 基本类型属性注入 `@Value`
### 按类型注入域属性 `@Autowired`
需要在域属性上使用注解 `@Autowired`，该注解默认使用按类型自动装配 Bean 的方式。使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。
### 按名称注入域属性 `@Autowired` 与 `@Qualifier`
需要在域属性上联合使用注解 `@Autowired` 与 `@Qualifier`。 `@Qualifier` 的 value 属性用于指定要匹配的 Bean 的 id 值。同样类中无需 setter，也可加到 setter 上。
### 域属性注解 `@Resource`
Spring 提供了对 JSR-250 规范中定义 `@Resource` 标准注解的支持。 `@Resource` 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。
### Bean 的生命始末 `@PostConstruct` 与 `@PreDestroy`
在方法上使用 `@PostConstruct`，与原来的 `init-method` 等效。在方法上使 `@PreDestroy`，与 `destroy-method` 等效。

*School.java*
```
// 组件，表示当前类被 Spring 容器所管理
@Component("mySchool")
public class School {
	@Value("清华大学")
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
// @Scope("prototype")   // 默认也是 singleton
@Component("myStudent")
public class Student {
	@Value("张三")
	private String name;
	@Value("23")
	private int age;

// ------------------- byType 方式的注解式注入 -------------------
//	@Autowired
//	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

// ----- byName 方式的注解式注入，要求 @Autowired 与 @Qualifier 联合使用 ----
//	@Autowired
//	@Qualifier("mySchool")
//	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

// -------------------- 域属性注解 @Resource --------------------
	// @Resource(name="mySchool")   // byName 方式的注解式注入
	@Resource   // byType 方式的注解式注入
	private School school;   // 对象属性，域属性
// --------------------------------------------------------------

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}

	// Bean 的生命始 @PostConstruct
	@PostConstruct
	public void initAfter() {
		System.out.println("当前Bean初始化刚完毕");
	}

	// Bean 的生命末 @PreDestroy
	@PreDestroy
	public void preDestroy() {
		System.out.println("当前Bean即将被销毁");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">
        
	<!-- 组件扫描 top.qingrang 这个包及其子包 -->
	<!--<context:component-scan base-package="top.qingrang"/> -->
	
	<!-- 组件扫描 top.qingrang 这个包的子包 -->
	<!--<context:component-scan base-package="top.qingrang.*"/> -->
	
	<context:component-scan base-package="top.qingrang.di01"/>
	
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载 Spring 配置文件
	String resource = "top/qingrang/di01/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
### 使用 JavaConfig 进行配置
JavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。
JavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML文件，而是由程序员使用 Java 自己编写的 Java 类。

*School.java*
```
public class School {
	private String name;

	public School() {
		super();
		// TODO Auto-generated constructor stub
	}

	public School(String name) {
		super();
		this.name = name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private int age;
	private School school; // 对象属性，域属性

	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public void setName(String name) {
		System.out.println("执行setName()");
		this.name = name;
	}

	public void setAge(int age) {
		System.out.println("执行setAge()");
		this.age = age;
	}

	public void setSchool(School school) {
		this.school = school;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + ", school=" + school
				+ "]";
	}
}
```
*MyJavaConfig.java*
```
@Configuration    // 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建
public class MyJavaConfig {
	
	@Bean(name="school")
	public School mySchoolCreator() {
		return new School("北京大学");
	}
	
	// autowire=Autowire.BY_TYPE 指从当前类这个容器中查找与域属性的类型具有is-a关系的Bean
	/*
	@Bean(name="myStudent", autowire=Autowire.BY_TYPE)
	public Student myStudentCreator() {
		return new Student("张三", 23);
	}
	*/
	
	// autowire=Autowire.BY_NAME 指从当前类这个容器中查找与域属性同名的Bean
	@Bean(name="myStudent", autowire=Autowire.BY_NAME)
	public Student myStudentCreator() {
		return new Student("张三", 23);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 扫描组件 -->
	<context:component-scan base-package="top.qingrang.di05"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/di05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	Student student = (Student) ac.getBean("myStudent");
	System.out.println(student);
}
```
### 使用 Spring 的 JUnit4 测试 Spring
使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，及从 Spring 容器中通过 getBean() 获取对象了。这些工作将由 JUnit4 注解，配合着域属性的自动注入注解共同完成。
*School.java*
```
public class School {
	private String name;

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "School [name=" + name + "]";
	}
}
```
*Student.java*
```
public class Student {
	private String name;
	private School school;   // 对象属性，域属性
	
	public void setName(String name) {
		this.name = name;
	}

	public void setSchool(School school) {
		this.school = school;
	}
	@Override
	public String toString() {
		return "Student [name=" + name + ", school=" + school + "]";
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 School -->
    <bean id="mySchool" class="top.qingrang.di06.School">
    	<property name="name" value="清华大学"/>
    </bean>

    <!-- 注册 Student -->
    <bean id="myStudent" class="top.qingrang.di06.Student">
    	<property name="name" value="张三"/>
    	<property name="school" ref="mySchool"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@RunWith(SpringJUnit4ClassRunner.class)	// 指定运行环境
@ContextConfiguration(locations="classpath:top/qingrang/di06/applicationContext.xml") // 指定配置文件位置
public class MyTest {

	//对于需要从容器中获取的 Bean 对象，使用 byType 或 byName 方式，将其自动注入.
	@Autowired
	private Student student;

	@Autowired
	private School school;

	//然后就可以直接测试对象了.
	@Test
	public void test01() {
		System.out.println(student);
	}
	
	@Test
	public void test02() {
		System.out.println(school);
	}
}
```

### 注解与 XML 共同使用
注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。
XML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。
若注解与 XML 同用， **XML 的优先级要高于注解**。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000766s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001524s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000858s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000321s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000874s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000296s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000369s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring(一) - IOC（控制反转）\r',`content`='# Spring(一) - IOC（控制反转）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n## 第一个 Spring 程序\r\n### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n## Bean 的装配\r\nBean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。\r\n### 默认装配方式\r\n代码通过 `getBean()` 方式从容器获取指定的 Bean 实例，容器首先会调用 Bean 类的无参构造器，创建空值的实例对象。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl();  -->\r\n    <bean id=\"myService\" class=\"com.bjpowernode.ba01.SomeServiceImpl\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"com/bjpowernode/ba01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n### 动态工厂 Bean\r\n有些时候，项目中需要通过工厂类来创建 Bean 实例，而不能像前面例子中似的，直接由 Spring 容器来装配 Bean 实例。使用工厂模式创建 Bean 实例，就会使工厂类与要创建的 Bean 类耦合到一起。但，这样做的缺点是，不仅工厂类与目标类耦合到了一起，测试类与工厂类也耦合到了一起。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n### 静态工厂 Bean\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	//静态方法\r\n	public static ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n### Bean 后处理器\r\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\r\n\r\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是**设计模式中的代理模式**。\r\n\r\n代码中需要**自定义 Bean 后处理器类**。该类就是**实现**了**接口 BeanPostProcessor** 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\r\n\r\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\r\n\r\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\r\n\r\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	String doSome();\r\n	String doOther();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public String doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n		return \"doSome() - abc\";\r\n	}\r\n	\r\n	@Override\r\n	public String doOther() {\r\n		System.out.println(\"执行doOther()方法\");\r\n		return \"doOther() - def\";\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n\r\n	// bean：表示当前正在进行初始化的Bean对象\r\n	// beanName：表示当前正在进行初始化的Bean对象的id\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- before() ---方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- after() ---方法\");\r\n		//判断 SomeServiceImpl 对象\r\n		if (\"myService\".equals(beanName)) {\r\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\r\n					bean.getClass().getInterfaces(),\r\n					new InvocationHandler() {\r\n						@Override\r\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n							Object invoke = method.invoke(bean, args);\r\n							//判断具体方法\r\n							if (\"doSome\".equals(method.getName())) {\r\n								return ((String) invoke).toUpperCase();\r\n							}\r\n							return invoke;\r\n						}\r\n					});\r\n			return obj;\r\n		}\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册 Bean 后处理器 -->\r\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	System.out.println(service.doSome());\r\n	System.out.println(service.doOther());\r\n\r\n	System.out.println(\"======================\");\r\n\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\r\n	System.out.println(service2.doSome());\r\n	System.out.println(service2.doOther());\r\n}\r\n```\r\n\r\n*输出结果*\r\n```\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行doSome()方法\r\nDOSOME() - ABC\r\n执行doOther()方法\r\ndoOther() - def\r\n======================\r\n执行doSome()方法\r\ndoSome() - abc\r\n执行doOther()方法\r\ndoOther() - def\r\n```\r\n### Bean 的生命周期\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\r\n	private String adao;\r\n	private String bdao;\r\n\r\n	public void setAdao(String adao) {\r\n		this.adao = adao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public void setBdao(String bdao) {\r\n		this.bdao = bdao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"Step1：执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"Step9：执行 doSome() 方法\");\r\n	}\r\n\r\n	public void setUp() {\r\n		System.out.println(\"Step7：初始化完毕之后\");\r\n	}\r\n\r\n	public void tearDown() {\r\n		System.out.println(\"Step11：销毁之前\");\r\n	}\r\n\r\n	@Override\r\n	public void setBeanName(String name) {\r\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\r\n	}\r\n\r\n	@Override\r\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\r\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\r\n	}\r\n\r\n	@Override\r\n	public void afterPropertiesSet() throws Exception {\r\n		System.out.println(\"Step6：Bean 初始化完毕了\");\r\n	}\r\n\r\n	@Override\r\n	public void destroy() throws Exception {\r\n		System.out.println(\"Step10：实现接口的销毁之前\");\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - Bean 后处理器*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\r\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\r\n    	<property name=\"adao\" value=\"aaa\"/>\r\n    	<property name=\"bdao\" value=\"bbb\"/>\r\n   	</bean>\r\n\r\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n	// 对于销毁方法的执行，有两个条件：\r\n	// 1)当前的Bean需要是singleton的\r\n	// 2)要手工关闭容器\r\n	((ClassPathXmlApplicationContext)ac).close();\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\nStep1：执行无参构造器\r\nStep2：执行 setter\r\nStep2：执行 setter\r\nStep3：获取到 bean 的 id = myService\r\nStep4：获取到 BeanFactory 容器\r\nStep5：MyBeanPostProcessor - 执行 before() 方法\r\nStep6：Bean 初始化完毕了\r\nStep7：初始化完毕之后\r\nStep8：MyBeanPostProcessor - 执行 after() 方法\r\nStep9：执行 doSome() 方法\r\nStep10：实现接口的销毁之前\r\nStep11：销毁之前\r\n```\r\n## 基于 XML 的 DI\r\nBean 实例在调用无参构造器创建了空值对象后，就要**对 Bean 对象的属性进行初始化**。初始化是由容器自动完成的，称为注入。\r\n### 注入分类\r\n#### 设值注入(常用)\r\n和 `setter` 方法有关系。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di01.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"age\" value=\"23\"/>\r\n        <!-- 对于对象的注入要用 ref -->\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di01.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\n执行setName()\r\n执行setAge()\r\nStudent [name=张三, age=23, school=School [name=清华大学]]\r\n```\r\n#### 构造注入(很少用)\r\n和 `setter` 方法没有关系，和构造方法有关系。\r\n\r\n*Student.java - 为 Student 增加带参构造器*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school;   // 对象属性，域属性\r\n\r\n	/**\r\n	 * 带参数的构造方法\r\n	 */\r\n	public Student(String name, int age, School school) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n		this.school = school;\r\n	}\r\n	...\r\n}\r\n```\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di02.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di02.Student\">\r\n        <!-- 构造器参数，指定 name -->\r\n    	<constructor-arg name=\"name\" value=\"李四\"/>\r\n    	<constructor-arg name=\"age\" value=\"24\"/>\r\n    	<constructor-arg name=\"school\" ref=\"mySchool\"/>\r\n\r\n        <!-- 构造器参数，使用索引 -->\r\n    	<!--\r\n    	<constructor-arg index=\"0\" value=\"李四\"/>\r\n    	<constructor-arg index=\"1\" value=\"24\"/>\r\n    	<constructor-arg index=\"2\" ref=\"mySchool\"/>\r\n    	 -->\r\n\r\n        <!-- 构造器参数，默认索引 -->\r\n    	<!--\r\n    	<constructor-arg value=\"李四\"/>\r\n    	<constructor-arg value=\"24\"/>\r\n    	<constructor-arg ref=\"mySchool\"/>\r\n    	 -->\r\n    </bean>\r\n</beans>\r\n```\r\n### 集合属性注入\r\n基本类型数组，对象数组，List，Set，Map，Properties 等。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Some.java*\r\n```\r\npublic class Some {\r\n	private School[] schools; // 对象数组\r\n	private String[] myStrs; // 字符串数组\r\n	private List<String> myList; // List\r\n	private Set<String> mySet; // Set\r\n	private Map<String, Object> myMap; // Map\r\n	private Properties myPros; // Properties\r\n\r\n	public void setSchools(School[] schools) {\r\n		this.schools = schools;\r\n	}\r\n	public void setMyStrs(String[] myStrs) {\r\n		this.myStrs = myStrs;\r\n	}\r\n	public void setMyList(List<String> myList) {\r\n		this.myList = myList;\r\n	}\r\n	public void setMySet(Set<String> mySet) {\r\n		this.mySet = mySet;\r\n	}\r\n	public void setMyMap(Map<String, Object> myMap) {\r\n		this.myMap = myMap;\r\n	}\r\n	public void setMyPros(Properties myPros) {\r\n		this.myPros = myPros;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Some [schools=\" + Arrays.toString(schools) + \", myStrs=\"\r\n				+ Arrays.toString(myStrs) + \", myList=\" + myList + \", mySet=\"\r\n				+ mySet + \", myMap=\" + myMap + \", myPros=\" + myPros + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.xml*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n    <bean id=\"mySchool2\" class=\"top.qingrang.di05.School\">\r\n    	<property name=\"name\" value=\"北京大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"mySome\" class=\"top.qingrang.di05.Some\">\r\n		<!-- 对象数组 -->\r\n    	<property name=\"schools\">\r\n    		<array>\r\n    			<ref bean=\"mySchool\"/>\r\n    			<ref bean=\"mySchool2\"/>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写，带 ref 的若只有一个可以简写，多个则不行 -->\r\n		<property name=\"schools\" value=\"mySchool\"/>\r\n\r\n		<!-- 基本类型数组 -->\r\n    	<property name=\"myStrs\">\r\n    		<array>\r\n    			<value>中国</value>\r\n    			<value>北京</value>\r\n    		</array>\r\n    	</property>\r\n		<!-- 数组：简写 -->\r\n		<property name=\"myStrs\" value=\"中国,北京\"/>\r\n\r\n		<!-- List<String> -->\r\n    	<property name=\"myList\">\r\n    		<list>\r\n    			<value>大兴</value>\r\n    			<value>亦庄</value>\r\n    		</list>\r\n    	</property>\r\n		<!-- List<String>：简写 -->\r\n		<property name=\"myList\" value=\"大兴,亦庄\"/>\r\n\r\n		<!-- Set<String> -->\r\n    	<property name=\"mySet\">\r\n    		<set>\r\n    			<value>大族企业湾</value>\r\n    			<value>10号楼</value>\r\n    		</set>\r\n    	</property>\r\n		<!-- Set<String>：简写 -->\r\n		<property name=\"mySet\" value=\"大族企业湾,10号楼\"/>\r\n\r\n		<!-- Map<String, Object>，Map 的键值都是 object -->\r\n    	<property name=\"myMap\">\r\n    		<map>\r\n    			<entry key=\"mobile\" value=\"1234567\"/>\r\n    			<entry key=\"QQ\" value=\"7654321\"/>\r\n    		</map>\r\n    	</property>\r\n\r\n		<!-- Properties，Properties 的键值都是字符串 -->\r\n    	<property name=\"myPros\">\r\n    		<props>\r\n    			<prop key=\"education\">大学</prop>\r\n    			<prop key=\"gender\">男</prop>\r\n    		</props>\r\n    	</property>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载 Spring 配置文件\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Some some = (Some) ac.getBean(\"mySome\");\r\n	System.out.println(some);\r\n}\r\n```\r\n### 对于域属性(对象)的自动注入\r\n#### byName 方式自动注入\r\n![byName 方式自动注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-04-38.png)\r\n#### byType 方式自动注入\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-17-22-06-41.png)\r\n### 使用 SPEL 注入\r\nSPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。用法： `<bean id=“abc” value=“#{…}”/>`。\r\n*Person.java*\r\n```\r\npublic class Person {\r\n	private String pname;\r\n	private int page;\r\n\r\n	public void setPname(String pname) {\r\n		this.pname = pname;\r\n	}\r\n	public void setPage(int page) {\r\n		this.page = page;\r\n	}\r\n	public String getPname() {\r\n		return pname;\r\n	}\r\n	public int getPage() {\r\n		return page;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Person [pname=\" + pname + \", page=\" + page + \"]\";\r\n	}\r\n	\r\n	public int computeAge() {\r\n		return page > 25 ? 25 : page;\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册School -->\r\n    <bean id=\"myPerson\" class=\"top.qingrang.di09.Person\">\r\n    	<property name=\"pname\" value=\"李四\"/>\r\n    	<property name=\"page\" value=\"#{T(java.lang.Math).random() * 50}\"/>   \r\n    </bean>\r\n    \r\n    <bean id=\"myStudent\" class=\"top.qingrang.di09.Student\">\r\n    	<property name=\"name\" value=\"#{myPerson.pname}\"/>\r\n    	<!-- <property name=\"age\" value=\"#{myPerson.page > 25 ? 25 : myPerson.page}\"/> -->\r\n    	<property name=\"age\" value=\"#{myPerson.computeAge() }\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di09/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Person person = (Person) ac.getBean(\"myPerson\");\r\n	System.out.println(person);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n### 使用内部 Bean 注入\r\n若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。\r\n\r\n*applicationContext.mxl*\r\n```\r\n<!-- 注册 Student -->\r\n<bean id=\"myStudent\" class=\"top.qingrang.di10.Student\">\r\n	<property name=\"name\" value=\"张三\"/>\r\n	<property name=\"age\" value=\"23\"/>\r\n	<property name=\"school\">\r\n		<!-- 内部 Bean -->\r\n	    <bean class=\"top.qingrang.di10.School\">\r\n	    	<property name=\"name\" value=\"清华大学\"/>\r\n	    </bean>\r\n	</property>\r\n</bean>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di10/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	\r\n	// 不能访问，会报错\r\n	//org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named \'mySchool\' is defined\r\n	School school = (School) ac.getBean(\"mySchool\");\r\n	System.out.println(school);\r\n}\r\n```\r\n### 使用同类抽象 Bean 注入\r\n当若干 Bean 实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象 Bean，以简化配置文件。\r\n\r\n抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。\r\n\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private String school; // 学校\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n\r\n	public void setSchool(String school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<!-- 同类抽象 Bean，abstract=\"true\" -->\r\n<bean id=\"baseStudent\" class=\"top.qingrang.di11.Student\" abstract=\"true\">\r\n	<property name=\"school\" value=\"清华大学\"/>\r\n</bean>\r\n<!-- 利用 parent 实现继承 -->\r\n<bean id=\"myStudent\" parent=\"baseStudent\">\r\n	<property name=\"name\" value=\"张三\"/>\r\n	<property name=\"age\" value=\"23\"/>\r\n</bean>\r\n<bean id=\"myStudent2\" parent=\"baseStudent\">\r\n	<property name=\"name\" value=\"李四\"/>\r\n	<property name=\"age\" value=\"24\"/>\r\n</bean>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/di11/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	Student student2 = (Student) ac.getBean(\"myStudent2\");\r\n	System.out.println(student2);\r\n}\r\n```\r\n### 使用异类抽象 Bean 注入\r\n当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。\r\n![异类抽象 Bean 注入](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-18-19-41-35.png)\r\n### 为应用指定多个 Spring 配置文件\r\n在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。\r\n#### 平等关系的配置文件\r\n假设有两个配置文件：`spring-base.xml`，`spring-beans.xml`\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 可变参数\r\n	String resource = \"top/qingrang/di13/spring-base.xml\";\r\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource, resource2);\r\n	// 参数数组\r\n	String resource = \"top/qingrang/di13/spring-base.xml\";\r\n	String resource2 = \"top/qingrang/di13/spring-beans.xml\";\r\n	String[] resources = {resource, resource2};\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resources);\r\n	// 通配符\r\n	String resource = \"top/qingrang/di13/spring-*.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n	Teacher teacher = (Teacher) ac.getBean(\"myTeacher\");\r\n	System.out.println(teacher);\r\n}\r\n```\r\n#### 包含关系的配置文件\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n	<!-- \r\n	<import resource=\"classpath:top/qingrang/di14/spring-base.xml\"/>\r\n	<import resource=\"classpath:top/qingrang/di14/spring-beans.xml\"/>\r\n	 -->\r\n\r\n	<!-- 使用通配符 -->\r\n	<import resource=\"classpath:top/qingrang/di14/spring-*.xml\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/di14/springTotal.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	...\r\n}\r\n```\r\n## 基于注解的 DI\r\n对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。\r\n### 定义 Bean `@Component`\r\n- 与 `@Component` 注解功能相同，但意义不同的注解还有三个：\r\n	- `@Repository`：注解在 Dao 实现类上\r\n	- `@Service`：注解在 Service 实现类上\r\n	- `@Controller`：注解在 SpringMVC 的处理器上\r\n\r\n### Bean 的作用域 `@Scope`\r\n### 基本类型属性注入 `@Value`\r\n### 按类型注入域属性 `@Autowired`\r\n需要在域属性上使用注解 `@Autowired`，该注解默认使用按类型自动装配 Bean 的方式。使用该注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。\r\n### 按名称注入域属性 `@Autowired` 与 `@Qualifier`\r\n需要在域属性上联合使用注解 `@Autowired` 与 `@Qualifier`。 `@Qualifier` 的 value 属性用于指定要匹配的 Bean 的 id 值。同样类中无需 setter，也可加到 setter 上。\r\n### 域属性注解 `@Resource`\r\nSpring 提供了对 JSR-250 规范中定义 `@Resource` 标准注解的支持。 `@Resource` 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。\r\n### Bean 的生命始末 `@PostConstruct` 与 `@PreDestroy`\r\n在方法上使用 `@PostConstruct`，与原来的 `init-method` 等效。在方法上使 `@PreDestroy`，与 `destroy-method` 等效。\r\n\r\n*School.java*\r\n```\r\n// 组件，表示当前类被 Spring 容器所管理\r\n@Component(\"mySchool\")\r\npublic class School {\r\n	@Value(\"清华大学\")\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\n// @Scope(\"prototype\")   // 默认也是 singleton\r\n@Component(\"myStudent\")\r\npublic class Student {\r\n	@Value(\"张三\")\r\n	private String name;\r\n	@Value(\"23\")\r\n	private int age;\r\n\r\n// ------------------- byType 方式的注解式注入 -------------------\r\n//	@Autowired\r\n//	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n// ----- byName 方式的注解式注入，要求 @Autowired 与 @Qualifier 联合使用 ----\r\n//	@Autowired\r\n//	@Qualifier(\"mySchool\")\r\n//	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n// -------------------- 域属性注解 @Resource --------------------\r\n	// @Resource(name=\"mySchool\")   // byName 方式的注解式注入\r\n	@Resource   // byType 方式的注解式注入\r\n	private School school;   // 对象属性，域属性\r\n// --------------------------------------------------------------\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n\r\n	// Bean 的生命始 @PostConstruct\r\n	@PostConstruct\r\n	public void initAfter() {\r\n		System.out.println(\"当前Bean初始化刚完毕\");\r\n	}\r\n\r\n	// Bean 的生命末 @PreDestroy\r\n	@PreDestroy\r\n	public void preDestroy() {\r\n		System.out.println(\"当前Bean即将被销毁\");\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n        \r\n	<!-- 组件扫描 top.qingrang 这个包及其子包 -->\r\n	<!--<context:component-scan base-package=\"top.qingrang\"/> -->\r\n	\r\n	<!-- 组件扫描 top.qingrang 这个包的子包 -->\r\n	<!--<context:component-scan base-package=\"top.qingrang.*\"/> -->\r\n	\r\n	<context:component-scan base-package=\"top.qingrang.di01\"/>\r\n	\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载 Spring 配置文件\r\n	String resource = \"top/qingrang/di01/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n### 使用 JavaConfig 进行配置\r\nJavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。\r\nJavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML文件，而是由程序员使用 Java 自己编写的 Java 类。\r\n\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public School() {\r\n		super();\r\n		// TODO Auto-generated constructor stub\r\n	}\r\n\r\n	public School(String name) {\r\n		super();\r\n		this.name = name;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private int age;\r\n	private School school; // 对象属性，域属性\r\n\r\n	public Student() {\r\n		super();\r\n		// TODO Auto-generated constructor stub\r\n	}\r\n\r\n	public Student(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n\r\n	public void setName(String name) {\r\n		System.out.println(\"执行setName()\");\r\n		this.name = name;\r\n	}\r\n\r\n	public void setAge(int age) {\r\n		System.out.println(\"执行setAge()\");\r\n		this.age = age;\r\n	}\r\n\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", age=\" + age + \", school=\" + school\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n*MyJavaConfig.java*\r\n```\r\n@Configuration    // 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建\r\npublic class MyJavaConfig {\r\n	\r\n	@Bean(name=\"school\")\r\n	public School mySchoolCreator() {\r\n		return new School(\"北京大学\");\r\n	}\r\n	\r\n	// autowire=Autowire.BY_TYPE 指从当前类这个容器中查找与域属性的类型具有is-a关系的Bean\r\n	/*\r\n	@Bean(name=\"myStudent\", autowire=Autowire.BY_TYPE)\r\n	public Student myStudentCreator() {\r\n		return new Student(\"张三\", 23);\r\n	}\r\n	*/\r\n	\r\n	// autowire=Autowire.BY_NAME 指从当前类这个容器中查找与域属性同名的Bean\r\n	@Bean(name=\"myStudent\", autowire=Autowire.BY_NAME)\r\n	public Student myStudentCreator() {\r\n		return new Student(\"张三\", 23);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n	<!-- 扫描组件 -->\r\n	<context:component-scan base-package=\"top.qingrang.di05\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/di05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	Student student = (Student) ac.getBean(\"myStudent\");\r\n	System.out.println(student);\r\n}\r\n```\r\n### 使用 Spring 的 JUnit4 测试 Spring\r\n使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，及从 Spring 容器中通过 getBean() 获取对象了。这些工作将由 JUnit4 注解，配合着域属性的自动注入注解共同完成。\r\n*School.java*\r\n```\r\npublic class School {\r\n	private String name;\r\n\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"School [name=\" + name + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private String name;\r\n	private School school;   // 对象属性，域属性\r\n	\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n\r\n	public void setSchool(School school) {\r\n		this.school = school;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [name=\" + name + \", school=\" + school + \"]\";\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 School -->\r\n    <bean id=\"mySchool\" class=\"top.qingrang.di06.School\">\r\n    	<property name=\"name\" value=\"清华大学\"/>\r\n    </bean>\r\n\r\n    <!-- 注册 Student -->\r\n    <bean id=\"myStudent\" class=\"top.qingrang.di06.Student\">\r\n    	<property name=\"name\" value=\"张三\"/>\r\n    	<property name=\"school\" ref=\"mySchool\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@RunWith(SpringJUnit4ClassRunner.class)	// 指定运行环境\r\n@ContextConfiguration(locations=\"classpath:top/qingrang/di06/applicationContext.xml\") // 指定配置文件位置\r\npublic class MyTest {\r\n\r\n	//对于需要从容器中获取的 Bean 对象，使用 byType 或 byName 方式，将其自动注入.\r\n	@Autowired\r\n	private Student student;\r\n\r\n	@Autowired\r\n	private School school;\r\n\r\n	//然后就可以直接测试对象了.\r\n	@Test\r\n	public void test01() {\r\n		System.out.println(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test02() {\r\n		System.out.println(school);\r\n	}\r\n}\r\n```\r\n\r\n### 注解与 XML 共同使用\r\n注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。\r\nXML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。\r\n若注解与 XML 同用， **XML 的优先级要高于注解**。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.001582s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001985s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000322s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000909s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=20  WHERE  `groups` = 'Java' [ RunTime:0.000315s ]
---------------------------------------------------------------
[ 2018-11-18T22:14:06+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.051352s][吞吐率：19.47req/s] [内存消耗：2,056.34kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000558s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001409s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000748s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000892s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000297s ]
---------------------------------------------------------------
[ 2018-11-18T22:15:04+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ info ] qingrang.top/daily/admin/note/addnote.html [运行时间：0.060006s][吞吐率：16.66req/s] [内存消耗：1,978.15kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'addnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '986',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
  'content' => '# Spring(二) - AOP（控制反转）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。

',
  'test-editormd-html-code' => '<h1 id="h1-spring-aop-"><a name="Spring(二) - AOP（控制反转）" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Spring(二) - AOP（控制反转）</h1><div class="markdown-toc editormd-markdown-toc">[TOC]</div><p>Spring 是一个基于 <strong>IOC</strong> 和 <strong>AOP</strong> 的结构 J2EE 系统的框架。</p>
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->addNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000516s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001201s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000391s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000335s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001026s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('Spring(二) - AOP（控制反转）\r' , '# Spring(二) - AOP（控制反转）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n\r\n' , 'Java' , 2 , '2018-11-18') [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001219s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000467s ]
---------------------------------------------------------------
[ 2018-11-18T22:15:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.083386s][吞吐率：11.99req/s] [内存消耗：2,320.92kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000442s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001366s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001995s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000565s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001102s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000343s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000681s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000971s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000401s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000731s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000446s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000422s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001492s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000228s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.002170s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001215s ]
---------------------------------------------------------------
[ 2018-11-18T22:15:26+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.072590s][吞吐率：13.78req/s] [内存消耗：2,586.12kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '14',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'Java',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000726s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001423s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.002426s ]
---------------------------------------------------------------
[ 2018-11-18T22:15:37+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.109873s][吞吐率：9.10req/s] [内存消耗：2,320.29kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000736s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002050s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002875s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000924s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001576s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000528s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000766s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001406s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000511s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000658s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000401s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000545s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001744s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000414s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001826s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001032s ]
---------------------------------------------------------------
[ 2018-11-18T22:15:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/250.html
[ info ] qingrang.top/daily/admin/note/editnote/id/250.html [运行时间：0.091947s][吞吐率：10.88req/s] [内存消耗：2,028.11kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000602s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003668s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.003552s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.016174s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.001383s ]
---------------------------------------------------------------
[ 2018-11-18T22:16:00+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/250.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/250.html [运行时间：0.073793s][吞吐率：13.55req/s] [内存消耗：2,048.09kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '339',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(二) - AOP（面向切面）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。

',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000542s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001548s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000399s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000316s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000882s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000324s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000289s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=250,`p_id`=2,`title`='Spring(二) - AOP（面向切面）\r',`content`='# Spring(二) - AOP（面向切面）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 250 [ RunTime:0.000581s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001350s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000351s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001092s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000382s ]
---------------------------------------------------------------
[ 2018-11-18T22:16:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/250.html
[ info ] qingrang.top/daily/admin/note/shownote/id/250.html [运行时间：0.092028s][吞吐率：10.87req/s] [内存消耗：1,979.93kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000605s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002186s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.002063s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001875s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000443s ]
---------------------------------------------------------------
[ 2018-11-18T22:16:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.105400s][吞吐率：9.49req/s] [内存消耗：2,325.76kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000552s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001945s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002598s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000752s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001492s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000472s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000750s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001428s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000441s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000595s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000436s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000552s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001623s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000393s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001564s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001008s ]
---------------------------------------------------------------
[ 2018-11-18T22:16:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/249.html
[ info ] qingrang.top/daily/admin/note/shownote/id/249.html [运行时间：0.063131s][吞吐率：15.84req/s] [内存消耗：1,981.12kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=hge9pia5328bpr4hf4aq2an796',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '249',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000625s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001362s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 249 LIMIT 1 [ RunTime:0.000400s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000873s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000283s ]
