---------------------------------------------------------------
[ 2018-11-10T13:30:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.041763s][吞吐率：23.94req/s] [内存消耗：1,339.89kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-10T13:31:12+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.088253s][吞吐率：11.33req/s] [内存消耗：1,922.46kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001714s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002421s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000606s ]
---------------------------------------------------------------
[ 2018-11-10T13:31:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.076879s][吞吐率：13.01req/s] [内存消耗：2,286.60kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000710s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001545s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002969s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000608s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000941s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000432s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000688s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000891s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000325s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000413s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000333s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000478s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001030s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000262s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001050s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000713s ]
---------------------------------------------------------------
[ 2018-11-10T13:33:11+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.059305s][吞吐率：16.86req/s] [内存消耗：2,072.51kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000616s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001503s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000658s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001018s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000359s ]
---------------------------------------------------------------
[ 2018-11-10T15:25:57+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.068605s][吞吐率：14.58req/s] [内存消耗：2,284.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '59400',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000906s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001843s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.002034s ]
---------------------------------------------------------------
[ 2018-11-10T15:49:32+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.062372s][吞吐率：16.03req/s] [内存消耗：2,297.80kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '62086',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000813s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001420s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001550s ]
---------------------------------------------------------------
[ 2018-11-10T15:49:33+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.060881s][吞吐率：16.43req/s] [内存消耗：2,297.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '62086',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000641s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001383s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001433s ]
---------------------------------------------------------------
[ 2018-11-10T15:49:39+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.093051s][吞吐率：10.75req/s] [内存消耗：2,297.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '62086',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000734s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001734s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.002198s ]
---------------------------------------------------------------
[ 2018-11-10T15:51:24+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.066728s][吞吐率：14.99req/s] [内存消耗：2,298.05kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '62135',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```
### 延迟加载',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000735s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001322s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```\n### 延迟加载',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001680s ]
---------------------------------------------------------------
[ 2018-11-10T15:51:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/1.html
[ info ] qingrang.top/daily/admin/note/editnote/id/1.html [运行时间：0.062267s][吞吐率：16.06req/s] [内存消耗：2,086.99kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000614s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001563s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000738s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000979s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000396s ]
---------------------------------------------------------------
[ 2018-11-10T15:51:44+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.059339s][吞吐率：16.85req/s] [内存消耗：2,021.30kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '54',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/1.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'context' => '### 延迟加载',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000647s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001502s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='延迟加载',`content`='### 延迟加载',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000657s ]
---------------------------------------------------------------
[ 2018-11-10T16:48:03+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.050226s][吞吐率：19.91req/s] [内存消耗：1,415.67kb] [文件加载：50]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '5483',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/1.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'context' => '[TOC]
### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ LOG ] INIT File
[ error ] [8]未定义数组下标: 1[/var/www/html/daily/application/admin/controller/Note.php:169]
---------------------------------------------------------------
[ 2018-11-10T18:19:33+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.080125s][吞吐率：12.48req/s] [内存消耗：2,346.74kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '74984',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001515s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002529s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```\n\n### 延迟加载\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\n\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\n\n#### 关联对象加载时机\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\n\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\n\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\n\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\n\n#### 延迟加载的总开关\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\n\n*mybatis.xml*\n```\n<configuration>\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 设置整个应用所使用的常量 -->\n    <settings>\n        <!-- 延迟加载的总开关 -->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    </settings>\n\n    <typeAliases>\n		...\n    </typeAliases>\n</configuration>\n```\n\n#### 直接加载\n*mybatis.xml*\n```\n<settings>\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\n</settings>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\n	System.out.println(country.getCname());\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 直接加载（√）：查询 country，查询 minister ---\nChina\nTotal：3\n```\n\n#### 侵入式延迟加载\n*mybatis.xml*\n```\n<!-- 设置整个应用所使用的常量 -->\n<settings>\n    <!-- 延迟加载的总开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!-- 侵入式延迟加载 -->\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\n</settings>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\n	System.out.println(country.getCname());\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 侵入式延迟加载（X）：查询 country ---\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\nChina\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\nTotal：3\n```\n#### 深度延迟加载\n*mybatis.xml*\n```\n<!-- 设置整个应用所使用的常量 -->\n<settings>\n    <!-- 延迟加载的总开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n</settings>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\n	System.out.println(country.getCname());\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 深度延迟加载（X）：查询 country ---\nChina\n---- 深度延迟加载（X）：访问主加载对象 ---\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\nTotal：3\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.002458s ]
---------------------------------------------------------------
[ 2018-11-10T18:19:35+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/243.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/243.html [运行时间：0.077295s][吞吐率：12.94req/s] [内存消耗：2,348.99kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '81000',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000650s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001614s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000646s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000346s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001077s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000372s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000371s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=243,`p_id`=2,`title`='Mybatis\r',`content`='# Mybatis\r\n[TOC]\r\n## Mybatis 体系结构和工作原理\r\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\r\n## 第一个 MyBaits 程序\r\n### 主配置文件详解\r\n1. 注册数据库连接四要素属性文件\r\n`<properties resource=\"jdbc_mysql.properties\"/>`\r\n1. 定义类型别名\r\n```\r\n<typeAliases>\r\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\r\n	<package name=\"top.qingrang.beans\"/>\r\n</typeAliases>\r\n```\r\n1. 配置运行环境\r\n```\r\n<environments default=\"XXX2\">\r\n	<!-- 环境，eg：上线环境 -->\r\n	<environment id=\"XXX1\">\r\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n		<transactionManager type=\"JDBC\"/>\r\n		<!-- 数据源，数据库连接池 -->\r\n		<dataSource type=\"POOLED\">\r\n			<!-- 数据库连接四要素 -->\r\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n			<property name=\"url\" value=\"${jdbc.url}\"/>\r\n			<property name=\"username\" value=\"${jdbc.user}\"/>\r\n			<property name=\"password\" value=\"${jdbc.password}\"/>\r\n		</dataSource>\r\n	</environment>\r\n\r\n	<!-- 另一个环境，eg：本地测试的环境 -->\r\n	<environment id=\"XXX2\">\r\n		...\r\n	</environment>\r\n</environments>\r\n```\r\n1. 注册映射文件\r\n```\r\n<mappers>\r\n	<!-- 配置文件路径 -->\r\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n>问题？\r\n\r\n1. environments 下为什么可以配置多个 environment？\r\n方便切换运行环境，只需要改变 `default` 即可\r\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\r\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\r\n1. 什么是数据库连接池？\r\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\r\n\r\n*mybatis.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 注册数据库连接四要素属性文件 -->\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 定义类型别名 -->\r\n    <typeAliases>\r\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\r\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\r\n        <package name=\"top.qingrang.beans\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\r\n    <environments default=\"onlineEM\">\r\n        <!-- 上线以后的环境 -->\r\n        <environment id=\"onlineEM\">\r\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n            <transactionManager type=\"JDBC\"/>\r\n            <!-- 数据源，数据库连接池 -->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- 数据库连接四要素 -->\r\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n                <property name=\"url\" value=\"${jdbc.url}\"/>\r\n                <property name=\"username\" value=\"${jdbc.user}\"/>\r\n                <property name=\"password\" value=\"${jdbc.password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n        <!-- 本地测试的环境 -->\r\n        <environment id=\"testEM\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"111\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <!-- 注册映射文件 -->\r\n    <mappers>\r\n        <!-- 配置文件路径 -->\r\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n    </mappers>\r\n\r\n</configuration>\r\n```\r\n### 核心代码\r\n利用 sqlSession 对象，执行相关操作。\r\n```\r\nprivate SqlSession sqlSession;\r\n\r\n@Override\r\npublic void insertStu(Student student) {\r\n	try {\r\n		// 1.加载主配置文件\r\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n		// 2.创建 SqlSessionFactory 对象\r\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n		// 3.创建 sqlSession 对象\r\n		sqlSession = sqlSessionFactory.openSession();\r\n		// 4.执行相关操作\r\n		sqlSession.insert(\"insertStudent\", student);\r\n		// 5.提交\r\n		sqlSession.commit();\r\n	} catch (IOException e) {\r\n		e.printStackTrace();\r\n	} finally {\r\n		if(sqlSession != null) {\r\n			// 6.关闭\r\n			sqlSession.close();\r\n		}\r\n	}\r\n}\r\n```\r\n### 封装 MyBatis 工具类\r\n*MyBatisUtils.java*\r\n```\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * MyBatis 工具类\r\n */\r\npublic class MyBatisUtils {\r\n\r\n	private static SqlSessionFactory sqlSessionFactory;\r\n\r\n	/**\r\n	 * 得到 SqlSession 对象\r\n	 */\r\n	public static SqlSession getSqlSession() {\r\n		try {\r\n			// 1.加载主配置文件\r\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n			if (sqlSessionFactory == null) {\r\n				// 2.创建 SqlSessionFactory 对象\r\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n			}\r\n			// 3.返回 SqlSession 对象\r\n			return sqlSessionFactory.openSession();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return null;\r\n	}\r\n}\r\n```\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n### 源码分析\r\n#### 输入流的关闭\r\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的创建\r\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\r\n\r\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\r\n\r\n>dirty 详解\r\n\r\ntrue：和数据库中的数据不一致(脏)\r\nfalse：和数据库中的数据一致(不脏)\r\n\r\n#### 增删改的执行\r\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\r\n\r\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\r\n\r\n#### SqlSession 的提交 commit()\r\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的关闭\r\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 单表的 CURD 操作\r\n### 常用的增删改查\r\n*mapper.xml*\r\n```\r\n<!-- parameterType 可以省略 -->\r\n<insert id=\"insertStudent\" parameterType=\"Student\">\r\n	<!-- 这里的 #{} 是属性 -->\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<!-- 插入后用新 id 初始化被插入对象 -->\r\n<insert id=\"insertStudentCacheId\">\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\r\n		select @@identity\r\n	</selectKey>\r\n</insert>\r\n\r\n<delete id=\"deleteStudentById\">\r\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\r\n	DELETE FROM student WHERE id = #{id}\r\n</delete>\r\n\r\n<update id=\"updateStudent\">\r\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\r\n</update>\r\n\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n\r\n<!-- 模糊查询 -->\r\n<select id=\"selectStudentsByName\" resultType=\"Student\">\r\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\r\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\r\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\r\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\r\n</select>\r\n```\r\n\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void insertStudentCacheId(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.insert(\"insertStudentCacheId\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void deleteStudentById(int id) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.delete(\"deleteStudentById\", id);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.update(\"updateStudent\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectAllStudents\");\r\n			//查询不需要 sqlSession.commit();\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n\r\n	@Override\r\n	public Map<String, Object> selectAllStudentsMap() {\r\n		Map<String, Object> map = new HashMap<>();\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return map;\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		Student student = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			student = sqlSession.selectOne(\"selectStudentById\", id);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return student;\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectStudentsByName(String name) {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n}\r\n```\r\n\r\n### 属性名与查询字段名不相同\r\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\r\n```\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n```\r\n#### 解决方案一：查询字段使用别名\r\n```\r\n<insert id=\"insertStudent\">\r\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n#### 解决方案二：使用结果映射 resultMap\r\n```\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"tid\" property=\"id\"/>\r\n	<result column=\"tname\" property=\"name\"/>\r\n 	<result column=\"tage\" property=\"age\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n### Mapper 动态代理\r\n#### 修改映射文件的 namespace 属性值\r\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\r\n通过接口名即可定位到映射文件 mapper.\r\n#### 删除 IStudentDaoImpl 实现类\r\n#### 修改 MyText.java 测试方法\r\n*MyTex.java*\r\n```\r\npublic class MyTest {\r\n	private IStudentDao dao;\r\n	private SqlSession sqlSession;\r\n\r\n	@Before\r\n	public void before() {\r\n		sqlSession = MyBatisUtils.getSqlSession();\r\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n	}\r\n\r\n	@After\r\n	public void after() {\r\n		if(sqlSession != null) {\r\n			sqlSession.close();\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudent() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudent(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudentCacheId() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudentCacheId(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testDeleteStudentById() {\r\n		dao.deleteStudentById(12);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testUpdateStudent() {\r\n		Student student = new Student(\"张三\", 25, 93.5);\r\n		student.setId(15);\r\n		dao.updateStudent(student);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testSelectAllStudents() {\r\n		List<Student> students = dao.selectAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentById() {\r\n		Student student = dao.selectStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentsByName() {\r\n		List<Student> students = dao.selectStudentsByName(\"张\");\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n}\r\n```\r\n##### Dao 对象的获取\r\n```\r\nprivate IStudentDao dao;\r\nprivate SqlSession sqlSession;\r\n\r\n@Before\r\npublic void before() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n}\r\n```\r\n##### sqlSession 的关闭\r\n```\r\n@After\r\npublic void after() {\r\n	if(sqlSession != null) {\r\n		sqlSession.close();\r\n	}\r\n}\r\n```\r\n##### sqlSession 的提交\r\n```\r\n@Test\r\npublic void testDeleteStudentById() {\r\n	dao.deleteStudentById(12);\r\n	sqlSession.commit();\r\n}\r\n```\r\n\r\n\r\n### 多条件查询\r\n#### 根据 Map 查询\r\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition(Map<String, Object> map);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 多条件查询 -->\r\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\r\n		and age > #{ageCon}\r\n		and score > #{stu.score}  -- 对象.属性\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition() {\r\n	Student stu = new Student(\"田七\", 27, 95);\r\n\r\n	Map<String, Object> map = new HashMap<String, Object>();\r\n	map.put(\"nameCon\", \"张\");\r\n	map.put(\"ageCon\", 23);\r\n	map.put(\"stu\", stu);	//放入了学生对象\r\n\r\n	List<Student> students = dao.selectStudentsByCondition(map);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### 使用索引号\r\n>需求：找出姓张的，年龄大于 25 的\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition2(String name,int age);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 使用索引号 -->\r\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{0} \'%\' --0,1 索引号\r\n		and age > #{1}\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition2() {\r\n	//参数直接对应 mapper.xml 中的索引号\r\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n### 总结：#{} 中可以放什么内容？\r\n1. 参数对象的属性\r\n2. 随意内容，此时的#{}是个占位符\r\n3. 参数为map时的key\r\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\r\n5. 参数的索引号\r\n\r\n### 动态 SQL\r\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\r\n\r\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\r\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\r\n\r\n#### if 和 where\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByWhere(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<if test=\"name != null and name != \'\'\">\r\n			and name like \'%\' #{name} \'%\'\r\n		</if>\r\n		<if test=\"age > 0\">\r\n			and age > #{age}\r\n		</if>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByWhere() {\r\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\r\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\r\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\r\n\r\n	List<Student> students = dao.selectStudentsByWhere(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n#### choose\r\n**类似于 switch case ，且每个 case 都自带了 break.**\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByChoose(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\r\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<choose>\r\n			<when test=\"name != null and name !=\'\'\">\r\n				and name like \'%\' #{name} \'%\'\r\n			</when>\r\n			<when test=\"age > 0\">\r\n				and age > #{age}\r\n			</when>\r\n			<otherwise>\r\n				1 = 2\r\n			</otherwise>\r\n		</choose>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByChoose() {\r\n	// Student stu = new Student(\"张\", 23, 0);\r\n	// Student stu = new Student(\"\", 23, 0);\r\n	Student stu = new Student(\"\", 0, 0);\r\n\r\n	List<Student> students = dao.selectStudentsByChoose(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历数组\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsByForeach(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为基本类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach2(List<Integer> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach2() {\r\n	List<Integer> ids = new ArrayList<>();\r\n	ids.add(1);\r\n	ids.add(3);\r\n	List<Student> students = dao.selectStudentsByForeach2(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为自定义类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach3(List<Student> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\r\n            #{stu.id}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach3() {\r\n	Student stu1 = new Student();\r\n	stu1.setId(1);\r\n	Student stu2 = new Student();\r\n	stu2.setId(3);\r\n	List<Student> stus = new ArrayList<>();\r\n	stus.add(stu1);\r\n	stus.add(stu2);\r\n	List<Student> students = dao.selectStudentsByForeach3(stus);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <sql/>标签\r\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\r\n\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsBySqlFragment(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\r\n    select <include refid=\"selectColumns\"/> -- sql 片段\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\r\n<sql id=\"selectColumns\">\r\n    id,name,age,score\r\n</sql>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsBySqlFragment() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n## 关联关系查询\r\n### 一对多关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	// 关联属性\r\n	private Set<Minister> ministers;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Minister> getMinisters() {\r\n		return ministers;\r\n	}\r\n	public void setMinisters(Set<Minister> ministers) {\r\n		this.ministers = ministers;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\r\n				+ ministers + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<!--多表连接查询语句-->\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname,mid,mname\r\n    from country,minister\r\n    where countryId=cid and cname=#{cname}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\r\n    <collection property=\"ministers\" ofType=\"Minister\">\r\n        <id column=\"mid\" property=\"mid\"/>\r\n        <result column=\"mname\" property=\"mname\"/>\r\n    </collection>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname from country where cname=#{xxx}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <collection property=\"ministers\" \r\n                ofType=\"Minister\"\r\n                select=\"selectMinisterByCountry\"\r\n                column=\"cid\"/>\r\n</resultMap>\r\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\r\n    select mid,mname from minister where countryId=#{ooo}\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n\r\n\r\n### 多对一关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	private Country country;	//关联属性\r\n\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	public Country getCountry() { return country; }\r\n	public void setCountry(Country country) { this.country = country; }\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*IMinisterDao*\r\n```\r\nMinister selectMinisterById(int mid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,cid,cname\r\n    from minister, country\r\n    where countryId=cid and mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\" javaType=\"Country\">\r\n        <id column=\"cid\" property=\"cid\"/>\r\n        <result column=\"cname\" property=\"cname\"/>\r\n    </association>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void selectMinisterById() {\r\n	Minister minister = dao.selectMinisterById(2);\r\n	System.out.println(minister);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,countryId from minister where mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\"\r\n                 javaType=\"Country\"\r\n                 select=\"selectCountryById\"\r\n                 column=\"countryId\"/>\r\n</resultMap>\r\n<select id=\"selectCountryById\" resultType=\"Country\">\r\n    select cid,cname from country where cid=#{ooo}\r\n</select>\r\n```\r\n\r\n\r\n\r\n### 自关联查询\r\n类似于目录的递归。\r\n#### 以一对多方式处理\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private Set<NewsLabel> children;\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public Set<NewsLabel> getChildren() {\r\n		return children;\r\n	}\r\n	public void setChildren(Set<NewsLabel> children) {\r\n		this.children = children;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\r\n				+ children + \"]\";\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目的所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nList<NewsLabel> selectChildrenByParent(int pid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\"\r\n				ofType=\"NewsLabel\"\r\n				select=\"selectChildrenByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\r\n	for (NewsLabel newsLabel : children) {\r\n		System.out.println(newsLabel);\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目及其所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where id=#{xxx}\r\n</select>\r\n\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\" \r\n				ofType=\"NewsLabel\"\r\n				select=\"selectNewslabelByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{ooo}\r\n</select>\r\n\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n#### 以多对一方式处理\r\n>需求：查询所有栏目及其父辈栏目\r\n\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private NewsLabel parent;   // 父栏目\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public NewsLabel getParent() {\r\n		return parent;\r\n	}\r\n	public void setParent(NewsLabel parent) {\r\n		this.parent = parent;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name,pid from newslabel where id=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<association property=\"parent\" \r\n				 javaType=\"NewsLabel\"\r\n				 select=\"selectNewsLabelById\"\r\n				 column=\"pid\"/>\r\n</resultMap>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n\r\n### 多对多关联查询\r\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\r\n>实体类\r\n\r\n*Course.java*\r\n```\r\npublic class Course {\r\n	private Integer cid;\r\n	private String cname;\r\n	private Set<Student> students;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Student> getStudents() {\r\n		return students;\r\n	}\r\n	public void setStudents(Set<Student> students) {\r\n		this.students = students;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private Integer sid;\r\n	private String sname;\r\n	private Set<Course> courses;\r\n	public Integer getSid() {\r\n		return sid;\r\n	}\r\n	public void setSid(Integer sid) {\r\n		this.sid = sid;\r\n	}\r\n	public String getSname() {\r\n		return sname;\r\n	}\r\n	public void setSname(String sname) {\r\n		this.sname = sname;\r\n	}\r\n	public Set<Course> getCourses() {\r\n		return courses;\r\n	}\r\n	public void setCourses(Set<Course> courses) {\r\n		this.courses = courses;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\r\n				+ courses + \"]\";\r\n	}\r\n}\r\n```\r\n>Dao\r\n\r\n*IStudentDao.java*\r\n```\r\nStudent selectStudentById(int sid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select sid,sname,cid,cname\r\n	from student,middle,course\r\n	where sid=studentId and cid=courseId and sid=#{xxx}\r\n</select>\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"sid\" property=\"sid\"/>\r\n	<result column=\"sname\" property=\"sname\"/>\r\n	<collection property=\"courses\" ofType=\"Course\">\r\n		<id column=\"cid\" property=\"cid\"/>\r\n		<result column=\"cname\" property=\"cname\"/>\r\n	</collection>\r\n</resultMap>\r\n```\r\n>Test\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Student student = dao.selectStudentById(1);\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n### 延迟加载\r\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\r\n\r\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\r\n\r\n#### 关联对象加载时机\r\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\r\n\r\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\r\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\r\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\r\n\r\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\r\n\r\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\r\n\r\n#### 延迟加载的总开关\r\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\r\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\r\n\r\n*mybatis.xml*\r\n```\r\n<configuration>\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 设置整个应用所使用的常量 -->\r\n    <settings>\r\n        <!-- 延迟加载的总开关 -->\r\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    </settings>\r\n\r\n    <typeAliases>\r\n		...\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n\r\n#### 直接加载\r\n*mybatis.xml*\r\n```\r\n<settings>\r\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\r\n</settings>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\r\n	System.out.println(country.getCname());\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 直接加载（√）：查询 country，查询 minister ---\r\nChina\r\nTotal：3\r\n```\r\n\r\n#### 侵入式延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 侵入式延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 侵入式延迟加载（X）：查询 country ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nChina\r\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\r\nTotal：3\r\n```\r\n#### 深度延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 深度延迟加载（X）：查询 country ---\r\nChina\r\n---- 深度延迟加载（X）：访问主加载对象 ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nTotal：3\r\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\r\n```',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 243 [ RunTime:0.001680s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.002331s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000371s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001052s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000401s ]
---------------------------------------------------------------
[ 2018-11-10T18:19:35+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/243.html
[ info ] qingrang.top/daily/admin/note/shownote/id/243.html [运行时间：0.060125s][吞吐率：16.63req/s] [内存消耗：2,054.17kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000598s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001361s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000702s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000993s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000328s ]
---------------------------------------------------------------
[ 2018-11-10T18:19:40+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/1.html
[ info ] qingrang.top/daily/admin/note/editnote/id/1.html [运行时间：0.064129s][吞吐率：15.59req/s] [内存消耗：2,101.09kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000726s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001698s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.001043s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001542s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000292s ]
---------------------------------------------------------------
[ 2018-11-10T18:30:48+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.064310s][吞吐率：15.55req/s] [内存消耗：2,105.82kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000668s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001730s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000767s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000919s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000312s ]
---------------------------------------------------------------
[ 2018-11-10T18:31:04+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.066680s][吞吐率：15.00req/s] [内存消耗：2,203.38kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '7',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => 'pom',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000765s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001490s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%pom%' OR `content` LIKE '%pom%' ) ORDER BY date desc [ RunTime:0.010102s ]
---------------------------------------------------------------
[ 2018-11-10T18:31:07+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/noteview.html
[ info ] qingrang.top/daily/admin/note/noteview.html [运行时间：0.063864s][吞吐率：15.66req/s] [内存消耗：2,129.25kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'noteview',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'noteid' => '234',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->noteview[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000590s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001307s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 234 LIMIT 1 [ RunTime:0.000487s ]
---------------------------------------------------------------
[ 2018-11-10T18:31:08+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/noteview.html
[ info ] qingrang.top/daily/admin/note/noteview.html [运行时间：0.050697s][吞吐率：19.73req/s] [内存消耗：2,133.66kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'noteview',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'noteid' => '236',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->noteview[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000618s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001185s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000428s ]
---------------------------------------------------------------
[ 2018-11-10T18:31:11+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/236
[ info ] qingrang.top/daily/admin/note/editNote/id/236 [运行时间：0.053539s][吞吐率：18.68req/s] [内存消耗：2,034.69kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editNote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '236',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000468s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001391s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000452s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001014s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000296s ]
---------------------------------------------------------------
[ 2018-11-10T18:32:04+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/236.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/236.html [运行时间：0.072192s][吞吐率：13.85req/s] [内存消耗：2,093.78kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10295',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/236',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# IDEA + Maven + SSM 整合
## 创建 Maven 项目
## 修改 pom.xml 文件导入 ssm 相关的 jar 包
```
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>top.qingrang</groupId>
  <artifactId>diary_ssm</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>war</packaging>

  <properties>
    <spring.version>4.1.3.RELEASE</spring.version>
    <pagehelper.version>5.1.2-beta</pagehelper.version>
    <mysql.version>5.1.6</mysql.version>
    <mybatis.spring.version>1.2.3</mybatis.spring.version>
    <mybatis.version>3.1.1</mybatis.version>
    <junit.version>4.12</junit.version>
    <jstl.version>1.2</jstl.version>
    <jsqlparser.version>1.0</jsqlparser.version>
    <jackson.version>1.2.7</jackson.version>
    <servlet-api.version>3.1.0</servlet-api.version>
    <druid.version>1.0.18</druid.version>
    <log4j.version>1.2.16</log4j.version>
    <commons-logging.version>1.2</commons-logging.version>
    <commons-fileupload.version>1.2.1</commons-fileupload.version>
    <commons-io.version>1.3.2</commons-io.version>
    <commons-lang.version>2.6</commons-lang.version>
    <aopalliance.version>1.0</aopalliance.version>
    <mybatis-generator.version>1.3.5</mybatis-generator.version>
	<cglib.version>3.2.5</cglib.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>${junit.version}</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>${mybatis.version}</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>${mybatis.spring.version}</version>
    </dependency>

    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>${mysql.version}</version>
    </dependency>

    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>${druid.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-beans</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>${spring.version}</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aspects</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <!-- JSP相关 -->
    <dependency>
      <groupId>jstl</groupId>
      <artifactId>jstl</artifactId>
      <version>${jstl.version}</version>
    </dependency>

    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>${servlet-api.version}</version>
      <scope>provided</scope>
    </dependency>

    <!-- pageHelper -->
    <dependency>
      <groupId>com.github.pagehelper</groupId>
      <artifactId>pagehelper</artifactId>
      <version>${pagehelper.version}</version>
    </dependency>

    <!--jsqlparser-->
    <dependency>
      <groupId>com.github.jsqlparser</groupId>
      <artifactId>jsqlparser</artifactId>
      <version>${jsqlparser.version}</version>
    </dependency>
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>${log4j.version}</version>
    </dependency>

    <dependency>
      <groupId>commons-logging</groupId>
      <artifactId>commons-logging</artifactId>
      <version>${commons-logging.version}</version>
    </dependency>

    <dependency>
      <groupId>commons-fileupload</groupId>
      <artifactId>commons-fileupload</artifactId>
      <version>${commons-fileupload.version}</version>
    </dependency>

    <dependency>
      <groupId>commons-io</groupId>
      <artifactId>commons-io</artifactId>
      <version>${commons-io.version}</version>
    </dependency>

    <dependency>
      <groupId>commons-lang</groupId>
      <artifactId>commons-lang</artifactId>
      <version>${commons-lang.version}</version>
    </dependency>

    <dependency>
      <groupId>aopalliance</groupId>
      <artifactId>aopalliance</artifactId>
      <version>${aopalliance.version}</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis.generator</groupId>
      <artifactId>mybatis-generator-core</artifactId>
      <version>${mybatis-generator.version}</version>
    </dependency>

	<dependency>
      <groupId>cglib</groupId>
      <artifactId>cglib</artifactId>
      <version>${cglib.version}</version>
    </dependency>

  </dependencies>

  <build>
    <finalName>${project.artifactId}</finalName>
    <plugins>
      <!-- 资源文件拷贝插件 -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-resources-plugin</artifactId>
        <version>2.7</version>
        <configuration>
          <encoding>UTF-8</encoding>
        </configuration>
      </plugin>
      <!-- java编译插件 -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.2</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
          <encoding>UTF-8</encoding>
        </configuration>
      </plugin>
    </plugins>
    <pluginManagement>
      <plugins>
        <!-- 配置Tomcat插件 -->
        <plugin>
          <groupId>org.apache.tomcat.maven</groupId>
          <artifactId>tomcat7-maven-plugin</artifactId>
          <version>2.2</version>
        </plugin>
      </plugins>
    </pluginManagement>

    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <includes>
          <include>**/*.properties</include>
          <include>**/*.xml</include>
          <include>**/*.tld</include>
        </includes>
        <filtering>false</filtering>
      </resource>
      <resource>
        <directory>src/main/java</directory>
        <includes>
          <include>**/*.properties</include>
          <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
      </resource>
    </resources>

  </build>

</project>
```
',
  'groups' => 'Java',
  'showsel' => '0',
  'showse2' => '0',
  'id' => '236',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000664s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001427s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000565s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000371s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000937s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000321s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000279s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=236,`p_id`=2,`title`='IDEA + Maven + SSM 整合\r',`content`='# IDEA + Maven + SSM 整合\r\n## 创建 Maven 项目\r\n## 修改 pom.xml 文件导入 ssm 相关的 jar 包\r\n```\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n  <groupId>top.qingrang</groupId>\r\n  <artifactId>diary_ssm</artifactId>\r\n  <version>0.0.1-SNAPSHOT</version>\r\n  <packaging>war</packaging>\r\n\r\n  <properties>\r\n    <spring.version>4.1.3.RELEASE</spring.version>\r\n    <pagehelper.version>5.1.2-beta</pagehelper.version>\r\n    <mysql.version>5.1.6</mysql.version>\r\n    <mybatis.spring.version>1.2.3</mybatis.spring.version>\r\n    <mybatis.version>3.1.1</mybatis.version>\r\n    <junit.version>4.12</junit.version>\r\n    <jstl.version>1.2</jstl.version>\r\n    <jsqlparser.version>1.0</jsqlparser.version>\r\n    <jackson.version>1.2.7</jackson.version>\r\n    <servlet-api.version>3.1.0</servlet-api.version>\r\n    <druid.version>1.0.18</druid.version>\r\n    <log4j.version>1.2.16</log4j.version>\r\n    <commons-logging.version>1.2</commons-logging.version>\r\n    <commons-fileupload.version>1.2.1</commons-fileupload.version>\r\n    <commons-io.version>1.3.2</commons-io.version>\r\n    <commons-lang.version>2.6</commons-lang.version>\r\n    <aopalliance.version>1.0</aopalliance.version>\r\n    <mybatis-generator.version>1.3.5</mybatis-generator.version>\r\n	<cglib.version>3.2.5</cglib.version>\r\n  </properties>\r\n\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>${junit.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.mybatis</groupId>\r\n      <artifactId>mybatis</artifactId>\r\n      <version>${mybatis.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.mybatis</groupId>\r\n      <artifactId>mybatis-spring</artifactId>\r\n      <version>${mybatis.spring.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>mysql</groupId>\r\n      <artifactId>mysql-connector-java</artifactId>\r\n      <version>${mysql.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>com.alibaba</groupId>\r\n      <artifactId>druid</artifactId>\r\n      <version>${druid.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-context</artifactId>\r\n      <version>${spring.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-test</artifactId>\r\n      <version>${spring.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-beans</artifactId>\r\n      <version>${spring.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-webmvc</artifactId>\r\n      <version>${spring.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-jdbc</artifactId>\r\n      <version>${spring.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-aspects</artifactId>\r\n      <version>${spring.version}</version>\r\n    </dependency>\r\n    <!-- JSP相关 -->\r\n    <dependency>\r\n      <groupId>jstl</groupId>\r\n      <artifactId>jstl</artifactId>\r\n      <version>${jstl.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>javax.servlet</groupId>\r\n      <artifactId>javax.servlet-api</artifactId>\r\n      <version>${servlet-api.version}</version>\r\n      <scope>provided</scope>\r\n    </dependency>\r\n\r\n    <!-- pageHelper -->\r\n    <dependency>\r\n      <groupId>com.github.pagehelper</groupId>\r\n      <artifactId>pagehelper</artifactId>\r\n      <version>${pagehelper.version}</version>\r\n    </dependency>\r\n\r\n    <!--jsqlparser-->\r\n    <dependency>\r\n      <groupId>com.github.jsqlparser</groupId>\r\n      <artifactId>jsqlparser</artifactId>\r\n      <version>${jsqlparser.version}</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>log4j</groupId>\r\n      <artifactId>log4j</artifactId>\r\n      <version>${log4j.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>commons-logging</groupId>\r\n      <artifactId>commons-logging</artifactId>\r\n      <version>${commons-logging.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>commons-fileupload</groupId>\r\n      <artifactId>commons-fileupload</artifactId>\r\n      <version>${commons-fileupload.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>commons-io</groupId>\r\n      <artifactId>commons-io</artifactId>\r\n      <version>${commons-io.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>commons-lang</groupId>\r\n      <artifactId>commons-lang</artifactId>\r\n      <version>${commons-lang.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>aopalliance</groupId>\r\n      <artifactId>aopalliance</artifactId>\r\n      <version>${aopalliance.version}</version>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>org.mybatis.generator</groupId>\r\n      <artifactId>mybatis-generator-core</artifactId>\r\n      <version>${mybatis-generator.version}</version>\r\n    </dependency>\r\n\r\n	<dependency>\r\n      <groupId>cglib</groupId>\r\n      <artifactId>cglib</artifactId>\r\n      <version>${cglib.version}</version>\r\n    </dependency>\r\n\r\n  </dependencies>\r\n\r\n  <build>\r\n    <finalName>${project.artifactId}</finalName>\r\n    <plugins>\r\n      <!-- 资源文件拷贝插件 -->\r\n      <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n        <artifactId>maven-resources-plugin</artifactId>\r\n        <version>2.7</version>\r\n        <configuration>\r\n          <encoding>UTF-8</encoding>\r\n        </configuration>\r\n      </plugin>\r\n      <!-- java编译插件 -->\r\n      <plugin>\r\n        <groupId>org.apache.maven.plugins</groupId>\r\n        <artifactId>maven-compiler-plugin</artifactId>\r\n        <version>3.2</version>\r\n        <configuration>\r\n          <source>1.8</source>\r\n          <target>1.8</target>\r\n          <encoding>UTF-8</encoding>\r\n        </configuration>\r\n      </plugin>\r\n    </plugins>\r\n    <pluginManagement>\r\n      <plugins>\r\n        <!-- 配置Tomcat插件 -->\r\n        <plugin>\r\n          <groupId>org.apache.tomcat.maven</groupId>\r\n          <artifactId>tomcat7-maven-plugin</artifactId>\r\n          <version>2.2</version>\r\n        </plugin>\r\n      </plugins>\r\n    </pluginManagement>\r\n\r\n    <resources>\r\n      <resource>\r\n        <directory>src/main/resources</directory>\r\n        <includes>\r\n          <include>**/*.properties</include>\r\n          <include>**/*.xml</include>\r\n          <include>**/*.tld</include>\r\n        </includes>\r\n        <filtering>false</filtering>\r\n      </resource>\r\n      <resource>\r\n        <directory>src/main/java</directory>\r\n        <includes>\r\n          <include>**/*.properties</include>\r\n          <include>**/*.xml</include>\r\n        </includes>\r\n        <filtering>false</filtering>\r\n      </resource>\r\n    </resources>\r\n\r\n  </build>\r\n\r\n</project>\r\n```\r\n',`groups`='Java',`is_show`=0,`publish`=0,`summary`=''  WHERE  `id` = 236 [ RunTime:0.000852s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001158s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000545s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000948s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000560s ]
---------------------------------------------------------------
[ 2018-11-10T18:32:04+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/236.html
[ info ] qingrang.top/daily/admin/note/shownote/id/236.html [运行时间：0.056207s][吞吐率：17.79req/s] [内存消耗：1,986.95kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editNote/id/236',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '236',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000520s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001310s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000463s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000914s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
---------------------------------------------------------------
[ 2018-11-10T18:32:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.076750s][吞吐率：13.03req/s] [内存消耗：2,341.10kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000558s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001511s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001891s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000501s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000892s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000313s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000508s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000868s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000325s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000452s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000325s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000352s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001040s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000220s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000977s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000680s ]
---------------------------------------------------------------
[ 2018-11-10T18:35:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/243.html
[ info ] qingrang.top/daily/admin/note/shownote/id/243.html [运行时间：0.066509s][吞吐率：15.04req/s] [内存消耗：2,053.94kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000788s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002185s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000907s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001270s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000383s ]
---------------------------------------------------------------
[ 2018-11-10T21:21:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/1.html
[ info ] qingrang.top/daily/admin/note/editnote/id/1.html [运行时间：0.076956s][吞吐率：12.99req/s] [内存消耗：2,100.89kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001419s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002690s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.001015s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001500s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000435s ]
---------------------------------------------------------------
[ 2018-11-10T21:21:52+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.069231s][吞吐率：14.44req/s] [内存消耗：2,105.82kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000877s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001920s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000902s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001044s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000369s ]
---------------------------------------------------------------
[ 2018-11-10T22:13:01+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/243.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/243.html [运行时间：0.082175s][吞吐率：12.17req/s] [内存消耗：2,356.96kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '83763',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```
## 查询缓存
查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。

MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000682s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001645s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000830s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000363s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000959s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000472s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000364s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=243,`p_id`=2,`title`='Mybatis\r',`content`='# Mybatis\r\n[TOC]\r\n## Mybatis 体系结构和工作原理\r\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\r\n## 第一个 MyBaits 程序\r\n### 主配置文件详解\r\n1. 注册数据库连接四要素属性文件\r\n`<properties resource=\"jdbc_mysql.properties\"/>`\r\n1. 定义类型别名\r\n```\r\n<typeAliases>\r\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\r\n	<package name=\"top.qingrang.beans\"/>\r\n</typeAliases>\r\n```\r\n1. 配置运行环境\r\n```\r\n<environments default=\"XXX2\">\r\n	<!-- 环境，eg：上线环境 -->\r\n	<environment id=\"XXX1\">\r\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n		<transactionManager type=\"JDBC\"/>\r\n		<!-- 数据源，数据库连接池 -->\r\n		<dataSource type=\"POOLED\">\r\n			<!-- 数据库连接四要素 -->\r\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n			<property name=\"url\" value=\"${jdbc.url}\"/>\r\n			<property name=\"username\" value=\"${jdbc.user}\"/>\r\n			<property name=\"password\" value=\"${jdbc.password}\"/>\r\n		</dataSource>\r\n	</environment>\r\n\r\n	<!-- 另一个环境，eg：本地测试的环境 -->\r\n	<environment id=\"XXX2\">\r\n		...\r\n	</environment>\r\n</environments>\r\n```\r\n1. 注册映射文件\r\n```\r\n<mappers>\r\n	<!-- 配置文件路径 -->\r\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n>问题？\r\n\r\n1. environments 下为什么可以配置多个 environment？\r\n方便切换运行环境，只需要改变 `default` 即可\r\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\r\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\r\n1. 什么是数据库连接池？\r\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\r\n\r\n*mybatis.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 注册数据库连接四要素属性文件 -->\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 定义类型别名 -->\r\n    <typeAliases>\r\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\r\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\r\n        <package name=\"top.qingrang.beans\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\r\n    <environments default=\"onlineEM\">\r\n        <!-- 上线以后的环境 -->\r\n        <environment id=\"onlineEM\">\r\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n            <transactionManager type=\"JDBC\"/>\r\n            <!-- 数据源，数据库连接池 -->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- 数据库连接四要素 -->\r\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n                <property name=\"url\" value=\"${jdbc.url}\"/>\r\n                <property name=\"username\" value=\"${jdbc.user}\"/>\r\n                <property name=\"password\" value=\"${jdbc.password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n        <!-- 本地测试的环境 -->\r\n        <environment id=\"testEM\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"111\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <!-- 注册映射文件 -->\r\n    <mappers>\r\n        <!-- 配置文件路径 -->\r\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n    </mappers>\r\n\r\n</configuration>\r\n```\r\n### 核心代码\r\n利用 sqlSession 对象，执行相关操作。\r\n```\r\nprivate SqlSession sqlSession;\r\n\r\n@Override\r\npublic void insertStu(Student student) {\r\n	try {\r\n		// 1.加载主配置文件\r\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n		// 2.创建 SqlSessionFactory 对象\r\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n		// 3.创建 sqlSession 对象\r\n		sqlSession = sqlSessionFactory.openSession();\r\n		// 4.执行相关操作\r\n		sqlSession.insert(\"insertStudent\", student);\r\n		// 5.提交\r\n		sqlSession.commit();\r\n	} catch (IOException e) {\r\n		e.printStackTrace();\r\n	} finally {\r\n		if(sqlSession != null) {\r\n			// 6.关闭\r\n			sqlSession.close();\r\n		}\r\n	}\r\n}\r\n```\r\n### 封装 MyBatis 工具类\r\n*MyBatisUtils.java*\r\n```\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * MyBatis 工具类\r\n */\r\npublic class MyBatisUtils {\r\n\r\n	private static SqlSessionFactory sqlSessionFactory;\r\n\r\n	/**\r\n	 * 得到 SqlSession 对象\r\n	 */\r\n	public static SqlSession getSqlSession() {\r\n		try {\r\n			// 1.加载主配置文件\r\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n			if (sqlSessionFactory == null) {\r\n				// 2.创建 SqlSessionFactory 对象\r\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n			}\r\n			// 3.返回 SqlSession 对象\r\n			return sqlSessionFactory.openSession();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return null;\r\n	}\r\n}\r\n```\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n### 源码分析\r\n#### 输入流的关闭\r\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的创建\r\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\r\n\r\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\r\n\r\n>dirty 详解\r\n\r\ntrue：和数据库中的数据不一致(脏)\r\nfalse：和数据库中的数据一致(不脏)\r\n\r\n#### 增删改的执行\r\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\r\n\r\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\r\n\r\n#### SqlSession 的提交 commit()\r\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的关闭\r\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 单表的 CURD 操作\r\n### 常用的增删改查\r\n*mapper.xml*\r\n```\r\n<!-- parameterType 可以省略 -->\r\n<insert id=\"insertStudent\" parameterType=\"Student\">\r\n	<!-- 这里的 #{} 是属性 -->\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<!-- 插入后用新 id 初始化被插入对象 -->\r\n<insert id=\"insertStudentCacheId\">\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\r\n		select @@identity\r\n	</selectKey>\r\n</insert>\r\n\r\n<delete id=\"deleteStudentById\">\r\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\r\n	DELETE FROM student WHERE id = #{id}\r\n</delete>\r\n\r\n<update id=\"updateStudent\">\r\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\r\n</update>\r\n\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n\r\n<!-- 模糊查询 -->\r\n<select id=\"selectStudentsByName\" resultType=\"Student\">\r\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\r\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\r\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\r\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\r\n</select>\r\n```\r\n\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void insertStudentCacheId(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.insert(\"insertStudentCacheId\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void deleteStudentById(int id) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.delete(\"deleteStudentById\", id);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.update(\"updateStudent\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectAllStudents\");\r\n			//查询不需要 sqlSession.commit();\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n\r\n	@Override\r\n	public Map<String, Object> selectAllStudentsMap() {\r\n		Map<String, Object> map = new HashMap<>();\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return map;\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		Student student = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			student = sqlSession.selectOne(\"selectStudentById\", id);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return student;\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectStudentsByName(String name) {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n}\r\n```\r\n\r\n### 属性名与查询字段名不相同\r\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\r\n```\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n```\r\n#### 解决方案一：查询字段使用别名\r\n```\r\n<insert id=\"insertStudent\">\r\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n#### 解决方案二：使用结果映射 resultMap\r\n```\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"tid\" property=\"id\"/>\r\n	<result column=\"tname\" property=\"name\"/>\r\n 	<result column=\"tage\" property=\"age\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n### Mapper 动态代理\r\n#### 修改映射文件的 namespace 属性值\r\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\r\n通过接口名即可定位到映射文件 mapper.\r\n#### 删除 IStudentDaoImpl 实现类\r\n#### 修改 MyText.java 测试方法\r\n*MyTex.java*\r\n```\r\npublic class MyTest {\r\n	private IStudentDao dao;\r\n	private SqlSession sqlSession;\r\n\r\n	@Before\r\n	public void before() {\r\n		sqlSession = MyBatisUtils.getSqlSession();\r\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n	}\r\n\r\n	@After\r\n	public void after() {\r\n		if(sqlSession != null) {\r\n			sqlSession.close();\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudent() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudent(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudentCacheId() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudentCacheId(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testDeleteStudentById() {\r\n		dao.deleteStudentById(12);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testUpdateStudent() {\r\n		Student student = new Student(\"张三\", 25, 93.5);\r\n		student.setId(15);\r\n		dao.updateStudent(student);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testSelectAllStudents() {\r\n		List<Student> students = dao.selectAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentById() {\r\n		Student student = dao.selectStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentsByName() {\r\n		List<Student> students = dao.selectStudentsByName(\"张\");\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n}\r\n```\r\n##### Dao 对象的获取\r\n```\r\nprivate IStudentDao dao;\r\nprivate SqlSession sqlSession;\r\n\r\n@Before\r\npublic void before() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n}\r\n```\r\n##### sqlSession 的关闭\r\n```\r\n@After\r\npublic void after() {\r\n	if(sqlSession != null) {\r\n		sqlSession.close();\r\n	}\r\n}\r\n```\r\n##### sqlSession 的提交\r\n```\r\n@Test\r\npublic void testDeleteStudentById() {\r\n	dao.deleteStudentById(12);\r\n	sqlSession.commit();\r\n}\r\n```\r\n\r\n\r\n### 多条件查询\r\n#### 根据 Map 查询\r\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition(Map<String, Object> map);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 多条件查询 -->\r\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\r\n		and age > #{ageCon}\r\n		and score > #{stu.score}  -- 对象.属性\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition() {\r\n	Student stu = new Student(\"田七\", 27, 95);\r\n\r\n	Map<String, Object> map = new HashMap<String, Object>();\r\n	map.put(\"nameCon\", \"张\");\r\n	map.put(\"ageCon\", 23);\r\n	map.put(\"stu\", stu);	//放入了学生对象\r\n\r\n	List<Student> students = dao.selectStudentsByCondition(map);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### 使用索引号\r\n>需求：找出姓张的，年龄大于 25 的\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition2(String name,int age);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 使用索引号 -->\r\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{0} \'%\' --0,1 索引号\r\n		and age > #{1}\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition2() {\r\n	//参数直接对应 mapper.xml 中的索引号\r\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n### 总结：#{} 中可以放什么内容？\r\n1. 参数对象的属性\r\n2. 随意内容，此时的#{}是个占位符\r\n3. 参数为map时的key\r\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\r\n5. 参数的索引号\r\n\r\n### 动态 SQL\r\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\r\n\r\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\r\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\r\n\r\n#### if 和 where\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByWhere(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<if test=\"name != null and name != \'\'\">\r\n			and name like \'%\' #{name} \'%\'\r\n		</if>\r\n		<if test=\"age > 0\">\r\n			and age > #{age}\r\n		</if>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByWhere() {\r\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\r\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\r\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\r\n\r\n	List<Student> students = dao.selectStudentsByWhere(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n#### choose\r\n**类似于 switch case ，且每个 case 都自带了 break.**\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByChoose(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\r\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<choose>\r\n			<when test=\"name != null and name !=\'\'\">\r\n				and name like \'%\' #{name} \'%\'\r\n			</when>\r\n			<when test=\"age > 0\">\r\n				and age > #{age}\r\n			</when>\r\n			<otherwise>\r\n				1 = 2\r\n			</otherwise>\r\n		</choose>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByChoose() {\r\n	// Student stu = new Student(\"张\", 23, 0);\r\n	// Student stu = new Student(\"\", 23, 0);\r\n	Student stu = new Student(\"\", 0, 0);\r\n\r\n	List<Student> students = dao.selectStudentsByChoose(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历数组\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsByForeach(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为基本类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach2(List<Integer> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach2() {\r\n	List<Integer> ids = new ArrayList<>();\r\n	ids.add(1);\r\n	ids.add(3);\r\n	List<Student> students = dao.selectStudentsByForeach2(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为自定义类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach3(List<Student> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\r\n            #{stu.id}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach3() {\r\n	Student stu1 = new Student();\r\n	stu1.setId(1);\r\n	Student stu2 = new Student();\r\n	stu2.setId(3);\r\n	List<Student> stus = new ArrayList<>();\r\n	stus.add(stu1);\r\n	stus.add(stu2);\r\n	List<Student> students = dao.selectStudentsByForeach3(stus);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <sql/>标签\r\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\r\n\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsBySqlFragment(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\r\n    select <include refid=\"selectColumns\"/> -- sql 片段\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\r\n<sql id=\"selectColumns\">\r\n    id,name,age,score\r\n</sql>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsBySqlFragment() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n## 关联关系查询\r\n### 一对多关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	// 关联属性\r\n	private Set<Minister> ministers;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Minister> getMinisters() {\r\n		return ministers;\r\n	}\r\n	public void setMinisters(Set<Minister> ministers) {\r\n		this.ministers = ministers;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\r\n				+ ministers + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<!--多表连接查询语句-->\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname,mid,mname\r\n    from country,minister\r\n    where countryId=cid and cname=#{cname}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\r\n    <collection property=\"ministers\" ofType=\"Minister\">\r\n        <id column=\"mid\" property=\"mid\"/>\r\n        <result column=\"mname\" property=\"mname\"/>\r\n    </collection>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname from country where cname=#{xxx}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <collection property=\"ministers\" \r\n                ofType=\"Minister\"\r\n                select=\"selectMinisterByCountry\"\r\n                column=\"cid\"/>\r\n</resultMap>\r\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\r\n    select mid,mname from minister where countryId=#{ooo}\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n\r\n\r\n### 多对一关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	private Country country;	//关联属性\r\n\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	public Country getCountry() { return country; }\r\n	public void setCountry(Country country) { this.country = country; }\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*IMinisterDao*\r\n```\r\nMinister selectMinisterById(int mid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,cid,cname\r\n    from minister, country\r\n    where countryId=cid and mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\" javaType=\"Country\">\r\n        <id column=\"cid\" property=\"cid\"/>\r\n        <result column=\"cname\" property=\"cname\"/>\r\n    </association>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void selectMinisterById() {\r\n	Minister minister = dao.selectMinisterById(2);\r\n	System.out.println(minister);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,countryId from minister where mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\"\r\n                 javaType=\"Country\"\r\n                 select=\"selectCountryById\"\r\n                 column=\"countryId\"/>\r\n</resultMap>\r\n<select id=\"selectCountryById\" resultType=\"Country\">\r\n    select cid,cname from country where cid=#{ooo}\r\n</select>\r\n```\r\n\r\n\r\n\r\n### 自关联查询\r\n类似于目录的递归。\r\n#### 以一对多方式处理\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private Set<NewsLabel> children;\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public Set<NewsLabel> getChildren() {\r\n		return children;\r\n	}\r\n	public void setChildren(Set<NewsLabel> children) {\r\n		this.children = children;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\r\n				+ children + \"]\";\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目的所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nList<NewsLabel> selectChildrenByParent(int pid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\"\r\n				ofType=\"NewsLabel\"\r\n				select=\"selectChildrenByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\r\n	for (NewsLabel newsLabel : children) {\r\n		System.out.println(newsLabel);\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目及其所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where id=#{xxx}\r\n</select>\r\n\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\" \r\n				ofType=\"NewsLabel\"\r\n				select=\"selectNewslabelByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{ooo}\r\n</select>\r\n\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n#### 以多对一方式处理\r\n>需求：查询所有栏目及其父辈栏目\r\n\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private NewsLabel parent;   // 父栏目\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public NewsLabel getParent() {\r\n		return parent;\r\n	}\r\n	public void setParent(NewsLabel parent) {\r\n		this.parent = parent;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name,pid from newslabel where id=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<association property=\"parent\" \r\n				 javaType=\"NewsLabel\"\r\n				 select=\"selectNewsLabelById\"\r\n				 column=\"pid\"/>\r\n</resultMap>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n\r\n### 多对多关联查询\r\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\r\n>实体类\r\n\r\n*Course.java*\r\n```\r\npublic class Course {\r\n	private Integer cid;\r\n	private String cname;\r\n	private Set<Student> students;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Student> getStudents() {\r\n		return students;\r\n	}\r\n	public void setStudents(Set<Student> students) {\r\n		this.students = students;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private Integer sid;\r\n	private String sname;\r\n	private Set<Course> courses;\r\n	public Integer getSid() {\r\n		return sid;\r\n	}\r\n	public void setSid(Integer sid) {\r\n		this.sid = sid;\r\n	}\r\n	public String getSname() {\r\n		return sname;\r\n	}\r\n	public void setSname(String sname) {\r\n		this.sname = sname;\r\n	}\r\n	public Set<Course> getCourses() {\r\n		return courses;\r\n	}\r\n	public void setCourses(Set<Course> courses) {\r\n		this.courses = courses;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\r\n				+ courses + \"]\";\r\n	}\r\n}\r\n```\r\n>Dao\r\n\r\n*IStudentDao.java*\r\n```\r\nStudent selectStudentById(int sid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select sid,sname,cid,cname\r\n	from student,middle,course\r\n	where sid=studentId and cid=courseId and sid=#{xxx}\r\n</select>\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"sid\" property=\"sid\"/>\r\n	<result column=\"sname\" property=\"sname\"/>\r\n	<collection property=\"courses\" ofType=\"Course\">\r\n		<id column=\"cid\" property=\"cid\"/>\r\n		<result column=\"cname\" property=\"cname\"/>\r\n	</collection>\r\n</resultMap>\r\n```\r\n>Test\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Student student = dao.selectStudentById(1);\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n### 延迟加载\r\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\r\n\r\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\r\n\r\n#### 关联对象加载时机\r\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\r\n\r\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\r\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\r\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\r\n\r\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\r\n\r\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\r\n\r\n#### 延迟加载的总开关\r\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\r\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\r\n\r\n*mybatis.xml*\r\n```\r\n<configuration>\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 设置整个应用所使用的常量 -->\r\n    <settings>\r\n        <!-- 延迟加载的总开关 -->\r\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    </settings>\r\n\r\n    <typeAliases>\r\n		...\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n\r\n#### 直接加载\r\n*mybatis.xml*\r\n```\r\n<settings>\r\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\r\n</settings>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\r\n	System.out.println(country.getCname());\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 直接加载（√）：查询 country，查询 minister ---\r\nChina\r\nTotal：3\r\n```\r\n\r\n#### 侵入式延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 侵入式延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 侵入式延迟加载（X）：查询 country ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nChina\r\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\r\nTotal：3\r\n```\r\n#### 深度延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 深度延迟加载（X）：查询 country ---\r\nChina\r\n---- 深度延迟加载（X）：访问主加载对象 ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nTotal：3\r\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\r\n```\r\n## 查询缓存\r\n查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。\r\n\r\nMyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 243 [ RunTime:0.002065s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.002565s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000461s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000990s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000396s ]
---------------------------------------------------------------
[ 2018-11-10T22:13:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/243.html
[ info ] qingrang.top/daily/admin/note/shownote/id/243.html [运行时间：0.071303s][吞吐率：14.02req/s] [内存消耗：2,055.22kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000864s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000968s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001461s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000434s ]
---------------------------------------------------------------
[ 2018-11-10T22:13:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.104885s][吞吐率：9.53req/s] [内存消耗：2,343.20kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000619s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001651s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001963s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000527s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001076s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000406s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000524s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000985s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000294s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000464s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000390s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001084s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000227s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001178s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000736s ]
---------------------------------------------------------------
[ 2018-11-10T22:13:58+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.158870s][吞吐率：6.29req/s] [内存消耗：2,343.20kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000892s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002335s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002793s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000877s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001805s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000482s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000824s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001643s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000595s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000635s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.001071s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000570s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001650s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000421s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.003153s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.001070s ]
---------------------------------------------------------------
[ 2018-11-10T22:14:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/233.html
[ info ] qingrang.top/daily/admin/note/shownote/id/233.html [运行时间：0.066786s][吞吐率：14.97req/s] [内存消耗：2,015.41kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '233',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000704s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001874s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 233 LIMIT 1 [ RunTime:0.000621s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001024s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000311s ]
---------------------------------------------------------------
[ 2018-11-10T22:14:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/233.html
[ info ] qingrang.top/daily/admin/note/editnote/id/233.html [运行时间：0.066541s][吞吐率：15.03req/s] [内存消耗：2,063.73kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '233',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000560s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001401s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 233 LIMIT 1 [ RunTime:0.000555s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000912s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000333s ]
---------------------------------------------------------------
[ 2018-11-10T23:06:01+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/233.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/233.html [运行时间：0.081549s][吞吐率：12.26req/s] [内存消耗：2,270.47kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '84375',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/233.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# 中国史纲
[TOC]
## 中国历史的时空坐标
时间和空间加在一块,才是完整的历史。
### 四个时间坐标点
中国历史发生过几次重要的转型,这些转型推动着中国历史向前的发展。

1.第一个转型,是**商周之变**,就是从商朝到周朝的转型。

这次转型之后,我们开始有了“中国”这个概念,中华文明当中最初的普世主义理想开始出现了。

2.第二个转型,**周秦之变**,就是从周朝到秦朝的转型。

这次转型,让中原从分封割据的局面进入到大一统的局面,中国历史也开始超越于中原之上,中原与草原的相互塑造和对抗开始成为中国历史的大脉络。

3.第三个转型,**唐宋之变**,就是从唐朝到宋朝的转型。

这次转型,让中国的社会结构从豪族社会进入到平民社会,此后中国历史再无长期的分裂,大一统开始成为一个不可逆的历史过程。在先秦之后,中国的文化在宋朝迎来了又一次大爆发,有些西方学者甚至称这是中国的文艺复兴。这次文化爆发,不仅决定了此后将近一千年的中国文化气质,也决定了日本、朝鲜、越南等其他儒教国家的文化气质。

4.第四个转型,就是**清朝末期开始的古今之变**,中国开始从古代社会向现代社会进行艰难转型。

这个过程带来了一系列轰轰烈烈的历史过程,转型过程直到今天仍在继续,还未完成。

### 五个空间坐标点
草原、中原、海洋、西域、高原。

这几个大的空间,彼此之间有着极为深刻的相互依赖相互塑造的关系,以至于脱离开一方就完全解释不了另一方,所以它们加在一块构成一个体系。

## 中国的概念和中华文明的普世主义理想【商周】【中原】
### 历史上第一次出现「中国」
周朝的第二位君主周成王,兴建了东都洛阳城,当时有个叫做「何」的贵族,这人铸了一件青铜器纪念这个事儿,1963年这个青铜器在陕西宝鸡被发现,今天称其为「何尊」，「何尊」的底部铸了一百多个字,里面提到,周武王说要"宅兹中国”,就是说要“住在中国”,这是"中国"这个词的最早来源。

什么叫中国？**达到了文明最高水准的地方,就是文明意义上的中心,古人就管这种地方叫做「中国」。**
### 中华文明的普世主义理想：究竟天命是降于周人呢,还是天命降于周王
商朝是由“商人"。他们认为天命降于商人。为了让天能够永远地保佑自己,商人会经常地进行大规模的祭祀活动,祭祀当中会大量用到活人做祭品。

这些被献祭的人从哪来呢?

从对外战争掠夺的羌人而来。所谓的羌人就是生活在商王朝西部的、除了商朝人以外的所有人。

商人的这种天命观,肯定会受到羌人的抵抗。其中,周人是最主要的一支抵抗力量,他们逐渐组织了很多苦不堪言的羌人群体来反抗商朝，反抗的时候,在周人中间有过一个观念层面的争论,究竟天命是降于周人呢,还是天命降于周王?争论的结果是,天命降于周王。

这个观念变化太重要了。初看上去,这似乎是把天命的载体变得狭隘了,实际上是把它变得普世了。

为什么这么说呢?如果天命是降于周人,那就和此前降于商人的路数差不多,周人的岁月要想静好,就得时刻压制住所有不是周人的群体。这样的话,周人和商人征战,谁胜谁败就不好说了。因为,对其他羌人群体来说,打完这一仗,十有八九只不过换了个地方拿我们献祭,凭啥要跟你混啊?而**如果天命是降于周王,则周王便是天下的共主,他不仅仅要为周人主持正义,而是要为全天下人主持正义,这是一种真正的普世主义观念**。

### 什么是封建社会
推翻了商朝之后,周朝又是如何具体建立它的统治方式呢?那就是,分封制。周天子向下分封了他的大量亲戚和重臣,意图依靠他们形成的藩属诸侯国,来拱卫周王。这样一种政治统治形式就被称作“封建”,这种社会叫做封建社会。

封建“这个词最初出自《左传》,里面有句话叫做“封建亲戚,以藩屏周”,就是说分封亲信出去建立诸侯国,作为周朝王室领地的屏障。**只有这种封土建邦、分封割据的状态,才叫做封建。**

封建社会的一大特征是,最高统治者是没有权力干涉诸侯国内部事务的,诸侯们确实是最高统治者的封臣,但某种意义上也像是个合伙人,都有比较强的独立性。

周朝的时候,诸侯都承认周天子是最高权威,但周天子并不能管诸侯国内部的事情。周朝在这个过程中建立了封建社会,但周天子又逐渐衰落了。在周天子衰落之后,历史的主角就变成了那些诸侯。诸侯们彼此不断竞争,最终终结了中国的封建社会。

## 封建社会的终结【春秋末期、战国初期】【中原】
到了西周后期,周天子的影响力越来越差,最终被迫迁都洛阳,中国历史进入到东周。

东周又分成了舂秋战国两个时期,**春秋末期出现了一些重要的技术发展,它带来了新的经济和人力资源,打破了过去的社会均衡,封建社会当中的贵族秩序崩塌了，封建社会也在春秋战国时代走上末日。**

### 战争的逻辑的变化
春秋之前的的战争十分注重礼仪性(战争都是贵族在参与，这就导致了参与人数并不多，他们认为战争是一件高贵的事，他们的战争可能就是比谁的正步踢得好)。但到了春秋中后期,随着楚国(楚国是个土生政权,并不是周天子分封的诸侯国，它的文化和中原有很大区别,也不大在乎中原的礼仪之类的东西,在当时的中原诸侯看来它就是个蛮夷之邦。)的加入，战争变成以砍死人为目的了。也正是由于这个战争逻辑的变化,才把中国引向了大一统。

### 两个技术变迁
诸侯分封次级诸侯，随着次级诸侯势力的增大，诸侯和次级诸侯的关系同周天子和诸侯的关系一样。在春秋末期、战国初期,出现了两个重要的技术变迁,让诸侯力量的扩大有了可能。正是因为这两次技术变革,打破了君主和封臣之间的力量均衡,周厉王当初搞不定自己下级的事,现在诸侯可以做到了,也就是诸侯能够搞定这些次级诸侯。

这两个技术变迁,一个是铁器和牛耕的农业生产技术,一个是竹简这种知识传播技术。

>铁器和牛耕 - 农业生产技术

铁器与牛耕的出现,提升了平民的劳动效率。过去,他们的耕种效率很低,只能在贵族控制的公田、又叫井田上种地,没有能力再去开垦自己的私田了;但是,铁器和牛耕让生产效率大大提升了,平民有余力去开垦自己的私田,甚至索性就从贵族控制的井田上跑路了。此时君主、贵族、平民三者之间的一种复杂博弈关系就出现了。注意,这儿所说的君主,指的就是周天子封的诸侯,贵族指的就是诸侯所封的次级诸侯,这会儿的历史已经没周天子什么事儿了。

君主向耕种私田的平民提供保护,平民向君主交税。平民从井田上越跑越多,贵族所控制的井田制就逐渐瓦解了,贵族的力量也逐渐削弱了。君主开始获得相对于贵族的优势。

>竹简 - 知识传播技术

 知识传播的成本急剧下降,一般的贵族子弟、甚至运气好的普通百姓,都有机会学习文字获得知识了。由于多年的人口膨胀,这个时候出现了很多有文化、却无法获得一块封地的贵族子弟,他们就变成游士,到处寻找把自己卖个好价钱的机会。

君主们早就想养一群可控的自己人了。什么样的人最好用呢?

第一,他们要在本国没有根基,没资本对抗君主;
第二,他们的地位尊荣都取决于君主的赏赐,就有动力与君主相配合。

从别国跑来的游士完全符合这两点要求。君主与游士拍即合,游士成为依附于君主的私人人事班底。这个人事班底,后来就发展为官僚制。

官僚和贵族的区别在于,本质上来说,官僚没有独立性,他们是职业经理人,其地位取决于君主的意志;贵族有独立性,他们是准合伙人,君主有大事必须和他们商量着来。游士的出现,终于让君主们可以全方位碾压贵族封臣,诸侯国也就从君主与贵族共治的结构,转向君主说了算的官僚制结构。

### 变法

这个过程在历史上被叫作什么呢?

变法! 没错,魏国的李悝变法、秦国的商鞅变法等等,就是这样展开的。

来自其他国家的游士,成了各诸侯国的新贵,他们压制住所在国的大贵族,把君主的意志贯彻下去。随着各种变法的展开,中国历史就进入到了战国时代。

对君主来说,这回有办法把平民也动员起来了。你们虽然不是贵族血统,但你们可以立军功。只要你有办法从战场上拎回更多的人头,你也有机会上升到比贵族还高的地位。这种激励可不得了,战争的规模和频次急剧上升,大规模的灭国之战很容易就爆发了。灭国之战都到什么量级呢?比如很多人推崇的战神白起,一场战役就会坑杀赵国的40万降兵,这都在变法之后成为可能，变法这个事情也有传染性,谁最先变法,谁的战争效率就大幅上升;其他国家如果不跟上,就只能等着挨打。

**随着各国陆续变法,各诸侯国内部的旧贵族阶层被一扫而空**。变法之后,君主能决定军功的标准,也就能决定官僚新贵们的地位高低,**君主对国家的控制力就变得更强**,再没有能够约束君主的力量,**分封割据的封建社会也就逐渐走上了终结之日**,战争逻辑的变化,影响还不止于此,当战争规模扩大到了诸侯国承受不起的时候,中国也就开始走向大一统。

## 诸子百家的三大流派【春秋后期】【中原】
春秋后期,天下大乱,礼崩乐坏。人们突然发现赖以理解世界的坐标系没有了,世界的意义丧失了。而这种时候,就是思想大爆发的时候。

诸子百家,根据他们对待传统不同的态度,可以分为三类:一类是力挺传统（**克己复礼**）,代表就是儒家;一类是抛弃传统（**以法代礼**）,代表就是法家;还有一类是不在乎传统（出世，**无为而治**）,代表就是道家。

### 儒家
孔子认为复古的路径是“克己复礼”,就是要克制自己的各种冲动,依照传统留下来的"礼"的要求来做事。这样就能达到儒家的最高理想,“仁”。

>如果你理解孔子是儒家的开创者,莫不如把他理解为此前巫师传统的集大成者。

儒家是从商周两朝的巫师系统发展出来的,巫师就是古代沟通天意与人事的神职人员，这种工作主要通过占卜和祭祀来完成。祭祀这属于最高的“礼”,而巫师们就是“礼”的具体操作者与记录者。

到了礼崩乐坏的时候,如果要想复古,第步肯定得先说清楚这个“古”究竟是什么。巫师系统有这方面的很多记录,当然是最合适的解说人选,他们由此就逐渐发展为儒家。

### 法家

儒家强调恢复“礼”,“礼”来自传统,贵族是“礼"的载体;法家强调创建“法”,“法”出自君主意志,官僚是法的执行者。

>法家常在别国成事

根据君主、贵族、官僚的博弈关系,各诸侯国的君主们肯定不会愿意接受儒家,而更愿意接受法所以孔子孟子都曾周游列国,都没得到过重用,反倒是法家的人占据各种高位。有趣的是,法家的鼓吹者往往在本国是不受欢迎的,无论是商鞅还是李斯,都是在别国建功立业。韩非虽然在别国没有能够建立功业,但在本国也从没获得过机会。原因在于,君主需要官僚在本国没有根基,才能听使唤;倘若是出身本国的法家,他总会有各种根基,这种人又太懂得法术势,很容易成为君主忌惮的对象。脱离了家乡的游士,如漂泊浮萍,孤身人,荣辱富贵都依赖于君主,君主最喜欢了。所以,法家只能在别国成事。

### 道家

顺其自然,让世界、让百姓自由自主地活动,事情自然就好了,这就叫“无为而治”。

道家认为,正是各种入世的念头才把事情搞糟了,倘若不再追求转瞬即逝的现世成就,天地一下子就宽了。

## 周秦之变【周-秦-汉】【中原】

周秦之变对中国的思想史还带来个自然延伸的影响,就是我们在历史上看到的,从秦皇到汉武,帝国的官方思想经历了**从法家到道家再到儒家**的转换过程。

### 周秦之变的“法家逻辑”
百家争鸣的诸多学说,哪一种更注重提升战争效率,它就会获得诸侯们在政治上的更多支持。从中胜出的就是法家。但你用法家就能够征服天下,却不能仅仅用法家来治理天下。

### 汉高祖的“无为而治”
为什么汉高祖会选择道家呢?最根本的原因在于力量均衡。

刘邦起家之前是个平民百姓,征服天下只能靠团结足够多的人。刘邦能够吸引一群重要将领和谋士追随自己,不是因为自己有力量,而是因为有威信。刘邦和这些人近乎是合伙人的关系,并没有压倒性力量来钳制他们,反倒会被这些兄弟给制衡住。这么一来,皇帝想要专制也不可能,**无为而治只是面对强大合伙人时的无奈之举。**

### 汉武帝的“独尊儒术”
“阳儒阴法",又称“**外儒内法**"。什么意思呢?从观念层面来看,是儒家在主导,儒生解读着天意,君主也不敢完全违背儒家的教导而行事。儒家表面上的迂腐,却为君主划出了大致的行动边界;但在具体的制度设计上,却还是法家逻辑。这样一来,**对君主来说,治理的效率有了,安抚民心的口径也有了。**

## 汉人王朝为何无法统治长城以北【汉】【中原】
这个问题,其底层是由儒家文化以及儒家文化的地理依赖性决定的。

### 究竟什么是汉人
**只要是接受儒家文化,并按儒家文化的指导生活的人,在古代就被视作汉人。**

### 儒家文化的地理依赖性
儒家文化光有个体心灵的皈依远远不够,个体还必须生活在一种特定的人际关系结构当中才行。

比如,“三从四德三纲五常"等等这些规矩,都是对某种人际关系的规定,脱离开人际关系根本就没法展开。把你一个人扔荒岛上,还让你三从四德,你肯定做不到。

儒家文化所要求的这种特定的人际关系,首先就要求有比较稳定的家庭组织,而稳定的家庭组织,前提是你得是定居的。

定居的前提是农耕,而农耕有一个最硬性的约束条件,就是年降水量。东亚大陆上,如果一个地方年降水量少于400毫米的话,靠农耕是活不下去的。

那么,东亚大陆的400毫米等降雨线在哪儿呢?

这条400毫米等降雨线,差不多和长城重合。长城再往北,年降水量就不足400毫米了。也就是说,儒家帝国在农耕地区的扩张极限,就是400毫米等降雨线。于是在这里,儒家帝国修建了长城。长城再往北就是游牧地区了。

在古代社会,由于农耕对降雨量的要求,使得你要是越过了长城以北,还想活得下去的话,就必须游牧化,否则是死路一条。而一旦游牧化之后,就意味着中原式的人际关系结构、家庭结构等等都没有基础了,无法再按照儒家的方式来生活了。

**儒家文化有一种地理依赖性。因为自然生态原因,儒家越不过去长城以北、嘉峪关以西。儒家文化只能在中原地区展开。**

### 中原和草原的继承逻辑区别
![中原和草原的继承逻辑区别](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/dFAEllbB47.png)*中原和草原的继承逻辑区别*

官僚制帝国有个很重要的特征,就是君主和官僚,在功能上是有分工的。君主的首要功能,是象征正当性。所以,君主的能力只排在第二位,第一重要的是君位继承的稳定性。嫡长子资格是最容易达成这种共识的。所以,中原的继承原则就稳定在嫡长子继承制上了。

## 草原征服型王朝为何能一统天下【+】【草原】
中原的统一的农耕帝国,促使草原出现了统一的游牧帝国。游牧帝国又反过来用军事压力改变中原帝国,并且能在中原帝国衰败时输入秩序,重建社会,建立同时统治中原和草原的庞大帝国。

这类帝国,必须能熟练运用中原和草原两套游戏规则。也就是说,它必须是一个胡汉二元帝国。

![草原王朝演化逻辑](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-22-52-43.png)*草原王朝演化逻辑*

### 游牧帝国是如何建立的
如果中原没有统一,中原各诸侯国会竞相和草原部落进行贸易,因为它们需要草原上的马。草原马,是战争的利器。如此一来,诸侯国之间竞争起来,草原无论是买还是卖,都能有个不错的价格,小部落们也就没有任何欲望想要联合起来。因为一旦联合了,贸易利润肯定会被盟主剥去一层,还不如不联合呢。

但是一旦中原统一,就不再有各个诸侯国的竞争,统一的大帝国垄断了中原市场,帝国就可以用政治手段去干涉贸易,要么压低价格,要么干脆断绝贸易。

这样一来,草原上的那么多小部落,他们仍然需要那些必需品,却没法正常地买来了,那就只有抢。要从中原帝国手里抢东西,小部落根本不是对手,那就必须联合成为一个大的部落联盟才行。于是,强大的游牧帝国出现了。

联合起来的草原帝国,其人口仍远远少于中原帝国,但却比中原帝国更有战斗力。

这个所谓的游牧帝国,事实上是一个庞大的部落联盟。联盟的大可汗通过垄断战利品的分配权,形成一个由战争衍生出来的中央财政。草原的中央财政和中原那种靠税收的财政体制很不一样,它主要是靠战争战利品形成的财政。

### 草原的周期性继承危机
草原可汗是必须经常出去打仗的,你不能带头抢东西回来,就没人愿意跟你了。由于对可汗战斗力的要求,意味着可汗的继承人绝不能是小孩。但是草原上战事频繁,可汘的寿命有很大不确定性,当大可汗去世的时候,他的儿子很有可能还未成年。

所以在草原上,一般来说,继承制不是中原式的父终子及,而是兄终弟及,也就是哥哥死了弟弟来继位。

中原有句古语叫做“胡虏无百年之运”,为什么草原帝国没有超过一百年的国运呢?

就是因为开国那一代可汗,他的兄弟几个加一块儿也活不过一百年。等到这一代全都去世之后,第二代一定会分裂。

### 草原力量注入中原
就中原来说,要面对的则是周期性的衰败危机。

在历史上有多次,中原是通过草原力量的注入,来重建秩序的。

---

东北是中原与草原的过渡带,但凡在东北能站得住脚的人,南北这两种治理模式他必须全懂。所以在入关后,他就可以建立起一个二元帝国。

所谓二元帝国,就是在长城以南,以中原儒家的方式来完成统治,统治者的身份是皇帝;而在长城以北,则按草原游牧的方式来完成统治,统治者的身份是大可汗。
### 二元帝国的治理逻辑
纯粹的中原人无法理解草原,纯粹的草原人也无法理解中原。

而东北则是中原与草原的过渡带,它北边靠着呼伦贝尔大草原,南边靠着辽东的农耕地区。但凡在东北能站得住脚的人,南北这两种治理模式他必须全懂。所以在入关后,他就可以建立起一个二元帝国。

所谓二元帝国,就是,在长城以南,能以中原儒家的方式来完成统治,统治者的身份是皇帝;在长城以北,则按草原游牧的方式来完成统治,统治者的身份是大可汗。


## 中国是如何走向豪族社会的【汉】【中原】
汉武帝的黩武政策,改变了汉朝社会结构,对社会的控制力由中央政府转移到了豪族手中。经过王莽篡位之后,豪族领袖刘秀干掉王莽,建立了东汉,最终形成了豪族和皇帝合作共治的局面。豪族社会维持了差不多一千年,一直到唐宋的转折期,豪族社会才结束。
### 豪族是怎么来的呢?
第一个来源是,战国时期贵族的后代,几百年来留下的世家大族盘根错节,还是很有势力的;
第二个来源是,文景之治的几十年,社会很自由,发展起来的很多大商人;
第三个来源是,地方的大侠、豪强,他们乐于去结交更多的人,愿意去庇护走投无路的人。
### 汉武帝:促使豪族兴起
汉武帝的爷爷和老爸,共同开创了中国古代历史上第一个著名的盛世“文景之治”,经过几十年,民间发展得非常富裕。到了汉武帝,帝国终于有了本钱与匈奴掰掰手腕。

汉武帝与匈奴的战争,断断续续地打了四十四年。匈奴方面自然是被打得妻离子散、苦不堪言,但是中原人民日子也并不好过。因为这些战争太费钱了,国库里的钱如流水一般花出去,钱不够用了,朝廷就不得不对百姓收更多的税。一次两次地增税,百姓还能忍受。但是长此以往,谁
也受不了啊,所以很多百姓就只好拋弃家园成为流民,那些没有成为流民的百姓,也都受不了。他们另想一辙,把土地扔了,自家的户口也不要了,投到地方豪族的门下接受保护,让官府从此找不着我,也就不用交税。

于史书记载,到武帝末年,天下的户口减少了一半,这当然不是战争打死了一半的人,而是跑掉了一半。

到了这个时候,朝廷就压制不了地方豪族了。豪族越来越强,中央政府能收的税越来越少,朝廷的日子就不好过了。
### 地方官僚与豪族结盟
在朝廷还比较有钱的时候,还有些办法控制地方郡守。一旦朝廷没钱了,郡守们就会琢磨如何扩大自己的势力。与豪族结盟,共同对抗朝廷,就是个不错的办法,监守自盗的戏码就上演了。

地方官僚和豪族联起手,大汉帝国的社会结构就开始发生深刻变化了。
### 王莽:抑制豪族
武帝之后的汉朝历史,恶性循环在不断加深。豪族越发展,朝廷越衰弱,朝廷越衰弱,豪族就越肆无忌惮，朝廷上几乎所有人都束手无策,最终一位看上去谦逊有礼、志向高远的人,众望所归,夺取了大权。这就是王莽。王莽先是成为帝国重臣,不久就篡位成为皇帝。

他上台之后做了很多改革政策,宣布了土地都属于国有的,民间不可以自行买卖,奴婢也不可以私自买卖,盐、铁这两种最重要的民用物资、山川林泽、铸造货币的权力,等等这一切,全都被收归国有。此外,还设置了一些国家储备机构,用来调节物价。

王莽这些政策的核心目标都是要抑制豪族,重新恢复帝国朝廷的统治能力。但是这种努力在当时是不可能成功的。原因很简单,你想要控制豪族,豪族会老老实实地等着你来控制他吗?除非你手上掌握的资源对豪族具有碾压性优势,否则豪族反抗起来绝对够你头疼的。王莽能掌握的资源从哪里来呢?只能来自社会上的税收。可是社会已经被豪族控制了,你到哪里去获取能碾压豪族的资源呢?要想真的干掉豪族,除非是有了新的技术进步。在豪族的控制之外,形成了新的经
济资源,皇帝可以在这里收到税,用这个来养活自己能控制的军队,才能干掉豪族,否则皇帝只能接受与豪族共治这样个事实。
### 刘秀:与豪族共治
豪族们起来反抗,很快就推翻了王莽的政权;刘秀作为这些豪族的领袖,建立了东汉政权。就凭刘秀的这些支持力量,东汉也注定只能是个皇帝与豪族合作共治的朝代。

东汉从西汉继承的是个豪族社会,刘秀身边的巨头们,能够从社会中直接获取支持,皇帝也就没机会消灭这些巨头了。

于是,刘秀直接就选择了在洛阳定都,这里没有军事地理优势,但这里是豪族们的大本营。这相当于刘秀明白地告诉了豪族,咱们都是一家人了。







## 为何后汉皇帝“亲小人、远贤臣”【后汉】【中原】
“贤臣”其实是世家大族,“小人"就是外戚、宦官,他们是皇帝中央集权的工具。

后汉皇帝“亲小人,远贤臣”的背后其实是皇权和世家大族的权力斗争。皇帝通过宦官之手,跟世家大族进行PK。

### 贤臣是谁
贤臣就是儒家化了的豪族。

有文化的豪族对社会有组织力,让皇上收税变得困难，皇上不大容易动得了他,还会引经据典地批评皇上,说你昏庸。

他们从东汉的时候逐渐发展起来,直到隋唐的历史上,被称为门阀士族,经常也简称为士族。

士族一代代发展壮大,逐渐成为世家大族,他们垄断了知识和地位,垄断了社会上的舆论。

这些人就是所谓“贤臣”,他们差不多把持了朝廷和地方的各种重要职位。世家大族彼此间还联姻通婚,形成了庞大的关系网络,对皇帝有着相当强的制约能力。
### 小人是谁
皇上要找来支持自己的人,来对抗世家大族。但问题是,世家大族把持着官僚体系,也控制着舆论,这些皇帝的支持者就肯定会被指责为“小人”了。这与他们实际上的人品、官品怎么样关系
不大。皇帝的行为,在世家大族嘴里,也肯定是"亲小人、远贤臣”了。

皇上到哪去找自己人呢?

到民间去找?就像前面说的,知识都被世家大族垄断,民间没什么可用之才。到朝廷上找?朝廷上放眼望去,都是彼此串通气的世家大族,也不行。

皇上还得保证这些人能站在自己一边。对皇帝来说,什么才能确保这些人支持自己尼?忠诚这东西是不敢指望了,能指望的是,他们的身份地位都完全依赖于皇帝这些人即便是出于自私,也得站在皇帝一边了。

那是什么人啊?只有两种,宦官,也就是太监,还有外戚,也就是皇后的家族。

宦官和外戚还彼此看不顺眼。宦官完全被世家大族们所瞧不起,外戚有不少也是出身世家大族的,但一旦与皇上结了亲,马上就会有压过其他世家大族一头的感觉,会借此不断扩大自己的势力范围,这又与其他的世家大族之间会发生矛盾。

于是,皇帝、外戚、宦官、世家大族组成的官僚,彼此之间形成了复杂的关系。

### 皇帝、外戚、宦官、世家大族的博弈关系
皇帝通过扶植宦官和外戚,跟这些世家大族进行PK,世家大族面对皇帝的这些对抗举措,便会进一步强化自己的”天下为己任”的形象,获得道德制高点,宦官和外戚就进一步被还原为“小人”。

### 东汉的瓦解
皇权与世家大族的这种冲突过程,会极大地败坏帝国的治理水准。

正赶上东汉末年进入了一个小冰期,连年天灾,民变四起。朝堂上各种勾心斗角,民间的疾苦实际上没人真的去管。在这种情况下,老百姓求告无门,只好想法自己组织起来,寻找活路。各种民间信仰,就是组织的工具,因此而获得了越来越大的影响力。

汉朝的儒学讲究天人感应认为天灾必定是皇帝失德,上天降下灾祸,皇帝被迫多次颁发罪己诏。皇上天天都在罪己的话,人们对朝廷的敬畏就会动摇了。民间信仰趁机说,自己才是天命所在,于是,到公元184年爆发了黄巾大起义,动摇天下。朝廷彻底没辙了,只能寄希望于世家大族与地方豪强兴兵勤王。但豪强们各怀鬼胎,逐鹿中原的诱惑迅速地让这些“贤臣"的种子都变成了乱世的枭雄。









',
  'groups' => 'Default',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '233',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000642s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001290s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 233 LIMIT 1 [ RunTime:0.000673s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 233 LIMIT 1 [ RunTime:0.000315s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001310s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000310s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000381s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000436s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=233,`p_id`=1,`title`='中国史纲\r',`content`='# 中国史纲\r\n[TOC]\r\n## 中国历史的时空坐标\r\n时间和空间加在一块,才是完整的历史。\r\n### 四个时间坐标点\r\n中国历史发生过几次重要的转型,这些转型推动着中国历史向前的发展。\r\n\r\n1.第一个转型,是**商周之变**,就是从商朝到周朝的转型。\r\n\r\n这次转型之后,我们开始有了“中国”这个概念,中华文明当中最初的普世主义理想开始出现了。\r\n\r\n2.第二个转型,**周秦之变**,就是从周朝到秦朝的转型。\r\n\r\n这次转型,让中原从分封割据的局面进入到大一统的局面,中国历史也开始超越于中原之上,中原与草原的相互塑造和对抗开始成为中国历史的大脉络。\r\n\r\n3.第三个转型,**唐宋之变**,就是从唐朝到宋朝的转型。\r\n\r\n这次转型,让中国的社会结构从豪族社会进入到平民社会,此后中国历史再无长期的分裂,大一统开始成为一个不可逆的历史过程。在先秦之后,中国的文化在宋朝迎来了又一次大爆发,有些西方学者甚至称这是中国的文艺复兴。这次文化爆发,不仅决定了此后将近一千年的中国文化气质,也决定了日本、朝鲜、越南等其他儒教国家的文化气质。\r\n\r\n4.第四个转型,就是**清朝末期开始的古今之变**,中国开始从古代社会向现代社会进行艰难转型。\r\n\r\n这个过程带来了一系列轰轰烈烈的历史过程,转型过程直到今天仍在继续,还未完成。\r\n\r\n### 五个空间坐标点\r\n草原、中原、海洋、西域、高原。\r\n\r\n这几个大的空间,彼此之间有着极为深刻的相互依赖相互塑造的关系,以至于脱离开一方就完全解释不了另一方,所以它们加在一块构成一个体系。\r\n\r\n## 中国的概念和中华文明的普世主义理想【商周】【中原】\r\n### 历史上第一次出现「中国」\r\n周朝的第二位君主周成王,兴建了东都洛阳城,当时有个叫做「何」的贵族,这人铸了一件青铜器纪念这个事儿,1963年这个青铜器在陕西宝鸡被发现,今天称其为「何尊」，「何尊」的底部铸了一百多个字,里面提到,周武王说要\"宅兹中国”,就是说要“住在中国”,这是\"中国\"这个词的最早来源。\r\n\r\n什么叫中国？**达到了文明最高水准的地方,就是文明意义上的中心,古人就管这种地方叫做「中国」。**\r\n### 中华文明的普世主义理想：究竟天命是降于周人呢,还是天命降于周王\r\n商朝是由“商人\"。他们认为天命降于商人。为了让天能够永远地保佑自己,商人会经常地进行大规模的祭祀活动,祭祀当中会大量用到活人做祭品。\r\n\r\n这些被献祭的人从哪来呢?\r\n\r\n从对外战争掠夺的羌人而来。所谓的羌人就是生活在商王朝西部的、除了商朝人以外的所有人。\r\n\r\n商人的这种天命观,肯定会受到羌人的抵抗。其中,周人是最主要的一支抵抗力量,他们逐渐组织了很多苦不堪言的羌人群体来反抗商朝，反抗的时候,在周人中间有过一个观念层面的争论,究竟天命是降于周人呢,还是天命降于周王?争论的结果是,天命降于周王。\r\n\r\n这个观念变化太重要了。初看上去,这似乎是把天命的载体变得狭隘了,实际上是把它变得普世了。\r\n\r\n为什么这么说呢?如果天命是降于周人,那就和此前降于商人的路数差不多,周人的岁月要想静好,就得时刻压制住所有不是周人的群体。这样的话,周人和商人征战,谁胜谁败就不好说了。因为,对其他羌人群体来说,打完这一仗,十有八九只不过换了个地方拿我们献祭,凭啥要跟你混啊?而**如果天命是降于周王,则周王便是天下的共主,他不仅仅要为周人主持正义,而是要为全天下人主持正义,这是一种真正的普世主义观念**。\r\n\r\n### 什么是封建社会\r\n推翻了商朝之后,周朝又是如何具体建立它的统治方式呢?那就是,分封制。周天子向下分封了他的大量亲戚和重臣,意图依靠他们形成的藩属诸侯国,来拱卫周王。这样一种政治统治形式就被称作“封建”,这种社会叫做封建社会。\r\n\r\n封建“这个词最初出自《左传》,里面有句话叫做“封建亲戚,以藩屏周”,就是说分封亲信出去建立诸侯国,作为周朝王室领地的屏障。**只有这种封土建邦、分封割据的状态,才叫做封建。**\r\n\r\n封建社会的一大特征是,最高统治者是没有权力干涉诸侯国内部事务的,诸侯们确实是最高统治者的封臣,但某种意义上也像是个合伙人,都有比较强的独立性。\r\n\r\n周朝的时候,诸侯都承认周天子是最高权威,但周天子并不能管诸侯国内部的事情。周朝在这个过程中建立了封建社会,但周天子又逐渐衰落了。在周天子衰落之后,历史的主角就变成了那些诸侯。诸侯们彼此不断竞争,最终终结了中国的封建社会。\r\n\r\n## 封建社会的终结【春秋末期、战国初期】【中原】\r\n到了西周后期,周天子的影响力越来越差,最终被迫迁都洛阳,中国历史进入到东周。\r\n\r\n东周又分成了舂秋战国两个时期,**春秋末期出现了一些重要的技术发展,它带来了新的经济和人力资源,打破了过去的社会均衡,封建社会当中的贵族秩序崩塌了，封建社会也在春秋战国时代走上末日。**\r\n\r\n### 战争的逻辑的变化\r\n春秋之前的的战争十分注重礼仪性(战争都是贵族在参与，这就导致了参与人数并不多，他们认为战争是一件高贵的事，他们的战争可能就是比谁的正步踢得好)。但到了春秋中后期,随着楚国(楚国是个土生政权,并不是周天子分封的诸侯国，它的文化和中原有很大区别,也不大在乎中原的礼仪之类的东西,在当时的中原诸侯看来它就是个蛮夷之邦。)的加入，战争变成以砍死人为目的了。也正是由于这个战争逻辑的变化,才把中国引向了大一统。\r\n\r\n### 两个技术变迁\r\n诸侯分封次级诸侯，随着次级诸侯势力的增大，诸侯和次级诸侯的关系同周天子和诸侯的关系一样。在春秋末期、战国初期,出现了两个重要的技术变迁,让诸侯力量的扩大有了可能。正是因为这两次技术变革,打破了君主和封臣之间的力量均衡,周厉王当初搞不定自己下级的事,现在诸侯可以做到了,也就是诸侯能够搞定这些次级诸侯。\r\n\r\n这两个技术变迁,一个是铁器和牛耕的农业生产技术,一个是竹简这种知识传播技术。\r\n\r\n>铁器和牛耕 - 农业生产技术\r\n\r\n铁器与牛耕的出现,提升了平民的劳动效率。过去,他们的耕种效率很低,只能在贵族控制的公田、又叫井田上种地,没有能力再去开垦自己的私田了;但是,铁器和牛耕让生产效率大大提升了,平民有余力去开垦自己的私田,甚至索性就从贵族控制的井田上跑路了。此时君主、贵族、平民三者之间的一种复杂博弈关系就出现了。注意,这儿所说的君主,指的就是周天子封的诸侯,贵族指的就是诸侯所封的次级诸侯,这会儿的历史已经没周天子什么事儿了。\r\n\r\n君主向耕种私田的平民提供保护,平民向君主交税。平民从井田上越跑越多,贵族所控制的井田制就逐渐瓦解了,贵族的力量也逐渐削弱了。君主开始获得相对于贵族的优势。\r\n\r\n>竹简 - 知识传播技术\r\n\r\n 知识传播的成本急剧下降,一般的贵族子弟、甚至运气好的普通百姓,都有机会学习文字获得知识了。由于多年的人口膨胀,这个时候出现了很多有文化、却无法获得一块封地的贵族子弟,他们就变成游士,到处寻找把自己卖个好价钱的机会。\r\n\r\n君主们早就想养一群可控的自己人了。什么样的人最好用呢?\r\n\r\n第一,他们要在本国没有根基,没资本对抗君主;\r\n第二,他们的地位尊荣都取决于君主的赏赐,就有动力与君主相配合。\r\n\r\n从别国跑来的游士完全符合这两点要求。君主与游士拍即合,游士成为依附于君主的私人人事班底。这个人事班底,后来就发展为官僚制。\r\n\r\n官僚和贵族的区别在于,本质上来说,官僚没有独立性,他们是职业经理人,其地位取决于君主的意志;贵族有独立性,他们是准合伙人,君主有大事必须和他们商量着来。游士的出现,终于让君主们可以全方位碾压贵族封臣,诸侯国也就从君主与贵族共治的结构,转向君主说了算的官僚制结构。\r\n\r\n### 变法\r\n\r\n这个过程在历史上被叫作什么呢?\r\n\r\n变法! 没错,魏国的李悝变法、秦国的商鞅变法等等,就是这样展开的。\r\n\r\n来自其他国家的游士,成了各诸侯国的新贵,他们压制住所在国的大贵族,把君主的意志贯彻下去。随着各种变法的展开,中国历史就进入到了战国时代。\r\n\r\n对君主来说,这回有办法把平民也动员起来了。你们虽然不是贵族血统,但你们可以立军功。只要你有办法从战场上拎回更多的人头,你也有机会上升到比贵族还高的地位。这种激励可不得了,战争的规模和频次急剧上升,大规模的灭国之战很容易就爆发了。灭国之战都到什么量级呢?比如很多人推崇的战神白起,一场战役就会坑杀赵国的40万降兵,这都在变法之后成为可能，变法这个事情也有传染性,谁最先变法,谁的战争效率就大幅上升;其他国家如果不跟上,就只能等着挨打。\r\n\r\n**随着各国陆续变法,各诸侯国内部的旧贵族阶层被一扫而空**。变法之后,君主能决定军功的标准,也就能决定官僚新贵们的地位高低,**君主对国家的控制力就变得更强**,再没有能够约束君主的力量,**分封割据的封建社会也就逐渐走上了终结之日**,战争逻辑的变化,影响还不止于此,当战争规模扩大到了诸侯国承受不起的时候,中国也就开始走向大一统。\r\n\r\n## 诸子百家的三大流派【春秋后期】【中原】\r\n春秋后期,天下大乱,礼崩乐坏。人们突然发现赖以理解世界的坐标系没有了,世界的意义丧失了。而这种时候,就是思想大爆发的时候。\r\n\r\n诸子百家,根据他们对待传统不同的态度,可以分为三类:一类是力挺传统（**克己复礼**）,代表就是儒家;一类是抛弃传统（**以法代礼**）,代表就是法家;还有一类是不在乎传统（出世，**无为而治**）,代表就是道家。\r\n\r\n### 儒家\r\n孔子认为复古的路径是“克己复礼”,就是要克制自己的各种冲动,依照传统留下来的\"礼\"的要求来做事。这样就能达到儒家的最高理想,“仁”。\r\n\r\n>如果你理解孔子是儒家的开创者,莫不如把他理解为此前巫师传统的集大成者。\r\n\r\n儒家是从商周两朝的巫师系统发展出来的,巫师就是古代沟通天意与人事的神职人员，这种工作主要通过占卜和祭祀来完成。祭祀这属于最高的“礼”,而巫师们就是“礼”的具体操作者与记录者。\r\n\r\n到了礼崩乐坏的时候,如果要想复古,第步肯定得先说清楚这个“古”究竟是什么。巫师系统有这方面的很多记录,当然是最合适的解说人选,他们由此就逐渐发展为儒家。\r\n\r\n### 法家\r\n\r\n儒家强调恢复“礼”,“礼”来自传统,贵族是“礼\"的载体;法家强调创建“法”,“法”出自君主意志,官僚是法的执行者。\r\n\r\n>法家常在别国成事\r\n\r\n根据君主、贵族、官僚的博弈关系,各诸侯国的君主们肯定不会愿意接受儒家,而更愿意接受法所以孔子孟子都曾周游列国,都没得到过重用,反倒是法家的人占据各种高位。有趣的是,法家的鼓吹者往往在本国是不受欢迎的,无论是商鞅还是李斯,都是在别国建功立业。韩非虽然在别国没有能够建立功业,但在本国也从没获得过机会。原因在于,君主需要官僚在本国没有根基,才能听使唤;倘若是出身本国的法家,他总会有各种根基,这种人又太懂得法术势,很容易成为君主忌惮的对象。脱离了家乡的游士,如漂泊浮萍,孤身人,荣辱富贵都依赖于君主,君主最喜欢了。所以,法家只能在别国成事。\r\n\r\n### 道家\r\n\r\n顺其自然,让世界、让百姓自由自主地活动,事情自然就好了,这就叫“无为而治”。\r\n\r\n道家认为,正是各种入世的念头才把事情搞糟了,倘若不再追求转瞬即逝的现世成就,天地一下子就宽了。\r\n\r\n## 周秦之变【周-秦-汉】【中原】\r\n\r\n周秦之变对中国的思想史还带来个自然延伸的影响,就是我们在历史上看到的,从秦皇到汉武,帝国的官方思想经历了**从法家到道家再到儒家**的转换过程。\r\n\r\n### 周秦之变的“法家逻辑”\r\n百家争鸣的诸多学说,哪一种更注重提升战争效率,它就会获得诸侯们在政治上的更多支持。从中胜出的就是法家。但你用法家就能够征服天下,却不能仅仅用法家来治理天下。\r\n\r\n### 汉高祖的“无为而治”\r\n为什么汉高祖会选择道家呢?最根本的原因在于力量均衡。\r\n\r\n刘邦起家之前是个平民百姓,征服天下只能靠团结足够多的人。刘邦能够吸引一群重要将领和谋士追随自己,不是因为自己有力量,而是因为有威信。刘邦和这些人近乎是合伙人的关系,并没有压倒性力量来钳制他们,反倒会被这些兄弟给制衡住。这么一来,皇帝想要专制也不可能,**无为而治只是面对强大合伙人时的无奈之举。**\r\n\r\n### 汉武帝的“独尊儒术”\r\n“阳儒阴法\",又称“**外儒内法**\"。什么意思呢?从观念层面来看,是儒家在主导,儒生解读着天意,君主也不敢完全违背儒家的教导而行事。儒家表面上的迂腐,却为君主划出了大致的行动边界;但在具体的制度设计上,却还是法家逻辑。这样一来,**对君主来说,治理的效率有了,安抚民心的口径也有了。**\r\n\r\n## 汉人王朝为何无法统治长城以北【汉】【中原】\r\n这个问题,其底层是由儒家文化以及儒家文化的地理依赖性决定的。\r\n\r\n### 究竟什么是汉人\r\n**只要是接受儒家文化,并按儒家文化的指导生活的人,在古代就被视作汉人。**\r\n\r\n### 儒家文化的地理依赖性\r\n儒家文化光有个体心灵的皈依远远不够,个体还必须生活在一种特定的人际关系结构当中才行。\r\n\r\n比如,“三从四德三纲五常\"等等这些规矩,都是对某种人际关系的规定,脱离开人际关系根本就没法展开。把你一个人扔荒岛上,还让你三从四德,你肯定做不到。\r\n\r\n儒家文化所要求的这种特定的人际关系,首先就要求有比较稳定的家庭组织,而稳定的家庭组织,前提是你得是定居的。\r\n\r\n定居的前提是农耕,而农耕有一个最硬性的约束条件,就是年降水量。东亚大陆上,如果一个地方年降水量少于400毫米的话,靠农耕是活不下去的。\r\n\r\n那么,东亚大陆的400毫米等降雨线在哪儿呢?\r\n\r\n这条400毫米等降雨线,差不多和长城重合。长城再往北,年降水量就不足400毫米了。也就是说,儒家帝国在农耕地区的扩张极限,就是400毫米等降雨线。于是在这里,儒家帝国修建了长城。长城再往北就是游牧地区了。\r\n\r\n在古代社会,由于农耕对降雨量的要求,使得你要是越过了长城以北,还想活得下去的话,就必须游牧化,否则是死路一条。而一旦游牧化之后,就意味着中原式的人际关系结构、家庭结构等等都没有基础了,无法再按照儒家的方式来生活了。\r\n\r\n**儒家文化有一种地理依赖性。因为自然生态原因,儒家越不过去长城以北、嘉峪关以西。儒家文化只能在中原地区展开。**\r\n\r\n### 中原和草原的继承逻辑区别\r\n![中原和草原的继承逻辑区别](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/dFAEllbB47.png)*中原和草原的继承逻辑区别*\r\n\r\n官僚制帝国有个很重要的特征,就是君主和官僚,在功能上是有分工的。君主的首要功能,是象征正当性。所以,君主的能力只排在第二位,第一重要的是君位继承的稳定性。嫡长子资格是最容易达成这种共识的。所以,中原的继承原则就稳定在嫡长子继承制上了。\r\n\r\n## 草原征服型王朝为何能一统天下【+】【草原】\r\n中原的统一的农耕帝国,促使草原出现了统一的游牧帝国。游牧帝国又反过来用军事压力改变中原帝国,并且能在中原帝国衰败时输入秩序,重建社会,建立同时统治中原和草原的庞大帝国。\r\n\r\n这类帝国,必须能熟练运用中原和草原两套游戏规则。也就是说,它必须是一个胡汉二元帝国。\r\n\r\n![草原王朝演化逻辑](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-22-52-43.png)*草原王朝演化逻辑*\r\n\r\n### 游牧帝国是如何建立的\r\n如果中原没有统一,中原各诸侯国会竞相和草原部落进行贸易,因为它们需要草原上的马。草原马,是战争的利器。如此一来,诸侯国之间竞争起来,草原无论是买还是卖,都能有个不错的价格,小部落们也就没有任何欲望想要联合起来。因为一旦联合了,贸易利润肯定会被盟主剥去一层,还不如不联合呢。\r\n\r\n但是一旦中原统一,就不再有各个诸侯国的竞争,统一的大帝国垄断了中原市场,帝国就可以用政治手段去干涉贸易,要么压低价格,要么干脆断绝贸易。\r\n\r\n这样一来,草原上的那么多小部落,他们仍然需要那些必需品,却没法正常地买来了,那就只有抢。要从中原帝国手里抢东西,小部落根本不是对手,那就必须联合成为一个大的部落联盟才行。于是,强大的游牧帝国出现了。\r\n\r\n联合起来的草原帝国,其人口仍远远少于中原帝国,但却比中原帝国更有战斗力。\r\n\r\n这个所谓的游牧帝国,事实上是一个庞大的部落联盟。联盟的大可汗通过垄断战利品的分配权,形成一个由战争衍生出来的中央财政。草原的中央财政和中原那种靠税收的财政体制很不一样,它主要是靠战争战利品形成的财政。\r\n\r\n### 草原的周期性继承危机\r\n草原可汗是必须经常出去打仗的,你不能带头抢东西回来,就没人愿意跟你了。由于对可汗战斗力的要求,意味着可汗的继承人绝不能是小孩。但是草原上战事频繁,可汘的寿命有很大不确定性,当大可汗去世的时候,他的儿子很有可能还未成年。\r\n\r\n所以在草原上,一般来说,继承制不是中原式的父终子及,而是兄终弟及,也就是哥哥死了弟弟来继位。\r\n\r\n中原有句古语叫做“胡虏无百年之运”,为什么草原帝国没有超过一百年的国运呢?\r\n\r\n就是因为开国那一代可汗,他的兄弟几个加一块儿也活不过一百年。等到这一代全都去世之后,第二代一定会分裂。\r\n\r\n### 草原力量注入中原\r\n就中原来说,要面对的则是周期性的衰败危机。\r\n\r\n在历史上有多次,中原是通过草原力量的注入,来重建秩序的。\r\n\r\n---\r\n\r\n东北是中原与草原的过渡带,但凡在东北能站得住脚的人,南北这两种治理模式他必须全懂。所以在入关后,他就可以建立起一个二元帝国。\r\n\r\n所谓二元帝国,就是在长城以南,以中原儒家的方式来完成统治,统治者的身份是皇帝;而在长城以北,则按草原游牧的方式来完成统治,统治者的身份是大可汗。\r\n### 二元帝国的治理逻辑\r\n纯粹的中原人无法理解草原,纯粹的草原人也无法理解中原。\r\n\r\n而东北则是中原与草原的过渡带,它北边靠着呼伦贝尔大草原,南边靠着辽东的农耕地区。但凡在东北能站得住脚的人,南北这两种治理模式他必须全懂。所以在入关后,他就可以建立起一个二元帝国。\r\n\r\n所谓二元帝国,就是,在长城以南,能以中原儒家的方式来完成统治,统治者的身份是皇帝;在长城以北,则按草原游牧的方式来完成统治,统治者的身份是大可汗。\r\n\r\n\r\n## 中国是如何走向豪族社会的【汉】【中原】\r\n汉武帝的黩武政策,改变了汉朝社会结构,对社会的控制力由中央政府转移到了豪族手中。经过王莽篡位之后,豪族领袖刘秀干掉王莽,建立了东汉,最终形成了豪族和皇帝合作共治的局面。豪族社会维持了差不多一千年,一直到唐宋的转折期,豪族社会才结束。\r\n### 豪族是怎么来的呢?\r\n第一个来源是,战国时期贵族的后代,几百年来留下的世家大族盘根错节,还是很有势力的;\r\n第二个来源是,文景之治的几十年,社会很自由,发展起来的很多大商人;\r\n第三个来源是,地方的大侠、豪强,他们乐于去结交更多的人,愿意去庇护走投无路的人。\r\n### 汉武帝:促使豪族兴起\r\n汉武帝的爷爷和老爸,共同开创了中国古代历史上第一个著名的盛世“文景之治”,经过几十年,民间发展得非常富裕。到了汉武帝,帝国终于有了本钱与匈奴掰掰手腕。\r\n\r\n汉武帝与匈奴的战争,断断续续地打了四十四年。匈奴方面自然是被打得妻离子散、苦不堪言,但是中原人民日子也并不好过。因为这些战争太费钱了,国库里的钱如流水一般花出去,钱不够用了,朝廷就不得不对百姓收更多的税。一次两次地增税,百姓还能忍受。但是长此以往,谁\r\n也受不了啊,所以很多百姓就只好拋弃家园成为流民,那些没有成为流民的百姓,也都受不了。他们另想一辙,把土地扔了,自家的户口也不要了,投到地方豪族的门下接受保护,让官府从此找不着我,也就不用交税。\r\n\r\n于史书记载,到武帝末年,天下的户口减少了一半,这当然不是战争打死了一半的人,而是跑掉了一半。\r\n\r\n到了这个时候,朝廷就压制不了地方豪族了。豪族越来越强,中央政府能收的税越来越少,朝廷的日子就不好过了。\r\n### 地方官僚与豪族结盟\r\n在朝廷还比较有钱的时候,还有些办法控制地方郡守。一旦朝廷没钱了,郡守们就会琢磨如何扩大自己的势力。与豪族结盟,共同对抗朝廷,就是个不错的办法,监守自盗的戏码就上演了。\r\n\r\n地方官僚和豪族联起手,大汉帝国的社会结构就开始发生深刻变化了。\r\n### 王莽:抑制豪族\r\n武帝之后的汉朝历史,恶性循环在不断加深。豪族越发展,朝廷越衰弱,朝廷越衰弱,豪族就越肆无忌惮，朝廷上几乎所有人都束手无策,最终一位看上去谦逊有礼、志向高远的人,众望所归,夺取了大权。这就是王莽。王莽先是成为帝国重臣,不久就篡位成为皇帝。\r\n\r\n他上台之后做了很多改革政策,宣布了土地都属于国有的,民间不可以自行买卖,奴婢也不可以私自买卖,盐、铁这两种最重要的民用物资、山川林泽、铸造货币的权力,等等这一切,全都被收归国有。此外,还设置了一些国家储备机构,用来调节物价。\r\n\r\n王莽这些政策的核心目标都是要抑制豪族,重新恢复帝国朝廷的统治能力。但是这种努力在当时是不可能成功的。原因很简单,你想要控制豪族,豪族会老老实实地等着你来控制他吗?除非你手上掌握的资源对豪族具有碾压性优势,否则豪族反抗起来绝对够你头疼的。王莽能掌握的资源从哪里来呢?只能来自社会上的税收。可是社会已经被豪族控制了,你到哪里去获取能碾压豪族的资源呢?要想真的干掉豪族,除非是有了新的技术进步。在豪族的控制之外,形成了新的经\r\n济资源,皇帝可以在这里收到税,用这个来养活自己能控制的军队,才能干掉豪族,否则皇帝只能接受与豪族共治这样个事实。\r\n### 刘秀:与豪族共治\r\n豪族们起来反抗,很快就推翻了王莽的政权;刘秀作为这些豪族的领袖,建立了东汉政权。就凭刘秀的这些支持力量,东汉也注定只能是个皇帝与豪族合作共治的朝代。\r\n\r\n东汉从西汉继承的是个豪族社会,刘秀身边的巨头们,能够从社会中直接获取支持,皇帝也就没机会消灭这些巨头了。\r\n\r\n于是,刘秀直接就选择了在洛阳定都,这里没有军事地理优势,但这里是豪族们的大本营。这相当于刘秀明白地告诉了豪族,咱们都是一家人了。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 为何后汉皇帝“亲小人、远贤臣”【后汉】【中原】\r\n“贤臣”其实是世家大族,“小人\"就是外戚、宦官,他们是皇帝中央集权的工具。\r\n\r\n后汉皇帝“亲小人,远贤臣”的背后其实是皇权和世家大族的权力斗争。皇帝通过宦官之手,跟世家大族进行PK。\r\n\r\n### 贤臣是谁\r\n贤臣就是儒家化了的豪族。\r\n\r\n有文化的豪族对社会有组织力,让皇上收税变得困难，皇上不大容易动得了他,还会引经据典地批评皇上,说你昏庸。\r\n\r\n他们从东汉的时候逐渐发展起来,直到隋唐的历史上,被称为门阀士族,经常也简称为士族。\r\n\r\n士族一代代发展壮大,逐渐成为世家大族,他们垄断了知识和地位,垄断了社会上的舆论。\r\n\r\n这些人就是所谓“贤臣”,他们差不多把持了朝廷和地方的各种重要职位。世家大族彼此间还联姻通婚,形成了庞大的关系网络,对皇帝有着相当强的制约能力。\r\n### 小人是谁\r\n皇上要找来支持自己的人,来对抗世家大族。但问题是,世家大族把持着官僚体系,也控制着舆论,这些皇帝的支持者就肯定会被指责为“小人”了。这与他们实际上的人品、官品怎么样关系\r\n不大。皇帝的行为,在世家大族嘴里,也肯定是\"亲小人、远贤臣”了。\r\n\r\n皇上到哪去找自己人呢?\r\n\r\n到民间去找?就像前面说的,知识都被世家大族垄断,民间没什么可用之才。到朝廷上找?朝廷上放眼望去,都是彼此串通气的世家大族,也不行。\r\n\r\n皇上还得保证这些人能站在自己一边。对皇帝来说,什么才能确保这些人支持自己尼?忠诚这东西是不敢指望了,能指望的是,他们的身份地位都完全依赖于皇帝这些人即便是出于自私,也得站在皇帝一边了。\r\n\r\n那是什么人啊?只有两种,宦官,也就是太监,还有外戚,也就是皇后的家族。\r\n\r\n宦官和外戚还彼此看不顺眼。宦官完全被世家大族们所瞧不起,外戚有不少也是出身世家大族的,但一旦与皇上结了亲,马上就会有压过其他世家大族一头的感觉,会借此不断扩大自己的势力范围,这又与其他的世家大族之间会发生矛盾。\r\n\r\n于是,皇帝、外戚、宦官、世家大族组成的官僚,彼此之间形成了复杂的关系。\r\n\r\n### 皇帝、外戚、宦官、世家大族的博弈关系\r\n皇帝通过扶植宦官和外戚,跟这些世家大族进行PK,世家大族面对皇帝的这些对抗举措,便会进一步强化自己的”天下为己任”的形象,获得道德制高点,宦官和外戚就进一步被还原为“小人”。\r\n\r\n### 东汉的瓦解\r\n皇权与世家大族的这种冲突过程,会极大地败坏帝国的治理水准。\r\n\r\n正赶上东汉末年进入了一个小冰期,连年天灾,民变四起。朝堂上各种勾心斗角,民间的疾苦实际上没人真的去管。在这种情况下,老百姓求告无门,只好想法自己组织起来,寻找活路。各种民间信仰,就是组织的工具,因此而获得了越来越大的影响力。\r\n\r\n汉朝的儒学讲究天人感应认为天灾必定是皇帝失德,上天降下灾祸,皇帝被迫多次颁发罪己诏。皇上天天都在罪己的话,人们对朝廷的敬畏就会动摇了。民间信仰趁机说,自己才是天命所在,于是,到公元184年爆发了黄巾大起义,动摇天下。朝廷彻底没辙了,只能寄希望于世家大族与地方豪强兴兵勤王。但豪强们各怀鬼胎,逐鹿中原的诱惑迅速地让这些“贤臣\"的种子都变成了乱世的枭雄。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Default',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 233 [ RunTime:0.001079s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001011s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=13  WHERE  `groups` = 'Default' [ RunTime:0.000337s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001018s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=13  WHERE  `groups` = 'Default' [ RunTime:0.000302s ]
---------------------------------------------------------------
[ 2018-11-10T23:06:01+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/233.html
[ info ] qingrang.top/daily/admin/note/shownote/id/233.html [运行时间：0.067502s][吞吐率：14.81req/s] [内存消耗：2,023.41kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/233.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=nhge48o4922hq7l50a9umghc00',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '233',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000697s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001325s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 233 LIMIT 1 [ RunTime:0.000807s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000959s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000292s ]
