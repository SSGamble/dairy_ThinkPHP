---------------------------------------------------------------
[ 2018-11-13T09:22:44+08:00 ] 74.120.168.12 66.249.64.207 GET /daily/admin/note/editnote/id/
[ info ] qingrang.top/daily/admin/note/editnote/id/ [运行时间：0.046901s][吞吐率：21.32req/s] [内存消耗：1,427.04kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'from' => 'googlebot(at)googlebot.com',
  'user-agent' => 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
  'accept-encoding' => 'gzip,deflate,br',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-13T14:12:22+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/212.html
[ info ] qingrang.top/daily/admin/show/shownote/id/212.html [运行时间：0.075098s][吞吐率：13.32req/s] [内存消耗：2,019.94kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/show/notelst/groups/Linux.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,ko-KR;q=0.8,ko;q=0.7,ja-JP;q=0.6,ja;q=0.5,zh-TW;q=0.4',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541129290,1541138671,1541151758,1541298048',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001408s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002781s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.001094s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002194s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000354s ]
---------------------------------------------------------------
[ 2018-11-13T15:42:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.041243s][吞吐率：24.25req/s] [内存消耗：1,428.44kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-13T15:42:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.041411s][吞吐率：24.15req/s] [内存消耗：1,340.78kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-13T15:42:59+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.075792s][吞吐率：13.19req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000773s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001504s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000417s ]
---------------------------------------------------------------
[ 2018-11-13T15:42:59+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.093604s][吞吐率：10.68req/s] [内存消耗：2,385.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000842s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002005s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003896s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000766s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001113s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000573s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000899s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001196s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000608s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000320s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000386s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001714s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000387s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001265s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000750s ]
---------------------------------------------------------------
[ 2018-11-13T16:28:58+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.074429s][吞吐率：13.44req/s] [内存消耗：2,468.88kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '14',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'Java',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001697s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003235s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Java' ORDER BY date desc [ RunTime:0.003274s ]
---------------------------------------------------------------
[ 2018-11-13T16:29:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editNote/id/228
[ info ] qingrang.top/daily/admin/note/editNote/id/228 [运行时间：0.066270s][吞吐率：15.09req/s] [内存消耗：2,032.50kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editNote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '228',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000629s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001557s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 228 LIMIT 1 [ RunTime:0.000795s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000969s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000508s ]
---------------------------------------------------------------
[ 2018-11-13T16:29:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.058882s][吞吐率：16.98req/s] [内存消耗：2,020.98kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000770s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001296s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000296s ]
---------------------------------------------------------------
[ 2018-11-13T16:29:40+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ info ] qingrang.top/daily/admin/note/addnote.html [运行时间：0.057295s][吞吐率：17.45req/s] [内存消耗：1,976.18kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'addnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '243',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
  'content' => '# Spring
',
  'test-editormd-html-code' => '<h1 id="h1-spring"><a name="Spring" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Spring</h1>',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->addNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000685s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001317s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000396s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000294s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.000995s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('Spring\r' , '# Spring\r\n' , 'Java' , 2 , '2018-11-13') [ RunTime:0.000471s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001295s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000446s ]
---------------------------------------------------------------
[ 2018-11-13T16:29:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.087299s][吞吐率：11.45req/s] [内存消耗：2,384.20kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000600s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001318s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002007s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000551s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001001s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000334s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000585s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000900s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000307s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000407s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000420s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001113s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000229s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001034s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000648s ]
---------------------------------------------------------------
[ 2018-11-13T16:29:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.067520s][吞吐率：14.81req/s] [内存消耗：2,027.84kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000602s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002272s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001051s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000360s ]
---------------------------------------------------------------
[ 2018-11-13T16:29:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/
[ info ] qingrang.top/daily/ [运行时间：0.078963s][吞吐率：12.66req/s] [内存消耗：2,162.25kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => '',
    1 => NULL,
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Show->notelst[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/notelst.html [ array (
  0 => 'list_new',
  1 => 'groups',
  2 => 'groups0',
  3 => 'groups1',
  4 => 'groups2',
  5 => 'groupname',
  6 => 'content',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000732s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001858s ]
[ sql ] [ SQL ] SELECT `content` FROM `note` WHERE  (  id=32 ) LIMIT 1 [ RunTime:0.000595s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 LIMIT 1 [ RunTime:0.001630s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `publish` = 1 ORDER BY id desc LIMIT 0,6 [ RunTime:0.000626s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001044s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `groups` <> 'Personal' [ RunTime:0.000395s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `groups` <> 'Personal'  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000408s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1  AND `groups` <> 'Personal' [ RunTime:0.000308s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000391s ]
---------------------------------------------------------------
[ 2018-11-13T16:33:29+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.072577s][吞吐率：13.78req/s] [内存消耗：2,174.70kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => 'spring',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000577s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001974s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%spring%' OR `content` LIKE '%spring%' ) ORDER BY date desc [ RunTime:0.010944s ]
---------------------------------------------------------------
[ 2018-11-13T16:33:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/228
[ info ] qingrang.top/daily/admin/note/shownote/id/228 [运行时间：0.050687s][吞吐率：19.73req/s] [内存消耗：1,984.29kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '228',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000512s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001367s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 228 LIMIT 1 [ RunTime:0.000551s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000885s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000285s ]
---------------------------------------------------------------
[ 2018-11-13T16:38:23+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.054195s][吞吐率：18.45req/s] [内存消耗：2,032.80kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '3763',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
## IOC
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的


',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000557s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001867s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n## IOC\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000729s ]
---------------------------------------------------------------
[ 2018-11-13T16:39:49+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/228
[ info ] qingrang.top/daily/admin/note/editnote/id/228 [运行时间：0.056099s][吞吐率：17.83req/s] [内存消耗：2,032.31kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '228',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000724s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001405s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 228 LIMIT 1 [ RunTime:0.000436s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000933s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000282s ]
---------------------------------------------------------------
[ 2018-11-13T16:40:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/228
[ info ] qingrang.top/daily/admin/note/shownote/id/228 [运行时间：0.051917s][吞吐率：19.26req/s] [内存消耗：1,984.01kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '228',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000497s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001506s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 228 LIMIT 1 [ RunTime:0.000443s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001015s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000279s ]
---------------------------------------------------------------
[ 2018-11-13T16:40:39+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.049661s][吞吐率：20.14req/s] [内存消耗：2,041.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '6378',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。


',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000462s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001399s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000480s ]
---------------------------------------------------------------
[ 2018-11-13T16:40:52+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.071827s][吞吐率：13.92req/s] [内存消耗：2,041.01kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '6393',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。


',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000500s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001404s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000524s ]
---------------------------------------------------------------
[ 2018-11-13T16:42:57+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/asearch.html
[ info ] qingrang.top/daily/admin/note/asearch.html [运行时间：0.065956s][吞吐率：15.16req/s] [内存消耗：2,335.43kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'asearch',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '7',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'key' => 'pom',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aSearch[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000579s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001348s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  ( `title` LIKE '%pom%' OR `content` LIKE '%pom%' ) ORDER BY date desc [ RunTime:0.009882s ]
---------------------------------------------------------------
[ 2018-11-13T16:43:01+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/noteview.html
[ info ] qingrang.top/daily/admin/note/noteview.html [运行时间：0.049591s][吞吐率：20.16req/s] [内存消耗：2,134.03kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'noteview',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '10',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'noteid' => '236',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->noteview[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000422s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001353s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000466s ]
---------------------------------------------------------------
[ 2018-11-13T16:43:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/236
[ info ] qingrang.top/daily/admin/note/shownote/id/236 [运行时间：0.054985s][吞吐率：18.19req/s] [内存消耗：1,986.68kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '236',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000533s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001303s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 236 LIMIT 1 [ RunTime:0.000431s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000959s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000314s ]
---------------------------------------------------------------
[ 2018-11-13T16:58:56+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.051612s][吞吐率：19.38req/s] [内存消耗：2,045.75kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '7487',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000499s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001378s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000503s ]
---------------------------------------------------------------
[ 2018-11-13T18:09:36+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.069220s][吞吐率：14.45req/s] [内存消耗：2,335.27kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000683s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001559s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002392s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000521s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000932s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000388s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000821s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000313s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000411s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000416s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000995s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000234s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000952s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000661s ]
---------------------------------------------------------------
[ 2018-11-13T18:09:39+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.054177s][吞吐率：18.46req/s] [内存消耗：2,028.08kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000537s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002335s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000410s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000826s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000300s ]
---------------------------------------------------------------
[ 2018-11-13T18:09:45+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.055411s][吞吐率：18.05req/s] [内存消耗：2,063.11kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '11687',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000556s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.003403s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000687s ]
---------------------------------------------------------------
[ 2018-11-13T18:47:49+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.063965s][吞吐率：15.63req/s] [内存消耗：2,076.68kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '14381',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000816s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001735s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\n#### 动态工厂 Bean\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000806s ]
---------------------------------------------------------------
[ 2018-11-13T18:59:18+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.065782s][吞吐率：15.20req/s] [内存消耗：2,087.38kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '17439',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。

',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000630s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001573s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\n#### 动态工厂 Bean\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000769s ]
---------------------------------------------------------------
[ 2018-11-13T18:59:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.059599s][吞吐率：16.78req/s] [内存消耗：2,087.42kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '17496',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。


#### Bean 后处理器',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000800s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001410s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring',`content`='# Spring\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## IOC（控制反转）\n### 概念\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\n\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\n\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\n\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\n\n>以获取对象的方式来进行比较\n\n- 传统的方式\n\n通过 new 关键字主动创建一个对象\n\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\n\n- IOC方式\n\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\n\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\n\n\n\n### 第一个 Spring 程序\n#### 传统的面向接口编程\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\n\n*ISomeService.java - 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	ISomeService service = new SomeServiceImpl();\n	service.doSome();\n}\n```\n#### Spring 实现\n*applicationContext.mxl - Spring 的配置文件*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test02() {\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\n	someService.doSome();\n}\n```\n\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\n\n>FileSystemXmlApplicationContext\n\n```\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\n\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\n```\n\n>BeanFactory 容器\n\n*Test.java*\n```\n@Test\npublic void test05() {\n	// 创建 BeanFactory 容器\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\n	service.doSome();\n}\n```\n\n>ApplicationContext 与 BeanFactory 容器的区别\n\n这两上容器对于其中 Bean 的创建时机不同：\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\n - 缺点：占用系统资源（内存、CPU等）\n - 优点：响应速度快\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\n - 缺点：相对来说，响应速度慢\n - 优点：不多占用系统资源\n\n### Bean 的装配\n#### 动态工厂 Bean\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	void doSome();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doSome() {\n		System.out.println(\"执行doSome()方法\");\n	}\n}\n```\n*ServiceFactory.java - service 工厂*\n```\npublic class ServiceFactory {\n	public ISomeService getSomeService() {\n		return new SomeServiceImpl();\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册动态工厂 -->\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\n\n    <!-- 注册 Service：动态工厂 Bean -->\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n*Test.java - 测试*\n```\npublic void test02() {\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\n	service.doSome();\n}\n```\n#### 静态工厂 Bean\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册 Service：静态工厂 Bean -->\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\n</beans>\n```\n#### 容器中 Bean 的作用域\n*applicationContext.mxl*\n```\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\n```\n\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\n\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\n\n\n#### Bean 后处理器',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000761s ]
---------------------------------------------------------------
[ 2018-11-13T19:00:23+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.072851s][吞吐率：13.73req/s] [内存消耗：2,107.51kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '18277',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。


#### Bean 后处理器',
  'groups' => 'Java',
  'showsel' => '0',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000691s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001313s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000419s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000319s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001039s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000287s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring\r',`content`='# Spring\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC（控制反转）\r\n### 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n\r\n\r\n### 第一个 Spring 程序\r\n#### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n#### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n### Bean 的装配\r\n#### 动态工厂 Bean\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 静态工厂 Bean\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n#### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n\r\n#### Bean 后处理器',`groups`='Java',`is_show`=0,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.001134s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.002125s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000488s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001132s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000316s ]
---------------------------------------------------------------
[ 2018-11-13T19:00:23+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.065512s][吞吐率：15.26req/s] [内存消耗：1,988.32kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000718s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001317s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000486s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001028s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000436s ]
---------------------------------------------------------------
[ 2018-11-13T21:28:26+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.063551s][吞吐率：15.74req/s] [内存消耗：2,035.94kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001452s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002692s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000758s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000930s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000324s ]
---------------------------------------------------------------
[ 2018-11-13T21:30:56+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.051651s][吞吐率：19.36req/s] [内存消耗：2,160.92kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '19',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'Algorithm',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000655s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001617s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'Algorithm' ORDER BY date desc [ RunTime:0.002450s ]
---------------------------------------------------------------
[ 2018-11-13T21:30:59+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/ashownote2.html
[ info ] qingrang.top/daily/admin/note/ashownote2.html [运行时间：0.057338s][吞吐率：17.44req/s] [内存消耗：2,172.49kb] [文件加载：52]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'ashownote2',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '23',
  'accept' => 'application/json, text/javascript, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groupname' => 'DesignPattern',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->aShowNote2[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000606s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001315s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` = 'DesignPattern' ORDER BY date desc [ RunTime:0.001346s ]
---------------------------------------------------------------
[ 2018-11-13T21:31:05+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/237
[ info ] qingrang.top/daily/admin/note/shownote/id/237 [运行时间：0.065205s][吞吐率：15.34req/s] [内存消耗：1,989.61kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '237',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000538s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001381s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 237 LIMIT 1 [ RunTime:0.000473s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000932s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000284s ]
---------------------------------------------------------------
[ 2018-11-13T22:35:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.076397s][吞吐率：13.09req/s] [内存消耗：2,165.98kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '33965',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。


#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。

代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```',
  'groups' => 'Java',
  'showsel' => '0',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000937s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001720s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000639s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000385s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001260s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000318s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000663s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring\r',`content`='# Spring\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC（控制反转）\r\n### 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n\r\n\r\n### 第一个 Spring 程序\r\n#### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n#### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n### Bean 的装配\r\n#### 动态工厂 Bean\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 静态工厂 Bean\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n#### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n\r\n#### Bean 后处理器\r\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\r\n\r\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。\r\n\r\n代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\r\n\r\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\r\n\r\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\r\n\r\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	String doSome();\r\n	String doOther();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public String doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n		return \"doSome() - abc\";\r\n	}\r\n	\r\n	@Override\r\n	public String doOther() {\r\n		System.out.println(\"执行doOther()方法\");\r\n		return \"doOther() - def\";\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n\r\n	// bean：表示当前正在进行初始化的Bean对象\r\n	// beanName：表示当前正在进行初始化的Bean对象的id\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- before() ---方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- after() ---方法\");\r\n		//判断 SomeServiceImpl 对象\r\n		if (\"myService\".equals(beanName)) {\r\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\r\n					bean.getClass().getInterfaces(),\r\n					new InvocationHandler() {\r\n						@Override\r\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n							Object invoke = method.invoke(bean, args);\r\n							//判断具体方法\r\n							if (\"doSome\".equals(method.getName())) {\r\n								return ((String) invoke).toUpperCase();\r\n							}\r\n							return invoke;\r\n						}\r\n					});\r\n			return obj;\r\n		}\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册 Bean 后处理器 -->\r\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	System.out.println(service.doSome());\r\n	System.out.println(service.doOther());\r\n\r\n	System.out.println(\"======================\");\r\n\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\r\n	System.out.println(service2.doSome());\r\n	System.out.println(service2.doOther());\r\n}\r\n```\r\n\r\n*输出结果*\r\n```\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行doSome()方法\r\nDOSOME() - ABC\r\n执行doOther()方法\r\ndoOther() - def\r\n======================\r\n执行doSome()方法\r\ndoSome() - abc\r\n执行doOther()方法\r\ndoOther() - def\r\n```\r\n\r\n\r\n#### Bean 的生命周期\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\r\n	private String adao;\r\n	private String bdao;\r\n\r\n	public void setAdao(String adao) {\r\n		this.adao = adao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public void setBdao(String bdao) {\r\n		this.bdao = bdao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"Step1：执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"Step9：执行 doSome() 方法\");\r\n	}\r\n\r\n	public void setUp() {\r\n		System.out.println(\"Step7：初始化完毕之后\");\r\n	}\r\n\r\n	public void tearDown() {\r\n		System.out.println(\"Step11：销毁之前\");\r\n	}\r\n\r\n	@Override\r\n	public void setBeanName(String name) {\r\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\r\n	}\r\n\r\n	@Override\r\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\r\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\r\n	}\r\n\r\n	@Override\r\n	public void afterPropertiesSet() throws Exception {\r\n		System.out.println(\"Step6：Bean 初始化完毕了\");\r\n	}\r\n\r\n	@Override\r\n	public void destroy() throws Exception {\r\n		System.out.println(\"Step10：实现接口的销毁之前\");\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - Bean 后处理器*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\r\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\r\n    	<property name=\"adao\" value=\"aaa\"/>\r\n    	<property name=\"bdao\" value=\"bbb\"/>\r\n   	</bean>\r\n\r\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n	// 对于销毁方法的执行，有两个条件：\r\n	// 1)当前的Bean需要是singleton的\r\n	// 2)要手工关闭容器\r\n	((ClassPathXmlApplicationContext)ac).close();\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\nStep1：执行无参构造器\r\nStep2：执行 setter\r\nStep2：执行 setter\r\nStep3：获取到 bean 的 id = myService\r\nStep4：获取到 BeanFactory 容器\r\nStep5：MyBeanPostProcessor - 执行 before() 方法\r\nStep6：Bean 初始化完毕了\r\nStep7：初始化完毕之后\r\nStep8：MyBeanPostProcessor - 执行 after() 方法\r\nStep9：执行 doSome() 方法\r\nStep10：实现接口的销毁之前\r\nStep11：销毁之前\r\n```',`groups`='Java',`is_show`=0,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.001376s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001259s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000352s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001024s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000393s ]
---------------------------------------------------------------
[ 2018-11-13T22:35:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.056794s][吞吐率：17.61req/s] [内存消耗：2,012.63kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000553s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001243s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000743s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001066s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000365s ]
---------------------------------------------------------------
[ 2018-11-13T22:36:31+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.074743s][吞吐率：13.38req/s] [内存消耗：2,357.07kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000670s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001400s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001997s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000576s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001058s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000313s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000412s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001168s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000269s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000431s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000336s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000420s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001128s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000312s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000904s ]
---------------------------------------------------------------
[ 2018-11-13T22:36:48+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/247.html
[ info ] qingrang.top/daily/admin/note/editnote/id/247.html [运行时间：0.058136s][吞吐率：17.20req/s] [内存消耗：2,060.65kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000595s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001357s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000444s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000823s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000274s ]
---------------------------------------------------------------
[ 2018-11-13T22:36:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/247.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/247.html [运行时间：0.070061s][吞吐率：14.27req/s] [内存消耗：2,166.04kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '33965',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## IOC（控制反转）
### 概念
控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代
码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。
- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。

依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。

>以获取对象的方式来进行比较

- 传统的方式

通过 new 关键字主动创建一个对象

相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。

- IOC方式

对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。

相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。



### 第一个 Spring 程序
#### 传统的面向接口编程
经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。

*ISomeService.java - 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*Test.java - 测试*
```
@Test
public void test01() {
	ISomeService service = new SomeServiceImpl();
	service.doSome();
}
```
#### Spring 实现
*applicationContext.mxl - Spring 的配置文件*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->
    <bean id="myService" class="top.qingrang.service.SomeServiceImpl"/>

</beans>
```
*Test.java - 测试*
```
@Test
public void test02() {
	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	ISomeService someService = (ISomeService)ac.getBean("myService");
	someService.doSome();
}
```

从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。

>FileSystemXmlApplicationContext

```
// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml");

// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件
ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml");
```

>BeanFactory 容器

*Test.java*
```
@Test
public void test05() {
	// 创建 BeanFactory 容器
	BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
	ISomeService service = (ISomeService) bf.getBean("myService");
	service.doSome();
}
```

>ApplicationContext 与 BeanFactory 容器的区别

这两上容器对于其中 Bean 的创建时机不同：
1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建
 - 缺点：占用系统资源（内存、CPU等）
 - 优点：响应速度快
1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建
 - 缺点：相对来说，响应速度慢
 - 优点：不多占用系统资源

### Bean 的装配
#### 动态工厂 Bean
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doSome() {
		System.out.println("执行doSome()方法");
	}
}
```
*ServiceFactory.java - service 工厂*
```
public class ServiceFactory {
	public ISomeService getSomeService() {
		return new SomeServiceImpl();
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册动态工厂 -->
    <bean id="factory" class="top.qingrang.ba02.ServiceFactory"/>

    <!-- 注册 Service：动态工厂 Bean -->
    <bean id="myService" factory-bean="factory" factory-method="getSomeService"/>
</beans>
```
*Test.java - 测试*
```
public void test02() {
	String resource = "top/qingrang/ba02/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
}
```
#### 静态工厂 Bean
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service：静态工厂 Bean -->
    <bean id="myService" class="top.qingrang.ba03.ServiceFactory" factory-method="getSomeService"/>
</beans>
```
#### 容器中 Bean 的作用域
*applicationContext.mxl*
```
<bean id="myService" class="top.qingrang.ba04.SomeServiceImpl" scope="prototype"/>
```

当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。
1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。
1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。
1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。
1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。
1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。

对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。


#### Bean 后处理器
Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。

需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。

代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。

Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。

`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之前由容器自动调用。

`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`

该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。

*ISomeService.java - service 接口*
```
public interface ISomeService {
	String doSome();
	String doOther();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public String doSome() {
		System.out.println("执行doSome()方法");
		return "doSome() - abc";
	}
	
	@Override
	public String doOther() {
		System.out.println("执行doOther()方法");
		return "doOther() - def";
	}
}
```
*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*
```
public class MyBeanPostProcessor implements BeanPostProcessor {

	// bean：表示当前正在进行初始化的Bean对象
	// beanName：表示当前正在进行初始化的Bean对象的id
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- before() ---方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
		System.out.println("执行 ---- after() ---方法");
		//判断 SomeServiceImpl 对象
		if ("myService".equals(beanName)) {
			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),
					bean.getClass().getInterfaces(),
					new InvocationHandler() {
						@Override
						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
							Object invoke = method.invoke(bean, args);
							//判断具体方法
							if ("doSome".equals(method.getName())) {
								return ((String) invoke).toUpperCase();
							}
							return invoke;
						}
					});
			return obj;
		}
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册 Service -->
    <bean id="myService" class="top.qingrang.ba05.SomeServiceImpl"/>
    <bean id="myService2" class="top.qingrang.ba05.SomeServiceImpl"/>

    <!-- 注册 Bean 后处理器 -->
    <bean class="top.qingrang.ba05.MyBeanPostProcessor"/>

</beans>
```
*Test.java - 测试*
```
public void test01() {
	String resource = "top/qingrang/ba05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);

	ISomeService service = (ISomeService) ac.getBean("myService");
	System.out.println(service.doSome());
	System.out.println(service.doOther());

	System.out.println("======================");

	ISomeService service2 = (ISomeService) ac.getBean("myService2");
	System.out.println(service2.doSome());
	System.out.println(service2.doOther());
}
```

*输出结果*
```
执行 ---- before() ---方法
执行 ---- after() ---方法
执行 ---- before() ---方法
执行 ---- after() ---方法
执行doSome()方法
DOSOME() - ABC
执行doOther()方法
doOther() - def
======================
执行doSome()方法
doSome() - abc
执行doOther()方法
doOther() - def
```


#### Bean 的生命周期
*ISomeService.java - service 接口*
```
public interface ISomeService {
	void doSome();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {
	private String adao;
	private String bdao;

	public void setAdao(String adao) {
		this.adao = adao;
		System.out.println("Step2：执行 setter");
	}

	public void setBdao(String bdao) {
		this.bdao = bdao;
		System.out.println("Step2：执行 setter");
	}

	public SomeServiceImpl() {
		System.out.println("Step1：执行无参构造器");
	}

	@Override
	public void doSome() {
		System.out.println("Step9：执行 doSome() 方法");
	}

	public void setUp() {
		System.out.println("Step7：初始化完毕之后");
	}

	public void tearDown() {
		System.out.println("Step11：销毁之前");
	}

	@Override
	public void setBeanName(String name) {
		System.out.println("Step3：获取到 bean 的 id = " + name);
	}

	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		System.out.println("Step4：获取到 BeanFactory 容器");
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Step6：Bean 初始化完毕了");
	}

	@Override
	public void destroy() throws Exception {
		System.out.println("Step10：实现接口的销毁之前");
	}
}
```
*MyBeanPostProcessor.java - Bean 后处理器*
```
public class MyBeanPostProcessor implements BeanPostProcessor {
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("Step5：MyBeanPostProcessor - 执行 before() 方法");
		return bean;
	}

	@Override
	public Object postProcessAfterInitialization(final Object bean, String beanName)
			throws BeansException {
		System.out.println("Step8：MyBeanPostProcessor - 执行 after() 方法");
		return bean;
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册Service -->
    <bean id="myService" class="top.qingrang.ba07.SomeServiceImpl"
    		init-method="setUp" destroy-method="tearDown">
    	<property name="adao" value="aaa"/>
    	<property name="bdao" value="bbb"/>
   	</bean>

   	<bean class="top.qingrang.ba07.MyBeanPostProcessor"/>
</beans>
```
*Test.java - 测试*
```
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/ba07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("myService");
	service.doSome();
	// 对于销毁方法的执行，有两个条件：
	// 1)当前的Bean需要是singleton的
	// 2)要手工关闭容器
	((ClassPathXmlApplicationContext)ac).close();
}
```

*输出信息*
```
Step1：执行无参构造器
Step2：执行 setter
Step2：执行 setter
Step3：获取到 bean 的 id = myService
Step4：获取到 BeanFactory 容器
Step5：MyBeanPostProcessor - 执行 before() 方法
Step6：Bean 初始化完毕了
Step7：初始化完毕之后
Step8：MyBeanPostProcessor - 执行 after() 方法
Step9：执行 doSome() 方法
Step10：实现接口的销毁之前
Step11：销毁之前
```',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000540s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001263s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000564s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000345s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001186s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000343s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=247,`p_id`=2,`title`='Spring\r',`content`='# Spring\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## IOC（控制反转）\r\n### 概念\r\n控制反转（IOC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 创建对象。\r\n\r\nIoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。\r\n- 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代\r\n码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。\r\n- 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。\r\n\r\n依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。\r\n\r\n依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。\r\n\r\n>以获取对象的方式来进行比较\r\n\r\n- 传统的方式\r\n\r\n通过 new 关键字主动创建一个对象\r\n\r\n相当于你自己去菜市场 new 了一只鸡，不过是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。\r\n\r\n- IOC方式\r\n\r\n对象的生命周期由 Spring 来管理，直接从 Spring 那里去获取一个对象。IOC 是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，现在交给了 Spring。\r\n\r\n相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。\r\n\r\n\r\n\r\n### 第一个 Spring 程序\r\n#### 传统的面向接口编程\r\n经过以下例子可以看出，若接口（Service 层）变了，Test(View 层) 也的改，耦合度很高。\r\n\r\n*ISomeService.java - 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	ISomeService service = new SomeServiceImpl();\r\n	service.doSome();\r\n}\r\n```\r\n#### Spring 实现\r\n*applicationContext.mxl - Spring 的配置文件*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service，Spring 底层实际是做了 SomeServiceImpl myService = new SomeServiceImpl(); -->\r\n    <bean id=\"myService\" class=\"top.qingrang.service.SomeServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test02() {\r\n	// 创建容器对象，加载 Spring 配置文件，会从类路径下查找配置文件\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	ISomeService someService = (ISomeService)ac.getBean(\"myService\");\r\n	someService.doSome();\r\n}\r\n```\r\n\r\n从以上代码中已经看不到 `SomeServiceImpl` 这个实现类了，就做到了解耦。\r\n\r\n>FileSystemXmlApplicationContext\r\n\r\n```\r\n// 创建容器对象，加载 Spring 配置文件，会从项目的根下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"applicationContext.xml\");\r\n\r\n// 创建容器对象，加载 Spring 配置文件，会从当前文件系统的 D 盘根目录下查找配置文件\r\nApplicationContext ac = new FileSystemXmlApplicationContext(\"d:/applicationContext.xml\");\r\n```\r\n\r\n>BeanFactory 容器\r\n\r\n*Test.java*\r\n```\r\n@Test\r\npublic void test05() {\r\n	// 创建 BeanFactory 容器\r\n	BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\r\n	ISomeService service = (ISomeService) bf.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n\r\n>ApplicationContext 与 BeanFactory 容器的区别\r\n\r\n这两上容器对于其中 Bean 的创建时机不同：\r\n1. ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建\r\n - 缺点：占用系统资源（内存、CPU等）\r\n - 优点：响应速度快\r\n1. BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建\r\n - 缺点：相对来说，响应速度慢\r\n - 优点：不多占用系统资源\r\n\r\n### Bean 的装配\r\n#### 动态工厂 Bean\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n	}\r\n}\r\n```\r\n*ServiceFactory.java - service 工厂*\r\n```\r\npublic class ServiceFactory {\r\n	public ISomeService getSomeService() {\r\n		return new SomeServiceImpl();\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册动态工厂 -->\r\n    <bean id=\"factory\" class=\"top.qingrang.ba02.ServiceFactory\"/>\r\n\r\n    <!-- 注册 Service：动态工厂 Bean -->\r\n    <bean id=\"myService\" factory-bean=\"factory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test02() {\r\n	String resource = \"top/qingrang/ba02/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n}\r\n```\r\n#### 静态工厂 Bean\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service：静态工厂 Bean -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba03.ServiceFactory\" factory-method=\"getSomeService\"/>\r\n</beans>\r\n```\r\n#### 容器中 Bean 的作用域\r\n*applicationContext.mxl*\r\n```\r\n<bean id=\"myService\" class=\"top.qingrang.ba04.SomeServiceImpl\" scope=\"prototype\"/>\r\n```\r\n\r\n当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。\r\n1. singleton： 单例模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。该 Bean 是在容器被创建时即被装配好了。 默认为单例的。\r\n1. prototype： 原型模式。即每次使用 getBean 方法获取的同一个 `<bean />` 的实例都是一个新的实例。Bean 实例是在代码中使用该 Bean 实例时才进行装配的。\r\n1. request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。\r\n1. session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。\r\n1. global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session 是等同的。\r\n\r\n对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。\r\n\r\n\r\n#### Bean 后处理器\r\nBean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。由于该 Bean 是由其它 Bean 自动调用执行，不是程序员手工调用，故此 Bean 无须 id 属性。\r\n\r\n需要做的是，在 Bean 后处理器类方法中，只要对 Bean 类与 Bean 类中的方法进行判断，就可实现对指定的 Bean 的指定方法进行功能扩展与增强。方法返回的 Bean 对象，即是增强过的对象。就是设计模式中的代理模式。\r\n\r\n代码中需要自定义 Bean 后处理器类。该类就是实现了接口 BeanPostProcessor 的类。该接口中包含两个方法，分别在目标 Bean 初始化完毕之前与之后执行。它们的返回值为：功能被扩展或增强后的 Bean 对象。\r\n\r\nBean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean 被初始化完毕。所以 Bean 后处理器中两个方法的执行，是在这个方法之前之后执行。 这个方法在后面将会讲到。\r\n\r\n`public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之前由容器自动调用。\r\n\r\n`public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException`\r\n\r\n该方法会在目标 Bean 初始化完毕之后由容器自动调用。它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。\r\n\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	String doSome();\r\n	String doOther();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public String doSome() {\r\n		System.out.println(\"执行doSome()方法\");\r\n		return \"doSome() - abc\";\r\n	}\r\n	\r\n	@Override\r\n	public String doOther() {\r\n		System.out.println(\"执行doOther()方法\");\r\n		return \"doOther() - def\";\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - 自定义 Bean 后处理器类*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n\r\n	// bean：表示当前正在进行初始化的Bean对象\r\n	// beanName：表示当前正在进行初始化的Bean对象的id\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- before() ---方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {\r\n		System.out.println(\"执行 ---- after() ---方法\");\r\n		//判断 SomeServiceImpl 对象\r\n		if (\"myService\".equals(beanName)) {\r\n			Object obj = Proxy.newProxyInstance(bean.getClass().getClassLoader(),\r\n					bean.getClass().getInterfaces(),\r\n					new InvocationHandler() {\r\n						@Override\r\n						public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n							Object invoke = method.invoke(bean, args);\r\n							//判断具体方法\r\n							if (\"doSome\".equals(method.getName())) {\r\n								return ((String) invoke).toUpperCase();\r\n							}\r\n							return invoke;\r\n						}\r\n					});\r\n			return obj;\r\n		}\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册 Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n    <bean id=\"myService2\" class=\"top.qingrang.ba05.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册 Bean 后处理器 -->\r\n    <bean class=\"top.qingrang.ba05.MyBeanPostProcessor\"/>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	String resource = \"top/qingrang/ba05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	System.out.println(service.doSome());\r\n	System.out.println(service.doOther());\r\n\r\n	System.out.println(\"======================\");\r\n\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"myService2\");\r\n	System.out.println(service2.doSome());\r\n	System.out.println(service2.doOther());\r\n}\r\n```\r\n\r\n*输出结果*\r\n```\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行 ---- before() ---方法\r\n执行 ---- after() ---方法\r\n执行doSome()方法\r\nDOSOME() - ABC\r\n执行doOther()方法\r\ndoOther() - def\r\n======================\r\n执行doSome()方法\r\ndoSome() - abc\r\n执行doOther()方法\r\ndoOther() - def\r\n```\r\n\r\n\r\n#### Bean 的生命周期\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	void doSome();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService, BeanNameAware, BeanFactoryAware, InitializingBean, DisposableBean {\r\n	private String adao;\r\n	private String bdao;\r\n\r\n	public void setAdao(String adao) {\r\n		this.adao = adao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public void setBdao(String bdao) {\r\n		this.bdao = bdao;\r\n		System.out.println(\"Step2：执行 setter\");\r\n	}\r\n\r\n	public SomeServiceImpl() {\r\n		System.out.println(\"Step1：执行无参构造器\");\r\n	}\r\n\r\n	@Override\r\n	public void doSome() {\r\n		System.out.println(\"Step9：执行 doSome() 方法\");\r\n	}\r\n\r\n	public void setUp() {\r\n		System.out.println(\"Step7：初始化完毕之后\");\r\n	}\r\n\r\n	public void tearDown() {\r\n		System.out.println(\"Step11：销毁之前\");\r\n	}\r\n\r\n	@Override\r\n	public void setBeanName(String name) {\r\n		System.out.println(\"Step3：获取到 bean 的 id = \" + name);\r\n	}\r\n\r\n	@Override\r\n	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\r\n		System.out.println(\"Step4：获取到 BeanFactory 容器\");\r\n	}\r\n\r\n	@Override\r\n	public void afterPropertiesSet() throws Exception {\r\n		System.out.println(\"Step6：Bean 初始化完毕了\");\r\n	}\r\n\r\n	@Override\r\n	public void destroy() throws Exception {\r\n		System.out.println(\"Step10：实现接口的销毁之前\");\r\n	}\r\n}\r\n```\r\n*MyBeanPostProcessor.java - Bean 后处理器*\r\n```\r\npublic class MyBeanPostProcessor implements BeanPostProcessor {\r\n	@Override\r\n	public Object postProcessBeforeInitialization(Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step5：MyBeanPostProcessor - 执行 before() 方法\");\r\n		return bean;\r\n	}\r\n\r\n	@Override\r\n	public Object postProcessAfterInitialization(final Object bean, String beanName)\r\n			throws BeansException {\r\n		System.out.println(\"Step8：MyBeanPostProcessor - 执行 after() 方法\");\r\n		return bean;\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册Service -->\r\n    <bean id=\"myService\" class=\"top.qingrang.ba07.SomeServiceImpl\"\r\n    		init-method=\"setUp\" destroy-method=\"tearDown\">\r\n    	<property name=\"adao\" value=\"aaa\"/>\r\n    	<property name=\"bdao\" value=\"bbb\"/>\r\n   	</bean>\r\n\r\n   	<bean class=\"top.qingrang.ba07.MyBeanPostProcessor\"/>\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/ba07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"myService\");\r\n	service.doSome();\r\n	// 对于销毁方法的执行，有两个条件：\r\n	// 1)当前的Bean需要是singleton的\r\n	// 2)要手工关闭容器\r\n	((ClassPathXmlApplicationContext)ac).close();\r\n}\r\n```\r\n\r\n*输出信息*\r\n```\r\nStep1：执行无参构造器\r\nStep2：执行 setter\r\nStep2：执行 setter\r\nStep3：获取到 bean 的 id = myService\r\nStep4：获取到 BeanFactory 容器\r\nStep5：MyBeanPostProcessor - 执行 before() 方法\r\nStep6：Bean 初始化完毕了\r\nStep7：初始化完毕之后\r\nStep8：MyBeanPostProcessor - 执行 after() 方法\r\nStep9：执行 doSome() 方法\r\nStep10：实现接口的销毁之前\r\nStep11：销毁之前\r\n```',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 247 [ RunTime:0.000863s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001160s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000342s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000946s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000307s ]
---------------------------------------------------------------
[ 2018-11-13T22:36:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/247.html
[ info ] qingrang.top/daily/admin/note/shownote/id/247.html [运行时间：0.051691s][吞吐率：19.35req/s] [内存消耗：2,012.63kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/247.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '247',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000436s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001448s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 247 LIMIT 1 [ RunTime:0.000488s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000877s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000282s ]
---------------------------------------------------------------
[ 2018-11-13T22:37:00+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.078637s][吞吐率：12.72req/s] [内存消耗：2,375.02kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000645s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001552s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002186s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000557s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001136s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000721s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000502s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001055s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000455s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000414s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000352s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000387s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000938s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000235s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001234s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000676s ]
---------------------------------------------------------------
[ 2018-11-13T22:37:12+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.094945s][吞吐率：10.53req/s] [内存消耗：2,130.66kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000498s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001389s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000658s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000942s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000469s ]
---------------------------------------------------------------
[ 2018-11-13T22:37:18+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/243.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/243.html [运行时间：0.083200s][吞吐率：12.02req/s] [内存消耗：2,437.43kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '107200',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```
## 查询缓存
查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。

MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。

myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。

无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。

但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

#### 一级查询缓存的存在性证明
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。
#### 从缓存读取数据的依据是 Sql 的 id
缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。

*MyTest.java*
```
@Test
public void test02() {
	//使用了不同的查询语句，查询相同的记录 id
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 增删改对一级查询缓存的影响
增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。

*MyTest.java*
```
@Test
public void test03() {
	Country country = dao.selectCountryById(2);
	System.out.println(country);

	// 增删改操作都会清空一级缓存，无论是否提交
	dao.insertCountry(new Country(3,"USA"));

	Country country2 = dao.selectCountryById(2);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: 3(Integer), USA(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]
```

### 内置二级缓存
使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。

#### 开启内置的二级缓存步骤
1）对实体进行序列化
2）在映射文件中添加 `<cache/>` 标签

*Country.java - 实例化*
```
public class Country implements Serializable { }
```

*mybatis.xml - 添加 <cache/> 标签*
```
<mapper namespace="top.qingrang.sql_session_cache.dao.ICountryDao">
	<cache/>
</mapper>
```

*MyTest.java*
```
@Test
public void test01() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	//关闭 sqlSession，一级缓存会刷新
	sqlSession.close();
	//二级缓存会伴随整个生命周期
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
#### 增删改对二级缓存的影响
1. 增删改同样也会清空二级缓存
2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除
3. 从 DB 中进行 select 查询的条件是：
1)缓存中根本就不存在这个 key
2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null

*MyTest.java*
```
@Test
public void test02() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById2(2);
	System.out.println(country);
	sqlSession.close();
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	dao.insertCountry(new Country("Japan"));
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: null, Japan(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 二级缓存的配置
为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。

`<cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/>`

- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：
- FIFO： First In First Out， 先进先出
- LRU： Least Recently Used，未被使用时间最长的
- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。
- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。
- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。

#### 二级缓存的关闭
二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。
##### 全局关闭
所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。
```
<settings>
    <setting name="cacheEnabled" value="false" />
</settings>
```
##### 局部关闭
整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。

`useCache="false"`

```
<select id="selectCountryById" useCache="false" resultType="Country">
		select cid,cname from country where cid=#{xxx}
	</select>
```

### ehcache 二级查询缓存
使用 ehcache 二级缓存，实体类无需实现序列化接口。

将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`

*pom.xml*
```
<!--ehcache 相关包 -->
<dependency>
  <groupId>net.sf.ehcache</groupId>
  <artifactId>ehcache</artifactId>
  <version>2.7.5</version>
</dependency>
<dependency>
  <groupId>org.mybatis.caches</groupId>
  <artifactId>mybatis-ehcache</artifactId>
  <version>1.1.0</version>
</dependency>
```

*mapper.xml*
```
<mapper namespace="com.bjpowernode.dao.IStudentDao">
	<cache type="org.mybatis.caches.ehcache.EhcacheCache">
		<property name="timeToIdleSeconds" value="60"/>
	</cache>
</mapper>
```



## 注解
mybatis 的注解，主要是用于替换映射文件。而映射文件中无非存放着增、删、改、查的 SQL 映射标签。所以， mybatis 注解，就是要替换映射文件中的 SQL 标签。mybatis 官方文档中指出，若要真正想发挥 mybatis 功能，还是要用映射文件。即 mybatis官方并不建议通过注解方式来使用 mybatis。

由于 MyBatis 注解替换的是映射文件，所以这里就不需要映射文件了，将其直接删除。由于没有了映射文件，所以主配置文件中不能使用 `<mapper/>` 注册 mapper 的位置了。需要使用`<package/>` 标签。

*mybatis.xml*
```
<mappers>
	<package name="com.bjpowernode.dao"/>
</mappers>

```

*IStudentDao.java*
```
public interface IStudentDao {
	@Insert(value={"insert into student(name,age,score) values(#{name}, #{age}, #{score})"})
	void insertStudent(Student student);
	
	@Insert("insert into student(name,age,score) values(#{name}, #{age}, #{score})")
	@SelectKey(statement="select @@identity", resultType=int.class, keyProperty="id", before=false)
	void insertStudentCacheId(Student student);
	
	@Delete(value="delete from student where id=#{xxx}")
	void deleteStudentById(int id);
	
	@Update("update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}")
	void updateStudent(Student student);
	
	@Select("select id,name,age,score from student")
	List<Student> selectAllStudents();
	
	@Select("select id,name,age,score from student where id=#{jjj}")
	Student selectStudentById(int id);
	
	@Select("select id,name,age,score from student where name like \'%\' #{xxx} \'%\'")
	List<Student> selectStudentsByName(String name);
}
```',
  'groups' => 'Java',
  'showsel' => '0',
  'showse2' => '1',
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000568s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001278s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000786s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000356s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000939s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000365s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=243,`p_id`=2,`title`='Mybatis\r',`content`='# Mybatis\r\n[TOC]\r\n## Mybatis 体系结构和工作原理\r\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\r\n## 第一个 MyBaits 程序\r\n### 主配置文件详解\r\n1. 注册数据库连接四要素属性文件\r\n`<properties resource=\"jdbc_mysql.properties\"/>`\r\n1. 定义类型别名\r\n```\r\n<typeAliases>\r\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\r\n	<package name=\"top.qingrang.beans\"/>\r\n</typeAliases>\r\n```\r\n1. 配置运行环境\r\n```\r\n<environments default=\"XXX2\">\r\n	<!-- 环境，eg：上线环境 -->\r\n	<environment id=\"XXX1\">\r\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n		<transactionManager type=\"JDBC\"/>\r\n		<!-- 数据源，数据库连接池 -->\r\n		<dataSource type=\"POOLED\">\r\n			<!-- 数据库连接四要素 -->\r\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n			<property name=\"url\" value=\"${jdbc.url}\"/>\r\n			<property name=\"username\" value=\"${jdbc.user}\"/>\r\n			<property name=\"password\" value=\"${jdbc.password}\"/>\r\n		</dataSource>\r\n	</environment>\r\n\r\n	<!-- 另一个环境，eg：本地测试的环境 -->\r\n	<environment id=\"XXX2\">\r\n		...\r\n	</environment>\r\n</environments>\r\n```\r\n1. 注册映射文件\r\n```\r\n<mappers>\r\n	<!-- 配置文件路径 -->\r\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n>问题？\r\n\r\n1. environments 下为什么可以配置多个 environment？\r\n方便切换运行环境，只需要改变 `default` 即可\r\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\r\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\r\n1. 什么是数据库连接池？\r\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\r\n\r\n*mybatis.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 注册数据库连接四要素属性文件 -->\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 定义类型别名 -->\r\n    <typeAliases>\r\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\r\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\r\n        <package name=\"top.qingrang.beans\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\r\n    <environments default=\"onlineEM\">\r\n        <!-- 上线以后的环境 -->\r\n        <environment id=\"onlineEM\">\r\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n            <transactionManager type=\"JDBC\"/>\r\n            <!-- 数据源，数据库连接池 -->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- 数据库连接四要素 -->\r\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n                <property name=\"url\" value=\"${jdbc.url}\"/>\r\n                <property name=\"username\" value=\"${jdbc.user}\"/>\r\n                <property name=\"password\" value=\"${jdbc.password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n        <!-- 本地测试的环境 -->\r\n        <environment id=\"testEM\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"111\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <!-- 注册映射文件 -->\r\n    <mappers>\r\n        <!-- 配置文件路径 -->\r\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n    </mappers>\r\n\r\n</configuration>\r\n```\r\n### 核心代码\r\n利用 sqlSession 对象，执行相关操作。\r\n```\r\nprivate SqlSession sqlSession;\r\n\r\n@Override\r\npublic void insertStu(Student student) {\r\n	try {\r\n		// 1.加载主配置文件\r\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n		// 2.创建 SqlSessionFactory 对象\r\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n		// 3.创建 sqlSession 对象\r\n		sqlSession = sqlSessionFactory.openSession();\r\n		// 4.执行相关操作\r\n		sqlSession.insert(\"insertStudent\", student);\r\n		// 5.提交\r\n		sqlSession.commit();\r\n	} catch (IOException e) {\r\n		e.printStackTrace();\r\n	} finally {\r\n		if(sqlSession != null) {\r\n			// 6.关闭\r\n			sqlSession.close();\r\n		}\r\n	}\r\n}\r\n```\r\n### 封装 MyBatis 工具类\r\n*MyBatisUtils.java*\r\n```\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * MyBatis 工具类\r\n */\r\npublic class MyBatisUtils {\r\n\r\n	private static SqlSessionFactory sqlSessionFactory;\r\n\r\n	/**\r\n	 * 得到 SqlSession 对象\r\n	 */\r\n	public static SqlSession getSqlSession() {\r\n		try {\r\n			// 1.加载主配置文件\r\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n			if (sqlSessionFactory == null) {\r\n				// 2.创建 SqlSessionFactory 对象\r\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n			}\r\n			// 3.返回 SqlSession 对象\r\n			return sqlSessionFactory.openSession();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return null;\r\n	}\r\n}\r\n```\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n### 源码分析\r\n#### 输入流的关闭\r\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的创建\r\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\r\n\r\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\r\n\r\n>dirty 详解\r\n\r\ntrue：和数据库中的数据不一致(脏)\r\nfalse：和数据库中的数据一致(不脏)\r\n\r\n#### 增删改的执行\r\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\r\n\r\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\r\n\r\n#### SqlSession 的提交 commit()\r\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的关闭\r\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 单表的 CURD 操作\r\n### 常用的增删改查\r\n*mapper.xml*\r\n```\r\n<!-- parameterType 可以省略 -->\r\n<insert id=\"insertStudent\" parameterType=\"Student\">\r\n	<!-- 这里的 #{} 是属性 -->\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<!-- 插入后用新 id 初始化被插入对象 -->\r\n<insert id=\"insertStudentCacheId\">\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\r\n		select @@identity\r\n	</selectKey>\r\n</insert>\r\n\r\n<delete id=\"deleteStudentById\">\r\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\r\n	DELETE FROM student WHERE id = #{id}\r\n</delete>\r\n\r\n<update id=\"updateStudent\">\r\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\r\n</update>\r\n\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n\r\n<!-- 模糊查询 -->\r\n<select id=\"selectStudentsByName\" resultType=\"Student\">\r\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\r\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\r\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\r\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\r\n</select>\r\n```\r\n\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void insertStudentCacheId(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.insert(\"insertStudentCacheId\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void deleteStudentById(int id) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.delete(\"deleteStudentById\", id);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.update(\"updateStudent\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectAllStudents\");\r\n			//查询不需要 sqlSession.commit();\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n\r\n	@Override\r\n	public Map<String, Object> selectAllStudentsMap() {\r\n		Map<String, Object> map = new HashMap<>();\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return map;\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		Student student = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			student = sqlSession.selectOne(\"selectStudentById\", id);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return student;\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectStudentsByName(String name) {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n}\r\n```\r\n\r\n### 属性名与查询字段名不相同\r\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\r\n```\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n```\r\n#### 解决方案一：查询字段使用别名\r\n```\r\n<insert id=\"insertStudent\">\r\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n#### 解决方案二：使用结果映射 resultMap\r\n```\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"tid\" property=\"id\"/>\r\n	<result column=\"tname\" property=\"name\"/>\r\n 	<result column=\"tage\" property=\"age\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n### Mapper 动态代理\r\n#### 修改映射文件的 namespace 属性值\r\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\r\n通过接口名即可定位到映射文件 mapper.\r\n#### 删除 IStudentDaoImpl 实现类\r\n#### 修改 MyText.java 测试方法\r\n*MyTex.java*\r\n```\r\npublic class MyTest {\r\n	private IStudentDao dao;\r\n	private SqlSession sqlSession;\r\n\r\n	@Before\r\n	public void before() {\r\n		sqlSession = MyBatisUtils.getSqlSession();\r\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n	}\r\n\r\n	@After\r\n	public void after() {\r\n		if(sqlSession != null) {\r\n			sqlSession.close();\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudent() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudent(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudentCacheId() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudentCacheId(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testDeleteStudentById() {\r\n		dao.deleteStudentById(12);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testUpdateStudent() {\r\n		Student student = new Student(\"张三\", 25, 93.5);\r\n		student.setId(15);\r\n		dao.updateStudent(student);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testSelectAllStudents() {\r\n		List<Student> students = dao.selectAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentById() {\r\n		Student student = dao.selectStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentsByName() {\r\n		List<Student> students = dao.selectStudentsByName(\"张\");\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n}\r\n```\r\n##### Dao 对象的获取\r\n```\r\nprivate IStudentDao dao;\r\nprivate SqlSession sqlSession;\r\n\r\n@Before\r\npublic void before() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n}\r\n```\r\n##### sqlSession 的关闭\r\n```\r\n@After\r\npublic void after() {\r\n	if(sqlSession != null) {\r\n		sqlSession.close();\r\n	}\r\n}\r\n```\r\n##### sqlSession 的提交\r\n```\r\n@Test\r\npublic void testDeleteStudentById() {\r\n	dao.deleteStudentById(12);\r\n	sqlSession.commit();\r\n}\r\n```\r\n\r\n\r\n### 多条件查询\r\n#### 根据 Map 查询\r\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition(Map<String, Object> map);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 多条件查询 -->\r\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\r\n		and age > #{ageCon}\r\n		and score > #{stu.score}  -- 对象.属性\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition() {\r\n	Student stu = new Student(\"田七\", 27, 95);\r\n\r\n	Map<String, Object> map = new HashMap<String, Object>();\r\n	map.put(\"nameCon\", \"张\");\r\n	map.put(\"ageCon\", 23);\r\n	map.put(\"stu\", stu);	//放入了学生对象\r\n\r\n	List<Student> students = dao.selectStudentsByCondition(map);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### 使用索引号\r\n>需求：找出姓张的，年龄大于 25 的\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition2(String name,int age);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 使用索引号 -->\r\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{0} \'%\' --0,1 索引号\r\n		and age > #{1}\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition2() {\r\n	//参数直接对应 mapper.xml 中的索引号\r\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n### 总结：#{} 中可以放什么内容？\r\n1. 参数对象的属性\r\n2. 随意内容，此时的#{}是个占位符\r\n3. 参数为map时的key\r\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\r\n5. 参数的索引号\r\n\r\n### 动态 SQL\r\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\r\n\r\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\r\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\r\n\r\n#### if 和 where\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByWhere(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<if test=\"name != null and name != \'\'\">\r\n			and name like \'%\' #{name} \'%\'\r\n		</if>\r\n		<if test=\"age > 0\">\r\n			and age > #{age}\r\n		</if>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByWhere() {\r\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\r\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\r\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\r\n\r\n	List<Student> students = dao.selectStudentsByWhere(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n#### choose\r\n**类似于 switch case ，且每个 case 都自带了 break.**\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByChoose(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\r\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<choose>\r\n			<when test=\"name != null and name !=\'\'\">\r\n				and name like \'%\' #{name} \'%\'\r\n			</when>\r\n			<when test=\"age > 0\">\r\n				and age > #{age}\r\n			</when>\r\n			<otherwise>\r\n				1 = 2\r\n			</otherwise>\r\n		</choose>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByChoose() {\r\n	// Student stu = new Student(\"张\", 23, 0);\r\n	// Student stu = new Student(\"\", 23, 0);\r\n	Student stu = new Student(\"\", 0, 0);\r\n\r\n	List<Student> students = dao.selectStudentsByChoose(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历数组\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsByForeach(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为基本类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach2(List<Integer> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach2() {\r\n	List<Integer> ids = new ArrayList<>();\r\n	ids.add(1);\r\n	ids.add(3);\r\n	List<Student> students = dao.selectStudentsByForeach2(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为自定义类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach3(List<Student> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\r\n            #{stu.id}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach3() {\r\n	Student stu1 = new Student();\r\n	stu1.setId(1);\r\n	Student stu2 = new Student();\r\n	stu2.setId(3);\r\n	List<Student> stus = new ArrayList<>();\r\n	stus.add(stu1);\r\n	stus.add(stu2);\r\n	List<Student> students = dao.selectStudentsByForeach3(stus);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <sql/>标签\r\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\r\n\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsBySqlFragment(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\r\n    select <include refid=\"selectColumns\"/> -- sql 片段\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\r\n<sql id=\"selectColumns\">\r\n    id,name,age,score\r\n</sql>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsBySqlFragment() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n## 关联关系查询\r\n### 一对多关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	// 关联属性\r\n	private Set<Minister> ministers;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Minister> getMinisters() {\r\n		return ministers;\r\n	}\r\n	public void setMinisters(Set<Minister> ministers) {\r\n		this.ministers = ministers;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\r\n				+ ministers + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<!--多表连接查询语句-->\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname,mid,mname\r\n    from country,minister\r\n    where countryId=cid and cname=#{cname}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\r\n    <collection property=\"ministers\" ofType=\"Minister\">\r\n        <id column=\"mid\" property=\"mid\"/>\r\n        <result column=\"mname\" property=\"mname\"/>\r\n    </collection>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname from country where cname=#{xxx}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <collection property=\"ministers\" \r\n                ofType=\"Minister\"\r\n                select=\"selectMinisterByCountry\"\r\n                column=\"cid\"/>\r\n</resultMap>\r\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\r\n    select mid,mname from minister where countryId=#{ooo}\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n\r\n\r\n### 多对一关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	private Country country;	//关联属性\r\n\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	public Country getCountry() { return country; }\r\n	public void setCountry(Country country) { this.country = country; }\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*IMinisterDao*\r\n```\r\nMinister selectMinisterById(int mid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,cid,cname\r\n    from minister, country\r\n    where countryId=cid and mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\" javaType=\"Country\">\r\n        <id column=\"cid\" property=\"cid\"/>\r\n        <result column=\"cname\" property=\"cname\"/>\r\n    </association>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void selectMinisterById() {\r\n	Minister minister = dao.selectMinisterById(2);\r\n	System.out.println(minister);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,countryId from minister where mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\"\r\n                 javaType=\"Country\"\r\n                 select=\"selectCountryById\"\r\n                 column=\"countryId\"/>\r\n</resultMap>\r\n<select id=\"selectCountryById\" resultType=\"Country\">\r\n    select cid,cname from country where cid=#{ooo}\r\n</select>\r\n```\r\n\r\n\r\n\r\n### 自关联查询\r\n类似于目录的递归。\r\n#### 以一对多方式处理\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private Set<NewsLabel> children;\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public Set<NewsLabel> getChildren() {\r\n		return children;\r\n	}\r\n	public void setChildren(Set<NewsLabel> children) {\r\n		this.children = children;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\r\n				+ children + \"]\";\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目的所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nList<NewsLabel> selectChildrenByParent(int pid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\"\r\n				ofType=\"NewsLabel\"\r\n				select=\"selectChildrenByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\r\n	for (NewsLabel newsLabel : children) {\r\n		System.out.println(newsLabel);\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目及其所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where id=#{xxx}\r\n</select>\r\n\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\" \r\n				ofType=\"NewsLabel\"\r\n				select=\"selectNewslabelByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{ooo}\r\n</select>\r\n\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n#### 以多对一方式处理\r\n>需求：查询所有栏目及其父辈栏目\r\n\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private NewsLabel parent;   // 父栏目\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public NewsLabel getParent() {\r\n		return parent;\r\n	}\r\n	public void setParent(NewsLabel parent) {\r\n		this.parent = parent;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name,pid from newslabel where id=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<association property=\"parent\" \r\n				 javaType=\"NewsLabel\"\r\n				 select=\"selectNewsLabelById\"\r\n				 column=\"pid\"/>\r\n</resultMap>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n\r\n### 多对多关联查询\r\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\r\n>实体类\r\n\r\n*Course.java*\r\n```\r\npublic class Course {\r\n	private Integer cid;\r\n	private String cname;\r\n	private Set<Student> students;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Student> getStudents() {\r\n		return students;\r\n	}\r\n	public void setStudents(Set<Student> students) {\r\n		this.students = students;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private Integer sid;\r\n	private String sname;\r\n	private Set<Course> courses;\r\n	public Integer getSid() {\r\n		return sid;\r\n	}\r\n	public void setSid(Integer sid) {\r\n		this.sid = sid;\r\n	}\r\n	public String getSname() {\r\n		return sname;\r\n	}\r\n	public void setSname(String sname) {\r\n		this.sname = sname;\r\n	}\r\n	public Set<Course> getCourses() {\r\n		return courses;\r\n	}\r\n	public void setCourses(Set<Course> courses) {\r\n		this.courses = courses;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\r\n				+ courses + \"]\";\r\n	}\r\n}\r\n```\r\n>Dao\r\n\r\n*IStudentDao.java*\r\n```\r\nStudent selectStudentById(int sid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select sid,sname,cid,cname\r\n	from student,middle,course\r\n	where sid=studentId and cid=courseId and sid=#{xxx}\r\n</select>\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"sid\" property=\"sid\"/>\r\n	<result column=\"sname\" property=\"sname\"/>\r\n	<collection property=\"courses\" ofType=\"Course\">\r\n		<id column=\"cid\" property=\"cid\"/>\r\n		<result column=\"cname\" property=\"cname\"/>\r\n	</collection>\r\n</resultMap>\r\n```\r\n>Test\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Student student = dao.selectStudentById(1);\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n### 延迟加载\r\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\r\n\r\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\r\n\r\n#### 关联对象加载时机\r\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\r\n\r\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\r\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\r\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\r\n\r\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\r\n\r\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\r\n\r\n#### 延迟加载的总开关\r\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\r\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\r\n\r\n*mybatis.xml*\r\n```\r\n<configuration>\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 设置整个应用所使用的常量 -->\r\n    <settings>\r\n        <!-- 延迟加载的总开关 -->\r\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    </settings>\r\n\r\n    <typeAliases>\r\n		...\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n\r\n#### 直接加载\r\n*mybatis.xml*\r\n```\r\n<settings>\r\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\r\n</settings>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\r\n	System.out.println(country.getCname());\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 直接加载（√）：查询 country，查询 minister ---\r\nChina\r\nTotal：3\r\n```\r\n\r\n#### 侵入式延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 侵入式延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 侵入式延迟加载（X）：查询 country ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nChina\r\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\r\nTotal：3\r\n```\r\n#### 深度延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 深度延迟加载（X）：查询 country ---\r\nChina\r\n---- 深度延迟加载（X）：访问主加载对象 ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nTotal：3\r\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\r\n```\r\n## 查询缓存\r\n查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。\r\n\r\nMyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。\r\n\r\nmyBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。\r\n\r\n无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。\r\n\r\n但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n\r\n#### 一级查询缓存的存在性证明\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	Country country2 = dao.selectCountryById(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\nCountry [cid=1, cname=China]\r\n```\r\n只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。\r\n#### 从缓存读取数据的依据是 Sql 的 id\r\n缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test02() {\r\n	//使用了不同的查询语句，查询相同的记录 id\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	\r\n	Country country2 = dao.selectCountryById2(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 增删改对一级查询缓存的影响\r\n增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test03() {\r\n	Country country = dao.selectCountryById(2);\r\n	System.out.println(country);\r\n\r\n	// 增删改操作都会清空一级缓存，无论是否提交\r\n	dao.insertCountry(new Country(3,\"USA\"));\r\n\r\n	Country country2 = dao.selectCountryById(2);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 2(Integer)\r\nCountry [cid=2, cname=England]\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\r\n[DEBUG] ==> Parameters: 3(Integer), USA(String)\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 2(Integer)\r\nCountry [cid=2, cname=England]\r\n```\r\n\r\n### 内置二级缓存\r\n使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。\r\n\r\n#### 开启内置的二级缓存步骤\r\n1）对实体进行序列化\r\n2）在映射文件中添加 `<cache/>` 标签\r\n\r\n*Country.java - 实例化*\r\n```\r\npublic class Country implements Serializable { }\r\n```\r\n\r\n*mybatis.xml - 添加 <cache/> 标签*\r\n```\r\n<mapper namespace=\"top.qingrang.sql_session_cache.dao.ICountryDao\">\r\n	<cache/>\r\n</mapper>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	//关闭 sqlSession，一级缓存会刷新\r\n	sqlSession.close();\r\n	//二级缓存会伴随整个生命周期\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country2 = dao.selectCountryById(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 增删改对二级缓存的影响\r\n1. 增删改同样也会清空二级缓存\r\n2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除\r\n3. 从 DB 中进行 select 查询的条件是：\r\n1)缓存中根本就不存在这个 key\r\n2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test02() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country = dao.selectCountryById2(2);\r\n	System.out.println(country);\r\n	sqlSession.close();\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	dao.insertCountry(new Country(\"Japan\"));\r\n	Country country2 = dao.selectCountryById2(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\r\n[DEBUG] ==> Parameters: null, Japan(String)\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 二级缓存的配置\r\n为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。\r\n\r\n`<cache eviction=\"FIFO\" flushInterval=\"10800000\" readOnly=\"true\" size=\"512\"/>`\r\n\r\n- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：\r\n- FIFO： First In First Out， 先进先出\r\n- LRU： Least Recently Used，未被使用时间最长的\r\n- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。\r\n- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。\r\n- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。\r\n\r\n#### 二级缓存的关闭\r\n二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。\r\n##### 全局关闭\r\n所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。\r\n```\r\n<settings>\r\n    <setting name=\"cacheEnabled\" value=\"false\" />\r\n</settings>\r\n```\r\n##### 局部关闭\r\n整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。\r\n\r\n`useCache=\"false\"`\r\n\r\n```\r\n<select id=\"selectCountryById\" useCache=\"false\" resultType=\"Country\">\r\n		select cid,cname from country where cid=#{xxx}\r\n	</select>\r\n```\r\n\r\n### ehcache 二级查询缓存\r\n使用 ehcache 二级缓存，实体类无需实现序列化接口。\r\n\r\n将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`\r\n\r\n*pom.xml*\r\n```\r\n<!--ehcache 相关包 -->\r\n<dependency>\r\n  <groupId>net.sf.ehcache</groupId>\r\n  <artifactId>ehcache</artifactId>\r\n  <version>2.7.5</version>\r\n</dependency>\r\n<dependency>\r\n  <groupId>org.mybatis.caches</groupId>\r\n  <artifactId>mybatis-ehcache</artifactId>\r\n  <version>1.1.0</version>\r\n</dependency>\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<mapper namespace=\"com.bjpowernode.dao.IStudentDao\">\r\n	<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\">\r\n		<property name=\"timeToIdleSeconds\" value=\"60\"/>\r\n	</cache>\r\n</mapper>\r\n```\r\n\r\n\r\n\r\n## 注解\r\nmybatis 的注解，主要是用于替换映射文件。而映射文件中无非存放着增、删、改、查的 SQL 映射标签。所以， mybatis 注解，就是要替换映射文件中的 SQL 标签。mybatis 官方文档中指出，若要真正想发挥 mybatis 功能，还是要用映射文件。即 mybatis官方并不建议通过注解方式来使用 mybatis。\r\n\r\n由于 MyBatis 注解替换的是映射文件，所以这里就不需要映射文件了，将其直接删除。由于没有了映射文件，所以主配置文件中不能使用 `<mapper/>` 注册 mapper 的位置了。需要使用`<package/>` 标签。\r\n\r\n*mybatis.xml*\r\n```\r\n<mappers>\r\n	<package name=\"com.bjpowernode.dao\"/>\r\n</mappers>\r\n\r\n```\r\n\r\n*IStudentDao.java*\r\n```\r\npublic interface IStudentDao {\r\n	@Insert(value={\"insert into student(name,age,score) values(#{name}, #{age}, #{score})\"})\r\n	void insertStudent(Student student);\r\n	\r\n	@Insert(\"insert into student(name,age,score) values(#{name}, #{age}, #{score})\")\r\n	@SelectKey(statement=\"select @@identity\", resultType=int.class, keyProperty=\"id\", before=false)\r\n	void insertStudentCacheId(Student student);\r\n	\r\n	@Delete(value=\"delete from student where id=#{xxx}\")\r\n	void deleteStudentById(int id);\r\n	\r\n	@Update(\"update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\")\r\n	void updateStudent(Student student);\r\n	\r\n	@Select(\"select id,name,age,score from student\")\r\n	List<Student> selectAllStudents();\r\n	\r\n	@Select(\"select id,name,age,score from student where id=#{jjj}\")\r\n	Student selectStudentById(int id);\r\n	\r\n	@Select(\"select id,name,age,score from student where name like \'%\' #{xxx} \'%\'\")\r\n	List<Student> selectStudentsByName(String name);\r\n}\r\n```',`groups`='Java',`is_show`=0,`publish`=1,`summary`=''  WHERE  `id` = 243 [ RunTime:0.001891s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001118s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000349s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001014s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=19  WHERE  `groups` = 'Java' [ RunTime:0.000343s ]
---------------------------------------------------------------
[ 2018-11-13T22:37:19+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/243.html
[ info ] qingrang.top/daily/admin/note/shownote/id/243.html [运行时间：0.076150s][吞吐率：13.13req/s] [内存消耗：2,078.65kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000555s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001697s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000790s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000386s ]
---------------------------------------------------------------
[ 2018-11-13T22:37:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.075657s][吞吐率：13.22req/s] [内存消耗：2,319.36kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; Hm_lpvt_1769181352e9adc950166aada465644e=1542098176; PHPSESSID=h22836mi7br19o59rglfnkdc53',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000583s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001400s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001854s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000774s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001085s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000304s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000430s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001025s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000470s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000373s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001168s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000251s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001267s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000718s ]
---------------------------------------------------------------
[ 2018-11-13T22:45:18+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.040470s][吞吐率：24.71req/s] [内存消耗：1,339.90kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
