---------------------------------------------------------------
[ 2018-11-16T14:55:23+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.044701s][吞吐率：22.37req/s] [内存消耗：1,428.39kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-16T14:55:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.039167s][吞吐率：25.53req/s] [内存消耗：1,340.77kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-16T14:55:29+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.060322s][吞吐率：16.58req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001023s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.003080s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000551s ]
---------------------------------------------------------------
[ 2018-11-16T14:55:29+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.137705s][吞吐率：7.26req/s] [内存消耗：2,334.30kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000753s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002040s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.005378s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.001071s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001342s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000393s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000593s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001032s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000418s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000497s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000336s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001286s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000271s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001176s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000713s ]
---------------------------------------------------------------
[ 2018-11-16T14:55:33+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.063307s][吞吐率：15.80req/s] [内存消耗：2,061.96kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000663s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001436s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000709s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000914s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000398s ]
---------------------------------------------------------------
[ 2018-11-16T14:58:05+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.073091s][吞吐率：13.68req/s] [内存消耗：2,062.23kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000624s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001378s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000900s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000882s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000306s ]
---------------------------------------------------------------
[ 2018-11-16T15:07:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.058504s][吞吐率：17.09req/s] [内存消耗：2,113.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000734s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001785s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000715s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000908s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000311s ]
---------------------------------------------------------------
[ 2018-11-16T15:09:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.071219s][吞吐率：14.04req/s] [内存消耗：2,396.88kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '112849',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
---
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33

---






',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000636s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001478s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000627s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000339s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000988s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000421s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000284s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验：fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n========================================================================*/\r\n\r\n```\r\n\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n>不 sleep 的输出：\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n----------------------------------------------------------\r\n>sleep() 后的输出：\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n========================================================================*/\r\n```\r\n\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验：李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n### 信号量\r\n#### 信号量的概念\r\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\r\n1. 测试控制该资源的信号量。\r\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\r\n\r\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\r\n\r\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\r\n\r\n#### 信号量的创建与打开 semget\r\n函数声明：`int semget(key_t key,int nsems,int semflg)`\r\n\r\nkey：所创建或打开的信号量集合的键\r\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\r\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\r\n\r\n返回：\r\n- 成功：返回信号量ID\r\n- 失败：-1，并设置 errno\r\n\r\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\r\n\r\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\r\n\r\n#### 对信号量的控制 semctl\r\n\r\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\r\n\r\nsemid：为信号量集合的标识符。\r\nsemnum：用于指明某个特定信号量。\r\ncmd：表示调用该函数希望执行的命令\r\ncmd 的常用设置：\r\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\r\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\r\n\r\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\r\n```\r\nunion semen{\r\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\r\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\r\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\r\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\r\n};\r\n```\r\n\r\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\r\n```\r\nushort semid_ds{\r\n	struct ipc_perm sem_perm;	//所有者和标致权限\r\n	time_t sem_otime;	//最后操作时间\r\n	time_t sem_ctime;	//最后更改时间\r\n	unsigned short sem_nsems;	//信号集中的信号数量\r\n}\r\n```\r\n\r\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\r\n#### 对信号量的操作——semop\r\n改变信号量的值\r\n\r\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\r\n\r\nsemid：为信号量集合的ID\r\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\r\n```\r\nstruct sembuf{\r\n	short sem_num;	//信号量在信号集中的编号\r\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\r\n	short sem_flag;	//标志位\r\n};\r\n```\r\nnops：参数 sops 所指数组中元素的个数\r\n\r\n返回：若成功则为 0，若出错则为 -1。\r\n\r\n### 共享内存\r\n#### 共享内存的概念\r\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\r\n\r\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\r\n\r\n#### 共享内存的创建和打开 shmget\r\n函数声明：`int shmget(key_t key, int size, int flag) ;`\r\n\r\nkey：表示所创建或打开的共享内存的键\r\nsize：表示共享内存区域的大小\r\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\r\n\r\n返回：若成功则为共享内存ID，若出错则为 -1。\r\n\r\n#### 共享内存的附加 shmat\r\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\r\n\r\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\r\n`\r\n\r\nshmid：表示要附加的共享内存段的ID\r\naddr：虚拟地址\r\nflag：用于表示函数的操作方式\r\n\r\n返回：若成功则为指向共享内存段的指针，若出错则为-1\r\n\r\n#### 共享内存的分离 shmdt\r\n解除物理内存与进程虚拟地址空间的映射关系\r\n\r\n函数声明：`int shmdt(void *addr) ;`\r\n\r\naddr：是以前调用 shmat 时的返回值。\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n#### 共享内存的控制 shmctl\r\n对共享内存段执行多种操作。\r\n\r\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\r\n`\r\nshmid：为共享内存的标识符\r\ncmd：表示调用该函数希望执行的操作\r\n\r\n---\r\ncmd 的取值和对应操作如下：\r\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\r\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\r\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\r\n\r\n---\r\nbuf：指向 shmid_ds 结构体的指针\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。	\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n//semun 共用体\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;//信号量ID\r\nint shmid;//共享内存ID\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\n// P操作，获取信号量，-1\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\r\n	semop(semid, &buf, 1);	//改变信号量的值\r\n}\r\n\r\n// V操作，释放信号量，+1\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\r\n	\r\n	//删除信号量\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n\r\n	//删除共享内存\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	//int semget(key_t key,int nsems,int semflg)\r\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\r\n	//成功：返回信号量ID，失败：-1\r\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\r\n\r\n	if(semid == -1)	//信号量创建失败\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	 //返回信号量ID\r\n		printf(\"create semaphore ok\\n\");\r\n	}\r\n\r\n	//semun 共用体\r\n	union semun x;\r\n	x.val = 1;  //信号量初值应为多少？为1\r\n\r\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\r\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\r\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\r\n	\r\n	//int shmget(key_t key, int size, int flag);\r\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\r\n	//若成功则为共享内存ID，若出错则为 -1\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\r\n	if(shmid == -1)	\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	//返回共享内存ID\r\n		printf(\"create shared-memory ok\\n\");\r\n	}\r\n\r\n	//void *shmat(int shmid, void *addr, int flag) ;\r\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\r\n	//成功则为指向共享内存段的指针，若出错则为-1\r\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\r\n\r\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\r\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\r\n\r\n	//flag 是否是子进程\r\n	char is_child = 0;\r\n	int i;\r\n	//循环创建 10 个进程\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork(); \r\n		if(pid == 0)	//子进程\r\n		{\r\n			is_child = 1;  //设置子进程中 is_child 为 1\r\n			break;  //退出循环\r\n		}\r\n	}\r\n\r\n	//子进程\r\n	if(is_child)\r\n	{\r\n		p(semid);  // P操作，获取信号量（-1）\r\n\r\n		srand(time(NULL) + i);	//设置随机种子数\r\n		int num = rand()%10;	//取 0-9 随机数\r\n\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\r\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作，释放信号量（+1）\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\r\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();//挂起，等待信号唤醒\r\n	}\r\n\r\n	return 0;\r\n}\r\n/*========================================================================\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n========================================================================*/\r\n```\r\n## socket 编程接口\r\n### 套接口概念\r\n套接口实际就是网络进程的 PID（Process ID）。\r\n\r\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\r\n### 阻塞模式和非阻塞模式（同步和异步）\r\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\r\n\r\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\r\n\r\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\r\n\r\n### getsockname/getpeername\r\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\r\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\r\n*函数定义*\r\n```\r\n#include<sys/socket.h>\r\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\r\n```\r\n\r\n### 字节序转换\r\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\r\n\r\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\r\n\r\n#### 返回网络字节序 htons/htonl\r\n`u_short htons(u_short hostshort);`\r\n\r\n`u_long htonl(u_long hostlong);`\r\n\r\n#### 返回主机字节序 ntohs/ntohl\r\n`u_short ntohs(u_short netshort);`\r\n\r\n`u_long ntohl(u_long netlong);`\r\n\r\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\r\n### 地址转换函数\r\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\r\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\r\n要实现两者之间的转换，就要用到以下两个函数：\r\n\r\n`unsigned long inet_addr(const char FAR* cp);`\r\n\r\n成功：返回 32 位二进制的网络字节序地址\r\n出错：返回 INADDR_NONE。\r\n\r\n`char FAR* inet_ntoa(struct in_addr in);`\r\n\r\n成功：返回字符串的指针\r\n失败：返回 NULL\r\n\r\n### 流套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\r\n客户端：创建套接字——请求连接。\r\n\r\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\r\n\r\n最后，通信完毕，任意一方都可关闭套接字。\r\n### 数据报套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\r\n客户端：创建套接字——直接进行数据的发送。\r\n\r\n通信完毕，任意一方都可关闭套接字。\r\n\r\n### sockaddr 和 sockaddr_in 结构体\r\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\r\n\r\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\r\n\r\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\r\n```\r\nstruct sockaddr\r\n{\r\n	unit8_t	sa_len;\r\n	sa_family_t	sa_family;	//协议族名\r\n	char	sa_data[14];\r\n}\r\n```\r\n\r\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\r\n```\r\nstruct sockaddr_in\r\n{\r\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\r\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\r\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\r\n	struct in_addr sin_addr;\r\n	char	sin_zero[8];	//备用的域名，未使用\r\n};\r\nstruct in_addr\r\n{\r\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\r\n};\r\n```\r\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\r\n\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\r\n\r\n### 套接口函数\r\n#### 总结步骤\r\n>一个服务器进程中系统调用的顺序通常如下\r\n\r\nsocket();\r\nbind();\r\nlisten();\r\naccept();\r\n>而客户端进程的调用则比较简单\r\n\r\nsocket();\r\nconnect();\r\n#### 创建套接字 socket\r\n\r\n`int socket(int family,int type,int protocol);`\r\n\r\nfamily：指明协议族\r\ntype：指明套接口类型\r\nprotocol：一般为 0\r\n\r\n成功：返回值为非负描述字\r\n失败：返回值为负值\r\n\r\n>参数 family 的取值范围\r\n\r\nAF_LOCAL：UNIX 协议族\r\nAF_ROUTE：路由套接口\r\nAF_INET：IPv4 协议\r\nAF_INET6：IPV6 协议\r\nAF_KEY：密钥套接口\r\n\r\n>参数 type 的取值范围\r\n\r\nSOCK_STREAM：TCP 套接口\r\nSOCK_DGRAM：UDP 套接口\r\nSOCK_PACKET：支持数据链路访问\r\nSOCK_RAM：原始套接口\r\n\r\n#### 绑定套接口 bind\r\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\r\n\r\nsockfd：套接字\r\nmyaddr：是一个指向特定协议地址结构体的指针\r\naddrlen：是地址结构体的长度。\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\r\n\r\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\r\n\r\n#### 连接 connect\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\nsockfd：套接口描述字\r\nserv_addr：目的端口和IP地址的套接口\r\naddrlen：目的套接口的长度\r\n\r\n成功：返回 0\r\n失败：返回 -l\r\n\r\n#### 监听 listen\r\n`int listen(int sockfd,int backlog);`\r\n\r\nsockfd：套接字\r\nbacklog：规定内核为此套接口排队的最大选择个数\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 接受连接 accept (阻塞函数)\r\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\r\n\r\ncliaddr：远程客户的套接口地址\r\naddrlen：套接口地址长度\r\nsockfd：监听套接字，它由函数 socket() 生成\r\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\r\n\r\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\r\n失败：返回 -1\r\n\r\n>客户套接和监听套接字的区别：\r\n\r\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\r\n\r\n>accept()是一个阻塞函数\r\n\r\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\r\n\r\n#### 关闭 close\r\n`int close(int sockfd);`\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 发送 send/sendto (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int send(int sockfd,const void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\r\n\r\n#### 接收 recv/recvfrom (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int recv(int sockfd,void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\r\n\r\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\r\n\r\n>Mysend 方法\r\n\r\n```\r\nint Mysend(SOCKET s, const char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iSendCount = 0:\r\n	int iLength = len:\r\n	while (iLength > 0)\r\n	{\r\n		int n = send(s, buf* iSendCount, iLength, flags);\r\n		if(n == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= n:\r\n		iSendCount += n:\r\n	}\r\n	return iSendCount\r\n}\r\n```\r\n\r\n>Myrecv 方法\r\n\r\n```\r\nint Myrecv(SOCKET s, char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iRecvCount = 0;\r\n	int iLength = len;\r\n	while (iLength > 0)\r\n	{\r\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\r\n		if(nReU == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= nRev;\r\n		iRecuCount += nRev;\r\n	}\r\n	return iRecvCount;\r\n}\r\n```\r\n## 多线程\r\n### 线程函数的原型\r\n#### Windows\r\n`DWOED ThreadProc(LPVOID lpParameter);`\r\n### 创建新线程\r\n#### Windows - CreateThread\r\nWin32 API 函数 ：CreateThread()\r\n```\r\nHANDLE CreateThread(\r\n	LPSECURITY_ATTRIBUTES lpsa,\r\n	DWORD cbStack,\r\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\r\n	LPVOID lpvThreadParam,	//传给线程函数的参数\r\n	DWORD fdwCreate,\r\n	LPDWORD lpIDThread\r\n);\r\n```\r\n#### Unix - pthread_create\r\n```\r\n#include  <pthread.h>\r\nint  pthread_create（\r\n	pthread_t  *thread,	//待传入线程的线程ID指针\r\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n	void  *arg	//要传给线程执行函数的参数\r\n）\r\n```\r\n### 一个线程等待另一个线程结束的方法\r\n#### Unix - pthread_join\r\n```\r\n#include  <pthread.h>\r\nint pthread_join(\r\n	pthread_t thread,\r\n	void **retval\r\n);\r\n```\r\n### Linux 中编译多线程程序的方法\r\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\r\n\r\n### 线程的并发（同步）问题\r\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\r\n\r\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\r\n\r\nWindows 中主要函数有：\r\n```\r\nCreateSemaphore() //创建信号量\r\nWaitForSingleObject() //获取信号量，P\r\nReleaseSemaphore() //释放信号量，V\r\nCloseHandle() //关闭一个内核对象\r\n```\r\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\r\n```\r\n/*------------------------------------------------------------------------------------------------\r\n任务：\r\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\r\n思路：\r\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\r\n-------------------------------------------------------------------------------*/\r\n\r\n//=======================================================================================\r\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \r\n//=======================================================================================\r\n\r\n///*------------------------ Windows 的头文件 ----------------------------\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <time.h>\r\n#include <Winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\r\n//----------------------------------------------------------------------*/\r\n\r\n/*------------------------- Linux 的头文件 -----------------------------\r\n#include <sys/types.h>\r\n#include <sys/ipc.h>\r\n#include <sys/sem.h>\r\n#include <pthread.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h> \r\n#include <netinet/in.h> \r\n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\r\n-----------------------------------------------------------------------*/\r\n\r\n//=========================================\r\n//            	全局变量\r\n//=========================================\r\n\r\n//-------------------------- 判断平台 -------------------------\r\n#ifdef WINDOWS_VERSION //windows 平台\r\n	HANDLE  g_hSem;    //信号量的句柄\r\n	HANDLE  g_hThread[10];  //10个线程的句柄\r\n#else //Linux 平台\r\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\r\n	{\r\n		int val;\r\n		struct semid_ds *buf;\r\n		ushort *array;\r\n	};\r\n	int   semid;    //信号量的ID\r\n	pthread_t thread_id[10];  //10个线程的ID\r\n#endif\r\n	int  total;      //和\r\n	int  listen_sock;    //用于监听的套接字\r\n	short port;      //端口\r\n//----------------------------------------------------\r\n\r\n/**\r\n * 发送\r\n */\r\nint mysend(int sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int send(int sockfd,const void *buffer,int length,int flags);\r\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\r\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\n/**\r\n * 接收一个整数(阻塞函数)\r\n */\r\nint myrecv(int sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int recv(int sockfd,void *buffer,int length,int flags);\r\n		//返回：0是对方调用close()，-1是对方直接退出\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if(n == 0 || n == -1)  \r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n/**\r\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\r\n * \r\n * @param num 进程编号\r\n */\r\nvoid send_num_to_parent(int num)\r\n{\r\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET;\r\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\r\n	server_addr.sin_port  = htons(port);\r\n \r\n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\r\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\r\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\r\n\r\n	mysend(sock, (char *)&num, 4, 0);\r\n\r\n#ifdef WINDOWS_VERSION\r\n	closesocket(sock);\r\n#else\r\n	close(sock);\r\n#endif\r\n}\r\n\r\n#ifndef WINDOWS_VERSION\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n#endif\r\n\r\n\r\n#ifdef WINDOWS_VERSION\r\n	DWORD WINAPI thread_function(void *arg) \r\n#else\r\n	/**\r\n	 * 线程函数\r\n	 * 处理 accept，并创建下一个线程\r\n	 */\r\n	void *thread_function(void *arg)\r\n#endif\r\n	{ \r\n		int index = (int)arg;	//序号\r\n\r\n		//准备接受连接请求\r\n		struct sockaddr_in peer_addr;//套接口地址结构体\r\n		int size = sizeof(struct sockaddr_in);\r\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\r\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\r\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\r\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\r\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\r\n \r\n		//accept 完毕，创建下一个线程\r\n		if(index < 9)\r\n#ifdef WINDOWS_VERSION\r\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\r\n#else\r\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\r\n#endif\r\n\r\n		//自己，服务端\r\n		int num;\r\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\r\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\r\n\r\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\r\n#ifdef WINDOWS_VERSION\r\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\r\n		total += num;\r\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\r\n		closesocket(comm_sock);\r\n		// ExitThread(0);\r\n		return 0;//线程结束\r\n#else\r\n		p(semid);\r\n		total += num;\r\n		v(semid);\r\n		//int close(int sockfd);\r\n		//成功：返回 0，失败：返回 -1\r\n		close(comm_sock);\r\n		pthread_exit(NULL);\r\n#endif\r\n	}\r\n\r\n/**\r\n * 父进程(服务器)\r\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\r\n */\r\nvoid init_socket()\r\n{\r\n	//int socket(int family,int type,int protocol);\r\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\r\n	//成功：返回值为非负描述字，失败：返回值为负值\r\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\r\n\r\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET; //IP_V4\r\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\r\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\r\n\r\n	//随机产生一个端口号，但要大于1024才行\r\n	srand(time(NULL));  \r\n	port = rand()%10000;\r\n	while(port < 1024)\r\n		port = rand()%10000;\r\n\r\n	//htons：将主机的无符号短整形数转换为网络字节顺序\r\n	server_addr.sin_port = htons(port);\r\n\r\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\r\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\r\n	//成功：返回 0，失败：返回 -1\r\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\r\n\r\n	//int listen(int sockfd,int backlog);\r\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\r\n	//成功：返回 0，失败：返回 -1\r\n	listen(listen_sock, 5);//将套接字置于监听状态\r\n\r\n	printf(\"parent : 服务器开始监听连接请求\\n\");\r\n}\r\n\r\n/**\r\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\r\n * @param i 线程编号	\r\n */\r\nvoid do_child(int i)\r\n{\r\n	srand(time(NULL) + i);\r\n	int num = rand()%10;\r\n\r\n	printf(\"child%d: %d\\n\", i, num);\r\n\r\n	send_num_to_parent(num);\r\n}\r\n\r\n/**\r\n * 主函数\r\n *\r\n * @param  argc 命令行输入的参数个数\r\n * @param  argv 字符二维数组\r\n */\r\nint main(int argc, char* argv[])\r\n{\r\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \r\n#ifdef WINDOWS_VERSION\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n#endif\r\n\r\n	// Windows 中的父进程，Linux 中的父、子进程\r\n	if(argc == 1)  \r\n	{\r\n		total = 0;	//初始化 total 为 0 \r\n\r\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\r\n#ifdef WINDOWS_VERSION\r\n		//1 个信号量，初始为 1\r\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\r\n#else\r\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\r\n		union semun x;\r\n		x.val = 1;\r\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\r\n#endif\r\n  \r\n		//初始化网络环境，完成服务器的准备工作\r\n		init_socket();\r\n\r\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\r\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\r\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\r\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\r\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\r\n#else\r\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\r\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\r\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n		//	void  *arg	//要传给线程执行函数的参数\r\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\r\n#endif\r\n\r\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\r\n#ifdef WINDOWS_VERSION\r\n		STARTUPINFO si;\r\n		PROCESS_INFORMATION pi;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			//处理命令行字符串\r\n			char *p = GetCommandLine();\r\n			char strCmdLine[256];\r\n			strcpy(strCmdLine, p);\r\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\r\n\r\n			ZeroMemory( &si, sizeof(si) );\r\n			si.cb = sizeof(si);\r\n			ZeroMemory( &pi, sizeof(pi) );\r\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\r\n		}\r\n		//等待 10 个线程结束\r\n		for(i=0; i<10; i++)\r\n			WaitForSingleObject(g_hThread[i], INFINITE);\r\n#else\r\n		char is_child = 0;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			pid_t pid = fork();\r\n			if(pid == 0)\r\n			{\r\n				is_child = 1;\r\n				break;\r\n			}\r\n		}\r\n		if(is_child)\r\n		{\r\n			do_child(i);\r\n			return 0;\r\n		}\r\n		else\r\n		{\r\n			//等待 10 个线程结束\r\n			for(i=0; i<10; i++)\r\n				pthread_join(thread_id[i], NULL);\r\n		}\r\n#endif\r\n		printf(\"parent : all threads ended, total=%d\\n\", total);\r\n\r\n//删除信号量\r\n#ifdef WINDOWS_VERSION\r\n		CloseHandle(g_hSem);\r\n#else\r\n		semctl(semid, IPC_RMID, 0);\r\n#endif\r\n	}\r\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \r\n	{\r\n#ifdef WINDOWS_VERSION\r\n		char *p = GetCommandLine();\r\n		//下面 2 行从命令行中解析出端口号\r\n		p = strchr(p, \'-\');\r\n		sscanf(p+1, \"%d\", &port);\r\n\r\n		//下面 3 行从命令行中解析出子进程的序号\r\n		p = strchr(p+1, \'-\');\r\n		int index;\r\n		sscanf(p+1, \"%d\", &index);\r\n		do_child(index);\r\n#endif\r\n	}\r\n else\r\n	printf(\"启动命令不正确\\n\");\r\n	return 0;\r\n}\r\n```\r\n---\r\nparent : 服务器开始监听连接请求\r\nchild0: 1\r\nparent : 线程0接受一个连接请求\r\nparent : 线程0接收到一个整数1\r\nchild1: 4\r\nparent : 线程1接受一个连接请求\r\nparent : 线程1接收到一个整数4\r\nchild2: 7\r\nparent : 线程2接受一个连接请求\r\nparent : 线程2接收到一个整数7\r\nchild3: 0\r\nparent : 线程3接受一个连接请求\r\nparent : 线程3接收到一个整数0\r\nchild5: 7\r\nchild4: 4\r\nparent : 线程4接受一个连接请求\r\nchild6: 0\r\nchild7: 3\r\nchild8: 7\r\nparent : 线程4接收到一个整数7\r\nchild9: 0\r\nparent : 线程5接受一个连接请求\r\nparent : 线程5接收到一个整数4\r\nparent : 线程6接受一个连接请求\r\nparent : 线程6接收到一个整数0\r\nparent : 线程7接受一个连接请求\r\nparent : 线程7接收到一个整数3\r\nparent : 线程8接受一个连接请求\r\nparent : 线程8接收到一个整数7\r\nparent : 线程9接受一个连接请求\r\nparent : 线程9接收到一个整数0\r\nparent : all threads ended, total=33\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识'  WHERE  `id` = 212 [ RunTime:0.001987s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001547s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000371s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000881s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000429s ]
---------------------------------------------------------------
[ 2018-11-16T15:09:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.073553s][吞吐率：13.60req/s] [内存消耗：2,062.14kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000682s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001415s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000628s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000888s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000340s ]
---------------------------------------------------------------
[ 2018-11-16T17:11:04+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.061682s][吞吐率：16.21req/s] [内存消耗：2,062.14kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=1bilc5rrgnlpqehhmbcmd9bjt1',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000885s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001595s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000726s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000825s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000349s ]
---------------------------------------------------------------
[ 2018-11-16T20:57:47+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.048644s][吞吐率：20.56req/s] [内存消耗：1,428.40kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-16T20:57:49+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.039488s][吞吐率：25.32req/s] [内存消耗：1,340.77kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-16T20:57:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.058698s][吞吐率：17.04req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001383s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002371s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000529s ]
---------------------------------------------------------------
[ 2018-11-16T20:57:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.081288s][吞吐率：12.30req/s] [内存消耗：2,334.39kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000623s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001510s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003293s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000759s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001040s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000598s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001021s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000320s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000547s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000384s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000427s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001157s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000270s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001189s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000709s ]
---------------------------------------------------------------
[ 2018-11-16T21:03:20+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.070113s][吞吐率：14.26req/s] [内存消耗：2,114.35kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000700s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001897s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000743s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000996s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000374s ]
---------------------------------------------------------------
[ 2018-11-16T21:05:55+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.078305s][吞吐率：12.77req/s] [内存消耗：2,622.40kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '181149',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
*输出*
```
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33
```

### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
```
// FileDownloadThroughServer.cpp : Defines the entry point for the console application.
//

/*----------------------------------------------------------------------------------------------------------
功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。
----------------------------------------------------------------------------------------------------------*/


#include "stdafx.h"
#include "stdio.h"
#include <map>
#include <vector>
#include "Winsock2.h"
#pragma comment(lib, "ws2_32.lib")


//宏定义
//---------------------------------------------------------------------------------------------------------
#define SERVER_NOTIFY_PORT		1024	//通知端口
#define SERVER_REFRESH_PORT		1025	//刷新端口
#define SERVER_TRANSFER_PORT	1026	//传输端口
#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令
#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令
//---------------------------------------------------------------------------------------------------------


//结构体定义
//---------------------------------------------------------------------------------------------------------
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
	char				filename[100];	//文件名
	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址
	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传
	union
	{
		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体
		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
	};
};
struct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
	SOCKET	sock;						//告诉客户端是谁想下载他的文件
	char	filename[100];				//告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//---------------------------------------------------------------------------------------------------------


//全局变量
//---------------------------------------------------------------------------------------------------------
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap<SOCKET, SHARED_FILE>		g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector<SHARED_FILE>				g_files_list;
std::vector<SHARED_FILE>				g_files_list2;
unsigned int							g_serverip;				//服务器的IP，网络字节序表示	
HANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//---------------------------------------------------------------------------------------------------------


int mysend(SOCKET sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while (remain > 0)
	{
		int n = send(sock, buf + sent, remain, flags);
		if (n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while (remain > 0)
	{
		int n = recv(sock, buf + received, remain, flags);
		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
			break;
		remain -= n;
		received += n;
	}
	return received;
}

//-------------------------------------------------------------------------------------------------------
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
	SOCKET comm_sock = (SOCKET)lpParam;

	while (1)
	{
		char c;
		int ret = recv(comm_sock, &c, 1, 0);
		if (ret == 0 || ret == -1)
			break;
	}
	printf("有一个客户端退出了\\n");

	//删除g_shared_files中的信息
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	g_shared_files.erase(comm_sock);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
	SOCKET server_refresh_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);
	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;
	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	//最后发一个空文件名告诉客户端已发完
	SHARED_FILE sf;
	sf.filename[0] = \'\\0\';
	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);

	closesocket(comm_sock);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
	SOCKET server_notify_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);
	printf("有一个客户端上线了\\n");

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
	char buf[100];
	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字
	sf.client_addr = client_addr;
	sf.notify_sock = comm_sock;
	while (1)
	{
		myrecv(comm_sock, buf, 100, 0);
		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名
			break;
		strcpy(sf.filename, buf);

		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
	}

	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
	SOCKET server_transfer_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

	//接收一个“传输头部”
	TRANSFER_HEADER th;
	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);
	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
	{
		//构造一个“通知头部”准备发给被下载方
		NOTIFY_HEADER nh;
		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
		SOCKET client_notify_sock = th.shared_file.notify_sock;

		//向这个通知套接字发送“通知头部”
		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
			closesocket(comm_sock);
	}
	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
	{
		//从“传输头部”中取出下载方对应的套接字
		SOCKET download_client_sock = th.sock;

		//循环接收数据并转发给下载方
		char buf[1024];
		while (1)
		{
			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
			if (i > 0)
				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
			else
			{
				closesocket(download_client_sock);
				break;
			}
		}
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_REFRESH_PORT);

	while (1)
	{
		//创建流套接字并连接到服务器的刷新端口
		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

		//接收最新共享文件列表
		while (1)
		{
			SHARED_FILE sf;
			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

			if (sf.filename[0] != \'\\0\')  //如果不是空文件名
				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
			else  //空文件名，表示服务器本次发送共享文件列表已经完毕
				break;
		}


		closesocket(refresh_sock);

		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		g_files_list2.clear();
		g_files_list2 = g_files_list;
		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
		printf("最新共享文件列表：\\n");

		std::vector<SHARED_FILE>::const_iterator it;
		int i = 1;
		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
		{
			printf("%d - %s:%d上的%s", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);
			printf("\\n");
		}
		printf("请输入文件的序号进行下载（0-退出）：\\n");

		Sleep(10000);
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示上传的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字
	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	FILE *fp = fopen(pnh->filename, "rb");
	if (fp != NULL)
		printf("开始上传文件%s\\n", pnh->filename);
	else
	{
		printf("找不到文件%s，上传失败\\n", pnh->filename);
		closesocket(client_upload_sock);
		delete pnh;
		return 0;
	}

	//循环读取文件数据并上传
	char buf[1024];
	while (1)
	{
		int i = fread(buf, 1, 1024, fp);
		mysend(client_upload_sock, buf, i, 0);
		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了
			break;
	}
	fclose(fp);
	closesocket(client_upload_sock);
	printf("文件%s上传完成\\n", pnh->filename);

	delete pnh;
	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
	SOCKET client_notify_sock = (SOCKET)lpParam;

	while (1)
	{
		//接收一个“通知头部”
		NOTIFY_HEADER nh;
		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		printf("收到一个下载%s的通知\\n", nh.filename);

		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
		*pnh = nh;
		//创建线程，用来上传文件
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
	SHARED_FILE *psf = (SHARED_FILE *)lpParam;

	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示下载的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
	th.shared_file = *psf;  //指明想下载哪一个文件
	delete psf;
	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	printf("开始下载%s:%d的%s\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	FILE *fp = fopen(th.shared_file.filename, "wb");
	//循环接收数据并写入文件
	char buf[1024];
	while (1)
	{
		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
		if (i > 0)
			fwrite(buf, 1, i, fp);
		else
			break;
	}
	fclose(fp);
	closesocket(client_download_sock);
	printf("%s:%d的%s下载完毕\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
	int number;
	while (1)
	{
		scanf("%d", &number);
		//客户端退出的方式是用户按下0
		if (number == 0)
		{
			CloseHandle(g_client_semaphore);
			exit(0);
		}

		//为防止此时正在刷新 g_files_list2，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		if (number > g_files_list2.size())
			printf("请输入正确的序号\\n");
		else
		{
			SHARED_FILE *psf = new SHARED_FILE;
			*psf = g_files_list2[number - 1];

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			struct sockaddr_in clientAddr;
			int clientAddrLen = sizeof(clientAddr);
			//用于获取与某个套接字关联的本地协议地址
			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数

			SHARED_FILE	sel_file = *psf;

			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数
			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
			{
				printf("不能下载自己的文件\\n");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			else
			{
				//创建线程，用来完成下载任务
				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
			}

			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		}
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

int main(int argc, char* argv[])
{
	if (argc == 1)
	{
		printf("使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n");
		return 0;
	}

	//下面4行进行Windows网络环境的初始化。Linux中不需要
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);

	if (argc == 2 && strcmp(argv[1], "-server") == 0)
	{
		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		//创建通知端口的监听套接字
		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_notify_sock, 5);
		//创建线程，用来在通知端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

		//创建刷新端口的监听套接字
		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_REFRESH_PORT);
		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_refresh_sock, 5);
		//创建线程，用来在刷新端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

		//创建传输端口的监听套接字
		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_transfer_sock, 5);
		//创建线程，用来在传输端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

		printf("服务器在3个端口开始监听连接请求\\n");

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else if (argc >= 3 && strcmp(argv[1], "-client") == 0) //xx.exe -client s_ip xxx xxx
	{
		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		g_serverip = inet_addr(argv[2]);

		//创建用于连接到服务器通知端口的套接字
		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = g_serverip;
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		printf("客户端请求连接成功\\n");

		//发送共享文件名，文件名长度与服务器约定为100字节
		char buf[100];
		int i;
		for (i = 3; i<argc; i++)
		{
			strcpy(buf, argv[i]);
			mysend(client_notify_sock, buf, 100, 0);
		}
		//最后发送一个空文件名告诉服务器共享文件名已发完
		buf[0] = \'\\0\';
		mysend(client_notify_sock, buf, 100, 0);
		printf("客户端发送共享文件名成功\\n");

		//创建线程，用来接收服务器发来的“通知头部”
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，每隔10秒向服务器请求最新的共享文件列表
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，用来接收用户的键盘输入
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else
		printf("启动参数不正确\\n");

	return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
	通知
		等待连接：server_notify_sock
		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

		创建线程 server_quit_thread：
			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

	刷新
		等待连接：server_refresh_sock
		- 向客户端发送共享文件列表

	传输
		等待连接：server_transfer_sock
		- 服务器接收一个“传输头部”，判断是下载还是上传
			下载：
				构造一个“通知头部”发给被下载方
				client_notify_thread：...
			上传：	
				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
				client_download_thread：循环接收数据并写入文件

----------------------------------------------------------------------
客户端： xx.exe -client s_ip xxx xxx

	连接服务器通知端口告知上线，发送共享文件名
		服务器：接收客户端发来的共享文件名
				server_quit_thread

	创建 3 个线程：

	client_refresh_thread：
		创建流套接字并连接到服务器的刷新端口
		接收最新共享文件列表

	client_userinput_thread：
		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
			client_download_thread：
				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
				给服务器发送表示下载的“传输头部”
				循环接收数据并写入文件

	client_notify_thread：
		接收一个“通知头部”
		创建线程，client_upload_thread：
			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
			构造一个表示上传的“传输头部”并发送给服务器
			循环读取文件数据并上传

*/
```





',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000764s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001478s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000805s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000317s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000964s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000418s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000285s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验：fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n========================================================================*/\r\n\r\n```\r\n\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n>不 sleep 的输出：\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n----------------------------------------------------------\r\n>sleep() 后的输出：\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n========================================================================*/\r\n```\r\n\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验：李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n### 信号量\r\n#### 信号量的概念\r\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\r\n1. 测试控制该资源的信号量。\r\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\r\n\r\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\r\n\r\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\r\n\r\n#### 信号量的创建与打开 semget\r\n函数声明：`int semget(key_t key,int nsems,int semflg)`\r\n\r\nkey：所创建或打开的信号量集合的键\r\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\r\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\r\n\r\n返回：\r\n- 成功：返回信号量ID\r\n- 失败：-1，并设置 errno\r\n\r\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\r\n\r\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\r\n\r\n#### 对信号量的控制 semctl\r\n\r\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\r\n\r\nsemid：为信号量集合的标识符。\r\nsemnum：用于指明某个特定信号量。\r\ncmd：表示调用该函数希望执行的命令\r\ncmd 的常用设置：\r\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\r\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\r\n\r\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\r\n```\r\nunion semen{\r\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\r\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\r\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\r\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\r\n};\r\n```\r\n\r\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\r\n```\r\nushort semid_ds{\r\n	struct ipc_perm sem_perm;	//所有者和标致权限\r\n	time_t sem_otime;	//最后操作时间\r\n	time_t sem_ctime;	//最后更改时间\r\n	unsigned short sem_nsems;	//信号集中的信号数量\r\n}\r\n```\r\n\r\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\r\n#### 对信号量的操作——semop\r\n改变信号量的值\r\n\r\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\r\n\r\nsemid：为信号量集合的ID\r\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\r\n```\r\nstruct sembuf{\r\n	short sem_num;	//信号量在信号集中的编号\r\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\r\n	short sem_flag;	//标志位\r\n};\r\n```\r\nnops：参数 sops 所指数组中元素的个数\r\n\r\n返回：若成功则为 0，若出错则为 -1。\r\n\r\n### 共享内存\r\n#### 共享内存的概念\r\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\r\n\r\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\r\n\r\n#### 共享内存的创建和打开 shmget\r\n函数声明：`int shmget(key_t key, int size, int flag) ;`\r\n\r\nkey：表示所创建或打开的共享内存的键\r\nsize：表示共享内存区域的大小\r\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\r\n\r\n返回：若成功则为共享内存ID，若出错则为 -1。\r\n\r\n#### 共享内存的附加 shmat\r\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\r\n\r\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\r\n`\r\n\r\nshmid：表示要附加的共享内存段的ID\r\naddr：虚拟地址\r\nflag：用于表示函数的操作方式\r\n\r\n返回：若成功则为指向共享内存段的指针，若出错则为-1\r\n\r\n#### 共享内存的分离 shmdt\r\n解除物理内存与进程虚拟地址空间的映射关系\r\n\r\n函数声明：`int shmdt(void *addr) ;`\r\n\r\naddr：是以前调用 shmat 时的返回值。\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n#### 共享内存的控制 shmctl\r\n对共享内存段执行多种操作。\r\n\r\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\r\n`\r\nshmid：为共享内存的标识符\r\ncmd：表示调用该函数希望执行的操作\r\n\r\n---\r\ncmd 的取值和对应操作如下：\r\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\r\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\r\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\r\n\r\n---\r\nbuf：指向 shmid_ds 结构体的指针\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。	\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n//semun 共用体\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;//信号量ID\r\nint shmid;//共享内存ID\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\n// P操作，获取信号量，-1\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\r\n	semop(semid, &buf, 1);	//改变信号量的值\r\n}\r\n\r\n// V操作，释放信号量，+1\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\r\n	\r\n	//删除信号量\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n\r\n	//删除共享内存\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	//int semget(key_t key,int nsems,int semflg)\r\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\r\n	//成功：返回信号量ID，失败：-1\r\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\r\n\r\n	if(semid == -1)	//信号量创建失败\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	 //返回信号量ID\r\n		printf(\"create semaphore ok\\n\");\r\n	}\r\n\r\n	//semun 共用体\r\n	union semun x;\r\n	x.val = 1;  //信号量初值应为多少？为1\r\n\r\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\r\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\r\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\r\n	\r\n	//int shmget(key_t key, int size, int flag);\r\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\r\n	//若成功则为共享内存ID，若出错则为 -1\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\r\n	if(shmid == -1)	\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	//返回共享内存ID\r\n		printf(\"create shared-memory ok\\n\");\r\n	}\r\n\r\n	//void *shmat(int shmid, void *addr, int flag) ;\r\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\r\n	//成功则为指向共享内存段的指针，若出错则为-1\r\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\r\n\r\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\r\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\r\n\r\n	//flag 是否是子进程\r\n	char is_child = 0;\r\n	int i;\r\n	//循环创建 10 个进程\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork(); \r\n		if(pid == 0)	//子进程\r\n		{\r\n			is_child = 1;  //设置子进程中 is_child 为 1\r\n			break;  //退出循环\r\n		}\r\n	}\r\n\r\n	//子进程\r\n	if(is_child)\r\n	{\r\n		p(semid);  // P操作，获取信号量（-1）\r\n\r\n		srand(time(NULL) + i);	//设置随机种子数\r\n		int num = rand()%10;	//取 0-9 随机数\r\n\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\r\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作，释放信号量（+1）\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\r\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();//挂起，等待信号唤醒\r\n	}\r\n\r\n	return 0;\r\n}\r\n/*========================================================================\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n========================================================================*/\r\n```\r\n## socket 编程接口\r\n### 套接口概念\r\n套接口实际就是网络进程的 PID（Process ID）。\r\n\r\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\r\n### 阻塞模式和非阻塞模式（同步和异步）\r\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\r\n\r\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\r\n\r\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\r\n\r\n### getsockname/getpeername\r\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\r\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\r\n*函数定义*\r\n```\r\n#include<sys/socket.h>\r\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\r\n```\r\n\r\n### 字节序转换\r\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\r\n\r\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\r\n\r\n#### 返回网络字节序 htons/htonl\r\n`u_short htons(u_short hostshort);`\r\n\r\n`u_long htonl(u_long hostlong);`\r\n\r\n#### 返回主机字节序 ntohs/ntohl\r\n`u_short ntohs(u_short netshort);`\r\n\r\n`u_long ntohl(u_long netlong);`\r\n\r\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\r\n### 地址转换函数\r\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\r\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\r\n要实现两者之间的转换，就要用到以下两个函数：\r\n\r\n`unsigned long inet_addr(const char FAR* cp);`\r\n\r\n成功：返回 32 位二进制的网络字节序地址\r\n出错：返回 INADDR_NONE。\r\n\r\n`char FAR* inet_ntoa(struct in_addr in);`\r\n\r\n成功：返回字符串的指针\r\n失败：返回 NULL\r\n\r\n### 流套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\r\n客户端：创建套接字——请求连接。\r\n\r\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\r\n\r\n最后，通信完毕，任意一方都可关闭套接字。\r\n### 数据报套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\r\n客户端：创建套接字——直接进行数据的发送。\r\n\r\n通信完毕，任意一方都可关闭套接字。\r\n\r\n### sockaddr 和 sockaddr_in 结构体\r\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\r\n\r\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\r\n\r\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\r\n```\r\nstruct sockaddr\r\n{\r\n	unit8_t	sa_len;\r\n	sa_family_t	sa_family;	//协议族名\r\n	char	sa_data[14];\r\n}\r\n```\r\n\r\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\r\n```\r\nstruct sockaddr_in\r\n{\r\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\r\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\r\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\r\n	struct in_addr sin_addr;\r\n	char	sin_zero[8];	//备用的域名，未使用\r\n};\r\nstruct in_addr\r\n{\r\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\r\n};\r\n```\r\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\r\n\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\r\n\r\n### 套接口函数\r\n#### 总结步骤\r\n>一个服务器进程中系统调用的顺序通常如下\r\n\r\nsocket();\r\nbind();\r\nlisten();\r\naccept();\r\n>而客户端进程的调用则比较简单\r\n\r\nsocket();\r\nconnect();\r\n#### 创建套接字 socket\r\n\r\n`int socket(int family,int type,int protocol);`\r\n\r\nfamily：指明协议族\r\ntype：指明套接口类型\r\nprotocol：一般为 0\r\n\r\n成功：返回值为非负描述字\r\n失败：返回值为负值\r\n\r\n>参数 family 的取值范围\r\n\r\nAF_LOCAL：UNIX 协议族\r\nAF_ROUTE：路由套接口\r\nAF_INET：IPv4 协议\r\nAF_INET6：IPV6 协议\r\nAF_KEY：密钥套接口\r\n\r\n>参数 type 的取值范围\r\n\r\nSOCK_STREAM：TCP 套接口\r\nSOCK_DGRAM：UDP 套接口\r\nSOCK_PACKET：支持数据链路访问\r\nSOCK_RAM：原始套接口\r\n\r\n#### 绑定套接口 bind\r\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\r\n\r\nsockfd：套接字\r\nmyaddr：是一个指向特定协议地址结构体的指针\r\naddrlen：是地址结构体的长度。\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\r\n\r\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\r\n\r\n#### 连接 connect\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\nsockfd：套接口描述字\r\nserv_addr：目的端口和IP地址的套接口\r\naddrlen：目的套接口的长度\r\n\r\n成功：返回 0\r\n失败：返回 -l\r\n\r\n#### 监听 listen\r\n`int listen(int sockfd,int backlog);`\r\n\r\nsockfd：套接字\r\nbacklog：规定内核为此套接口排队的最大选择个数\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 接受连接 accept (阻塞函数)\r\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\r\n\r\ncliaddr：远程客户的套接口地址\r\naddrlen：套接口地址长度\r\nsockfd：监听套接字，它由函数 socket() 生成\r\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\r\n\r\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\r\n失败：返回 -1\r\n\r\n>客户套接和监听套接字的区别：\r\n\r\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\r\n\r\n>accept()是一个阻塞函数\r\n\r\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\r\n\r\n#### 关闭 close\r\n`int close(int sockfd);`\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 发送 send/sendto (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int send(int sockfd,const void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\r\n\r\n#### 接收 recv/recvfrom (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int recv(int sockfd,void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\r\n\r\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\r\n\r\n>Mysend 方法\r\n\r\n```\r\nint Mysend(SOCKET s, const char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iSendCount = 0:\r\n	int iLength = len:\r\n	while (iLength > 0)\r\n	{\r\n		int n = send(s, buf* iSendCount, iLength, flags);\r\n		if(n == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= n:\r\n		iSendCount += n:\r\n	}\r\n	return iSendCount\r\n}\r\n```\r\n\r\n>Myrecv 方法\r\n\r\n```\r\nint Myrecv(SOCKET s, char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iRecvCount = 0;\r\n	int iLength = len;\r\n	while (iLength > 0)\r\n	{\r\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\r\n		if(nReU == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= nRev;\r\n		iRecuCount += nRev;\r\n	}\r\n	return iRecvCount;\r\n}\r\n```\r\n## 多线程\r\n### 线程函数的原型\r\n#### Windows\r\n`DWOED ThreadProc(LPVOID lpParameter);`\r\n### 创建新线程\r\n#### Windows - CreateThread\r\nWin32 API 函数 ：CreateThread()\r\n```\r\nHANDLE CreateThread(\r\n	LPSECURITY_ATTRIBUTES lpsa,\r\n	DWORD cbStack,\r\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\r\n	LPVOID lpvThreadParam,	//传给线程函数的参数\r\n	DWORD fdwCreate,\r\n	LPDWORD lpIDThread\r\n);\r\n```\r\n#### Unix - pthread_create\r\n```\r\n#include  <pthread.h>\r\nint  pthread_create（\r\n	pthread_t  *thread,	//待传入线程的线程ID指针\r\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n	void  *arg	//要传给线程执行函数的参数\r\n）\r\n```\r\n### 一个线程等待另一个线程结束的方法\r\n#### Unix - pthread_join\r\n```\r\n#include  <pthread.h>\r\nint pthread_join(\r\n	pthread_t thread,\r\n	void **retval\r\n);\r\n```\r\n### Linux 中编译多线程程序的方法\r\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\r\n\r\n### 线程的并发（同步）问题\r\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\r\n\r\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\r\n\r\nWindows 中主要函数有：\r\n```\r\nCreateSemaphore() //创建信号量\r\nWaitForSingleObject() //获取信号量，P\r\nReleaseSemaphore() //释放信号量，V\r\nCloseHandle() //关闭一个内核对象\r\n```\r\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\r\n```\r\n/*------------------------------------------------------------------------------------------------\r\n任务：\r\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\r\n思路：\r\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\r\n-------------------------------------------------------------------------------*/\r\n\r\n//=======================================================================================\r\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \r\n//=======================================================================================\r\n\r\n///*------------------------ Windows 的头文件 ----------------------------\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <time.h>\r\n#include <Winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\r\n//----------------------------------------------------------------------*/\r\n\r\n/*------------------------- Linux 的头文件 -----------------------------\r\n#include <sys/types.h>\r\n#include <sys/ipc.h>\r\n#include <sys/sem.h>\r\n#include <pthread.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h> \r\n#include <netinet/in.h> \r\n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\r\n-----------------------------------------------------------------------*/\r\n\r\n//=========================================\r\n//            	全局变量\r\n//=========================================\r\n\r\n//-------------------------- 判断平台 -------------------------\r\n#ifdef WINDOWS_VERSION //windows 平台\r\n	HANDLE  g_hSem;    //信号量的句柄\r\n	HANDLE  g_hThread[10];  //10个线程的句柄\r\n#else //Linux 平台\r\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\r\n	{\r\n		int val;\r\n		struct semid_ds *buf;\r\n		ushort *array;\r\n	};\r\n	int   semid;    //信号量的ID\r\n	pthread_t thread_id[10];  //10个线程的ID\r\n#endif\r\n	int  total;      //和\r\n	int  listen_sock;    //用于监听的套接字\r\n	short port;      //端口\r\n//----------------------------------------------------\r\n\r\n/**\r\n * 发送\r\n */\r\nint mysend(int sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int send(int sockfd,const void *buffer,int length,int flags);\r\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\r\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\n/**\r\n * 接收一个整数(阻塞函数)\r\n */\r\nint myrecv(int sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int recv(int sockfd,void *buffer,int length,int flags);\r\n		//返回：0是对方调用close()，-1是对方直接退出\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if(n == 0 || n == -1)  \r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n/**\r\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\r\n * \r\n * @param num 进程编号\r\n */\r\nvoid send_num_to_parent(int num)\r\n{\r\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET;\r\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\r\n	server_addr.sin_port  = htons(port);\r\n \r\n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\r\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\r\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\r\n\r\n	mysend(sock, (char *)&num, 4, 0);\r\n\r\n#ifdef WINDOWS_VERSION\r\n	closesocket(sock);\r\n#else\r\n	close(sock);\r\n#endif\r\n}\r\n\r\n#ifndef WINDOWS_VERSION\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n#endif\r\n\r\n\r\n#ifdef WINDOWS_VERSION\r\n	DWORD WINAPI thread_function(void *arg) \r\n#else\r\n	/**\r\n	 * 线程函数\r\n	 * 处理 accept，并创建下一个线程\r\n	 */\r\n	void *thread_function(void *arg)\r\n#endif\r\n	{ \r\n		int index = (int)arg;	//序号\r\n\r\n		//准备接受连接请求\r\n		struct sockaddr_in peer_addr;//套接口地址结构体\r\n		int size = sizeof(struct sockaddr_in);\r\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\r\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\r\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\r\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\r\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\r\n \r\n		//accept 完毕，创建下一个线程\r\n		if(index < 9)\r\n#ifdef WINDOWS_VERSION\r\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\r\n#else\r\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\r\n#endif\r\n\r\n		//自己，服务端\r\n		int num;\r\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\r\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\r\n\r\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\r\n#ifdef WINDOWS_VERSION\r\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\r\n		total += num;\r\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\r\n		closesocket(comm_sock);\r\n		// ExitThread(0);\r\n		return 0;//线程结束\r\n#else\r\n		p(semid);\r\n		total += num;\r\n		v(semid);\r\n		//int close(int sockfd);\r\n		//成功：返回 0，失败：返回 -1\r\n		close(comm_sock);\r\n		pthread_exit(NULL);\r\n#endif\r\n	}\r\n\r\n/**\r\n * 父进程(服务器)\r\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\r\n */\r\nvoid init_socket()\r\n{\r\n	//int socket(int family,int type,int protocol);\r\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\r\n	//成功：返回值为非负描述字，失败：返回值为负值\r\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\r\n\r\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET; //IP_V4\r\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\r\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\r\n\r\n	//随机产生一个端口号，但要大于1024才行\r\n	srand(time(NULL));  \r\n	port = rand()%10000;\r\n	while(port < 1024)\r\n		port = rand()%10000;\r\n\r\n	//htons：将主机的无符号短整形数转换为网络字节顺序\r\n	server_addr.sin_port = htons(port);\r\n\r\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\r\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\r\n	//成功：返回 0，失败：返回 -1\r\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\r\n\r\n	//int listen(int sockfd,int backlog);\r\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\r\n	//成功：返回 0，失败：返回 -1\r\n	listen(listen_sock, 5);//将套接字置于监听状态\r\n\r\n	printf(\"parent : 服务器开始监听连接请求\\n\");\r\n}\r\n\r\n/**\r\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\r\n * @param i 线程编号	\r\n */\r\nvoid do_child(int i)\r\n{\r\n	srand(time(NULL) + i);\r\n	int num = rand()%10;\r\n\r\n	printf(\"child%d: %d\\n\", i, num);\r\n\r\n	send_num_to_parent(num);\r\n}\r\n\r\n/**\r\n * 主函数\r\n *\r\n * @param  argc 命令行输入的参数个数\r\n * @param  argv 字符二维数组\r\n */\r\nint main(int argc, char* argv[])\r\n{\r\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \r\n#ifdef WINDOWS_VERSION\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n#endif\r\n\r\n	// Windows 中的父进程，Linux 中的父、子进程\r\n	if(argc == 1)  \r\n	{\r\n		total = 0;	//初始化 total 为 0 \r\n\r\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\r\n#ifdef WINDOWS_VERSION\r\n		//1 个信号量，初始为 1\r\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\r\n#else\r\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\r\n		union semun x;\r\n		x.val = 1;\r\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\r\n#endif\r\n  \r\n		//初始化网络环境，完成服务器的准备工作\r\n		init_socket();\r\n\r\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\r\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\r\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\r\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\r\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\r\n#else\r\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\r\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\r\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n		//	void  *arg	//要传给线程执行函数的参数\r\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\r\n#endif\r\n\r\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\r\n#ifdef WINDOWS_VERSION\r\n		STARTUPINFO si;\r\n		PROCESS_INFORMATION pi;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			//处理命令行字符串\r\n			char *p = GetCommandLine();\r\n			char strCmdLine[256];\r\n			strcpy(strCmdLine, p);\r\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\r\n\r\n			ZeroMemory( &si, sizeof(si) );\r\n			si.cb = sizeof(si);\r\n			ZeroMemory( &pi, sizeof(pi) );\r\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\r\n		}\r\n		//等待 10 个线程结束\r\n		for(i=0; i<10; i++)\r\n			WaitForSingleObject(g_hThread[i], INFINITE);\r\n#else\r\n		char is_child = 0;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			pid_t pid = fork();\r\n			if(pid == 0)\r\n			{\r\n				is_child = 1;\r\n				break;\r\n			}\r\n		}\r\n		if(is_child)\r\n		{\r\n			do_child(i);\r\n			return 0;\r\n		}\r\n		else\r\n		{\r\n			//等待 10 个线程结束\r\n			for(i=0; i<10; i++)\r\n				pthread_join(thread_id[i], NULL);\r\n		}\r\n#endif\r\n		printf(\"parent : all threads ended, total=%d\\n\", total);\r\n\r\n//删除信号量\r\n#ifdef WINDOWS_VERSION\r\n		CloseHandle(g_hSem);\r\n#else\r\n		semctl(semid, IPC_RMID, 0);\r\n#endif\r\n	}\r\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \r\n	{\r\n#ifdef WINDOWS_VERSION\r\n		char *p = GetCommandLine();\r\n		//下面 2 行从命令行中解析出端口号\r\n		p = strchr(p, \'-\');\r\n		sscanf(p+1, \"%d\", &port);\r\n\r\n		//下面 3 行从命令行中解析出子进程的序号\r\n		p = strchr(p+1, \'-\');\r\n		int index;\r\n		sscanf(p+1, \"%d\", &index);\r\n		do_child(index);\r\n#endif\r\n	}\r\n else\r\n	printf(\"启动命令不正确\\n\");\r\n	return 0;\r\n}\r\n```\r\n*输出*\r\n```\r\nparent : 服务器开始监听连接请求\r\nchild0: 1\r\nparent : 线程0接受一个连接请求\r\nparent : 线程0接收到一个整数1\r\nchild1: 4\r\nparent : 线程1接受一个连接请求\r\nparent : 线程1接收到一个整数4\r\nchild2: 7\r\nparent : 线程2接受一个连接请求\r\nparent : 线程2接收到一个整数7\r\nchild3: 0\r\nparent : 线程3接受一个连接请求\r\nparent : 线程3接收到一个整数0\r\nchild5: 7\r\nchild4: 4\r\nparent : 线程4接受一个连接请求\r\nchild6: 0\r\nchild7: 3\r\nchild8: 7\r\nparent : 线程4接收到一个整数7\r\nchild9: 0\r\nparent : 线程5接受一个连接请求\r\nparent : 线程5接收到一个整数4\r\nparent : 线程6接受一个连接请求\r\nparent : 线程6接收到一个整数0\r\nparent : 线程7接受一个连接请求\r\nparent : 线程7接收到一个整数3\r\nparent : 线程8接受一个连接请求\r\nparent : 线程8接收到一个整数7\r\nparent : 线程9接受一个连接请求\r\nparent : 线程9接收到一个整数0\r\nparent : all threads ended, total=33\r\n```\r\n\r\n### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n```\r\n// FileDownloadThroughServer.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n/*----------------------------------------------------------------------------------------------------------\r\n功能：\r\n建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。\r\n文件存在于各个客户端上，而不在服务器上。\r\n要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n思路：\r\n1.服务器至少应该开放3个TCP端口供客户端连接。\r\n(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。\r\n(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。\r\n(3)第三个用来提供文件传输的中转服务，叫做传输端口。\r\n2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量\r\n应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。\r\n3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。\r\n其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。\r\n4.服务器和客户端都要大量使用多线程。\r\n5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，\r\n第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，\r\n二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和\r\n退出时都要被修改，所以必须有并发控制。\r\n6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是\r\n共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以\r\n防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。\r\n7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，\r\n然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。\r\n客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的\r\n“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个\r\n“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的\r\n文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传\r\n的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。\r\n考查：\r\n1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。\r\n2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，\r\n使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。\r\n3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。\r\n4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示\r\n这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时\r\n也会下载不成功，而且服务器有不确定的动作。试进行debug。\r\n----------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n#include \"stdafx.h\"\r\n#include \"stdio.h\"\r\n#include <map>\r\n#include <vector>\r\n#include \"Winsock2.h\"\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\n\r\n//宏定义\r\n//---------------------------------------------------------------------------------------------------------\r\n#define SERVER_NOTIFY_PORT		1024	//通知端口\r\n#define SERVER_REFRESH_PORT		1025	//刷新端口\r\n#define SERVER_TRANSFER_PORT	1026	//传输端口\r\n#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令\r\n#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\n//结构体定义\r\n//---------------------------------------------------------------------------------------------------------\r\n#pragma pack(4)  //设置结构体按照4字节对齐\r\nstruct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到\r\n{\r\n	char				filename[100];	//文件名\r\n	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址\r\n	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字\r\n};\r\nstruct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传\r\n{\r\n	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传\r\n	union\r\n	{\r\n		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体\r\n		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字\r\n	};\r\n};\r\nstruct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件\r\n{\r\n	SOCKET	sock;						//告诉客户端是谁想下载他的文件\r\n	char	filename[100];				//告诉客户端想下载他的哪个文件\r\n};\r\n#pragma pack()  //取消结构体的字节对齐\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\n//全局变量\r\n//---------------------------------------------------------------------------------------------------------\r\n//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体\r\nstd::multimap<SOCKET, SHARED_FILE>		g_shared_files;\r\n//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝\r\nstd::vector<SHARED_FILE>				g_files_list;\r\nstd::vector<SHARED_FILE>				g_files_list2;\r\nunsigned int							g_serverip;				//服务器的IP，网络字节序表示	\r\nHANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问\r\nHANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\nint mysend(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = send(sock, buf + sent, remain, flags);\r\n		if (n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\nint myrecv(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出\r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器用于判断某个客户端是否下线\r\n//参数：服务器上对应于某个客户端的通知套接字\r\n//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线\r\n//创建者：server_notify_thread()\r\nDWORD WINAPI server_quit_thread(LPVOID lpParam)\r\n{\r\n	SOCKET comm_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		char c;\r\n		int ret = recv(comm_sock, &c, 1, 0);\r\n		if (ret == 0 || ret == -1)\r\n			break;\r\n	}\r\n	printf(\"有一个客户端退出了\\n\");\r\n\r\n	//删除g_shared_files中的信息\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	g_shared_files.erase(comm_sock);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器把最新共享文件列表发给客户端\r\n//参数：服务器在刷新端口上的监听套接字\r\n//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端\r\n//创建者：main()\r\nDWORD WINAPI server_refresh_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_refresh_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;\r\n	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)\r\n		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	//最后发一个空文件名告诉客户端已发完\r\n	SHARED_FILE sf;\r\n	sf.filename[0] = \'\\0\';\r\n	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);\r\n\r\n	closesocket(comm_sock);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器接受一个客户端上线\r\n//参数：服务器在通知端口上的监听套接字\r\n//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射\r\n//创建者：main()\r\nDWORD WINAPI server_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_notify_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);\r\n	printf(\"有一个客户端上线了\\n\");\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n	char buf[100];\r\n	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字\r\n	sf.client_addr = client_addr;\r\n	sf.notify_sock = comm_sock;\r\n	while (1)\r\n	{\r\n		myrecv(comm_sock, buf, 100, 0);\r\n		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名\r\n			break;\r\n		strcpy(sf.filename, buf);\r\n\r\n		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p\r\n		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息\r\n		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v\r\n	}\r\n\r\n	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器为文件传输做中转服务\r\n//参数：服务器在传输端口上的监听套接字\r\n//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转\r\n//创建者：main()\r\nDWORD WINAPI server_transfer_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_transfer_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n	//接收一个“传输头部”\r\n	TRANSFER_HEADER th;\r\n	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件\r\n	{\r\n		//构造一个“通知头部”准备发给被下载方\r\n		NOTIFY_HEADER nh;\r\n		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字\r\n		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方\r\n\r\n		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字\r\n		SOCKET client_notify_sock = th.shared_file.notify_sock;\r\n\r\n		//向这个通知套接字发送“通知头部”\r\n		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出\r\n			closesocket(comm_sock);\r\n	}\r\n	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件\r\n	{\r\n		//从“传输头部”中取出下载方对应的套接字\r\n		SOCKET download_client_sock = th.sock;\r\n\r\n		//循环接收数据并转发给下载方\r\n		char buf[1024];\r\n		while (1)\r\n		{\r\n			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节\r\n			if (i > 0)\r\n				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节\r\n			else\r\n			{\r\n				closesocket(download_client_sock);\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端每隔10秒向服务器请求最新共享文件列表\r\n//参数：NULL\r\n//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示\r\n//创建者：main()\r\nDWORD WINAPI client_refresh_thread(LPVOID lpParam)\r\n{\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n\r\n	while (1)\r\n	{\r\n		//创建流套接字并连接到服务器的刷新端口\r\n		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n		//接收最新共享文件列表\r\n		while (1)\r\n		{\r\n			SHARED_FILE sf;\r\n			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体\r\n\r\n			if (sf.filename[0] != \'\\0\')  //如果不是空文件名\r\n				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面\r\n			else  //空文件名，表示服务器本次发送共享文件列表已经完毕\r\n				break;\r\n		}\r\n\r\n\r\n		closesocket(refresh_sock);\r\n\r\n		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		g_files_list2.clear();\r\n		g_files_list2 = g_files_list;\r\n		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表\r\n		printf(\"最新共享文件列表：\\n\");\r\n\r\n		std::vector<SHARED_FILE>::const_iterator it;\r\n		int i = 1;\r\n		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)\r\n		{\r\n			printf(\"%d - %s:%d上的%s\", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);\r\n			printf(\"\\n\");\r\n		}\r\n		printf(\"请输入文件的序号进行下载（0-退出）：\\n\");\r\n\r\n		Sleep(10000);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端进行文件上传\r\n//参数：指向“通知头部”的指针\r\n//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件\r\n//创建者：client_notify_thread()\r\nDWORD WINAPI client_upload_thread(LPVOID lpParam)\r\n{\r\n	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;\r\n\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示上传的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传\r\n	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字\r\n	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	FILE *fp = fopen(pnh->filename, \"rb\");\r\n	if (fp != NULL)\r\n		printf(\"开始上传文件%s\\n\", pnh->filename);\r\n	else\r\n	{\r\n		printf(\"找不到文件%s，上传失败\\n\", pnh->filename);\r\n		closesocket(client_upload_sock);\r\n		delete pnh;\r\n		return 0;\r\n	}\r\n\r\n	//循环读取文件数据并上传\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = fread(buf, 1, 1024, fp);\r\n		mysend(client_upload_sock, buf, i, 0);\r\n		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_upload_sock);\r\n	printf(\"文件%s上传完成\\n\", pnh->filename);\r\n\r\n	delete pnh;\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端响应服务器发来的通知\r\n//参数：客户端已经同服务器的通知端口建立连接的通知套接字\r\n//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传\r\n//创建者：main()\r\nDWORD WINAPI client_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET client_notify_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		//接收一个“通知头部”\r\n		NOTIFY_HEADER nh;\r\n		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		printf(\"收到一个下载%s的通知\\n\", nh.filename);\r\n\r\n		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖\r\n		*pnh = nh;\r\n		//创建线程，用来上传文件\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端进行指定文件的下载\r\n//参数：指向想下载的共享文件结构体的指针\r\n//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘\r\n//创建者：client_userinput_thread()\r\nDWORD WINAPI client_download_thread(LPVOID lpParam)\r\n{\r\n	SHARED_FILE *psf = (SHARED_FILE *)lpParam;\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示下载的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载\r\n	th.shared_file = *psf;  //指明想下载哪一个文件\r\n	delete psf;\r\n	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	printf(\"开始下载%s:%d的%s\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	FILE *fp = fopen(th.shared_file.filename, \"wb\");\r\n	//循环接收数据并写入文件\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()\r\n		if (i > 0)\r\n			fwrite(buf, 1, i, fp);\r\n		else\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_download_sock);\r\n	printf(\"%s:%d的%s下载完毕\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端接收并处理用户的键盘输入\r\n//参数：NULL\r\n//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载\r\n//创建者：main()\r\nDWORD WINAPI client_userinput_thread(LPVOID lpParam)\r\n{\r\n	int number;\r\n	while (1)\r\n	{\r\n		scanf(\"%d\", &number);\r\n		//客户端退出的方式是用户按下0\r\n		if (number == 0)\r\n		{\r\n			CloseHandle(g_client_semaphore);\r\n			exit(0);\r\n		}\r\n\r\n		//为防止此时正在刷新 g_files_list2，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		if (number > g_files_list2.size())\r\n			printf(\"请输入正确的序号\\n\");\r\n		else\r\n		{\r\n			SHARED_FILE *psf = new SHARED_FILE;\r\n			*psf = g_files_list2[number - 1];\r\n\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			struct sockaddr_in clientAddr;\r\n			int clientAddrLen = sizeof(clientAddr);\r\n			//用于获取与某个套接字关联的本地协议地址\r\n			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\n			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数\r\n\r\n			SHARED_FILE	sel_file = *psf;\r\n\r\n			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数\r\n			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))\r\n			{\r\n				printf(\"不能下载自己的文件\\n\");\r\n			}\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			else\r\n			{\r\n				//创建线程，用来完成下载任务\r\n				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);\r\n			}\r\n\r\n			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	if (argc == 1)\r\n	{\r\n		printf(\"使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n\");\r\n		return 0;\r\n	}\r\n\r\n	//下面4行进行Windows网络环境的初始化。Linux中不需要\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n\r\n	if (argc == 2 && strcmp(argv[1], \"-server\") == 0)\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改\r\n		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		//创建通知端口的监听套接字\r\n		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_notify_sock, 5);\r\n		//创建线程，用来在通知端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n		//创建刷新端口的监听套接字\r\n		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_refresh_sock, 5);\r\n		//创建线程，用来在刷新端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n		//创建传输端口的监听套接字\r\n		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_transfer_sock, 5);\r\n		//创建线程，用来在传输端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n		printf(\"服务器在3个端口开始监听连接请求\\n\");\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else if (argc >= 3 && strcmp(argv[1], \"-client\") == 0) //xx.exe -client s_ip xxx xxx\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写\r\n		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		g_serverip = inet_addr(argv[2]);\r\n\r\n		//创建用于连接到服务器通知端口的套接字\r\n		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = g_serverip;\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		printf(\"客户端请求连接成功\\n\");\r\n\r\n		//发送共享文件名，文件名长度与服务器约定为100字节\r\n		char buf[100];\r\n		int i;\r\n		for (i = 3; i<argc; i++)\r\n		{\r\n			strcpy(buf, argv[i]);\r\n			mysend(client_notify_sock, buf, 100, 0);\r\n		}\r\n		//最后发送一个空文件名告诉服务器共享文件名已发完\r\n		buf[0] = \'\\0\';\r\n		mysend(client_notify_sock, buf, 100, 0);\r\n		printf(\"客户端发送共享文件名成功\\n\");\r\n\r\n		//创建线程，用来接收服务器发来的“通知头部”\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，每隔10秒向服务器请求最新的共享文件列表\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，用来接收用户的键盘输入\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else\r\n		printf(\"启动参数不正确\\n\");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n/*\r\n服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。\r\n	通知\r\n		等待连接：server_notify_sock\r\n		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n\r\n		创建线程 server_quit_thread：\r\n			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)\r\n\r\n	刷新\r\n		等待连接：server_refresh_sock\r\n		- 向客户端发送共享文件列表\r\n\r\n	传输\r\n		等待连接：server_transfer_sock\r\n		- 服务器接收一个“传输头部”，判断是下载还是上传\r\n			下载：\r\n				构造一个“通知头部”发给被下载方\r\n				client_notify_thread：...\r\n			上传：	\r\n				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方\r\n				client_download_thread：循环接收数据并写入文件\r\n\r\n----------------------------------------------------------------------\r\n客户端： xx.exe -client s_ip xxx xxx\r\n\r\n	连接服务器通知端口告知上线，发送共享文件名\r\n		服务器：接收客户端发来的共享文件名\r\n				server_quit_thread\r\n\r\n	创建 3 个线程：\r\n\r\n	client_refresh_thread：\r\n		创建流套接字并连接到服务器的刷新端口\r\n		接收最新共享文件列表\r\n\r\n	client_userinput_thread：\r\n		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，\r\n			client_download_thread：\r\n				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...\r\n				给服务器发送表示下载的“传输头部”\r\n				循环接收数据并写入文件\r\n\r\n	client_notify_thread：\r\n		接收一个“通知头部”\r\n		创建线程，client_upload_thread：\r\n			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口\r\n			构造一个表示上传的“传输头部”并发送给服务器\r\n			循环读取文件数据并上传\r\n\r\n*/\r\n```\r\n\r\n\r\n\r\n\r\n\r\n',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识'  WHERE  `id` = 212 [ RunTime:0.002634s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001300s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001198s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000369s ]
---------------------------------------------------------------
[ 2018-11-16T21:05:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.059608s][吞吐率：16.78req/s] [内存消耗：2,095.86kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000593s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001343s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000761s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000857s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000294s ]
---------------------------------------------------------------
[ 2018-11-16T21:06:28+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.062218s][吞吐率：16.07req/s] [内存消耗：2,147.55kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000608s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001341s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000841s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000975s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000412s ]
---------------------------------------------------------------
[ 2018-11-16T21:08:13+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.075955s][吞吐率：13.17req/s] [内存消耗：2,768.38kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '181119',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
*输出*
```
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33
```

### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
```
// FileDownloadThroughServer.cpp : Defines the entry point for the console application.
//

/*----------------------------------------------------------------------------------------------------------
功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。
----------------------------------------------------------------------------------------------------------*/


#include "stdafx.h"
#include "stdio.h"
#include <map>
#include <vector>
#include "Winsock2.h"
#pragma comment(lib, "ws2_32.lib")


//宏定义
//---------------------------------------------------------------------------------------------------------
#define SERVER_NOTIFY_PORT		1024	//通知端口
#define SERVER_REFRESH_PORT		1025	//刷新端口
#define SERVER_TRANSFER_PORT	1026	//传输端口
#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令
#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令
//---------------------------------------------------------------------------------------------------------


//结构体定义
//---------------------------------------------------------------------------------------------------------
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
	char				filename[100];	//文件名
	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址
	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传
	union
	{
		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体
		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
	};
};
struct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
	SOCKET	sock;						//告诉客户端是谁想下载他的文件
	char	filename[100];				//告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//---------------------------------------------------------------------------------------------------------


//全局变量
//---------------------------------------------------------------------------------------------------------
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap<SOCKET, SHARED_FILE>		g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector<SHARED_FILE>				g_files_list;
std::vector<SHARED_FILE>				g_files_list2;
unsigned int							g_serverip;				//服务器的IP，网络字节序表示	
HANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//---------------------------------------------------------------------------------------------------------


int mysend(SOCKET sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while (remain > 0)
	{
		int n = send(sock, buf + sent, remain, flags);
		if (n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while (remain > 0)
	{
		int n = recv(sock, buf + received, remain, flags);
		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
			break;
		remain -= n;
		received += n;
	}
	return received;
}

//-------------------------------------------------------------------------------------------------------
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
	SOCKET comm_sock = (SOCKET)lpParam;

	while (1)
	{
		char c;
		int ret = recv(comm_sock, &c, 1, 0);
		if (ret == 0 || ret == -1)
			break;
	}
	printf("有一个客户端退出了\\n");

	//删除g_shared_files中的信息
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	g_shared_files.erase(comm_sock);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
	SOCKET server_refresh_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);
	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;
	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	//最后发一个空文件名告诉客户端已发完
	SHARED_FILE sf;
	sf.filename[0] = \'\\0\';
	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);

	closesocket(comm_sock);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
	SOCKET server_notify_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);
	printf("有一个客户端上线了\\n");

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
	char buf[100];
	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字
	sf.client_addr = client_addr;
	sf.notify_sock = comm_sock;
	while (1)
	{
		myrecv(comm_sock, buf, 100, 0);
		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名
			break;
		strcpy(sf.filename, buf);

		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
	}

	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
	SOCKET server_transfer_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

	//接收一个“传输头部”
	TRANSFER_HEADER th;
	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);
	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
	{
		//构造一个“通知头部”准备发给被下载方
		NOTIFY_HEADER nh;
		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
		SOCKET client_notify_sock = th.shared_file.notify_sock;

		//向这个通知套接字发送“通知头部”
		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
			closesocket(comm_sock);
	}
	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
	{
		//从“传输头部”中取出下载方对应的套接字
		SOCKET download_client_sock = th.sock;

		//循环接收数据并转发给下载方
		char buf[1024];
		while (1)
		{
			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
			if (i > 0)
				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
			else
			{
				closesocket(download_client_sock);
				break;
			}
		}
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_REFRESH_PORT);

	while (1)
	{
		//创建流套接字并连接到服务器的刷新端口
		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

		//接收最新共享文件列表
		while (1)
		{
			SHARED_FILE sf;
			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

			if (sf.filename[0] != \'\\0\')  //如果不是空文件名
				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
			else  //空文件名，表示服务器本次发送共享文件列表已经完毕
				break;
		}


		closesocket(refresh_sock);

		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		g_files_list2.clear();
		g_files_list2 = g_files_list;
		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
		printf("最新共享文件列表：\\n");

		std::vector<SHARED_FILE>::const_iterator it;
		int i = 1;
		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
		{
			printf("%d - %s:%d上的%s", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);
			printf("\\n");
		}
		printf("请输入文件的序号进行下载（0-退出）：\\n");

		Sleep(10000);
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示上传的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字
	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	FILE *fp = fopen(pnh->filename, "rb");
	if (fp != NULL)
		printf("开始上传文件%s\\n", pnh->filename);
	else
	{
		printf("找不到文件%s，上传失败\\n", pnh->filename);
		closesocket(client_upload_sock);
		delete pnh;
		return 0;
	}

	//循环读取文件数据并上传
	char buf[1024];
	while (1)
	{
		int i = fread(buf, 1, 1024, fp);
		mysend(client_upload_sock, buf, i, 0);
		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了
			break;
	}
	fclose(fp);
	closesocket(client_upload_sock);
	printf("文件%s上传完成\\n", pnh->filename);

	delete pnh;
	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
	SOCKET client_notify_sock = (SOCKET)lpParam;

	while (1)
	{
		//接收一个“通知头部”
		NOTIFY_HEADER nh;
		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		printf("收到一个下载%s的通知\\n", nh.filename);

		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
		*pnh = nh;
		//创建线程，用来上传文件
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
	SHARED_FILE *psf = (SHARED_FILE *)lpParam;

	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示下载的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
	th.shared_file = *psf;  //指明想下载哪一个文件
	delete psf;
	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	printf("开始下载%s:%d的%s\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	FILE *fp = fopen(th.shared_file.filename, "wb");
	//循环接收数据并写入文件
	char buf[1024];
	while (1)
	{
		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
		if (i > 0)
			fwrite(buf, 1, i, fp);
		else
			break;
	}
	fclose(fp);
	closesocket(client_download_sock);
	printf("%s:%d的%s下载完毕\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
	int number;
	while (1)
	{
		scanf("%d", &number);
		//客户端退出的方式是用户按下0
		if (number == 0)
		{
			CloseHandle(g_client_semaphore);
			exit(0);
		}

		//为防止此时正在刷新 g_files_list2，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		if (number > g_files_list2.size())
			printf("请输入正确的序号\\n");
		else
		{
			SHARED_FILE *psf = new SHARED_FILE;
			*psf = g_files_list2[number - 1];

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			struct sockaddr_in clientAddr;
			int clientAddrLen = sizeof(clientAddr);
			//用于获取与某个套接字关联的本地协议地址
			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数

			SHARED_FILE	sel_file = *psf;

			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数
			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
			{
				printf("不能下载自己的文件\\n");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			else
			{
				//创建线程，用来完成下载任务
				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
			}

			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		}
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

int main(int argc, char* argv[])
{
	if (argc == 1)
	{
		printf("使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n");
		return 0;
	}

	//下面4行进行Windows网络环境的初始化。Linux中不需要
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);

	if (argc == 2 && strcmp(argv[1], "-server") == 0)
	{
		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		//创建通知端口的监听套接字
		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_notify_sock, 5);
		//创建线程，用来在通知端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

		//创建刷新端口的监听套接字
		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_REFRESH_PORT);
		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_refresh_sock, 5);
		//创建线程，用来在刷新端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

		//创建传输端口的监听套接字
		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_transfer_sock, 5);
		//创建线程，用来在传输端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

		printf("服务器在3个端口开始监听连接请求\\n");

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else if (argc >= 3 && strcmp(argv[1], "-client") == 0) //xx.exe -client s_ip xxx xxx
	{
		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		g_serverip = inet_addr(argv[2]);

		//创建用于连接到服务器通知端口的套接字
		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = g_serverip;
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		printf("客户端请求连接成功\\n");

		//发送共享文件名，文件名长度与服务器约定为100字节
		char buf[100];
		int i;
		for (i = 3; i<argc; i++)
		{
			strcpy(buf, argv[i]);
			mysend(client_notify_sock, buf, 100, 0);
		}
		//最后发送一个空文件名告诉服务器共享文件名已发完
		buf[0] = \'\\0\';
		mysend(client_notify_sock, buf, 100, 0);
		printf("客户端发送共享文件名成功\\n");

		//创建线程，用来接收服务器发来的“通知头部”
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，每隔10秒向服务器请求最新的共享文件列表
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，用来接收用户的键盘输入
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else
		printf("启动参数不正确\\n");

	return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
	通知
		等待连接：server_notify_sock
		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

		创建线程 server_quit_thread：
			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

	刷新
		等待连接：server_refresh_sock
		- 向客户端发送共享文件列表

	传输
		等待连接：server_transfer_sock
		- 服务器接收一个“传输头部”，判断是下载还是上传
			下载：
				构造一个“通知头部”发给被下载方
				client_notify_thread：...
			上传：	
				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
				client_download_thread：循环接收数据并写入文件

//----------------------------------------------------------------------
客户端： xx.exe -client s_ip xxx xxx

	连接服务器通知端口告知上线，发送共享文件名
		服务器：接收客户端发来的共享文件名
				server_quit_thread

	创建 3 个线程：

	client_refresh_thread：
		创建流套接字并连接到服务器的刷新端口
		接收最新共享文件列表

	client_userinput_thread：
		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
			client_download_thread：
				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
				给服务器发送表示下载的“传输头部”
				循环接收数据并写入文件

	client_notify_thread：
		接收一个“通知头部”
		创建线程，client_upload_thread：
			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
			构造一个表示上传的“传输头部”并发送给服务器
			循环读取文件数据并上传

*/
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000625s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001373s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000856s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001163s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000300s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000316s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验：fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n========================================================================*/\r\n\r\n```\r\n\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n>不 sleep 的输出：\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n----------------------------------------------------------\r\n>sleep() 后的输出：\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n========================================================================*/\r\n```\r\n\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验：李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n### 信号量\r\n#### 信号量的概念\r\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\r\n1. 测试控制该资源的信号量。\r\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\r\n\r\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\r\n\r\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\r\n\r\n#### 信号量的创建与打开 semget\r\n函数声明：`int semget(key_t key,int nsems,int semflg)`\r\n\r\nkey：所创建或打开的信号量集合的键\r\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\r\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\r\n\r\n返回：\r\n- 成功：返回信号量ID\r\n- 失败：-1，并设置 errno\r\n\r\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\r\n\r\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\r\n\r\n#### 对信号量的控制 semctl\r\n\r\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\r\n\r\nsemid：为信号量集合的标识符。\r\nsemnum：用于指明某个特定信号量。\r\ncmd：表示调用该函数希望执行的命令\r\ncmd 的常用设置：\r\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\r\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\r\n\r\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\r\n```\r\nunion semen{\r\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\r\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\r\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\r\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\r\n};\r\n```\r\n\r\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\r\n```\r\nushort semid_ds{\r\n	struct ipc_perm sem_perm;	//所有者和标致权限\r\n	time_t sem_otime;	//最后操作时间\r\n	time_t sem_ctime;	//最后更改时间\r\n	unsigned short sem_nsems;	//信号集中的信号数量\r\n}\r\n```\r\n\r\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\r\n#### 对信号量的操作——semop\r\n改变信号量的值\r\n\r\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\r\n\r\nsemid：为信号量集合的ID\r\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\r\n```\r\nstruct sembuf{\r\n	short sem_num;	//信号量在信号集中的编号\r\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\r\n	short sem_flag;	//标志位\r\n};\r\n```\r\nnops：参数 sops 所指数组中元素的个数\r\n\r\n返回：若成功则为 0，若出错则为 -1。\r\n\r\n### 共享内存\r\n#### 共享内存的概念\r\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\r\n\r\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\r\n\r\n#### 共享内存的创建和打开 shmget\r\n函数声明：`int shmget(key_t key, int size, int flag) ;`\r\n\r\nkey：表示所创建或打开的共享内存的键\r\nsize：表示共享内存区域的大小\r\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\r\n\r\n返回：若成功则为共享内存ID，若出错则为 -1。\r\n\r\n#### 共享内存的附加 shmat\r\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\r\n\r\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\r\n`\r\n\r\nshmid：表示要附加的共享内存段的ID\r\naddr：虚拟地址\r\nflag：用于表示函数的操作方式\r\n\r\n返回：若成功则为指向共享内存段的指针，若出错则为-1\r\n\r\n#### 共享内存的分离 shmdt\r\n解除物理内存与进程虚拟地址空间的映射关系\r\n\r\n函数声明：`int shmdt(void *addr) ;`\r\n\r\naddr：是以前调用 shmat 时的返回值。\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n#### 共享内存的控制 shmctl\r\n对共享内存段执行多种操作。\r\n\r\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\r\n`\r\nshmid：为共享内存的标识符\r\ncmd：表示调用该函数希望执行的操作\r\n\r\n---\r\ncmd 的取值和对应操作如下：\r\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\r\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\r\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\r\n\r\n---\r\nbuf：指向 shmid_ds 结构体的指针\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。	\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n//semun 共用体\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;//信号量ID\r\nint shmid;//共享内存ID\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\n// P操作，获取信号量，-1\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\r\n	semop(semid, &buf, 1);	//改变信号量的值\r\n}\r\n\r\n// V操作，释放信号量，+1\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\r\n	\r\n	//删除信号量\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n\r\n	//删除共享内存\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	//int semget(key_t key,int nsems,int semflg)\r\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\r\n	//成功：返回信号量ID，失败：-1\r\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\r\n\r\n	if(semid == -1)	//信号量创建失败\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	 //返回信号量ID\r\n		printf(\"create semaphore ok\\n\");\r\n	}\r\n\r\n	//semun 共用体\r\n	union semun x;\r\n	x.val = 1;  //信号量初值应为多少？为1\r\n\r\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\r\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\r\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\r\n	\r\n	//int shmget(key_t key, int size, int flag);\r\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\r\n	//若成功则为共享内存ID，若出错则为 -1\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\r\n	if(shmid == -1)	\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	//返回共享内存ID\r\n		printf(\"create shared-memory ok\\n\");\r\n	}\r\n\r\n	//void *shmat(int shmid, void *addr, int flag) ;\r\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\r\n	//成功则为指向共享内存段的指针，若出错则为-1\r\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\r\n\r\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\r\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\r\n\r\n	//flag 是否是子进程\r\n	char is_child = 0;\r\n	int i;\r\n	//循环创建 10 个进程\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork(); \r\n		if(pid == 0)	//子进程\r\n		{\r\n			is_child = 1;  //设置子进程中 is_child 为 1\r\n			break;  //退出循环\r\n		}\r\n	}\r\n\r\n	//子进程\r\n	if(is_child)\r\n	{\r\n		p(semid);  // P操作，获取信号量（-1）\r\n\r\n		srand(time(NULL) + i);	//设置随机种子数\r\n		int num = rand()%10;	//取 0-9 随机数\r\n\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\r\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作，释放信号量（+1）\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\r\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();//挂起，等待信号唤醒\r\n	}\r\n\r\n	return 0;\r\n}\r\n/*========================================================================\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n========================================================================*/\r\n```\r\n## socket 编程接口\r\n### 套接口概念\r\n套接口实际就是网络进程的 PID（Process ID）。\r\n\r\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\r\n### 阻塞模式和非阻塞模式（同步和异步）\r\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\r\n\r\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\r\n\r\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\r\n\r\n### getsockname/getpeername\r\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\r\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\r\n*函数定义*\r\n```\r\n#include<sys/socket.h>\r\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\r\n```\r\n\r\n### 字节序转换\r\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\r\n\r\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\r\n\r\n#### 返回网络字节序 htons/htonl\r\n`u_short htons(u_short hostshort);`\r\n\r\n`u_long htonl(u_long hostlong);`\r\n\r\n#### 返回主机字节序 ntohs/ntohl\r\n`u_short ntohs(u_short netshort);`\r\n\r\n`u_long ntohl(u_long netlong);`\r\n\r\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\r\n### 地址转换函数\r\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\r\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\r\n要实现两者之间的转换，就要用到以下两个函数：\r\n\r\n`unsigned long inet_addr(const char FAR* cp);`\r\n\r\n成功：返回 32 位二进制的网络字节序地址\r\n出错：返回 INADDR_NONE。\r\n\r\n`char FAR* inet_ntoa(struct in_addr in);`\r\n\r\n成功：返回字符串的指针\r\n失败：返回 NULL\r\n\r\n### 流套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\r\n客户端：创建套接字——请求连接。\r\n\r\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\r\n\r\n最后，通信完毕，任意一方都可关闭套接字。\r\n### 数据报套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\r\n客户端：创建套接字——直接进行数据的发送。\r\n\r\n通信完毕，任意一方都可关闭套接字。\r\n\r\n### sockaddr 和 sockaddr_in 结构体\r\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\r\n\r\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\r\n\r\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\r\n```\r\nstruct sockaddr\r\n{\r\n	unit8_t	sa_len;\r\n	sa_family_t	sa_family;	//协议族名\r\n	char	sa_data[14];\r\n}\r\n```\r\n\r\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\r\n```\r\nstruct sockaddr_in\r\n{\r\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\r\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\r\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\r\n	struct in_addr sin_addr;\r\n	char	sin_zero[8];	//备用的域名，未使用\r\n};\r\nstruct in_addr\r\n{\r\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\r\n};\r\n```\r\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\r\n\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\r\n\r\n### 套接口函数\r\n#### 总结步骤\r\n>一个服务器进程中系统调用的顺序通常如下\r\n\r\nsocket();\r\nbind();\r\nlisten();\r\naccept();\r\n>而客户端进程的调用则比较简单\r\n\r\nsocket();\r\nconnect();\r\n#### 创建套接字 socket\r\n\r\n`int socket(int family,int type,int protocol);`\r\n\r\nfamily：指明协议族\r\ntype：指明套接口类型\r\nprotocol：一般为 0\r\n\r\n成功：返回值为非负描述字\r\n失败：返回值为负值\r\n\r\n>参数 family 的取值范围\r\n\r\nAF_LOCAL：UNIX 协议族\r\nAF_ROUTE：路由套接口\r\nAF_INET：IPv4 协议\r\nAF_INET6：IPV6 协议\r\nAF_KEY：密钥套接口\r\n\r\n>参数 type 的取值范围\r\n\r\nSOCK_STREAM：TCP 套接口\r\nSOCK_DGRAM：UDP 套接口\r\nSOCK_PACKET：支持数据链路访问\r\nSOCK_RAM：原始套接口\r\n\r\n#### 绑定套接口 bind\r\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\r\n\r\nsockfd：套接字\r\nmyaddr：是一个指向特定协议地址结构体的指针\r\naddrlen：是地址结构体的长度。\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\r\n\r\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\r\n\r\n#### 连接 connect\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\nsockfd：套接口描述字\r\nserv_addr：目的端口和IP地址的套接口\r\naddrlen：目的套接口的长度\r\n\r\n成功：返回 0\r\n失败：返回 -l\r\n\r\n#### 监听 listen\r\n`int listen(int sockfd,int backlog);`\r\n\r\nsockfd：套接字\r\nbacklog：规定内核为此套接口排队的最大选择个数\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 接受连接 accept (阻塞函数)\r\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\r\n\r\ncliaddr：远程客户的套接口地址\r\naddrlen：套接口地址长度\r\nsockfd：监听套接字，它由函数 socket() 生成\r\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\r\n\r\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\r\n失败：返回 -1\r\n\r\n>客户套接和监听套接字的区别：\r\n\r\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\r\n\r\n>accept()是一个阻塞函数\r\n\r\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\r\n\r\n#### 关闭 close\r\n`int close(int sockfd);`\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 发送 send/sendto (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int send(int sockfd,const void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\r\n\r\n#### 接收 recv/recvfrom (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int recv(int sockfd,void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\r\n\r\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\r\n\r\n>Mysend 方法\r\n\r\n```\r\nint Mysend(SOCKET s, const char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iSendCount = 0:\r\n	int iLength = len:\r\n	while (iLength > 0)\r\n	{\r\n		int n = send(s, buf* iSendCount, iLength, flags);\r\n		if(n == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= n:\r\n		iSendCount += n:\r\n	}\r\n	return iSendCount\r\n}\r\n```\r\n\r\n>Myrecv 方法\r\n\r\n```\r\nint Myrecv(SOCKET s, char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iRecvCount = 0;\r\n	int iLength = len;\r\n	while (iLength > 0)\r\n	{\r\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\r\n		if(nReU == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= nRev;\r\n		iRecuCount += nRev;\r\n	}\r\n	return iRecvCount;\r\n}\r\n```\r\n## 多线程\r\n### 线程函数的原型\r\n#### Windows\r\n`DWOED ThreadProc(LPVOID lpParameter);`\r\n### 创建新线程\r\n#### Windows - CreateThread\r\nWin32 API 函数 ：CreateThread()\r\n```\r\nHANDLE CreateThread(\r\n	LPSECURITY_ATTRIBUTES lpsa,\r\n	DWORD cbStack,\r\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\r\n	LPVOID lpvThreadParam,	//传给线程函数的参数\r\n	DWORD fdwCreate,\r\n	LPDWORD lpIDThread\r\n);\r\n```\r\n#### Unix - pthread_create\r\n```\r\n#include  <pthread.h>\r\nint  pthread_create（\r\n	pthread_t  *thread,	//待传入线程的线程ID指针\r\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n	void  *arg	//要传给线程执行函数的参数\r\n）\r\n```\r\n### 一个线程等待另一个线程结束的方法\r\n#### Unix - pthread_join\r\n```\r\n#include  <pthread.h>\r\nint pthread_join(\r\n	pthread_t thread,\r\n	void **retval\r\n);\r\n```\r\n### Linux 中编译多线程程序的方法\r\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\r\n\r\n### 线程的并发（同步）问题\r\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\r\n\r\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\r\n\r\nWindows 中主要函数有：\r\n```\r\nCreateSemaphore() //创建信号量\r\nWaitForSingleObject() //获取信号量，P\r\nReleaseSemaphore() //释放信号量，V\r\nCloseHandle() //关闭一个内核对象\r\n```\r\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\r\n```\r\n/*------------------------------------------------------------------------------------------------\r\n任务：\r\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\r\n思路：\r\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\r\n-------------------------------------------------------------------------------*/\r\n\r\n//=======================================================================================\r\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \r\n//=======================================================================================\r\n\r\n///*------------------------ Windows 的头文件 ----------------------------\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <time.h>\r\n#include <Winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\r\n//----------------------------------------------------------------------*/\r\n\r\n/*------------------------- Linux 的头文件 -----------------------------\r\n#include <sys/types.h>\r\n#include <sys/ipc.h>\r\n#include <sys/sem.h>\r\n#include <pthread.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h> \r\n#include <netinet/in.h> \r\n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\r\n-----------------------------------------------------------------------*/\r\n\r\n//=========================================\r\n//            	全局变量\r\n//=========================================\r\n\r\n//-------------------------- 判断平台 -------------------------\r\n#ifdef WINDOWS_VERSION //windows 平台\r\n	HANDLE  g_hSem;    //信号量的句柄\r\n	HANDLE  g_hThread[10];  //10个线程的句柄\r\n#else //Linux 平台\r\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\r\n	{\r\n		int val;\r\n		struct semid_ds *buf;\r\n		ushort *array;\r\n	};\r\n	int   semid;    //信号量的ID\r\n	pthread_t thread_id[10];  //10个线程的ID\r\n#endif\r\n	int  total;      //和\r\n	int  listen_sock;    //用于监听的套接字\r\n	short port;      //端口\r\n//----------------------------------------------------\r\n\r\n/**\r\n * 发送\r\n */\r\nint mysend(int sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int send(int sockfd,const void *buffer,int length,int flags);\r\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\r\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\n/**\r\n * 接收一个整数(阻塞函数)\r\n */\r\nint myrecv(int sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int recv(int sockfd,void *buffer,int length,int flags);\r\n		//返回：0是对方调用close()，-1是对方直接退出\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if(n == 0 || n == -1)  \r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n/**\r\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\r\n * \r\n * @param num 进程编号\r\n */\r\nvoid send_num_to_parent(int num)\r\n{\r\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET;\r\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\r\n	server_addr.sin_port  = htons(port);\r\n \r\n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\r\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\r\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\r\n\r\n	mysend(sock, (char *)&num, 4, 0);\r\n\r\n#ifdef WINDOWS_VERSION\r\n	closesocket(sock);\r\n#else\r\n	close(sock);\r\n#endif\r\n}\r\n\r\n#ifndef WINDOWS_VERSION\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n#endif\r\n\r\n\r\n#ifdef WINDOWS_VERSION\r\n	DWORD WINAPI thread_function(void *arg) \r\n#else\r\n	/**\r\n	 * 线程函数\r\n	 * 处理 accept，并创建下一个线程\r\n	 */\r\n	void *thread_function(void *arg)\r\n#endif\r\n	{ \r\n		int index = (int)arg;	//序号\r\n\r\n		//准备接受连接请求\r\n		struct sockaddr_in peer_addr;//套接口地址结构体\r\n		int size = sizeof(struct sockaddr_in);\r\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\r\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\r\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\r\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\r\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\r\n \r\n		//accept 完毕，创建下一个线程\r\n		if(index < 9)\r\n#ifdef WINDOWS_VERSION\r\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\r\n#else\r\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\r\n#endif\r\n\r\n		//自己，服务端\r\n		int num;\r\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\r\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\r\n\r\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\r\n#ifdef WINDOWS_VERSION\r\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\r\n		total += num;\r\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\r\n		closesocket(comm_sock);\r\n		// ExitThread(0);\r\n		return 0;//线程结束\r\n#else\r\n		p(semid);\r\n		total += num;\r\n		v(semid);\r\n		//int close(int sockfd);\r\n		//成功：返回 0，失败：返回 -1\r\n		close(comm_sock);\r\n		pthread_exit(NULL);\r\n#endif\r\n	}\r\n\r\n/**\r\n * 父进程(服务器)\r\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\r\n */\r\nvoid init_socket()\r\n{\r\n	//int socket(int family,int type,int protocol);\r\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\r\n	//成功：返回值为非负描述字，失败：返回值为负值\r\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\r\n\r\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET; //IP_V4\r\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\r\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\r\n\r\n	//随机产生一个端口号，但要大于1024才行\r\n	srand(time(NULL));  \r\n	port = rand()%10000;\r\n	while(port < 1024)\r\n		port = rand()%10000;\r\n\r\n	//htons：将主机的无符号短整形数转换为网络字节顺序\r\n	server_addr.sin_port = htons(port);\r\n\r\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\r\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\r\n	//成功：返回 0，失败：返回 -1\r\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\r\n\r\n	//int listen(int sockfd,int backlog);\r\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\r\n	//成功：返回 0，失败：返回 -1\r\n	listen(listen_sock, 5);//将套接字置于监听状态\r\n\r\n	printf(\"parent : 服务器开始监听连接请求\\n\");\r\n}\r\n\r\n/**\r\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\r\n * @param i 线程编号	\r\n */\r\nvoid do_child(int i)\r\n{\r\n	srand(time(NULL) + i);\r\n	int num = rand()%10;\r\n\r\n	printf(\"child%d: %d\\n\", i, num);\r\n\r\n	send_num_to_parent(num);\r\n}\r\n\r\n/**\r\n * 主函数\r\n *\r\n * @param  argc 命令行输入的参数个数\r\n * @param  argv 字符二维数组\r\n */\r\nint main(int argc, char* argv[])\r\n{\r\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \r\n#ifdef WINDOWS_VERSION\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n#endif\r\n\r\n	// Windows 中的父进程，Linux 中的父、子进程\r\n	if(argc == 1)  \r\n	{\r\n		total = 0;	//初始化 total 为 0 \r\n\r\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\r\n#ifdef WINDOWS_VERSION\r\n		//1 个信号量，初始为 1\r\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\r\n#else\r\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\r\n		union semun x;\r\n		x.val = 1;\r\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\r\n#endif\r\n  \r\n		//初始化网络环境，完成服务器的准备工作\r\n		init_socket();\r\n\r\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\r\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\r\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\r\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\r\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\r\n#else\r\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\r\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\r\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n		//	void  *arg	//要传给线程执行函数的参数\r\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\r\n#endif\r\n\r\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\r\n#ifdef WINDOWS_VERSION\r\n		STARTUPINFO si;\r\n		PROCESS_INFORMATION pi;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			//处理命令行字符串\r\n			char *p = GetCommandLine();\r\n			char strCmdLine[256];\r\n			strcpy(strCmdLine, p);\r\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\r\n\r\n			ZeroMemory( &si, sizeof(si) );\r\n			si.cb = sizeof(si);\r\n			ZeroMemory( &pi, sizeof(pi) );\r\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\r\n		}\r\n		//等待 10 个线程结束\r\n		for(i=0; i<10; i++)\r\n			WaitForSingleObject(g_hThread[i], INFINITE);\r\n#else\r\n		char is_child = 0;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			pid_t pid = fork();\r\n			if(pid == 0)\r\n			{\r\n				is_child = 1;\r\n				break;\r\n			}\r\n		}\r\n		if(is_child)\r\n		{\r\n			do_child(i);\r\n			return 0;\r\n		}\r\n		else\r\n		{\r\n			//等待 10 个线程结束\r\n			for(i=0; i<10; i++)\r\n				pthread_join(thread_id[i], NULL);\r\n		}\r\n#endif\r\n		printf(\"parent : all threads ended, total=%d\\n\", total);\r\n\r\n//删除信号量\r\n#ifdef WINDOWS_VERSION\r\n		CloseHandle(g_hSem);\r\n#else\r\n		semctl(semid, IPC_RMID, 0);\r\n#endif\r\n	}\r\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \r\n	{\r\n#ifdef WINDOWS_VERSION\r\n		char *p = GetCommandLine();\r\n		//下面 2 行从命令行中解析出端口号\r\n		p = strchr(p, \'-\');\r\n		sscanf(p+1, \"%d\", &port);\r\n\r\n		//下面 3 行从命令行中解析出子进程的序号\r\n		p = strchr(p+1, \'-\');\r\n		int index;\r\n		sscanf(p+1, \"%d\", &index);\r\n		do_child(index);\r\n#endif\r\n	}\r\n else\r\n	printf(\"启动命令不正确\\n\");\r\n	return 0;\r\n}\r\n```\r\n*输出*\r\n```\r\nparent : 服务器开始监听连接请求\r\nchild0: 1\r\nparent : 线程0接受一个连接请求\r\nparent : 线程0接收到一个整数1\r\nchild1: 4\r\nparent : 线程1接受一个连接请求\r\nparent : 线程1接收到一个整数4\r\nchild2: 7\r\nparent : 线程2接受一个连接请求\r\nparent : 线程2接收到一个整数7\r\nchild3: 0\r\nparent : 线程3接受一个连接请求\r\nparent : 线程3接收到一个整数0\r\nchild5: 7\r\nchild4: 4\r\nparent : 线程4接受一个连接请求\r\nchild6: 0\r\nchild7: 3\r\nchild8: 7\r\nparent : 线程4接收到一个整数7\r\nchild9: 0\r\nparent : 线程5接受一个连接请求\r\nparent : 线程5接收到一个整数4\r\nparent : 线程6接受一个连接请求\r\nparent : 线程6接收到一个整数0\r\nparent : 线程7接受一个连接请求\r\nparent : 线程7接收到一个整数3\r\nparent : 线程8接受一个连接请求\r\nparent : 线程8接收到一个整数7\r\nparent : 线程9接受一个连接请求\r\nparent : 线程9接收到一个整数0\r\nparent : all threads ended, total=33\r\n```\r\n\r\n### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n```\r\n// FileDownloadThroughServer.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n/*----------------------------------------------------------------------------------------------------------\r\n功能：\r\n建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。\r\n文件存在于各个客户端上，而不在服务器上。\r\n要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n思路：\r\n1.服务器至少应该开放3个TCP端口供客户端连接。\r\n(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。\r\n(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。\r\n(3)第三个用来提供文件传输的中转服务，叫做传输端口。\r\n2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量\r\n应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。\r\n3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。\r\n其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。\r\n4.服务器和客户端都要大量使用多线程。\r\n5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，\r\n第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，\r\n二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和\r\n退出时都要被修改，所以必须有并发控制。\r\n6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是\r\n共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以\r\n防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。\r\n7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，\r\n然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。\r\n客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的\r\n“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个\r\n“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的\r\n文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传\r\n的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。\r\n考查：\r\n1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。\r\n2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，\r\n使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。\r\n3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。\r\n4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示\r\n这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时\r\n也会下载不成功，而且服务器有不确定的动作。试进行debug。\r\n----------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n#include \"stdafx.h\"\r\n#include \"stdio.h\"\r\n#include <map>\r\n#include <vector>\r\n#include \"Winsock2.h\"\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\n\r\n//宏定义\r\n//---------------------------------------------------------------------------------------------------------\r\n#define SERVER_NOTIFY_PORT		1024	//通知端口\r\n#define SERVER_REFRESH_PORT		1025	//刷新端口\r\n#define SERVER_TRANSFER_PORT	1026	//传输端口\r\n#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令\r\n#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\n//结构体定义\r\n//---------------------------------------------------------------------------------------------------------\r\n#pragma pack(4)  //设置结构体按照4字节对齐\r\nstruct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到\r\n{\r\n	char				filename[100];	//文件名\r\n	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址\r\n	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字\r\n};\r\nstruct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传\r\n{\r\n	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传\r\n	union\r\n	{\r\n		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体\r\n		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字\r\n	};\r\n};\r\nstruct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件\r\n{\r\n	SOCKET	sock;						//告诉客户端是谁想下载他的文件\r\n	char	filename[100];				//告诉客户端想下载他的哪个文件\r\n};\r\n#pragma pack()  //取消结构体的字节对齐\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\n//全局变量\r\n//---------------------------------------------------------------------------------------------------------\r\n//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体\r\nstd::multimap<SOCKET, SHARED_FILE>		g_shared_files;\r\n//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝\r\nstd::vector<SHARED_FILE>				g_files_list;\r\nstd::vector<SHARED_FILE>				g_files_list2;\r\nunsigned int							g_serverip;				//服务器的IP，网络字节序表示	\r\nHANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问\r\nHANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\nint mysend(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = send(sock, buf + sent, remain, flags);\r\n		if (n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\nint myrecv(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出\r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器用于判断某个客户端是否下线\r\n//参数：服务器上对应于某个客户端的通知套接字\r\n//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线\r\n//创建者：server_notify_thread()\r\nDWORD WINAPI server_quit_thread(LPVOID lpParam)\r\n{\r\n	SOCKET comm_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		char c;\r\n		int ret = recv(comm_sock, &c, 1, 0);\r\n		if (ret == 0 || ret == -1)\r\n			break;\r\n	}\r\n	printf(\"有一个客户端退出了\\n\");\r\n\r\n	//删除g_shared_files中的信息\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	g_shared_files.erase(comm_sock);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器把最新共享文件列表发给客户端\r\n//参数：服务器在刷新端口上的监听套接字\r\n//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端\r\n//创建者：main()\r\nDWORD WINAPI server_refresh_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_refresh_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;\r\n	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)\r\n		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	//最后发一个空文件名告诉客户端已发完\r\n	SHARED_FILE sf;\r\n	sf.filename[0] = \'\\0\';\r\n	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);\r\n\r\n	closesocket(comm_sock);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器接受一个客户端上线\r\n//参数：服务器在通知端口上的监听套接字\r\n//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射\r\n//创建者：main()\r\nDWORD WINAPI server_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_notify_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);\r\n	printf(\"有一个客户端上线了\\n\");\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n	char buf[100];\r\n	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字\r\n	sf.client_addr = client_addr;\r\n	sf.notify_sock = comm_sock;\r\n	while (1)\r\n	{\r\n		myrecv(comm_sock, buf, 100, 0);\r\n		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名\r\n			break;\r\n		strcpy(sf.filename, buf);\r\n\r\n		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p\r\n		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息\r\n		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v\r\n	}\r\n\r\n	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器为文件传输做中转服务\r\n//参数：服务器在传输端口上的监听套接字\r\n//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转\r\n//创建者：main()\r\nDWORD WINAPI server_transfer_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_transfer_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n	//接收一个“传输头部”\r\n	TRANSFER_HEADER th;\r\n	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件\r\n	{\r\n		//构造一个“通知头部”准备发给被下载方\r\n		NOTIFY_HEADER nh;\r\n		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字\r\n		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方\r\n\r\n		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字\r\n		SOCKET client_notify_sock = th.shared_file.notify_sock;\r\n\r\n		//向这个通知套接字发送“通知头部”\r\n		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出\r\n			closesocket(comm_sock);\r\n	}\r\n	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件\r\n	{\r\n		//从“传输头部”中取出下载方对应的套接字\r\n		SOCKET download_client_sock = th.sock;\r\n\r\n		//循环接收数据并转发给下载方\r\n		char buf[1024];\r\n		while (1)\r\n		{\r\n			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节\r\n			if (i > 0)\r\n				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节\r\n			else\r\n			{\r\n				closesocket(download_client_sock);\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端每隔10秒向服务器请求最新共享文件列表\r\n//参数：NULL\r\n//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示\r\n//创建者：main()\r\nDWORD WINAPI client_refresh_thread(LPVOID lpParam)\r\n{\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n\r\n	while (1)\r\n	{\r\n		//创建流套接字并连接到服务器的刷新端口\r\n		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n		//接收最新共享文件列表\r\n		while (1)\r\n		{\r\n			SHARED_FILE sf;\r\n			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体\r\n\r\n			if (sf.filename[0] != \'\\0\')  //如果不是空文件名\r\n				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面\r\n			else  //空文件名，表示服务器本次发送共享文件列表已经完毕\r\n				break;\r\n		}\r\n\r\n\r\n		closesocket(refresh_sock);\r\n\r\n		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		g_files_list2.clear();\r\n		g_files_list2 = g_files_list;\r\n		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表\r\n		printf(\"最新共享文件列表：\\n\");\r\n\r\n		std::vector<SHARED_FILE>::const_iterator it;\r\n		int i = 1;\r\n		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)\r\n		{\r\n			printf(\"%d - %s:%d上的%s\", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);\r\n			printf(\"\\n\");\r\n		}\r\n		printf(\"请输入文件的序号进行下载（0-退出）：\\n\");\r\n\r\n		Sleep(10000);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端进行文件上传\r\n//参数：指向“通知头部”的指针\r\n//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件\r\n//创建者：client_notify_thread()\r\nDWORD WINAPI client_upload_thread(LPVOID lpParam)\r\n{\r\n	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;\r\n\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示上传的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传\r\n	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字\r\n	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	FILE *fp = fopen(pnh->filename, \"rb\");\r\n	if (fp != NULL)\r\n		printf(\"开始上传文件%s\\n\", pnh->filename);\r\n	else\r\n	{\r\n		printf(\"找不到文件%s，上传失败\\n\", pnh->filename);\r\n		closesocket(client_upload_sock);\r\n		delete pnh;\r\n		return 0;\r\n	}\r\n\r\n	//循环读取文件数据并上传\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = fread(buf, 1, 1024, fp);\r\n		mysend(client_upload_sock, buf, i, 0);\r\n		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_upload_sock);\r\n	printf(\"文件%s上传完成\\n\", pnh->filename);\r\n\r\n	delete pnh;\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端响应服务器发来的通知\r\n//参数：客户端已经同服务器的通知端口建立连接的通知套接字\r\n//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传\r\n//创建者：main()\r\nDWORD WINAPI client_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET client_notify_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		//接收一个“通知头部”\r\n		NOTIFY_HEADER nh;\r\n		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		printf(\"收到一个下载%s的通知\\n\", nh.filename);\r\n\r\n		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖\r\n		*pnh = nh;\r\n		//创建线程，用来上传文件\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端进行指定文件的下载\r\n//参数：指向想下载的共享文件结构体的指针\r\n//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘\r\n//创建者：client_userinput_thread()\r\nDWORD WINAPI client_download_thread(LPVOID lpParam)\r\n{\r\n	SHARED_FILE *psf = (SHARED_FILE *)lpParam;\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示下载的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载\r\n	th.shared_file = *psf;  //指明想下载哪一个文件\r\n	delete psf;\r\n	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	printf(\"开始下载%s:%d的%s\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	FILE *fp = fopen(th.shared_file.filename, \"wb\");\r\n	//循环接收数据并写入文件\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()\r\n		if (i > 0)\r\n			fwrite(buf, 1, i, fp);\r\n		else\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_download_sock);\r\n	printf(\"%s:%d的%s下载完毕\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端接收并处理用户的键盘输入\r\n//参数：NULL\r\n//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载\r\n//创建者：main()\r\nDWORD WINAPI client_userinput_thread(LPVOID lpParam)\r\n{\r\n	int number;\r\n	while (1)\r\n	{\r\n		scanf(\"%d\", &number);\r\n		//客户端退出的方式是用户按下0\r\n		if (number == 0)\r\n		{\r\n			CloseHandle(g_client_semaphore);\r\n			exit(0);\r\n		}\r\n\r\n		//为防止此时正在刷新 g_files_list2，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		if (number > g_files_list2.size())\r\n			printf(\"请输入正确的序号\\n\");\r\n		else\r\n		{\r\n			SHARED_FILE *psf = new SHARED_FILE;\r\n			*psf = g_files_list2[number - 1];\r\n\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			struct sockaddr_in clientAddr;\r\n			int clientAddrLen = sizeof(clientAddr);\r\n			//用于获取与某个套接字关联的本地协议地址\r\n			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\n			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数\r\n\r\n			SHARED_FILE	sel_file = *psf;\r\n\r\n			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数\r\n			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))\r\n			{\r\n				printf(\"不能下载自己的文件\\n\");\r\n			}\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			else\r\n			{\r\n				//创建线程，用来完成下载任务\r\n				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);\r\n			}\r\n\r\n			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	if (argc == 1)\r\n	{\r\n		printf(\"使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n\");\r\n		return 0;\r\n	}\r\n\r\n	//下面4行进行Windows网络环境的初始化。Linux中不需要\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n\r\n	if (argc == 2 && strcmp(argv[1], \"-server\") == 0)\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改\r\n		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		//创建通知端口的监听套接字\r\n		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_notify_sock, 5);\r\n		//创建线程，用来在通知端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n		//创建刷新端口的监听套接字\r\n		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_refresh_sock, 5);\r\n		//创建线程，用来在刷新端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n		//创建传输端口的监听套接字\r\n		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_transfer_sock, 5);\r\n		//创建线程，用来在传输端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n		printf(\"服务器在3个端口开始监听连接请求\\n\");\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else if (argc >= 3 && strcmp(argv[1], \"-client\") == 0) //xx.exe -client s_ip xxx xxx\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写\r\n		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		g_serverip = inet_addr(argv[2]);\r\n\r\n		//创建用于连接到服务器通知端口的套接字\r\n		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = g_serverip;\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		printf(\"客户端请求连接成功\\n\");\r\n\r\n		//发送共享文件名，文件名长度与服务器约定为100字节\r\n		char buf[100];\r\n		int i;\r\n		for (i = 3; i<argc; i++)\r\n		{\r\n			strcpy(buf, argv[i]);\r\n			mysend(client_notify_sock, buf, 100, 0);\r\n		}\r\n		//最后发送一个空文件名告诉服务器共享文件名已发完\r\n		buf[0] = \'\\0\';\r\n		mysend(client_notify_sock, buf, 100, 0);\r\n		printf(\"客户端发送共享文件名成功\\n\");\r\n\r\n		//创建线程，用来接收服务器发来的“通知头部”\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，每隔10秒向服务器请求最新的共享文件列表\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，用来接收用户的键盘输入\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else\r\n		printf(\"启动参数不正确\\n\");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n/*\r\n服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。\r\n	通知\r\n		等待连接：server_notify_sock\r\n		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n\r\n		创建线程 server_quit_thread：\r\n			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)\r\n\r\n	刷新\r\n		等待连接：server_refresh_sock\r\n		- 向客户端发送共享文件列表\r\n\r\n	传输\r\n		等待连接：server_transfer_sock\r\n		- 服务器接收一个“传输头部”，判断是下载还是上传\r\n			下载：\r\n				构造一个“通知头部”发给被下载方\r\n				client_notify_thread：...\r\n			上传：	\r\n				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方\r\n				client_download_thread：循环接收数据并写入文件\r\n\r\n//----------------------------------------------------------------------\r\n客户端： xx.exe -client s_ip xxx xxx\r\n\r\n	连接服务器通知端口告知上线，发送共享文件名\r\n		服务器：接收客户端发来的共享文件名\r\n				server_quit_thread\r\n\r\n	创建 3 个线程：\r\n\r\n	client_refresh_thread：\r\n		创建流套接字并连接到服务器的刷新端口\r\n		接收最新共享文件列表\r\n\r\n	client_userinput_thread：\r\n		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，\r\n			client_download_thread：\r\n				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...\r\n				给服务器发送表示下载的“传输头部”\r\n				循环接收数据并写入文件\r\n\r\n	client_notify_thread：\r\n		接收一个“通知头部”\r\n		创建线程，client_upload_thread：\r\n			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口\r\n			构造一个表示上传的“传输头部”并发送给服务器\r\n			循环读取文件数据并上传\r\n\r\n*/\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识'  WHERE  `id` = 212 [ RunTime:0.002254s ]
---------------------------------------------------------------
[ 2018-11-16T21:08:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.062681s][吞吐率：15.95req/s] [内存消耗：2,148.06kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/updatenote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000572s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002424s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000585s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001009s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000327s ]
---------------------------------------------------------------
[ 2018-11-16T21:08:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.054482s][吞吐率：18.35req/s] [内存消耗：2,148.06kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/updatenote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000637s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001427s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000752s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000947s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000347s ]
---------------------------------------------------------------
[ 2018-11-16T21:09:53+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.068059s][吞吐率：14.69req/s] [内存消耗：2,622.20kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '181113',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
*输出*
```
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33
```

### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
```
// FileDownloadThroughServer.cpp : Defines the entry point for the console application.
//

/***********************************************************************************************************
功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。
***********************************************************************************************************/


#include "stdafx.h"
#include "stdio.h"
#include <map>
#include <vector>
#include "Winsock2.h"
#pragma comment(lib, "ws2_32.lib")


//宏定义
//********************************************************************************************************-
#define SERVER_NOTIFY_PORT		1024	//通知端口
#define SERVER_REFRESH_PORT		1025	//刷新端口
#define SERVER_TRANSFER_PORT	1026	//传输端口
#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令
#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令
//********************************************************************************************************-


//结构体定义
//********************************************************************************************************-
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
	char				filename[100];	//文件名
	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址
	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传
	union
	{
		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体
		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
	};
};
struct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
	SOCKET	sock;						//告诉客户端是谁想下载他的文件
	char	filename[100];				//告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//********************************************************************************************************-


//全局变量
//********************************************************************************************************-
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap<SOCKET, SHARED_FILE>		g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector<SHARED_FILE>				g_files_list;
std::vector<SHARED_FILE>				g_files_list2;
unsigned int							g_serverip;				//服务器的IP，网络字节序表示	
HANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//********************************************************************************************************-


int mysend(SOCKET sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while (remain > 0)
	{
		int n = send(sock, buf + sent, remain, flags);
		if (n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while (remain > 0)
	{
		int n = recv(sock, buf + received, remain, flags);
		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
			break;
		remain -= n;
		received += n;
	}
	return received;
}

//******************************************************************************************************-
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
	SOCKET comm_sock = (SOCKET)lpParam;

	while (1)
	{
		char c;
		int ret = recv(comm_sock, &c, 1, 0);
		if (ret == 0 || ret == -1)
			break;
	}
	printf("有一个客户端退出了\\n");

	//删除g_shared_files中的信息
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	g_shared_files.erase(comm_sock);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
	SOCKET server_refresh_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);
	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;
	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	//最后发一个空文件名告诉客户端已发完
	SHARED_FILE sf;
	sf.filename[0] = \'\\0\';
	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);

	closesocket(comm_sock);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
	SOCKET server_notify_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);
	printf("有一个客户端上线了\\n");

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
	char buf[100];
	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字
	sf.client_addr = client_addr;
	sf.notify_sock = comm_sock;
	while (1)
	{
		myrecv(comm_sock, buf, 100, 0);
		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名
			break;
		strcpy(sf.filename, buf);

		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
	}

	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
	SOCKET server_transfer_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

	//接收一个“传输头部”
	TRANSFER_HEADER th;
	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);
	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
	{
		//构造一个“通知头部”准备发给被下载方
		NOTIFY_HEADER nh;
		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
		SOCKET client_notify_sock = th.shared_file.notify_sock;

		//向这个通知套接字发送“通知头部”
		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
			closesocket(comm_sock);
	}
	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
	{
		//从“传输头部”中取出下载方对应的套接字
		SOCKET download_client_sock = th.sock;

		//循环接收数据并转发给下载方
		char buf[1024];
		while (1)
		{
			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
			if (i > 0)
				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
			else
			{
				closesocket(download_client_sock);
				break;
			}
		}
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_REFRESH_PORT);

	while (1)
	{
		//创建流套接字并连接到服务器的刷新端口
		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

		//接收最新共享文件列表
		while (1)
		{
			SHARED_FILE sf;
			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

			if (sf.filename[0] != \'\\0\')  //如果不是空文件名
				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
			else  //空文件名，表示服务器本次发送共享文件列表已经完毕
				break;
		}


		closesocket(refresh_sock);

		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		g_files_list2.clear();
		g_files_list2 = g_files_list;
		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
		printf("最新共享文件列表：\\n");

		std::vector<SHARED_FILE>::const_iterator it;
		int i = 1;
		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
		{
			printf("%d - %s:%d上的%s", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);
			printf("\\n");
		}
		printf("请输入文件的序号进行下载（0-退出）：\\n");

		Sleep(10000);
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示上传的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字
	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	FILE *fp = fopen(pnh->filename, "rb");
	if (fp != NULL)
		printf("开始上传文件%s\\n", pnh->filename);
	else
	{
		printf("找不到文件%s，上传失败\\n", pnh->filename);
		closesocket(client_upload_sock);
		delete pnh;
		return 0;
	}

	//循环读取文件数据并上传
	char buf[1024];
	while (1)
	{
		int i = fread(buf, 1, 1024, fp);
		mysend(client_upload_sock, buf, i, 0);
		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了
			break;
	}
	fclose(fp);
	closesocket(client_upload_sock);
	printf("文件%s上传完成\\n", pnh->filename);

	delete pnh;
	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
	SOCKET client_notify_sock = (SOCKET)lpParam;

	while (1)
	{
		//接收一个“通知头部”
		NOTIFY_HEADER nh;
		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		printf("收到一个下载%s的通知\\n", nh.filename);

		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
		*pnh = nh;
		//创建线程，用来上传文件
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
	SHARED_FILE *psf = (SHARED_FILE *)lpParam;

	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示下载的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
	th.shared_file = *psf;  //指明想下载哪一个文件
	delete psf;
	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	printf("开始下载%s:%d的%s\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	FILE *fp = fopen(th.shared_file.filename, "wb");
	//循环接收数据并写入文件
	char buf[1024];
	while (1)
	{
		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
		if (i > 0)
			fwrite(buf, 1, i, fp);
		else
			break;
	}
	fclose(fp);
	closesocket(client_download_sock);
	printf("%s:%d的%s下载完毕\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
	int number;
	while (1)
	{
		scanf("%d", &number);
		//客户端退出的方式是用户按下0
		if (number == 0)
		{
			CloseHandle(g_client_semaphore);
			exit(0);
		}

		//为防止此时正在刷新 g_files_list2，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		if (number > g_files_list2.size())
			printf("请输入正确的序号\\n");
		else
		{
			SHARED_FILE *psf = new SHARED_FILE;
			*psf = g_files_list2[number - 1];

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			struct sockaddr_in clientAddr;
			int clientAddrLen = sizeof(clientAddr);
			//用于获取与某个套接字关联的本地协议地址
			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数

			SHARED_FILE	sel_file = *psf;

			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数
			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
			{
				printf("不能下载自己的文件\\n");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			else
			{
				//创建线程，用来完成下载任务
				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
			}

			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		}
	}

	return 0;
}
//******************************************************************************************************-

int main(int argc, char* argv[])
{
	if (argc == 1)
	{
		printf("使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n");
		return 0;
	}

	//下面4行进行Windows网络环境的初始化。Linux中不需要
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);

	if (argc == 2 && strcmp(argv[1], "-server") == 0)
	{
		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		//创建通知端口的监听套接字
		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_notify_sock, 5);
		//创建线程，用来在通知端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

		//创建刷新端口的监听套接字
		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_REFRESH_PORT);
		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_refresh_sock, 5);
		//创建线程，用来在刷新端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

		//创建传输端口的监听套接字
		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_transfer_sock, 5);
		//创建线程，用来在传输端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

		printf("服务器在3个端口开始监听连接请求\\n");

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else if (argc >= 3 && strcmp(argv[1], "-client") == 0) //xx.exe -client s_ip xxx xxx
	{
		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		g_serverip = inet_addr(argv[2]);

		//创建用于连接到服务器通知端口的套接字
		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = g_serverip;
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		printf("客户端请求连接成功\\n");

		//发送共享文件名，文件名长度与服务器约定为100字节
		char buf[100];
		int i;
		for (i = 3; i<argc; i++)
		{
			strcpy(buf, argv[i]);
			mysend(client_notify_sock, buf, 100, 0);
		}
		//最后发送一个空文件名告诉服务器共享文件名已发完
		buf[0] = \'\\0\';
		mysend(client_notify_sock, buf, 100, 0);
		printf("客户端发送共享文件名成功\\n");

		//创建线程，用来接收服务器发来的“通知头部”
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，每隔10秒向服务器请求最新的共享文件列表
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，用来接收用户的键盘输入
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else
		printf("启动参数不正确\\n");

	return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
	通知
		等待连接：server_notify_sock
		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

		创建线程 server_quit_thread：
			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

	刷新
		等待连接：server_refresh_sock
		- 向客户端发送共享文件列表

	传输
		等待连接：server_transfer_sock
		- 服务器接收一个“传输头部”，判断是下载还是上传
			下载：
				构造一个“通知头部”发给被下载方
				client_notify_thread：...
			上传：	
				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
				client_download_thread：循环接收数据并写入文件

**********************************************************************
客户端： xx.exe -client s_ip xxx xxx

	连接服务器通知端口告知上线，发送共享文件名
		服务器：接收客户端发来的共享文件名
				server_quit_thread

	创建 3 个线程：

	client_refresh_thread：
		创建流套接字并连接到服务器的刷新端口
		接收最新共享文件列表

	client_userinput_thread：
		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
			client_download_thread：
				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
				给服务器发送表示下载的“传输头部”
				循环接收数据并写入文件

	client_notify_thread：
		接收一个“通知头部”
		创建线程，client_upload_thread：
			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
			构造一个表示上传的“传输头部”并发送给服务器
			循环读取文件数据并上传

*/
```',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000590s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001511s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000656s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000324s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000877s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000371s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000278s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验：fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n========================================================================*/\r\n\r\n```\r\n\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n>不 sleep 的输出：\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n----------------------------------------------------------\r\n>sleep() 后的输出：\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n========================================================================*/\r\n```\r\n\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验：李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n### 信号量\r\n#### 信号量的概念\r\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\r\n1. 测试控制该资源的信号量。\r\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\r\n\r\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\r\n\r\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\r\n\r\n#### 信号量的创建与打开 semget\r\n函数声明：`int semget(key_t key,int nsems,int semflg)`\r\n\r\nkey：所创建或打开的信号量集合的键\r\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\r\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\r\n\r\n返回：\r\n- 成功：返回信号量ID\r\n- 失败：-1，并设置 errno\r\n\r\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\r\n\r\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\r\n\r\n#### 对信号量的控制 semctl\r\n\r\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\r\n\r\nsemid：为信号量集合的标识符。\r\nsemnum：用于指明某个特定信号量。\r\ncmd：表示调用该函数希望执行的命令\r\ncmd 的常用设置：\r\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\r\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\r\n\r\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\r\n```\r\nunion semen{\r\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\r\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\r\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\r\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\r\n};\r\n```\r\n\r\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\r\n```\r\nushort semid_ds{\r\n	struct ipc_perm sem_perm;	//所有者和标致权限\r\n	time_t sem_otime;	//最后操作时间\r\n	time_t sem_ctime;	//最后更改时间\r\n	unsigned short sem_nsems;	//信号集中的信号数量\r\n}\r\n```\r\n\r\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\r\n#### 对信号量的操作——semop\r\n改变信号量的值\r\n\r\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\r\n\r\nsemid：为信号量集合的ID\r\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\r\n```\r\nstruct sembuf{\r\n	short sem_num;	//信号量在信号集中的编号\r\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\r\n	short sem_flag;	//标志位\r\n};\r\n```\r\nnops：参数 sops 所指数组中元素的个数\r\n\r\n返回：若成功则为 0，若出错则为 -1。\r\n\r\n### 共享内存\r\n#### 共享内存的概念\r\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\r\n\r\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\r\n\r\n#### 共享内存的创建和打开 shmget\r\n函数声明：`int shmget(key_t key, int size, int flag) ;`\r\n\r\nkey：表示所创建或打开的共享内存的键\r\nsize：表示共享内存区域的大小\r\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\r\n\r\n返回：若成功则为共享内存ID，若出错则为 -1。\r\n\r\n#### 共享内存的附加 shmat\r\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\r\n\r\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\r\n`\r\n\r\nshmid：表示要附加的共享内存段的ID\r\naddr：虚拟地址\r\nflag：用于表示函数的操作方式\r\n\r\n返回：若成功则为指向共享内存段的指针，若出错则为-1\r\n\r\n#### 共享内存的分离 shmdt\r\n解除物理内存与进程虚拟地址空间的映射关系\r\n\r\n函数声明：`int shmdt(void *addr) ;`\r\n\r\naddr：是以前调用 shmat 时的返回值。\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n#### 共享内存的控制 shmctl\r\n对共享内存段执行多种操作。\r\n\r\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\r\n`\r\nshmid：为共享内存的标识符\r\ncmd：表示调用该函数希望执行的操作\r\n\r\n---\r\ncmd 的取值和对应操作如下：\r\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\r\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\r\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\r\n\r\n---\r\nbuf：指向 shmid_ds 结构体的指针\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。	\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n//semun 共用体\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;//信号量ID\r\nint shmid;//共享内存ID\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\n// P操作，获取信号量，-1\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\r\n	semop(semid, &buf, 1);	//改变信号量的值\r\n}\r\n\r\n// V操作，释放信号量，+1\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\r\n	\r\n	//删除信号量\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n\r\n	//删除共享内存\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	//int semget(key_t key,int nsems,int semflg)\r\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\r\n	//成功：返回信号量ID，失败：-1\r\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\r\n\r\n	if(semid == -1)	//信号量创建失败\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	 //返回信号量ID\r\n		printf(\"create semaphore ok\\n\");\r\n	}\r\n\r\n	//semun 共用体\r\n	union semun x;\r\n	x.val = 1;  //信号量初值应为多少？为1\r\n\r\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\r\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\r\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\r\n	\r\n	//int shmget(key_t key, int size, int flag);\r\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\r\n	//若成功则为共享内存ID，若出错则为 -1\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\r\n	if(shmid == -1)	\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	//返回共享内存ID\r\n		printf(\"create shared-memory ok\\n\");\r\n	}\r\n\r\n	//void *shmat(int shmid, void *addr, int flag) ;\r\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\r\n	//成功则为指向共享内存段的指针，若出错则为-1\r\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\r\n\r\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\r\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\r\n\r\n	//flag 是否是子进程\r\n	char is_child = 0;\r\n	int i;\r\n	//循环创建 10 个进程\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork(); \r\n		if(pid == 0)	//子进程\r\n		{\r\n			is_child = 1;  //设置子进程中 is_child 为 1\r\n			break;  //退出循环\r\n		}\r\n	}\r\n\r\n	//子进程\r\n	if(is_child)\r\n	{\r\n		p(semid);  // P操作，获取信号量（-1）\r\n\r\n		srand(time(NULL) + i);	//设置随机种子数\r\n		int num = rand()%10;	//取 0-9 随机数\r\n\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\r\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作，释放信号量（+1）\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\r\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();//挂起，等待信号唤醒\r\n	}\r\n\r\n	return 0;\r\n}\r\n/*========================================================================\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n========================================================================*/\r\n```\r\n## socket 编程接口\r\n### 套接口概念\r\n套接口实际就是网络进程的 PID（Process ID）。\r\n\r\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\r\n### 阻塞模式和非阻塞模式（同步和异步）\r\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\r\n\r\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\r\n\r\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\r\n\r\n### getsockname/getpeername\r\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\r\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\r\n*函数定义*\r\n```\r\n#include<sys/socket.h>\r\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\r\n```\r\n\r\n### 字节序转换\r\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\r\n\r\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\r\n\r\n#### 返回网络字节序 htons/htonl\r\n`u_short htons(u_short hostshort);`\r\n\r\n`u_long htonl(u_long hostlong);`\r\n\r\n#### 返回主机字节序 ntohs/ntohl\r\n`u_short ntohs(u_short netshort);`\r\n\r\n`u_long ntohl(u_long netlong);`\r\n\r\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\r\n### 地址转换函数\r\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\r\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\r\n要实现两者之间的转换，就要用到以下两个函数：\r\n\r\n`unsigned long inet_addr(const char FAR* cp);`\r\n\r\n成功：返回 32 位二进制的网络字节序地址\r\n出错：返回 INADDR_NONE。\r\n\r\n`char FAR* inet_ntoa(struct in_addr in);`\r\n\r\n成功：返回字符串的指针\r\n失败：返回 NULL\r\n\r\n### 流套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\r\n客户端：创建套接字——请求连接。\r\n\r\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\r\n\r\n最后，通信完毕，任意一方都可关闭套接字。\r\n### 数据报套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\r\n客户端：创建套接字——直接进行数据的发送。\r\n\r\n通信完毕，任意一方都可关闭套接字。\r\n\r\n### sockaddr 和 sockaddr_in 结构体\r\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\r\n\r\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\r\n\r\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\r\n```\r\nstruct sockaddr\r\n{\r\n	unit8_t	sa_len;\r\n	sa_family_t	sa_family;	//协议族名\r\n	char	sa_data[14];\r\n}\r\n```\r\n\r\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\r\n```\r\nstruct sockaddr_in\r\n{\r\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\r\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\r\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\r\n	struct in_addr sin_addr;\r\n	char	sin_zero[8];	//备用的域名，未使用\r\n};\r\nstruct in_addr\r\n{\r\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\r\n};\r\n```\r\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\r\n\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\r\n\r\n### 套接口函数\r\n#### 总结步骤\r\n>一个服务器进程中系统调用的顺序通常如下\r\n\r\nsocket();\r\nbind();\r\nlisten();\r\naccept();\r\n>而客户端进程的调用则比较简单\r\n\r\nsocket();\r\nconnect();\r\n#### 创建套接字 socket\r\n\r\n`int socket(int family,int type,int protocol);`\r\n\r\nfamily：指明协议族\r\ntype：指明套接口类型\r\nprotocol：一般为 0\r\n\r\n成功：返回值为非负描述字\r\n失败：返回值为负值\r\n\r\n>参数 family 的取值范围\r\n\r\nAF_LOCAL：UNIX 协议族\r\nAF_ROUTE：路由套接口\r\nAF_INET：IPv4 协议\r\nAF_INET6：IPV6 协议\r\nAF_KEY：密钥套接口\r\n\r\n>参数 type 的取值范围\r\n\r\nSOCK_STREAM：TCP 套接口\r\nSOCK_DGRAM：UDP 套接口\r\nSOCK_PACKET：支持数据链路访问\r\nSOCK_RAM：原始套接口\r\n\r\n#### 绑定套接口 bind\r\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\r\n\r\nsockfd：套接字\r\nmyaddr：是一个指向特定协议地址结构体的指针\r\naddrlen：是地址结构体的长度。\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\r\n\r\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\r\n\r\n#### 连接 connect\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\nsockfd：套接口描述字\r\nserv_addr：目的端口和IP地址的套接口\r\naddrlen：目的套接口的长度\r\n\r\n成功：返回 0\r\n失败：返回 -l\r\n\r\n#### 监听 listen\r\n`int listen(int sockfd,int backlog);`\r\n\r\nsockfd：套接字\r\nbacklog：规定内核为此套接口排队的最大选择个数\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 接受连接 accept (阻塞函数)\r\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\r\n\r\ncliaddr：远程客户的套接口地址\r\naddrlen：套接口地址长度\r\nsockfd：监听套接字，它由函数 socket() 生成\r\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\r\n\r\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\r\n失败：返回 -1\r\n\r\n>客户套接和监听套接字的区别：\r\n\r\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\r\n\r\n>accept()是一个阻塞函数\r\n\r\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\r\n\r\n#### 关闭 close\r\n`int close(int sockfd);`\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 发送 send/sendto (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int send(int sockfd,const void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\r\n\r\n#### 接收 recv/recvfrom (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int recv(int sockfd,void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\r\n\r\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\r\n\r\n>Mysend 方法\r\n\r\n```\r\nint Mysend(SOCKET s, const char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iSendCount = 0:\r\n	int iLength = len:\r\n	while (iLength > 0)\r\n	{\r\n		int n = send(s, buf* iSendCount, iLength, flags);\r\n		if(n == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= n:\r\n		iSendCount += n:\r\n	}\r\n	return iSendCount\r\n}\r\n```\r\n\r\n>Myrecv 方法\r\n\r\n```\r\nint Myrecv(SOCKET s, char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iRecvCount = 0;\r\n	int iLength = len;\r\n	while (iLength > 0)\r\n	{\r\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\r\n		if(nReU == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= nRev;\r\n		iRecuCount += nRev;\r\n	}\r\n	return iRecvCount;\r\n}\r\n```\r\n## 多线程\r\n### 线程函数的原型\r\n#### Windows\r\n`DWOED ThreadProc(LPVOID lpParameter);`\r\n### 创建新线程\r\n#### Windows - CreateThread\r\nWin32 API 函数 ：CreateThread()\r\n```\r\nHANDLE CreateThread(\r\n	LPSECURITY_ATTRIBUTES lpsa,\r\n	DWORD cbStack,\r\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\r\n	LPVOID lpvThreadParam,	//传给线程函数的参数\r\n	DWORD fdwCreate,\r\n	LPDWORD lpIDThread\r\n);\r\n```\r\n#### Unix - pthread_create\r\n```\r\n#include  <pthread.h>\r\nint  pthread_create（\r\n	pthread_t  *thread,	//待传入线程的线程ID指针\r\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n	void  *arg	//要传给线程执行函数的参数\r\n）\r\n```\r\n### 一个线程等待另一个线程结束的方法\r\n#### Unix - pthread_join\r\n```\r\n#include  <pthread.h>\r\nint pthread_join(\r\n	pthread_t thread,\r\n	void **retval\r\n);\r\n```\r\n### Linux 中编译多线程程序的方法\r\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\r\n\r\n### 线程的并发（同步）问题\r\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\r\n\r\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\r\n\r\nWindows 中主要函数有：\r\n```\r\nCreateSemaphore() //创建信号量\r\nWaitForSingleObject() //获取信号量，P\r\nReleaseSemaphore() //释放信号量，V\r\nCloseHandle() //关闭一个内核对象\r\n```\r\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\r\n```\r\n/*------------------------------------------------------------------------------------------------\r\n任务：\r\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\r\n思路：\r\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\r\n-------------------------------------------------------------------------------*/\r\n\r\n//=======================================================================================\r\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \r\n//=======================================================================================\r\n\r\n///*------------------------ Windows 的头文件 ----------------------------\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <time.h>\r\n#include <Winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\r\n//----------------------------------------------------------------------*/\r\n\r\n/*------------------------- Linux 的头文件 -----------------------------\r\n#include <sys/types.h>\r\n#include <sys/ipc.h>\r\n#include <sys/sem.h>\r\n#include <pthread.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h> \r\n#include <netinet/in.h> \r\n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\r\n-----------------------------------------------------------------------*/\r\n\r\n//=========================================\r\n//            	全局变量\r\n//=========================================\r\n\r\n//-------------------------- 判断平台 -------------------------\r\n#ifdef WINDOWS_VERSION //windows 平台\r\n	HANDLE  g_hSem;    //信号量的句柄\r\n	HANDLE  g_hThread[10];  //10个线程的句柄\r\n#else //Linux 平台\r\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\r\n	{\r\n		int val;\r\n		struct semid_ds *buf;\r\n		ushort *array;\r\n	};\r\n	int   semid;    //信号量的ID\r\n	pthread_t thread_id[10];  //10个线程的ID\r\n#endif\r\n	int  total;      //和\r\n	int  listen_sock;    //用于监听的套接字\r\n	short port;      //端口\r\n//----------------------------------------------------\r\n\r\n/**\r\n * 发送\r\n */\r\nint mysend(int sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int send(int sockfd,const void *buffer,int length,int flags);\r\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\r\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\n/**\r\n * 接收一个整数(阻塞函数)\r\n */\r\nint myrecv(int sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int recv(int sockfd,void *buffer,int length,int flags);\r\n		//返回：0是对方调用close()，-1是对方直接退出\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if(n == 0 || n == -1)  \r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n/**\r\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\r\n * \r\n * @param num 进程编号\r\n */\r\nvoid send_num_to_parent(int num)\r\n{\r\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET;\r\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\r\n	server_addr.sin_port  = htons(port);\r\n \r\n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\r\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\r\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\r\n\r\n	mysend(sock, (char *)&num, 4, 0);\r\n\r\n#ifdef WINDOWS_VERSION\r\n	closesocket(sock);\r\n#else\r\n	close(sock);\r\n#endif\r\n}\r\n\r\n#ifndef WINDOWS_VERSION\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n#endif\r\n\r\n\r\n#ifdef WINDOWS_VERSION\r\n	DWORD WINAPI thread_function(void *arg) \r\n#else\r\n	/**\r\n	 * 线程函数\r\n	 * 处理 accept，并创建下一个线程\r\n	 */\r\n	void *thread_function(void *arg)\r\n#endif\r\n	{ \r\n		int index = (int)arg;	//序号\r\n\r\n		//准备接受连接请求\r\n		struct sockaddr_in peer_addr;//套接口地址结构体\r\n		int size = sizeof(struct sockaddr_in);\r\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\r\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\r\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\r\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\r\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\r\n \r\n		//accept 完毕，创建下一个线程\r\n		if(index < 9)\r\n#ifdef WINDOWS_VERSION\r\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\r\n#else\r\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\r\n#endif\r\n\r\n		//自己，服务端\r\n		int num;\r\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\r\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\r\n\r\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\r\n#ifdef WINDOWS_VERSION\r\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\r\n		total += num;\r\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\r\n		closesocket(comm_sock);\r\n		// ExitThread(0);\r\n		return 0;//线程结束\r\n#else\r\n		p(semid);\r\n		total += num;\r\n		v(semid);\r\n		//int close(int sockfd);\r\n		//成功：返回 0，失败：返回 -1\r\n		close(comm_sock);\r\n		pthread_exit(NULL);\r\n#endif\r\n	}\r\n\r\n/**\r\n * 父进程(服务器)\r\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\r\n */\r\nvoid init_socket()\r\n{\r\n	//int socket(int family,int type,int protocol);\r\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\r\n	//成功：返回值为非负描述字，失败：返回值为负值\r\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\r\n\r\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET; //IP_V4\r\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\r\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\r\n\r\n	//随机产生一个端口号，但要大于1024才行\r\n	srand(time(NULL));  \r\n	port = rand()%10000;\r\n	while(port < 1024)\r\n		port = rand()%10000;\r\n\r\n	//htons：将主机的无符号短整形数转换为网络字节顺序\r\n	server_addr.sin_port = htons(port);\r\n\r\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\r\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\r\n	//成功：返回 0，失败：返回 -1\r\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\r\n\r\n	//int listen(int sockfd,int backlog);\r\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\r\n	//成功：返回 0，失败：返回 -1\r\n	listen(listen_sock, 5);//将套接字置于监听状态\r\n\r\n	printf(\"parent : 服务器开始监听连接请求\\n\");\r\n}\r\n\r\n/**\r\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\r\n * @param i 线程编号	\r\n */\r\nvoid do_child(int i)\r\n{\r\n	srand(time(NULL) + i);\r\n	int num = rand()%10;\r\n\r\n	printf(\"child%d: %d\\n\", i, num);\r\n\r\n	send_num_to_parent(num);\r\n}\r\n\r\n/**\r\n * 主函数\r\n *\r\n * @param  argc 命令行输入的参数个数\r\n * @param  argv 字符二维数组\r\n */\r\nint main(int argc, char* argv[])\r\n{\r\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \r\n#ifdef WINDOWS_VERSION\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n#endif\r\n\r\n	// Windows 中的父进程，Linux 中的父、子进程\r\n	if(argc == 1)  \r\n	{\r\n		total = 0;	//初始化 total 为 0 \r\n\r\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\r\n#ifdef WINDOWS_VERSION\r\n		//1 个信号量，初始为 1\r\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\r\n#else\r\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\r\n		union semun x;\r\n		x.val = 1;\r\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\r\n#endif\r\n  \r\n		//初始化网络环境，完成服务器的准备工作\r\n		init_socket();\r\n\r\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\r\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\r\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\r\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\r\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\r\n#else\r\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\r\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\r\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n		//	void  *arg	//要传给线程执行函数的参数\r\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\r\n#endif\r\n\r\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\r\n#ifdef WINDOWS_VERSION\r\n		STARTUPINFO si;\r\n		PROCESS_INFORMATION pi;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			//处理命令行字符串\r\n			char *p = GetCommandLine();\r\n			char strCmdLine[256];\r\n			strcpy(strCmdLine, p);\r\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\r\n\r\n			ZeroMemory( &si, sizeof(si) );\r\n			si.cb = sizeof(si);\r\n			ZeroMemory( &pi, sizeof(pi) );\r\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\r\n		}\r\n		//等待 10 个线程结束\r\n		for(i=0; i<10; i++)\r\n			WaitForSingleObject(g_hThread[i], INFINITE);\r\n#else\r\n		char is_child = 0;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			pid_t pid = fork();\r\n			if(pid == 0)\r\n			{\r\n				is_child = 1;\r\n				break;\r\n			}\r\n		}\r\n		if(is_child)\r\n		{\r\n			do_child(i);\r\n			return 0;\r\n		}\r\n		else\r\n		{\r\n			//等待 10 个线程结束\r\n			for(i=0; i<10; i++)\r\n				pthread_join(thread_id[i], NULL);\r\n		}\r\n#endif\r\n		printf(\"parent : all threads ended, total=%d\\n\", total);\r\n\r\n//删除信号量\r\n#ifdef WINDOWS_VERSION\r\n		CloseHandle(g_hSem);\r\n#else\r\n		semctl(semid, IPC_RMID, 0);\r\n#endif\r\n	}\r\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \r\n	{\r\n#ifdef WINDOWS_VERSION\r\n		char *p = GetCommandLine();\r\n		//下面 2 行从命令行中解析出端口号\r\n		p = strchr(p, \'-\');\r\n		sscanf(p+1, \"%d\", &port);\r\n\r\n		//下面 3 行从命令行中解析出子进程的序号\r\n		p = strchr(p+1, \'-\');\r\n		int index;\r\n		sscanf(p+1, \"%d\", &index);\r\n		do_child(index);\r\n#endif\r\n	}\r\n else\r\n	printf(\"启动命令不正确\\n\");\r\n	return 0;\r\n}\r\n```\r\n*输出*\r\n```\r\nparent : 服务器开始监听连接请求\r\nchild0: 1\r\nparent : 线程0接受一个连接请求\r\nparent : 线程0接收到一个整数1\r\nchild1: 4\r\nparent : 线程1接受一个连接请求\r\nparent : 线程1接收到一个整数4\r\nchild2: 7\r\nparent : 线程2接受一个连接请求\r\nparent : 线程2接收到一个整数7\r\nchild3: 0\r\nparent : 线程3接受一个连接请求\r\nparent : 线程3接收到一个整数0\r\nchild5: 7\r\nchild4: 4\r\nparent : 线程4接受一个连接请求\r\nchild6: 0\r\nchild7: 3\r\nchild8: 7\r\nparent : 线程4接收到一个整数7\r\nchild9: 0\r\nparent : 线程5接受一个连接请求\r\nparent : 线程5接收到一个整数4\r\nparent : 线程6接受一个连接请求\r\nparent : 线程6接收到一个整数0\r\nparent : 线程7接受一个连接请求\r\nparent : 线程7接收到一个整数3\r\nparent : 线程8接受一个连接请求\r\nparent : 线程8接收到一个整数7\r\nparent : 线程9接受一个连接请求\r\nparent : 线程9接收到一个整数0\r\nparent : all threads ended, total=33\r\n```\r\n\r\n### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n```\r\n// FileDownloadThroughServer.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n/***********************************************************************************************************\r\n功能：\r\n建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。\r\n文件存在于各个客户端上，而不在服务器上。\r\n要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n思路：\r\n1.服务器至少应该开放3个TCP端口供客户端连接。\r\n(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。\r\n(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。\r\n(3)第三个用来提供文件传输的中转服务，叫做传输端口。\r\n2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量\r\n应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。\r\n3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。\r\n其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。\r\n4.服务器和客户端都要大量使用多线程。\r\n5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，\r\n第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，\r\n二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和\r\n退出时都要被修改，所以必须有并发控制。\r\n6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是\r\n共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以\r\n防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。\r\n7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，\r\n然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。\r\n客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的\r\n“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个\r\n“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的\r\n文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传\r\n的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。\r\n考查：\r\n1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。\r\n2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，\r\n使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。\r\n3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。\r\n4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示\r\n这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时\r\n也会下载不成功，而且服务器有不确定的动作。试进行debug。\r\n***********************************************************************************************************/\r\n\r\n\r\n#include \"stdafx.h\"\r\n#include \"stdio.h\"\r\n#include <map>\r\n#include <vector>\r\n#include \"Winsock2.h\"\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\n\r\n//宏定义\r\n//********************************************************************************************************-\r\n#define SERVER_NOTIFY_PORT		1024	//通知端口\r\n#define SERVER_REFRESH_PORT		1025	//刷新端口\r\n#define SERVER_TRANSFER_PORT	1026	//传输端口\r\n#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令\r\n#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令\r\n//********************************************************************************************************-\r\n\r\n\r\n//结构体定义\r\n//********************************************************************************************************-\r\n#pragma pack(4)  //设置结构体按照4字节对齐\r\nstruct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到\r\n{\r\n	char				filename[100];	//文件名\r\n	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址\r\n	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字\r\n};\r\nstruct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传\r\n{\r\n	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传\r\n	union\r\n	{\r\n		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体\r\n		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字\r\n	};\r\n};\r\nstruct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件\r\n{\r\n	SOCKET	sock;						//告诉客户端是谁想下载他的文件\r\n	char	filename[100];				//告诉客户端想下载他的哪个文件\r\n};\r\n#pragma pack()  //取消结构体的字节对齐\r\n//********************************************************************************************************-\r\n\r\n\r\n//全局变量\r\n//********************************************************************************************************-\r\n//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体\r\nstd::multimap<SOCKET, SHARED_FILE>		g_shared_files;\r\n//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝\r\nstd::vector<SHARED_FILE>				g_files_list;\r\nstd::vector<SHARED_FILE>				g_files_list2;\r\nunsigned int							g_serverip;				//服务器的IP，网络字节序表示	\r\nHANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问\r\nHANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问\r\n//********************************************************************************************************-\r\n\r\n\r\nint mysend(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = send(sock, buf + sent, remain, flags);\r\n		if (n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\nint myrecv(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出\r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器用于判断某个客户端是否下线\r\n//参数：服务器上对应于某个客户端的通知套接字\r\n//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线\r\n//创建者：server_notify_thread()\r\nDWORD WINAPI server_quit_thread(LPVOID lpParam)\r\n{\r\n	SOCKET comm_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		char c;\r\n		int ret = recv(comm_sock, &c, 1, 0);\r\n		if (ret == 0 || ret == -1)\r\n			break;\r\n	}\r\n	printf(\"有一个客户端退出了\\n\");\r\n\r\n	//删除g_shared_files中的信息\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	g_shared_files.erase(comm_sock);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器把最新共享文件列表发给客户端\r\n//参数：服务器在刷新端口上的监听套接字\r\n//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端\r\n//创建者：main()\r\nDWORD WINAPI server_refresh_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_refresh_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;\r\n	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)\r\n		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	//最后发一个空文件名告诉客户端已发完\r\n	SHARED_FILE sf;\r\n	sf.filename[0] = \'\\0\';\r\n	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);\r\n\r\n	closesocket(comm_sock);\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器接受一个客户端上线\r\n//参数：服务器在通知端口上的监听套接字\r\n//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射\r\n//创建者：main()\r\nDWORD WINAPI server_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_notify_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);\r\n	printf(\"有一个客户端上线了\\n\");\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n	char buf[100];\r\n	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字\r\n	sf.client_addr = client_addr;\r\n	sf.notify_sock = comm_sock;\r\n	while (1)\r\n	{\r\n		myrecv(comm_sock, buf, 100, 0);\r\n		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名\r\n			break;\r\n		strcpy(sf.filename, buf);\r\n\r\n		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p\r\n		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息\r\n		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v\r\n	}\r\n\r\n	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器为文件传输做中转服务\r\n//参数：服务器在传输端口上的监听套接字\r\n//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转\r\n//创建者：main()\r\nDWORD WINAPI server_transfer_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_transfer_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n	//接收一个“传输头部”\r\n	TRANSFER_HEADER th;\r\n	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件\r\n	{\r\n		//构造一个“通知头部”准备发给被下载方\r\n		NOTIFY_HEADER nh;\r\n		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字\r\n		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方\r\n\r\n		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字\r\n		SOCKET client_notify_sock = th.shared_file.notify_sock;\r\n\r\n		//向这个通知套接字发送“通知头部”\r\n		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出\r\n			closesocket(comm_sock);\r\n	}\r\n	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件\r\n	{\r\n		//从“传输头部”中取出下载方对应的套接字\r\n		SOCKET download_client_sock = th.sock;\r\n\r\n		//循环接收数据并转发给下载方\r\n		char buf[1024];\r\n		while (1)\r\n		{\r\n			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节\r\n			if (i > 0)\r\n				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节\r\n			else\r\n			{\r\n				closesocket(download_client_sock);\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端每隔10秒向服务器请求最新共享文件列表\r\n//参数：NULL\r\n//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示\r\n//创建者：main()\r\nDWORD WINAPI client_refresh_thread(LPVOID lpParam)\r\n{\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n\r\n	while (1)\r\n	{\r\n		//创建流套接字并连接到服务器的刷新端口\r\n		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n		//接收最新共享文件列表\r\n		while (1)\r\n		{\r\n			SHARED_FILE sf;\r\n			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体\r\n\r\n			if (sf.filename[0] != \'\\0\')  //如果不是空文件名\r\n				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面\r\n			else  //空文件名，表示服务器本次发送共享文件列表已经完毕\r\n				break;\r\n		}\r\n\r\n\r\n		closesocket(refresh_sock);\r\n\r\n		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		g_files_list2.clear();\r\n		g_files_list2 = g_files_list;\r\n		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表\r\n		printf(\"最新共享文件列表：\\n\");\r\n\r\n		std::vector<SHARED_FILE>::const_iterator it;\r\n		int i = 1;\r\n		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)\r\n		{\r\n			printf(\"%d - %s:%d上的%s\", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);\r\n			printf(\"\\n\");\r\n		}\r\n		printf(\"请输入文件的序号进行下载（0-退出）：\\n\");\r\n\r\n		Sleep(10000);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端进行文件上传\r\n//参数：指向“通知头部”的指针\r\n//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件\r\n//创建者：client_notify_thread()\r\nDWORD WINAPI client_upload_thread(LPVOID lpParam)\r\n{\r\n	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;\r\n\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示上传的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传\r\n	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字\r\n	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	FILE *fp = fopen(pnh->filename, \"rb\");\r\n	if (fp != NULL)\r\n		printf(\"开始上传文件%s\\n\", pnh->filename);\r\n	else\r\n	{\r\n		printf(\"找不到文件%s，上传失败\\n\", pnh->filename);\r\n		closesocket(client_upload_sock);\r\n		delete pnh;\r\n		return 0;\r\n	}\r\n\r\n	//循环读取文件数据并上传\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = fread(buf, 1, 1024, fp);\r\n		mysend(client_upload_sock, buf, i, 0);\r\n		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_upload_sock);\r\n	printf(\"文件%s上传完成\\n\", pnh->filename);\r\n\r\n	delete pnh;\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端响应服务器发来的通知\r\n//参数：客户端已经同服务器的通知端口建立连接的通知套接字\r\n//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传\r\n//创建者：main()\r\nDWORD WINAPI client_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET client_notify_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		//接收一个“通知头部”\r\n		NOTIFY_HEADER nh;\r\n		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		printf(\"收到一个下载%s的通知\\n\", nh.filename);\r\n\r\n		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖\r\n		*pnh = nh;\r\n		//创建线程，用来上传文件\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端进行指定文件的下载\r\n//参数：指向想下载的共享文件结构体的指针\r\n//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘\r\n//创建者：client_userinput_thread()\r\nDWORD WINAPI client_download_thread(LPVOID lpParam)\r\n{\r\n	SHARED_FILE *psf = (SHARED_FILE *)lpParam;\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示下载的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载\r\n	th.shared_file = *psf;  //指明想下载哪一个文件\r\n	delete psf;\r\n	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	printf(\"开始下载%s:%d的%s\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	FILE *fp = fopen(th.shared_file.filename, \"wb\");\r\n	//循环接收数据并写入文件\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()\r\n		if (i > 0)\r\n			fwrite(buf, 1, i, fp);\r\n		else\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_download_sock);\r\n	printf(\"%s:%d的%s下载完毕\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端接收并处理用户的键盘输入\r\n//参数：NULL\r\n//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载\r\n//创建者：main()\r\nDWORD WINAPI client_userinput_thread(LPVOID lpParam)\r\n{\r\n	int number;\r\n	while (1)\r\n	{\r\n		scanf(\"%d\", &number);\r\n		//客户端退出的方式是用户按下0\r\n		if (number == 0)\r\n		{\r\n			CloseHandle(g_client_semaphore);\r\n			exit(0);\r\n		}\r\n\r\n		//为防止此时正在刷新 g_files_list2，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		if (number > g_files_list2.size())\r\n			printf(\"请输入正确的序号\\n\");\r\n		else\r\n		{\r\n			SHARED_FILE *psf = new SHARED_FILE;\r\n			*psf = g_files_list2[number - 1];\r\n\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			struct sockaddr_in clientAddr;\r\n			int clientAddrLen = sizeof(clientAddr);\r\n			//用于获取与某个套接字关联的本地协议地址\r\n			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\n			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数\r\n\r\n			SHARED_FILE	sel_file = *psf;\r\n\r\n			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数\r\n			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))\r\n			{\r\n				printf(\"不能下载自己的文件\\n\");\r\n			}\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			else\r\n			{\r\n				//创建线程，用来完成下载任务\r\n				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);\r\n			}\r\n\r\n			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	if (argc == 1)\r\n	{\r\n		printf(\"使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n\");\r\n		return 0;\r\n	}\r\n\r\n	//下面4行进行Windows网络环境的初始化。Linux中不需要\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n\r\n	if (argc == 2 && strcmp(argv[1], \"-server\") == 0)\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改\r\n		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		//创建通知端口的监听套接字\r\n		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_notify_sock, 5);\r\n		//创建线程，用来在通知端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n		//创建刷新端口的监听套接字\r\n		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_refresh_sock, 5);\r\n		//创建线程，用来在刷新端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n		//创建传输端口的监听套接字\r\n		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_transfer_sock, 5);\r\n		//创建线程，用来在传输端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n		printf(\"服务器在3个端口开始监听连接请求\\n\");\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else if (argc >= 3 && strcmp(argv[1], \"-client\") == 0) //xx.exe -client s_ip xxx xxx\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写\r\n		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		g_serverip = inet_addr(argv[2]);\r\n\r\n		//创建用于连接到服务器通知端口的套接字\r\n		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = g_serverip;\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		printf(\"客户端请求连接成功\\n\");\r\n\r\n		//发送共享文件名，文件名长度与服务器约定为100字节\r\n		char buf[100];\r\n		int i;\r\n		for (i = 3; i<argc; i++)\r\n		{\r\n			strcpy(buf, argv[i]);\r\n			mysend(client_notify_sock, buf, 100, 0);\r\n		}\r\n		//最后发送一个空文件名告诉服务器共享文件名已发完\r\n		buf[0] = \'\\0\';\r\n		mysend(client_notify_sock, buf, 100, 0);\r\n		printf(\"客户端发送共享文件名成功\\n\");\r\n\r\n		//创建线程，用来接收服务器发来的“通知头部”\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，每隔10秒向服务器请求最新的共享文件列表\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，用来接收用户的键盘输入\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else\r\n		printf(\"启动参数不正确\\n\");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n/*\r\n服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。\r\n	通知\r\n		等待连接：server_notify_sock\r\n		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n\r\n		创建线程 server_quit_thread：\r\n			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)\r\n\r\n	刷新\r\n		等待连接：server_refresh_sock\r\n		- 向客户端发送共享文件列表\r\n\r\n	传输\r\n		等待连接：server_transfer_sock\r\n		- 服务器接收一个“传输头部”，判断是下载还是上传\r\n			下载：\r\n				构造一个“通知头部”发给被下载方\r\n				client_notify_thread：...\r\n			上传：	\r\n				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方\r\n				client_download_thread：循环接收数据并写入文件\r\n\r\n**********************************************************************\r\n客户端： xx.exe -client s_ip xxx xxx\r\n\r\n	连接服务器通知端口告知上线，发送共享文件名\r\n		服务器：接收客户端发来的共享文件名\r\n				server_quit_thread\r\n\r\n	创建 3 个线程：\r\n\r\n	client_refresh_thread：\r\n		创建流套接字并连接到服务器的刷新端口\r\n		接收最新共享文件列表\r\n\r\n	client_userinput_thread：\r\n		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，\r\n			client_download_thread：\r\n				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...\r\n				给服务器发送表示下载的“传输头部”\r\n				循环接收数据并写入文件\r\n\r\n	client_notify_thread：\r\n		接收一个“通知头部”\r\n		创建线程，client_upload_thread：\r\n			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口\r\n			构造一个表示上传的“传输头部”并发送给服务器\r\n			循环读取文件数据并上传\r\n\r\n*/\r\n```',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识'  WHERE  `id` = 212 [ RunTime:0.001973s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001022s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000360s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000870s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=11  WHERE  `groups` = 'Linux' [ RunTime:0.000336s ]
---------------------------------------------------------------
[ 2018-11-16T21:09:54+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.063463s][吞吐率：15.76req/s] [内存消耗：2,095.86kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000445s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001212s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000717s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000879s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000346s ]
---------------------------------------------------------------
[ 2018-11-16T21:10:14+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.053898s][吞吐率：18.55req/s] [内存消耗：2,147.55kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000607s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001449s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000545s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000939s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000305s ]
---------------------------------------------------------------
[ 2018-11-16T21:10:16+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.087316s][吞吐率：11.45req/s] [内存消耗：2,020.94kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000672s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001731s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000401s ]
---------------------------------------------------------------
[ 2018-11-16T21:10:37+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ info ] qingrang.top/daily/admin/note/addnote.html [运行时间：0.062793s][吞吐率：15.93req/s] [内存消耗：2,334.43kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'addnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '136543',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Default',
  'content' => '# text
```
// FileDownloadThroughServer.cpp : Defines the entry point for the console application.
//

/***********************************************************************************************************
功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。
***********************************************************************************************************/


#include "stdafx.h"
#include "stdio.h"
#include <map>
#include <vector>
#include "Winsock2.h"
#pragma comment(lib, "ws2_32.lib")


//宏定义
//********************************************************************************************************-
#define SERVER_NOTIFY_PORT		1024	//通知端口
#define SERVER_REFRESH_PORT		1025	//刷新端口
#define SERVER_TRANSFER_PORT	1026	//传输端口
#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令
#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令
//********************************************************************************************************-


//结构体定义
//********************************************************************************************************-
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
	char				filename[100];	//文件名
	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址
	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传
	union
	{
		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体
		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
	};
};
struct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
	SOCKET	sock;						//告诉客户端是谁想下载他的文件
	char	filename[100];				//告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//********************************************************************************************************-


//全局变量
//********************************************************************************************************-
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap<SOCKET, SHARED_FILE>		g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector<SHARED_FILE>				g_files_list;
std::vector<SHARED_FILE>				g_files_list2;
unsigned int							g_serverip;				//服务器的IP，网络字节序表示	
HANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//********************************************************************************************************-


int mysend(SOCKET sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while (remain > 0)
	{
		int n = send(sock, buf + sent, remain, flags);
		if (n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while (remain > 0)
	{
		int n = recv(sock, buf + received, remain, flags);
		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
			break;
		remain -= n;
		received += n;
	}
	return received;
}

//******************************************************************************************************-
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
	SOCKET comm_sock = (SOCKET)lpParam;

	while (1)
	{
		char c;
		int ret = recv(comm_sock, &c, 1, 0);
		if (ret == 0 || ret == -1)
			break;
	}
	printf("有一个客户端退出了\\n");

	//删除g_shared_files中的信息
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	g_shared_files.erase(comm_sock);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
	SOCKET server_refresh_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);
	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;
	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	//最后发一个空文件名告诉客户端已发完
	SHARED_FILE sf;
	sf.filename[0] = \'\\0\';
	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);

	closesocket(comm_sock);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
	SOCKET server_notify_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);
	printf("有一个客户端上线了\\n");

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
	char buf[100];
	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字
	sf.client_addr = client_addr;
	sf.notify_sock = comm_sock;
	while (1)
	{
		myrecv(comm_sock, buf, 100, 0);
		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名
			break;
		strcpy(sf.filename, buf);

		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
	}

	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
	SOCKET server_transfer_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

	//接收一个“传输头部”
	TRANSFER_HEADER th;
	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);
	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
	{
		//构造一个“通知头部”准备发给被下载方
		NOTIFY_HEADER nh;
		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
		SOCKET client_notify_sock = th.shared_file.notify_sock;

		//向这个通知套接字发送“通知头部”
		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
			closesocket(comm_sock);
	}
	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
	{
		//从“传输头部”中取出下载方对应的套接字
		SOCKET download_client_sock = th.sock;

		//循环接收数据并转发给下载方
		char buf[1024];
		while (1)
		{
			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
			if (i > 0)
				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
			else
			{
				closesocket(download_client_sock);
				break;
			}
		}
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_REFRESH_PORT);

	while (1)
	{
		//创建流套接字并连接到服务器的刷新端口
		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

		//接收最新共享文件列表
		while (1)
		{
			SHARED_FILE sf;
			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

			if (sf.filename[0] != \'\\0\')  //如果不是空文件名
				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
			else  //空文件名，表示服务器本次发送共享文件列表已经完毕
				break;
		}


		closesocket(refresh_sock);

		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		g_files_list2.clear();
		g_files_list2 = g_files_list;
		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
		printf("最新共享文件列表：\\n");

		std::vector<SHARED_FILE>::const_iterator it;
		int i = 1;
		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
		{
			printf("%d - %s:%d上的%s", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);
			printf("\\n");
		}
		printf("请输入文件的序号进行下载（0-退出）：\\n");

		Sleep(10000);
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示上传的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字
	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	FILE *fp = fopen(pnh->filename, "rb");
	if (fp != NULL)
		printf("开始上传文件%s\\n", pnh->filename);
	else
	{
		printf("找不到文件%s，上传失败\\n", pnh->filename);
		closesocket(client_upload_sock);
		delete pnh;
		return 0;
	}

	//循环读取文件数据并上传
	char buf[1024];
	while (1)
	{
		int i = fread(buf, 1, 1024, fp);
		mysend(client_upload_sock, buf, i, 0);
		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了
			break;
	}
	fclose(fp);
	closesocket(client_upload_sock);
	printf("文件%s上传完成\\n", pnh->filename);

	delete pnh;
	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
	SOCKET client_notify_sock = (SOCKET)lpParam;

	while (1)
	{
		//接收一个“通知头部”
		NOTIFY_HEADER nh;
		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		printf("收到一个下载%s的通知\\n", nh.filename);

		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
		*pnh = nh;
		//创建线程，用来上传文件
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
	SHARED_FILE *psf = (SHARED_FILE *)lpParam;

	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示下载的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
	th.shared_file = *psf;  //指明想下载哪一个文件
	delete psf;
	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	printf("开始下载%s:%d的%s\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	FILE *fp = fopen(th.shared_file.filename, "wb");
	//循环接收数据并写入文件
	char buf[1024];
	while (1)
	{
		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
		if (i > 0)
			fwrite(buf, 1, i, fp);
		else
			break;
	}
	fclose(fp);
	closesocket(client_download_sock);
	printf("%s:%d的%s下载完毕\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
	int number;
	while (1)
	{
		scanf("%d", &number);
		//客户端退出的方式是用户按下0
		if (number == 0)
		{
			CloseHandle(g_client_semaphore);
			exit(0);
		}

		//为防止此时正在刷新 g_files_list2，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		if (number > g_files_list2.size())
			printf("请输入正确的序号\\n");
		else
		{
			SHARED_FILE *psf = new SHARED_FILE;
			*psf = g_files_list2[number - 1];

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			struct sockaddr_in clientAddr;
			int clientAddrLen = sizeof(clientAddr);
			//用于获取与某个套接字关联的本地协议地址
			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数

			SHARED_FILE	sel_file = *psf;

			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数
			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
			{
				printf("不能下载自己的文件\\n");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			else
			{
				//创建线程，用来完成下载任务
				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
			}

			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		}
	}

	return 0;
}
//******************************************************************************************************-

int main(int argc, char* argv[])
{
	if (argc == 1)
	{
		printf("使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n");
		return 0;
	}

	//下面4行进行Windows网络环境的初始化。Linux中不需要
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);

	if (argc == 2 && strcmp(argv[1], "-server") == 0)
	{
		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		//创建通知端口的监听套接字
		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_notify_sock, 5);
		//创建线程，用来在通知端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

		//创建刷新端口的监听套接字
		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_REFRESH_PORT);
		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_refresh_sock, 5);
		//创建线程，用来在刷新端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

		//创建传输端口的监听套接字
		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_transfer_sock, 5);
		//创建线程，用来在传输端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

		printf("服务器在3个端口开始监听连接请求\\n");

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else if (argc >= 3 && strcmp(argv[1], "-client") == 0) //xx.exe -client s_ip xxx xxx
	{
		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		g_serverip = inet_addr(argv[2]);

		//创建用于连接到服务器通知端口的套接字
		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = g_serverip;
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		printf("客户端请求连接成功\\n");

		//发送共享文件名，文件名长度与服务器约定为100字节
		char buf[100];
		int i;
		for (i = 3; i<argc; i++)
		{
			strcpy(buf, argv[i]);
			mysend(client_notify_sock, buf, 100, 0);
		}
		//最后发送一个空文件名告诉服务器共享文件名已发完
		buf[0] = \'\\0\';
		mysend(client_notify_sock, buf, 100, 0);
		printf("客户端发送共享文件名成功\\n");

		//创建线程，用来接收服务器发来的“通知头部”
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，每隔10秒向服务器请求最新的共享文件列表
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，用来接收用户的键盘输入
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else
		printf("启动参数不正确\\n");

	return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
	通知
		等待连接：server_notify_sock
		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

		创建线程 server_quit_thread：
			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

	刷新
		等待连接：server_refresh_sock
		- 向客户端发送共享文件列表

	传输
		等待连接：server_transfer_sock
		- 服务器接收一个“传输头部”，判断是下载还是上传
			下载：
				构造一个“通知头部”发给被下载方
				client_notify_thread：...
			上传：	
				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
				client_download_thread：循环接收数据并写入文件

**********************************************************************
客户端： xx.exe -client s_ip xxx xxx

	连接服务器通知端口告知上线，发送共享文件名
		服务器：接收客户端发来的共享文件名
				server_quit_thread

	创建 3 个线程：

	client_refresh_thread：
		创建流套接字并连接到服务器的刷新端口
		接收最新共享文件列表

	client_userinput_thread：
		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
			client_download_thread：
				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
				给服务器发送表示下载的“传输头部”
				循环接收数据并写入文件

	client_notify_thread：
		接收一个“通知头部”
		创建线程，client_upload_thread：
			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
			构造一个表示上传的“传输头部”并发送给服务器
			循环读取文件数据并上传

*/
```',
  'test-editormd-html-code' => '<h1 id="h1-text"><a name="text" class="reference-link"></a><span class="header-link octicon octicon-link"></span>text</h1><pre><code>// FileDownloadThroughServer.cpp : Defines the entry point for the console application.
//

/***********************************************************************************************************
功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。
***********************************************************************************************************/


#include &quot;stdafx.h&quot;
#include &quot;stdio.h&quot;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &quot;Winsock2.h&quot;
#pragma comment(lib, &quot;ws2_32.lib&quot;)


//宏定义
//********************************************************************************************************-
#define SERVER_NOTIFY_PORT        1024    //通知端口
#define SERVER_REFRESH_PORT        1025    //刷新端口
#define SERVER_TRANSFER_PORT    1026    //传输端口
#define COMMAND_DOWNLOAD        0        //“传输头部”中表示下载的命令
#define COMMAND_UPLOAD            1        //“传输头部”中表示上传的命令
//********************************************************************************************************-


//结构体定义
//********************************************************************************************************-
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE                        //共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
    char                filename[100];    //文件名
    struct sockaddr_in    client_addr;    //文件所在的客户端的网络地址
    SOCKET                notify_sock;    //服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER                    //“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
    int cmd;                            //命令，指明本次传输是为了下载还是上传，0-下载，1-上传
    union
    {
        SHARED_FILE    shared_file;        //如果是下载，需要告诉服务器想下载的共享文件结构体
        SOCKET        sock;                //如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
    };
};
struct NOTIFY_HEADER                    //“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
    SOCKET    sock;                        //告诉客户端是谁想下载他的文件
    char    filename[100];                //告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//********************************************************************************************************-


//全局变量
//********************************************************************************************************-
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap&lt;SOCKET, SHARED_FILE&gt;        g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector&lt;SHARED_FILE&gt;                g_files_list;
std::vector&lt;SHARED_FILE&gt;                g_files_list2;
unsigned int                            g_serverip;                //服务器的IP，网络字节序表示    
HANDLE                                    g_server_semaphore;        //服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE                                    g_client_semaphore;        //客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//********************************************************************************************************-


int mysend(SOCKET sock, char *buf, int len, int flags)
{
    int sent = 0, remain = len;
    while (remain &gt; 0)
    {
        int n = send(sock, buf + sent, remain, flags);
        if (n == -1)  //出错的最大可能是对方关闭了套接字
            break;
        remain -= n;
        sent += n;
    }
    return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
    int received = 0, remain = len;
    while (remain &gt; 0)
    {
        int n = recv(sock, buf + received, remain, flags);
        if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
            break;
        remain -= n;
        received += n;
    }
    return received;
}

//******************************************************************************************************-
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
    SOCKET comm_sock = (SOCKET)lpParam;

    while (1)
    {
        char c;
        int ret = recv(comm_sock, &amp;c, 1, 0);
        if (ret == 0 || ret == -1)
            break;
    }
    printf(&quot;有一个客户端退出了\\n&quot;);

    //删除g_shared_files中的信息
    WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
    g_shared_files.erase(comm_sock);
    ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
    SOCKET server_refresh_sock = (SOCKET)lpParam;

    sockaddr_in client_addr;
    int size = sizeof(client_addr);
    SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&amp;client_addr, &amp;size);
    //创建线程，用来等待下一个连接请求
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

    //向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
    WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
    std::multimap&lt;SOCKET, SHARED_FILE&gt;::const_iterator it;
    for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
        mysend(comm_sock, (char *)&amp;(it-&gt;second), sizeof(SHARED_FILE), 0);
    ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

    //最后发一个空文件名告诉客户端已发完
    SHARED_FILE sf;
    sf.filename[0] = &#39;\\0&#39;;
    mysend(comm_sock, (char *)&amp;sf, sizeof(SHARED_FILE), 0);

    closesocket(comm_sock);

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
    SOCKET server_notify_sock = (SOCKET)lpParam;

    sockaddr_in client_addr;
    int size = sizeof(client_addr);
    SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&amp;client_addr, &amp;size);
    printf(&quot;有一个客户端上线了\\n&quot;);

    //创建线程，用来等待下一个连接请求
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

    //接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
    char buf[100];
    SHARED_FILE sf;    //文件名，客户端网络地址，客户端通知套接字
    sf.client_addr = client_addr;
    sf.notify_sock = comm_sock;
    while (1)
    {
        myrecv(comm_sock, buf, 100, 0);
        if (buf[0] == &#39;\\0&#39;)  //空文件名，说明客户端已发完所有共享文件名
            break;
        strcpy(sf.filename, buf);

        WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
        g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
        ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
    }

    //创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
    SOCKET server_transfer_sock = (SOCKET)lpParam;

    sockaddr_in client_addr;
    int size = sizeof(client_addr);
    SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&amp;client_addr, &amp;size);

    //创建线程，用来等待下一个连接请求
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

    //接收一个“传输头部”
    TRANSFER_HEADER th;
    myrecv(comm_sock, (char *)&amp;th, sizeof(TRANSFER_HEADER), 0);
    if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
    {
        //构造一个“通知头部”准备发给被下载方
        NOTIFY_HEADER nh;
        nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
        strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

        //从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
        SOCKET client_notify_sock = th.shared_file.notify_sock;

        //向这个通知套接字发送“通知头部”
        int ret = mysend(client_notify_sock, (char *)&amp;nh, sizeof(NOTIFY_HEADER), 0);
        if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
            closesocket(comm_sock);
    }
    else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
    {
        //从“传输头部”中取出下载方对应的套接字
        SOCKET download_client_sock = th.sock;

        //循环接收数据并转发给下载方
        char buf[1024];
        while (1)
        {
            int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
            if (i &gt; 0)
                mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
            else
            {
                closesocket(download_client_sock);
                break;
            }
        }
    }

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = g_serverip;
    server_addr.sin_port = htons(SERVER_REFRESH_PORT);

    while (1)
    {
        //创建流套接字并连接到服务器的刷新端口
        SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
        connect(refresh_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));

        //接收最新共享文件列表
        while (1)
        {
            SHARED_FILE sf;
            myrecv(refresh_sock, (char *)&amp;sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

            if (sf.filename[0] != &#39;\\0&#39;)  //如果不是空文件名
                g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
            else  //空文件名，表示服务器本次发送共享文件列表已经完毕
                break;
        }


        closesocket(refresh_sock);

        //为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
        WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
        g_files_list2.clear();
        g_files_list2 = g_files_list;
        ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
        g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
        printf(&quot;最新共享文件列表：\\n&quot;);

        std::vector&lt;SHARED_FILE&gt;::const_iterator it;
        int i = 1;
        for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
        {
            printf(&quot;%d - %s:%d上的%s&quot;, i, inet_ntoa(it-&gt;client_addr.sin_addr), ntohs(it-&gt;client_addr.sin_port), it-&gt;filename);
            printf(&quot;\\n&quot;);
        }
        printf(&quot;请输入文件的序号进行下载（0-退出）：\\n&quot;);

        Sleep(10000);
    }

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
    NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


    //创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
    SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = g_serverip;
    server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
    connect(client_upload_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));

    //构造一个表示上传的“传输头部”并发送给服务器
    TRANSFER_HEADER th;
    th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
    th.sock = pnh-&gt;sock;  //指明想下载这个文件的客户端套接字
    mysend(client_upload_sock, (char *)&amp;th, sizeof(TRANSFER_HEADER), 0);

    FILE *fp = fopen(pnh-&gt;filename, &quot;rb&quot;);
    if (fp != NULL)
        printf(&quot;开始上传文件%s\\n&quot;, pnh-&gt;filename);
    else
    {
        printf(&quot;找不到文件%s，上传失败\\n&quot;, pnh-&gt;filename);
        closesocket(client_upload_sock);
        delete pnh;
        return 0;
    }

    //循环读取文件数据并上传
    char buf[1024];
    while (1)
    {
        int i = fread(buf, 1, 1024, fp);
        mysend(client_upload_sock, buf, i, 0);
        if (i &lt; 1024)  //fread()没读满1024个字节表示是最后一次读文件了
            break;
    }
    fclose(fp);
    closesocket(client_upload_sock);
    printf(&quot;文件%s上传完成\\n&quot;, pnh-&gt;filename);

    delete pnh;
    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
    SOCKET client_notify_sock = (SOCKET)lpParam;

    while (1)
    {
        //接收一个“通知头部”
        NOTIFY_HEADER nh;
        myrecv(client_notify_sock, (char *)&amp;nh, sizeof(NOTIFY_HEADER), 0);
        printf(&quot;收到一个下载%s的通知\\n&quot;, nh.filename);

        NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
        *pnh = nh;
        //创建线程，用来上传文件
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
    }

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
    SHARED_FILE *psf = (SHARED_FILE *)lpParam;

    //创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
    SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = g_serverip;
    server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
    connect(client_download_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));

    //构造一个表示下载的“传输头部”并发送给服务器
    TRANSFER_HEADER th;
    th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
    th.shared_file = *psf;  //指明想下载哪一个文件
    delete psf;
    mysend(client_download_sock, (char *)&amp;th, sizeof(TRANSFER_HEADER), 0);

    printf(&quot;开始下载%s:%d的%s\\n&quot;, inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

    FILE *fp = fopen(th.shared_file.filename, &quot;wb&quot;);
    //循环接收数据并写入文件
    char buf[1024];
    while (1)
    {
        int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
        if (i &gt; 0)
            fwrite(buf, 1, i, fp);
        else
            break;
    }
    fclose(fp);
    closesocket(client_download_sock);
    printf(&quot;%s:%d的%s下载完毕\\n&quot;, inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

    return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
    int number;
    while (1)
    {
        scanf(&quot;%d&quot;, &amp;number);
        //客户端退出的方式是用户按下0
        if (number == 0)
        {
            CloseHandle(g_client_semaphore);
            exit(0);
        }

        //为防止此时正在刷新 g_files_list2，进行并发控制
        WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
        if (number &gt; g_files_list2.size())
            printf(&quot;请输入正确的序号\\n&quot;);
        else
        {
            SHARED_FILE *psf = new SHARED_FILE;
            *psf = g_files_list2[number - 1];

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            struct sockaddr_in clientAddr;
            int clientAddrLen = sizeof(clientAddr);
            //用于获取与某个套接字关联的本地协议地址
            //int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
            getsockname((SOCKET)lpParam, (struct sockaddr *)&amp;clientAddr, &amp;clientAddrLen);//添加getsockname函数

            SHARED_FILE    sel_file = *psf;

            //char FAR* inet_ntoa(struct in_addr in); 地址转换函数
            if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) &amp;&amp; ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
            {
                printf(&quot;不能下载自己的文件\\n&quot;);
            }
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else
            {
                //创建线程，用来完成下载任务
                CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
            }

            ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
        }
    }

    return 0;
}
//******************************************************************************************************-

int main(int argc, char* argv[])
{
    if (argc == 1)
    {
        printf(&quot;使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n&quot;);
        return 0;
    }

    //下面4行进行Windows网络环境的初始化。Linux中不需要
    WORD wVersionRequested;
    WSADATA wsaData;
    wVersionRequested = MAKEWORD(2, 2);
    WSAStartup(wVersionRequested, &amp;wsaData);

    if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;-server&quot;) == 0)
    {
        //创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
        g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

        //创建通知端口的监听套接字
        SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
        sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
        bind(server_notify_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
        listen(server_notify_sock, 5);
        //创建线程，用来在通知端口上接受连接请求
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

        //创建刷新端口的监听套接字
        SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
        server_addr.sin_port = htons(SERVER_REFRESH_PORT);
        bind(server_refresh_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
        listen(server_refresh_sock, 5);
        //创建线程，用来在刷新端口上接受连接请求
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

        //创建传输端口的监听套接字
        SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
        server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
        bind(server_transfer_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
        listen(server_transfer_sock, 5);
        //创建线程，用来在传输端口上接受连接请求
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

        printf(&quot;服务器在3个端口开始监听连接请求\\n&quot;);

        //消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
        MSG msg;
        while (GetMessage(&amp;msg, 0, 0, 0))
        {
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        }
    }
    else if (argc &gt;= 3 &amp;&amp; strcmp(argv[1], &quot;-client&quot;) == 0) //xx.exe -client s_ip xxx xxx
    {
        //创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
        g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

        g_serverip = inet_addr(argv[2]);

        //创建用于连接到服务器通知端口的套接字
        SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
        sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = g_serverip;
        server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
        connect(client_notify_sock, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));
        printf(&quot;客户端请求连接成功\\n&quot;);

        //发送共享文件名，文件名长度与服务器约定为100字节
        char buf[100];
        int i;
        for (i = 3; i&lt;argc; i++)
        {
            strcpy(buf, argv[i]);
            mysend(client_notify_sock, buf, 100, 0);
        }
        //最后发送一个空文件名告诉服务器共享文件名已发完
        buf[0] = &#39;\\0&#39;;
        mysend(client_notify_sock, buf, 100, 0);
        printf(&quot;客户端发送共享文件名成功\\n&quot;);

        //创建线程，用来接收服务器发来的“通知头部”
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

        //创建线程，每隔10秒向服务器请求最新的共享文件列表
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

        //创建线程，用来接收用户的键盘输入
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

        //消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
        MSG msg;
        while (GetMessage(&amp;msg, 0, 0, 0))
        {
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        }
    }
    else
        printf(&quot;启动参数不正确\\n&quot;);

    return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
    通知
        等待连接：server_notify_sock
        - 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

        创建线程 server_quit_thread：
            服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

    刷新
        等待连接：server_refresh_sock
        - 向客户端发送共享文件列表

    传输
        等待连接：server_transfer_sock
        - 服务器接收一个“传输头部”，判断是下载还是上传
            下载：
                构造一个“通知头部”发给被下载方
                client_notify_thread：...
            上传：    
                从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
                client_download_thread：循环接收数据并写入文件

**********************************************************************
客户端： xx.exe -client s_ip xxx xxx

    连接服务器通知端口告知上线，发送共享文件名
        服务器：接收客户端发来的共享文件名
                server_quit_thread

    创建 3 个线程：

    client_refresh_thread：
        创建流套接字并连接到服务器的刷新端口
        接收最新共享文件列表

    client_userinput_thread：
        键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
            client_download_thread：
                创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
                给服务器发送表示下载的“传输头部”
                循环接收数据并写入文件

    client_notify_thread：
        接收一个“通知头部”
        创建线程，client_upload_thread：
            创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
            构造一个表示上传的“传输头部”并发送给服务器
            循环读取文件数据并上传

*/
</code></pre>',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->addNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000519s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001304s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000381s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000399s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001233s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date`) VALUES ('text\r' , '# text\r\n```\r\n// FileDownloadThroughServer.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n/***********************************************************************************************************\r\n功能：\r\n建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。\r\n文件存在于各个客户端上，而不在服务器上。\r\n要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n思路：\r\n1.服务器至少应该开放3个TCP端口供客户端连接。\r\n(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。\r\n(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。\r\n(3)第三个用来提供文件传输的中转服务，叫做传输端口。\r\n2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量\r\n应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。\r\n3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。\r\n其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。\r\n4.服务器和客户端都要大量使用多线程。\r\n5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，\r\n第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，\r\n二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和\r\n退出时都要被修改，所以必须有并发控制。\r\n6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是\r\n共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以\r\n防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。\r\n7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，\r\n然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。\r\n客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的\r\n“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个\r\n“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的\r\n文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传\r\n的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。\r\n考查：\r\n1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。\r\n2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，\r\n使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。\r\n3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。\r\n4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示\r\n这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时\r\n也会下载不成功，而且服务器有不确定的动作。试进行debug。\r\n***********************************************************************************************************/\r\n\r\n\r\n#include \"stdafx.h\"\r\n#include \"stdio.h\"\r\n#include <map>\r\n#include <vector>\r\n#include \"Winsock2.h\"\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\n\r\n//宏定义\r\n//********************************************************************************************************-\r\n#define SERVER_NOTIFY_PORT		1024	//通知端口\r\n#define SERVER_REFRESH_PORT		1025	//刷新端口\r\n#define SERVER_TRANSFER_PORT	1026	//传输端口\r\n#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令\r\n#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令\r\n//********************************************************************************************************-\r\n\r\n\r\n//结构体定义\r\n//********************************************************************************************************-\r\n#pragma pack(4)  //设置结构体按照4字节对齐\r\nstruct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到\r\n{\r\n	char				filename[100];	//文件名\r\n	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址\r\n	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字\r\n};\r\nstruct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传\r\n{\r\n	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传\r\n	union\r\n	{\r\n		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体\r\n		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字\r\n	};\r\n};\r\nstruct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件\r\n{\r\n	SOCKET	sock;						//告诉客户端是谁想下载他的文件\r\n	char	filename[100];				//告诉客户端想下载他的哪个文件\r\n};\r\n#pragma pack()  //取消结构体的字节对齐\r\n//********************************************************************************************************-\r\n\r\n\r\n//全局变量\r\n//********************************************************************************************************-\r\n//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体\r\nstd::multimap<SOCKET, SHARED_FILE>		g_shared_files;\r\n//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝\r\nstd::vector<SHARED_FILE>				g_files_list;\r\nstd::vector<SHARED_FILE>				g_files_list2;\r\nunsigned int							g_serverip;				//服务器的IP，网络字节序表示	\r\nHANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问\r\nHANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问\r\n//********************************************************************************************************-\r\n\r\n\r\nint mysend(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = send(sock, buf + sent, remain, flags);\r\n		if (n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\nint myrecv(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出\r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器用于判断某个客户端是否下线\r\n//参数：服务器上对应于某个客户端的通知套接字\r\n//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线\r\n//创建者：server_notify_thread()\r\nDWORD WINAPI server_quit_thread(LPVOID lpParam)\r\n{\r\n	SOCKET comm_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		char c;\r\n		int ret = recv(comm_sock, &c, 1, 0);\r\n		if (ret == 0 || ret == -1)\r\n			break;\r\n	}\r\n	printf(\"有一个客户端退出了\\n\");\r\n\r\n	//删除g_shared_files中的信息\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	g_shared_files.erase(comm_sock);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器把最新共享文件列表发给客户端\r\n//参数：服务器在刷新端口上的监听套接字\r\n//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端\r\n//创建者：main()\r\nDWORD WINAPI server_refresh_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_refresh_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;\r\n	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)\r\n		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	//最后发一个空文件名告诉客户端已发完\r\n	SHARED_FILE sf;\r\n	sf.filename[0] = \'\\0\';\r\n	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);\r\n\r\n	closesocket(comm_sock);\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器接受一个客户端上线\r\n//参数：服务器在通知端口上的监听套接字\r\n//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射\r\n//创建者：main()\r\nDWORD WINAPI server_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_notify_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);\r\n	printf(\"有一个客户端上线了\\n\");\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n	char buf[100];\r\n	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字\r\n	sf.client_addr = client_addr;\r\n	sf.notify_sock = comm_sock;\r\n	while (1)\r\n	{\r\n		myrecv(comm_sock, buf, 100, 0);\r\n		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名\r\n			break;\r\n		strcpy(sf.filename, buf);\r\n\r\n		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p\r\n		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息\r\n		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v\r\n	}\r\n\r\n	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：服务器为文件传输做中转服务\r\n//参数：服务器在传输端口上的监听套接字\r\n//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转\r\n//创建者：main()\r\nDWORD WINAPI server_transfer_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_transfer_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n	//接收一个“传输头部”\r\n	TRANSFER_HEADER th;\r\n	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件\r\n	{\r\n		//构造一个“通知头部”准备发给被下载方\r\n		NOTIFY_HEADER nh;\r\n		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字\r\n		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方\r\n\r\n		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字\r\n		SOCKET client_notify_sock = th.shared_file.notify_sock;\r\n\r\n		//向这个通知套接字发送“通知头部”\r\n		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出\r\n			closesocket(comm_sock);\r\n	}\r\n	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件\r\n	{\r\n		//从“传输头部”中取出下载方对应的套接字\r\n		SOCKET download_client_sock = th.sock;\r\n\r\n		//循环接收数据并转发给下载方\r\n		char buf[1024];\r\n		while (1)\r\n		{\r\n			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节\r\n			if (i > 0)\r\n				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节\r\n			else\r\n			{\r\n				closesocket(download_client_sock);\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端每隔10秒向服务器请求最新共享文件列表\r\n//参数：NULL\r\n//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示\r\n//创建者：main()\r\nDWORD WINAPI client_refresh_thread(LPVOID lpParam)\r\n{\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n\r\n	while (1)\r\n	{\r\n		//创建流套接字并连接到服务器的刷新端口\r\n		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n		//接收最新共享文件列表\r\n		while (1)\r\n		{\r\n			SHARED_FILE sf;\r\n			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体\r\n\r\n			if (sf.filename[0] != \'\\0\')  //如果不是空文件名\r\n				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面\r\n			else  //空文件名，表示服务器本次发送共享文件列表已经完毕\r\n				break;\r\n		}\r\n\r\n\r\n		closesocket(refresh_sock);\r\n\r\n		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		g_files_list2.clear();\r\n		g_files_list2 = g_files_list;\r\n		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表\r\n		printf(\"最新共享文件列表：\\n\");\r\n\r\n		std::vector<SHARED_FILE>::const_iterator it;\r\n		int i = 1;\r\n		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)\r\n		{\r\n			printf(\"%d - %s:%d上的%s\", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);\r\n			printf(\"\\n\");\r\n		}\r\n		printf(\"请输入文件的序号进行下载（0-退出）：\\n\");\r\n\r\n		Sleep(10000);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端进行文件上传\r\n//参数：指向“通知头部”的指针\r\n//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件\r\n//创建者：client_notify_thread()\r\nDWORD WINAPI client_upload_thread(LPVOID lpParam)\r\n{\r\n	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;\r\n\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示上传的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传\r\n	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字\r\n	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	FILE *fp = fopen(pnh->filename, \"rb\");\r\n	if (fp != NULL)\r\n		printf(\"开始上传文件%s\\n\", pnh->filename);\r\n	else\r\n	{\r\n		printf(\"找不到文件%s，上传失败\\n\", pnh->filename);\r\n		closesocket(client_upload_sock);\r\n		delete pnh;\r\n		return 0;\r\n	}\r\n\r\n	//循环读取文件数据并上传\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = fread(buf, 1, 1024, fp);\r\n		mysend(client_upload_sock, buf, i, 0);\r\n		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_upload_sock);\r\n	printf(\"文件%s上传完成\\n\", pnh->filename);\r\n\r\n	delete pnh;\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端响应服务器发来的通知\r\n//参数：客户端已经同服务器的通知端口建立连接的通知套接字\r\n//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传\r\n//创建者：main()\r\nDWORD WINAPI client_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET client_notify_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		//接收一个“通知头部”\r\n		NOTIFY_HEADER nh;\r\n		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		printf(\"收到一个下载%s的通知\\n\", nh.filename);\r\n\r\n		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖\r\n		*pnh = nh;\r\n		//创建线程，用来上传文件\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端进行指定文件的下载\r\n//参数：指向想下载的共享文件结构体的指针\r\n//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘\r\n//创建者：client_userinput_thread()\r\nDWORD WINAPI client_download_thread(LPVOID lpParam)\r\n{\r\n	SHARED_FILE *psf = (SHARED_FILE *)lpParam;\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示下载的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载\r\n	th.shared_file = *psf;  //指明想下载哪一个文件\r\n	delete psf;\r\n	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	printf(\"开始下载%s:%d的%s\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	FILE *fp = fopen(th.shared_file.filename, \"wb\");\r\n	//循环接收数据并写入文件\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()\r\n		if (i > 0)\r\n			fwrite(buf, 1, i, fp);\r\n		else\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_download_sock);\r\n	printf(\"%s:%d的%s下载完毕\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\n//******************************************************************************************************-\r\n//功能：客户端接收并处理用户的键盘输入\r\n//参数：NULL\r\n//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载\r\n//创建者：main()\r\nDWORD WINAPI client_userinput_thread(LPVOID lpParam)\r\n{\r\n	int number;\r\n	while (1)\r\n	{\r\n		scanf(\"%d\", &number);\r\n		//客户端退出的方式是用户按下0\r\n		if (number == 0)\r\n		{\r\n			CloseHandle(g_client_semaphore);\r\n			exit(0);\r\n		}\r\n\r\n		//为防止此时正在刷新 g_files_list2，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		if (number > g_files_list2.size())\r\n			printf(\"请输入正确的序号\\n\");\r\n		else\r\n		{\r\n			SHARED_FILE *psf = new SHARED_FILE;\r\n			*psf = g_files_list2[number - 1];\r\n\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			struct sockaddr_in clientAddr;\r\n			int clientAddrLen = sizeof(clientAddr);\r\n			//用于获取与某个套接字关联的本地协议地址\r\n			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\n			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数\r\n\r\n			SHARED_FILE	sel_file = *psf;\r\n\r\n			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数\r\n			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))\r\n			{\r\n				printf(\"不能下载自己的文件\\n\");\r\n			}\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			else\r\n			{\r\n				//创建线程，用来完成下载任务\r\n				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);\r\n			}\r\n\r\n			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//******************************************************************************************************-\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	if (argc == 1)\r\n	{\r\n		printf(\"使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n\");\r\n		return 0;\r\n	}\r\n\r\n	//下面4行进行Windows网络环境的初始化。Linux中不需要\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n\r\n	if (argc == 2 && strcmp(argv[1], \"-server\") == 0)\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改\r\n		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		//创建通知端口的监听套接字\r\n		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_notify_sock, 5);\r\n		//创建线程，用来在通知端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n		//创建刷新端口的监听套接字\r\n		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_refresh_sock, 5);\r\n		//创建线程，用来在刷新端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n		//创建传输端口的监听套接字\r\n		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_transfer_sock, 5);\r\n		//创建线程，用来在传输端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n		printf(\"服务器在3个端口开始监听连接请求\\n\");\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else if (argc >= 3 && strcmp(argv[1], \"-client\") == 0) //xx.exe -client s_ip xxx xxx\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写\r\n		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		g_serverip = inet_addr(argv[2]);\r\n\r\n		//创建用于连接到服务器通知端口的套接字\r\n		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = g_serverip;\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		printf(\"客户端请求连接成功\\n\");\r\n\r\n		//发送共享文件名，文件名长度与服务器约定为100字节\r\n		char buf[100];\r\n		int i;\r\n		for (i = 3; i<argc; i++)\r\n		{\r\n			strcpy(buf, argv[i]);\r\n			mysend(client_notify_sock, buf, 100, 0);\r\n		}\r\n		//最后发送一个空文件名告诉服务器共享文件名已发完\r\n		buf[0] = \'\\0\';\r\n		mysend(client_notify_sock, buf, 100, 0);\r\n		printf(\"客户端发送共享文件名成功\\n\");\r\n\r\n		//创建线程，用来接收服务器发来的“通知头部”\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，每隔10秒向服务器请求最新的共享文件列表\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，用来接收用户的键盘输入\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else\r\n		printf(\"启动参数不正确\\n\");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n/*\r\n服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。\r\n	通知\r\n		等待连接：server_notify_sock\r\n		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n\r\n		创建线程 server_quit_thread：\r\n			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)\r\n\r\n	刷新\r\n		等待连接：server_refresh_sock\r\n		- 向客户端发送共享文件列表\r\n\r\n	传输\r\n		等待连接：server_transfer_sock\r\n		- 服务器接收一个“传输头部”，判断是下载还是上传\r\n			下载：\r\n				构造一个“通知头部”发给被下载方\r\n				client_notify_thread：...\r\n			上传：	\r\n				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方\r\n				client_download_thread：循环接收数据并写入文件\r\n\r\n**********************************************************************\r\n客户端： xx.exe -client s_ip xxx xxx\r\n\r\n	连接服务器通知端口告知上线，发送共享文件名\r\n		服务器：接收客户端发来的共享文件名\r\n				server_quit_thread\r\n\r\n	创建 3 个线程：\r\n\r\n	client_refresh_thread：\r\n		创建流套接字并连接到服务器的刷新端口\r\n		接收最新共享文件列表\r\n\r\n	client_userinput_thread：\r\n		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，\r\n			client_download_thread：\r\n				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...\r\n				给服务器发送表示下载的“传输头部”\r\n				循环接收数据并写入文件\r\n\r\n	client_notify_thread：\r\n		接收一个“通知头部”\r\n		创建线程，client_upload_thread：\r\n			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口\r\n			构造一个表示上传的“传输头部”并发送给服务器\r\n			循环读取文件数据并上传\r\n\r\n*/\r\n```' , 'Default' , 1 , '2018-11-16') [ RunTime:0.001316s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001061s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=14  WHERE  `groups` = 'Default' [ RunTime:0.000447s ]
---------------------------------------------------------------
[ 2018-11-16T21:10:38+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.076337s][吞吐率：13.10req/s] [内存消耗：2,328.11kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000579s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001268s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001957s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000629s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001018s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000326s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000488s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000880s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000359s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000402s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000334s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000413s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001170s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000267s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000980s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000685s ]
---------------------------------------------------------------
[ 2018-11-16T21:10:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/248.html
[ info ] qingrang.top/daily/admin/note/shownote/id/248.html [运行时间：0.051106s][吞吐率：19.57req/s] [内存消耗：2,030.18kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '248',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000422s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001192s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 248 LIMIT 1 [ RunTime:0.000471s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001053s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000282s ]
---------------------------------------------------------------
[ 2018-11-16T21:12:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.077561s][吞吐率：12.89req/s] [内存消耗：2,645.42kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '172067',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
*输出*
```
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33
```

### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。

- 功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
- 思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
- 考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。

```
#include "stdafx.h"
#include "stdio.h"
#include <map>
#include <vector>
#include "Winsock2.h"
#pragma comment(lib, "ws2_32.lib")


//宏定义
//********************************************************************************************************-
#define SERVER_NOTIFY_PORT		1024	//通知端口
#define SERVER_REFRESH_PORT		1025	//刷新端口
#define SERVER_TRANSFER_PORT	1026	//传输端口
#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令
#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令
//********************************************************************************************************-


//结构体定义
//********************************************************************************************************-
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
	char				filename[100];	//文件名
	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址
	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传
	union
	{
		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体
		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
	};
};
struct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
	SOCKET	sock;						//告诉客户端是谁想下载他的文件
	char	filename[100];				//告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//********************************************************************************************************-


//全局变量
//********************************************************************************************************-
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap<SOCKET, SHARED_FILE>		g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector<SHARED_FILE>				g_files_list;
std::vector<SHARED_FILE>				g_files_list2;
unsigned int							g_serverip;				//服务器的IP，网络字节序表示	
HANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//********************************************************************************************************-


int mysend(SOCKET sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while (remain > 0)
	{
		int n = send(sock, buf + sent, remain, flags);
		if (n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while (remain > 0)
	{
		int n = recv(sock, buf + received, remain, flags);
		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
			break;
		remain -= n;
		received += n;
	}
	return received;
}

//******************************************************************************************************-
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
	SOCKET comm_sock = (SOCKET)lpParam;

	while (1)
	{
		char c;
		int ret = recv(comm_sock, &c, 1, 0);
		if (ret == 0 || ret == -1)
			break;
	}
	printf("有一个客户端退出了\\n");

	//删除g_shared_files中的信息
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	g_shared_files.erase(comm_sock);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
	SOCKET server_refresh_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);
	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;
	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	//最后发一个空文件名告诉客户端已发完
	SHARED_FILE sf;
	sf.filename[0] = \'\\0\';
	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);

	closesocket(comm_sock);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
	SOCKET server_notify_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);
	printf("有一个客户端上线了\\n");

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
	char buf[100];
	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字
	sf.client_addr = client_addr;
	sf.notify_sock = comm_sock;
	while (1)
	{
		myrecv(comm_sock, buf, 100, 0);
		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名
			break;
		strcpy(sf.filename, buf);

		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
	}

	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
	SOCKET server_transfer_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

	//接收一个“传输头部”
	TRANSFER_HEADER th;
	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);
	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
	{
		//构造一个“通知头部”准备发给被下载方
		NOTIFY_HEADER nh;
		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
		SOCKET client_notify_sock = th.shared_file.notify_sock;

		//向这个通知套接字发送“通知头部”
		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
			closesocket(comm_sock);
	}
	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
	{
		//从“传输头部”中取出下载方对应的套接字
		SOCKET download_client_sock = th.sock;

		//循环接收数据并转发给下载方
		char buf[1024];
		while (1)
		{
			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
			if (i > 0)
				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
			else
			{
				closesocket(download_client_sock);
				break;
			}
		}
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_REFRESH_PORT);

	while (1)
	{
		//创建流套接字并连接到服务器的刷新端口
		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

		//接收最新共享文件列表
		while (1)
		{
			SHARED_FILE sf;
			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

			if (sf.filename[0] != \'\\0\')  //如果不是空文件名
				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
			else  //空文件名，表示服务器本次发送共享文件列表已经完毕
				break;
		}


		closesocket(refresh_sock);

		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		g_files_list2.clear();
		g_files_list2 = g_files_list;
		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
		printf("最新共享文件列表：\\n");

		std::vector<SHARED_FILE>::const_iterator it;
		int i = 1;
		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
		{
			printf("%d - %s:%d上的%s", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);
			printf("\\n");
		}
		printf("请输入文件的序号进行下载（0-退出）：\\n");

		Sleep(10000);
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示上传的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字
	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	FILE *fp = fopen(pnh->filename, "rb");
	if (fp != NULL)
		printf("开始上传文件%s\\n", pnh->filename);
	else
	{
		printf("找不到文件%s，上传失败\\n", pnh->filename);
		closesocket(client_upload_sock);
		delete pnh;
		return 0;
	}

	//循环读取文件数据并上传
	char buf[1024];
	while (1)
	{
		int i = fread(buf, 1, 1024, fp);
		mysend(client_upload_sock, buf, i, 0);
		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了
			break;
	}
	fclose(fp);
	closesocket(client_upload_sock);
	printf("文件%s上传完成\\n", pnh->filename);

	delete pnh;
	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
	SOCKET client_notify_sock = (SOCKET)lpParam;

	while (1)
	{
		//接收一个“通知头部”
		NOTIFY_HEADER nh;
		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		printf("收到一个下载%s的通知\\n", nh.filename);

		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
		*pnh = nh;
		//创建线程，用来上传文件
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
	}

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
	SHARED_FILE *psf = (SHARED_FILE *)lpParam;

	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示下载的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
	th.shared_file = *psf;  //指明想下载哪一个文件
	delete psf;
	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	printf("开始下载%s:%d的%s\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	FILE *fp = fopen(th.shared_file.filename, "wb");
	//循环接收数据并写入文件
	char buf[1024];
	while (1)
	{
		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
		if (i > 0)
			fwrite(buf, 1, i, fp);
		else
			break;
	}
	fclose(fp);
	closesocket(client_download_sock);
	printf("%s:%d的%s下载完毕\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	return 0;
}
//******************************************************************************************************-

//******************************************************************************************************-
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
	int number;
	while (1)
	{
		scanf("%d", &number);
		//客户端退出的方式是用户按下0
		if (number == 0)
		{
			CloseHandle(g_client_semaphore);
			exit(0);
		}

		//为防止此时正在刷新 g_files_list2，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		if (number > g_files_list2.size())
			printf("请输入正确的序号\\n");
		else
		{
			SHARED_FILE *psf = new SHARED_FILE;
			*psf = g_files_list2[number - 1];

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			struct sockaddr_in clientAddr;
			int clientAddrLen = sizeof(clientAddr);
			//用于获取与某个套接字关联的本地协议地址
			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数

			SHARED_FILE	sel_file = *psf;

			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数
			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
			{
				printf("不能下载自己的文件\\n");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			else
			{
				//创建线程，用来完成下载任务
				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
			}

			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		}
	}

	return 0;
}
//******************************************************************************************************-

int main(int argc, char* argv[])
{
	if (argc == 1)
	{
		printf("使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n");
		return 0;
	}

	//下面4行进行Windows网络环境的初始化。Linux中不需要
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);

	if (argc == 2 && strcmp(argv[1], "-server") == 0)
	{
		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		//创建通知端口的监听套接字
		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_notify_sock, 5);
		//创建线程，用来在通知端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

		//创建刷新端口的监听套接字
		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_REFRESH_PORT);
		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_refresh_sock, 5);
		//创建线程，用来在刷新端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

		//创建传输端口的监听套接字
		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_transfer_sock, 5);
		//创建线程，用来在传输端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

		printf("服务器在3个端口开始监听连接请求\\n");

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else if (argc >= 3 && strcmp(argv[1], "-client") == 0) //xx.exe -client s_ip xxx xxx
	{
		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		g_serverip = inet_addr(argv[2]);

		//创建用于连接到服务器通知端口的套接字
		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = g_serverip;
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		printf("客户端请求连接成功\\n");

		//发送共享文件名，文件名长度与服务器约定为100字节
		char buf[100];
		int i;
		for (i = 3; i<argc; i++)
		{
			strcpy(buf, argv[i]);
			mysend(client_notify_sock, buf, 100, 0);
		}
		//最后发送一个空文件名告诉服务器共享文件名已发完
		buf[0] = \'\\0\';
		mysend(client_notify_sock, buf, 100, 0);
		printf("客户端发送共享文件名成功\\n");

		//创建线程，用来接收服务器发来的“通知头部”
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，每隔10秒向服务器请求最新的共享文件列表
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，用来接收用户的键盘输入
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else
		printf("启动参数不正确\\n");

	return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
	通知
		等待连接：server_notify_sock
		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

		创建线程 server_quit_thread：
			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

	刷新
		等待连接：server_refresh_sock
		- 向客户端发送共享文件列表

	传输
		等待连接：server_transfer_sock
		- 服务器接收一个“传输头部”，判断是下载还是上传
			下载：
				构造一个“通知头部”发给被下载方
				client_notify_thread：...
			上传：	
				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
				client_download_thread：循环接收数据并写入文件

**********************************************************************
客户端： xx.exe -client s_ip xxx xxx

	连接服务器通知端口告知上线，发送共享文件名
		服务器：接收客户端发来的共享文件名
				server_quit_thread

	创建 3 个线程：

	client_refresh_thread：
		创建流套接字并连接到服务器的刷新端口
		接收最新共享文件列表

	client_userinput_thread：
		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
			client_download_thread：
				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
				给服务器发送表示下载的“传输头部”
				循环接收数据并写入文件

	client_notify_thread：
		接收一个“通知头部”
		创建线程，client_upload_thread：
			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
			构造一个表示上传的“传输头部”并发送给服务器
			循环读取文件数据并上传

*/
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000650s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001423s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Linux - C 编程',`content`='# Linux - C 编程\n[TOC]\n## 进程\n### 孤儿进程 和 僵尸进程\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\n\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\n\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\n\n### 进程标识符\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\n```\n//头文件\n#include <sys/types.h>\n#include <unistd.h>\n\n//返回:调用进程的 进程ID\npid_t getpid(void)	\n\n//返回:调用进程的 父进程ID\npid_t getppid(void);\n\n//返回:调用进程的 实际用户ID\nuid_t getuid(void)\n\n//返回:调用进程的 有效用户ID\nuid_t geteuid(void)\n\n//返回:调用进程的 实际组ID\ngid_t getgid (void)\n\n//返回:调用进程的 有效组ID\ngid_t getegid(void)\n```\n### 进程同步\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\n```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status) ;\npid_t waitpid(pid_t pid , int * status, int options) ;\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\n```\n### 实验：fork() 函数的使用\nfork() 函数:\n创建成功，父进程返回子进程的 id ，子进程返回 0\n创建失败，父进程返回 -1\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n\n```\n/*---------------------------------------------------\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\n-----------------------------------------------------*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\n	//调用fork()函数创建子进程\n	pid_t pid = fork();\n	if (pid == -1)	//创建失败\n	{\n		perror(\"fork error\");\n		exit(1);	//退出进程，指定返回值1\n	}\n	else if (pid > 0)	//创建成功 - 父进程\n	{\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	else if (pid == 0)	//创建成功 - 子进程\n	{\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\n	}\n	printf(\"........finish..........\\n\");\n	return 0;\n}\n\n/*========================================================================\n父进程,pid=3720,ppid=3514\n........finish..........\n子进程,pid=3721,ppid=2012\n........finish..........\n========================================================================*/\n\n```\n\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\n\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n\n```\n/*---------------------------------------------------\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\n-----------------------------------------------------*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main()\n{\n	pid_t pid;\n	int i;\n	//循环创建进程\n	for (i = 0; i<5; i++){				\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\n			break;\n	}\n	if (pid == -1){\n		perror(\"fork error\");\n		exit(1);\n	}\n	else if (pid>0){	//父进程\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\n		printf(\"parent process:pid=%d\\n\", getpid());\n	}\n	else if (pid == 0){		//子进程\n		//sleep(i);	//每个子进程分别沉睡不同的时间\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\n	}\n	return 0;\n}\n\n/*========================================================================\n>不 sleep 的输出：\nzhangliren@ubuntu:~/Documents$ ./a.out \nI am child=2,pid=3814\nparent process:pid=3812\nI am child=1,pid=3813\nI am child=4,pid=3816\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\nI am child=3,pid=3815\n|(终端提示符)\n----------------------------------------------------------\n>sleep() 后的输出：\nI am child=1,pid=3843\nI am child=2,pid=3844\nI am child=3,pid=3845\nI am child=4,pid=3846\nI am child=5,pid=3847\nparent process:pid=3842\n========================================================================*/\n```\n\n- 观察输出结果,会发现输出结果有以下问题\n（1）子进程的编号不是递增的\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\n这是为什么?\n\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\n\n## 信号和信号处理\n### 信号的概念\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\n\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\n\n### 常见函数\n#### kill\n给指定进程发送信号\n\n函数声明：`int kill(pid_t,int sig)`\npid：接收信号的进程ID\nsig：要发送的信号编号\n#### raise\n发送指定信号给当前进程自身\n\n函数声明：`int raise(int sig)`\n\n#### pause\n暂停进程，接收到任何信号后恢复\n\n函数声明：`int pause()`\n\n#### alarm\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\n\n函数声明：`unsigned int alarm(unsigned int seconds)`\n\n#### signal\n捕获信号后，执行指定函数\n\n函数声明：\n`typedef void (* sighandler_t)(int);`\n`sighandler_t signal(int signum,sighandler_t handler);`\n\nsignum：信号编号\nhandler：自定义信号处理函数的函数指针\n\n### 实验：李纳斯的第一个程序\n```\n/*---------------------------------------------------------------------------------------------------------\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\n---------------------------------------------------------------------------------------------------------*/\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n\npid_t pid;\n\n//自定义信号处理函数。\n//父进程打印 AAA，子进程打印 BBB\nvoid sigusr1_handler(int n)\n{\n	if(pid > 0)\n		printf(\"AAAA\\n\");\n	else\n		printf(\"BBBB\\n\");\n\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\n}\n\nvoid sigalrm_handler(int n)\n{\n	if(pid > 0){	//父进程\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\n	}\n	else{	//子进程\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\n	}\n}\n\nint main()\n{\n	//在fork()之前设置的信号处理函数会被子进程继承\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\n\n	pid = fork();\n	if (pid > 0)	//父进程\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\n\n	while(1)\n		pause();	//进程挂起，等待信号唤醒\n\n	return 0;\n}\n```\n## 进程间通信\n### 信号量\n#### 信号量的概念\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\n1. 测试控制该资源的信号量。\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\n\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\n\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\n\n#### 信号量的创建与打开 semget\n函数声明：`int semget(key_t key,int nsems,int semflg)`\n\nkey：所创建或打开的信号量集合的键\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\n\n返回：\n- 成功：返回信号量ID\n- 失败：-1，并设置 errno\n\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\n\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\n\n#### 对信号量的控制 semctl\n\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\n\nsemid：为信号量集合的标识符。\nsemnum：用于指明某个特定信号量。\ncmd：表示调用该函数希望执行的命令\ncmd 的常用设置：\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\n\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\n```\nunion semen{\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\n};\n```\n\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\n```\nushort semid_ds{\n	struct ipc_perm sem_perm;	//所有者和标致权限\n	time_t sem_otime;	//最后操作时间\n	time_t sem_ctime;	//最后更改时间\n	unsigned short sem_nsems;	//信号集中的信号数量\n}\n```\n\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\n#### 对信号量的操作——semop\n改变信号量的值\n\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\n\nsemid：为信号量集合的ID\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\n```\nstruct sembuf{\n	short sem_num;	//信号量在信号集中的编号\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\n	short sem_flag;	//标志位\n};\n```\nnops：参数 sops 所指数组中元素的个数\n\n返回：若成功则为 0，若出错则为 -1。\n\n### 共享内存\n#### 共享内存的概念\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\n\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\n\n#### 共享内存的创建和打开 shmget\n函数声明：`int shmget(key_t key, int size, int flag) ;`\n\nkey：表示所创建或打开的共享内存的键\nsize：表示共享内存区域的大小\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\n\n返回：若成功则为共享内存ID，若出错则为 -1。\n\n#### 共享内存的附加 shmat\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\n\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\n`\n\nshmid：表示要附加的共享内存段的ID\naddr：虚拟地址\nflag：用于表示函数的操作方式\n\n返回：若成功则为指向共享内存段的指针，若出错则为-1\n\n#### 共享内存的分离 shmdt\n解除物理内存与进程虚拟地址空间的映射关系\n\n函数声明：`int shmdt(void *addr) ;`\n\naddr：是以前调用 shmat 时的返回值。\n\n返回：若成功则为0，若出错则为 -1。\n\n#### 共享内存的控制 shmctl\n对共享内存段执行多种操作。\n\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\n`\nshmid：为共享内存的标识符\ncmd：表示调用该函数希望执行的操作\n\n---\ncmd 的取值和对应操作如下：\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\n\n---\nbuf：指向 shmid_ds 结构体的指针\n\n返回：若成功则为0，若出错则为 -1。\n\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\n```\n/*---------------------------------------------------------------------------------------------------------\n功能：\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\n\n思路：\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\n应使用信号量进行并发控制。	\n---------------------------------------------------------------------------------------------------------*/\n\n#include \"stdio.h\"\n#include \"sys/types.h\"\n#include \"signal.h\"\n#include \"sys/ipc.h\"\n#include \"sys/sem.h\"\n#include \"sys/shm.h\"\n\n//semun 共用体\nunion semun\n{\n	int val;\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \n	ushort *array;\n};\n\n\nint semid;//信号量ID\nint shmid;//共享内存ID\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\n\n// P操作，获取信号量，-1\nvoid p(int semid)\n{\n	struct sembuf buf = {0, -1, 0};\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\n	semop(semid, &buf, 1);	//改变信号量的值\n}\n\n// V操作，释放信号量，+1\nvoid v(int semid)\n{\n	struct sembuf buf = {0, 1, 0};\n	semop(semid, &buf, 1);\n}\n\nvoid sigusr1_handler(int n)\n{\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\n	\n	//删除信号量\n	if(semctl(semid, IPC_RMID, 0) == -1)  \n		printf(\"remove semaphore fail\\n\");\n	else\n		printf(\"remove semaphore ok\\n\");\n	\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\n\n	//删除共享内存\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \n		printf(\"remove shared-memory fail\\n\");\n	else\n		printf(\"remove shared-memory ok\\n\");\n\n	exit(0);\n}\n\nint main()\n{\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\n\n	//int semget(key_t key,int nsems,int semflg)\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\n	//成功：返回信号量ID，失败：-1\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\n\n	if(semid == -1)	//信号量创建失败\n	{\n		printf(\"create semaphore fail\\n\");\n		return 0;\n	}\n	else{	 //返回信号量ID\n		printf(\"create semaphore ok\\n\");\n	}\n\n	//semun 共用体\n	union semun x;\n	x.val = 1;  //信号量初值应为多少？为1\n\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\n	\n	//int shmget(key_t key, int size, int flag);\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\n	//若成功则为共享内存ID，若出错则为 -1\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\n	if(shmid == -1)	\n	{\n		printf(\"create shared-memory fail\\n\");\n		return 0;\n	}\n	else{	//返回共享内存ID\n		printf(\"create shared-memory ok\\n\");\n	}\n\n	//void *shmat(int shmid, void *addr, int flag) ;\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\n	//成功则为指向共享内存段的指针，若出错则为-1\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\n\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\n\n	//flag 是否是子进程\n	char is_child = 0;\n	int i;\n	//循环创建 10 个进程\n	for(i=0; i<10; i++)\n	{\n		pid_t pid = fork(); \n		if(pid == 0)	//子进程\n		{\n			is_child = 1;  //设置子进程中 is_child 为 1\n			break;  //退出循环\n		}\n	}\n\n	//子进程\n	if(is_child)\n	{\n		p(semid);  // P操作，获取信号量（-1）\n\n		srand(time(NULL) + i);	//设置随机种子数\n		int num = rand()%10;	//取 0-9 随机数\n\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\n\n		printf(\"child%d: %d\\n\", i, num);\n\n		v(semid);  //V操作，释放信号量（+1）\n\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \n	}\n	else\n	{\n		while(1)\n			pause();//挂起，等待信号唤醒\n	}\n\n	return 0;\n}\n/*========================================================================\ncreate semaphore ok\ncreate shared-memory ok\nchild0: 8\nchild1: 8\nchild5: 9\nchild4: 0\nchild6: 2\nchild3: 9\nchild7: 6\nchild8: 4\nchild9: 1\nchild2: 9\ncount = 10, total = 56\nremove semaphore ok\nremove shared-memory ok\n========================================================================*/\n```\n## socket 编程接口\n### 套接口概念\n套接口实际就是网络进程的 PID（Process ID）。\n\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\n### 阻塞模式和非阻塞模式（同步和异步）\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\n\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\n\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\n\n### getsockname/getpeername\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\n*函数定义*\n```\n#include<sys/socket.h>\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\n```\n\n### 字节序转换\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\n\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\n\n#### 返回网络字节序 htons/htonl\n`u_short htons(u_short hostshort);`\n\n`u_long htonl(u_long hostlong);`\n\n#### 返回主机字节序 ntohs/ntohl\n`u_short ntohs(u_short netshort);`\n\n`u_long ntohl(u_long netlong);`\n\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\n### 地址转换函数\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\n要实现两者之间的转换，就要用到以下两个函数：\n\n`unsigned long inet_addr(const char FAR* cp);`\n\n成功：返回 32 位二进制的网络字节序地址\n出错：返回 INADDR_NONE。\n\n`char FAR* inet_ntoa(struct in_addr in);`\n\n成功：返回字符串的指针\n失败：返回 NULL\n\n### 流套接字编程模型\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\n客户端：创建套接字——请求连接。\n\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\n\n最后，通信完毕，任意一方都可关闭套接字。\n### 数据报套接字编程模型\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\n客户端：创建套接字——直接进行数据的发送。\n\n通信完毕，任意一方都可关闭套接字。\n\n### sockaddr 和 sockaddr_in 结构体\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\n\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\n\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\n```\nstruct sockaddr\n{\n	unit8_t	sa_len;\n	sa_family_t	sa_family;	//协议族名\n	char	sa_data[14];\n}\n```\n\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\n```\nstruct sockaddr_in\n{\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\n	struct in_addr sin_addr;\n	char	sin_zero[8];	//备用的域名，未使用\n};\nstruct in_addr\n{\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\n};\n```\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\n\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\n\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\n\n### 套接口函数\n#### 总结步骤\n>一个服务器进程中系统调用的顺序通常如下\n\nsocket();\nbind();\nlisten();\naccept();\n>而客户端进程的调用则比较简单\n\nsocket();\nconnect();\n#### 创建套接字 socket\n\n`int socket(int family,int type,int protocol);`\n\nfamily：指明协议族\ntype：指明套接口类型\nprotocol：一般为 0\n\n成功：返回值为非负描述字\n失败：返回值为负值\n\n>参数 family 的取值范围\n\nAF_LOCAL：UNIX 协议族\nAF_ROUTE：路由套接口\nAF_INET：IPv4 协议\nAF_INET6：IPV6 协议\nAF_KEY：密钥套接口\n\n>参数 type 的取值范围\n\nSOCK_STREAM：TCP 套接口\nSOCK_DGRAM：UDP 套接口\nSOCK_PACKET：支持数据链路访问\nSOCK_RAM：原始套接口\n\n#### 绑定套接口 bind\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\n\nsockfd：套接字\nmyaddr：是一个指向特定协议地址结构体的指针\naddrlen：是地址结构体的长度。\n\n成功：返回 0\n失败：返回 -1\n\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\n\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\n\n#### 连接 connect\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\n\nsockfd：套接口描述字\nserv_addr：目的端口和IP地址的套接口\naddrlen：目的套接口的长度\n\n成功：返回 0\n失败：返回 -l\n\n#### 监听 listen\n`int listen(int sockfd,int backlog);`\n\nsockfd：套接字\nbacklog：规定内核为此套接口排队的最大选择个数\n\n成功：返回 0\n失败：返回 -1\n\n#### 接受连接 accept (阻塞函数)\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\n\ncliaddr：远程客户的套接口地址\naddrlen：套接口地址长度\nsockfd：监听套接字，它由函数 socket() 生成\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\n\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\n失败：返回 -1\n\n>客户套接和监听套接字的区别：\n\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\n\n>accept()是一个阻塞函数\n\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\n\n#### 关闭 close\n`int close(int sockfd);`\n\n成功：返回 0\n失败：返回 -1\n\n#### 发送 send/sendto (阻塞函数)\n面向连接的套接口（TCP）:\n\n`int send(int sockfd,const void *buffer,int length,int flags);`\n\n无连接的套接口（UDP）:\n\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\n\n#### 接收 recv/recvfrom (阻塞函数)\n面向连接的套接口（TCP）:\n\n`int recv(int sockfd,void *buffer,int length,int flags);`\n\n无连接的套接口（UDP）:\n\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\n\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\n\n>Mysend 方法\n\n```\nint Mysend(SOCKET s, const char *buf, int len, int flags)\n{\n	if(buf == NULL)\n		return 0;\n	int iSendCount = 0:\n	int iLength = len:\n	while (iLength > 0)\n	{\n		int n = send(s, buf* iSendCount, iLength, flags);\n		if(n == SOCKET_ERROR)\n			return 0:\n		iLength -= n:\n		iSendCount += n:\n	}\n	return iSendCount\n}\n```\n\n>Myrecv 方法\n\n```\nint Myrecv(SOCKET s, char *buf, int len, int flags)\n{\n	if(buf == NULL)\n		return 0;\n	int iRecvCount = 0;\n	int iLength = len;\n	while (iLength > 0)\n	{\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\n		if(nReU == SOCKET_ERROR)\n			return 0:\n		iLength -= nRev;\n		iRecuCount += nRev;\n	}\n	return iRecvCount;\n}\n```\n## 多线程\n### 线程函数的原型\n#### Windows\n`DWOED ThreadProc(LPVOID lpParameter);`\n### 创建新线程\n#### Windows - CreateThread\nWin32 API 函数 ：CreateThread()\n```\nHANDLE CreateThread(\n	LPSECURITY_ATTRIBUTES lpsa,\n	DWORD cbStack,\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\n	LPVOID lpvThreadParam,	//传给线程函数的参数\n	DWORD fdwCreate,\n	LPDWORD lpIDThread\n);\n```\n#### Unix - pthread_create\n```\n#include  <pthread.h>\nint  pthread_create（\n	pthread_t  *thread,	//待传入线程的线程ID指针\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\n	void  *arg	//要传给线程执行函数的参数\n）\n```\n### 一个线程等待另一个线程结束的方法\n#### Unix - pthread_join\n```\n#include  <pthread.h>\nint pthread_join(\n	pthread_t thread,\n	void **retval\n);\n```\n### Linux 中编译多线程程序的方法\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\n\n### 线程的并发（同步）问题\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\n\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\n\nWindows 中主要函数有：\n```\nCreateSemaphore() //创建信号量\nWaitForSingleObject() //获取信号量，P\nReleaseSemaphore() //释放信号量，V\nCloseHandle() //关闭一个内核对象\n```\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\n```\n/*------------------------------------------------------------------------------------------------\n任务：\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\n思路：\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\n-------------------------------------------------------------------------------*/\n\n//=======================================================================================\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \n//=======================================================================================\n\n///*------------------------ Windows 的头文件 ----------------------------\n#include \"stdafx.h\"\n#include <stdio.h>\n#include <time.h>\n#include <Winsock2.h>\n#pragma comment(lib, \"ws2_32.lib\")\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\n//----------------------------------------------------------------------*/\n\n/*------------------------- Linux 的头文件 -----------------------------\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/sem.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <netdb.h> \n#include <netinet/in.h> \n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\n-----------------------------------------------------------------------*/\n\n//=========================================\n//            	全局变量\n//=========================================\n\n//-------------------------- 判断平台 -------------------------\n#ifdef WINDOWS_VERSION //windows 平台\n	HANDLE  g_hSem;    //信号量的句柄\n	HANDLE  g_hThread[10];  //10个线程的句柄\n#else //Linux 平台\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\n	{\n		int val;\n		struct semid_ds *buf;\n		ushort *array;\n	};\n	int   semid;    //信号量的ID\n	pthread_t thread_id[10];  //10个线程的ID\n#endif\n	int  total;      //和\n	int  listen_sock;    //用于监听的套接字\n	short port;      //端口\n//----------------------------------------------------\n\n/**\n * 发送\n */\nint mysend(int sock, char *buf, int len, int flags)\n{\n	int sent = 0, remain = len;\n	while(remain > 0)\n	{\n		//int send(int sockfd,const void *buffer,int length,int flags);\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\n			break;\n		remain -= n;\n		sent += n;\n	}\n	return sent;\n}\n\n/**\n * 接收一个整数(阻塞函数)\n */\nint myrecv(int sock, char *buf, int len, int flags)\n{\n	int received = 0, remain = len;\n	while(remain > 0)\n	{\n		//int recv(int sockfd,void *buffer,int length,int flags);\n		//返回：0是对方调用close()，-1是对方直接退出\n		int n = recv(sock, buf + received, remain, flags);\n		if(n == 0 || n == -1)  \n			break;\n		remain -= n;\n		received += n;\n	}\n	return received;\n}\n\n/**\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\n * \n * @param num 进程编号\n */\nvoid send_num_to_parent(int num)\n{\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\n\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\n	struct sockaddr_in server_addr;\n	server_addr.sin_family  = AF_INET;\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\n	server_addr.sin_port  = htons(port);\n \n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\n\n	mysend(sock, (char *)&num, 4, 0);\n\n#ifdef WINDOWS_VERSION\n	closesocket(sock);\n#else\n	close(sock);\n#endif\n}\n\n#ifndef WINDOWS_VERSION\nvoid p(int semid)\n{\n	struct sembuf buf = {0, -1, 0};\n	semop(semid, &buf, 1);\n}\n\nvoid v(int semid)\n{\n	struct sembuf buf = {0, 1, 0};\n	semop(semid, &buf, 1);\n}\n#endif\n\n\n#ifdef WINDOWS_VERSION\n	DWORD WINAPI thread_function(void *arg) \n#else\n	/**\n	 * 线程函数\n	 * 处理 accept，并创建下一个线程\n	 */\n	void *thread_function(void *arg)\n#endif\n	{ \n		int index = (int)arg;	//序号\n\n		//准备接受连接请求\n		struct sockaddr_in peer_addr;//套接口地址结构体\n		int size = sizeof(struct sockaddr_in);\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\n \n		//accept 完毕，创建下一个线程\n		if(index < 9)\n#ifdef WINDOWS_VERSION\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\n#else\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\n#endif\n\n		//自己，服务端\n		int num;\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\n\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\n#ifdef WINDOWS_VERSION\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\n		total += num;\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\n		closesocket(comm_sock);\n		// ExitThread(0);\n		return 0;//线程结束\n#else\n		p(semid);\n		total += num;\n		v(semid);\n		//int close(int sockfd);\n		//成功：返回 0，失败：返回 -1\n		close(comm_sock);\n		pthread_exit(NULL);\n#endif\n	}\n\n/**\n * 父进程(服务器)\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\n */\nvoid init_socket()\n{\n	//int socket(int family,int type,int protocol);\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\n	//成功：返回值为非负描述字，失败：返回值为负值\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\n\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\n	struct sockaddr_in server_addr;\n	server_addr.sin_family  = AF_INET; //IP_V4\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\n\n	//随机产生一个端口号，但要大于1024才行\n	srand(time(NULL));  \n	port = rand()%10000;\n	while(port < 1024)\n		port = rand()%10000;\n\n	//htons：将主机的无符号短整形数转换为网络字节顺序\n	server_addr.sin_port = htons(port);\n\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\n	//成功：返回 0，失败：返回 -1\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\n\n	//int listen(int sockfd,int backlog);\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\n	//成功：返回 0，失败：返回 -1\n	listen(listen_sock, 5);//将套接字置于监听状态\n\n	printf(\"parent : 服务器开始监听连接请求\\n\");\n}\n\n/**\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\n * @param i 线程编号	\n */\nvoid do_child(int i)\n{\n	srand(time(NULL) + i);\n	int num = rand()%10;\n\n	printf(\"child%d: %d\\n\", i, num);\n\n	send_num_to_parent(num);\n}\n\n/**\n * 主函数\n *\n * @param  argc 命令行输入的参数个数\n * @param  argv 字符二维数组\n */\nint main(int argc, char* argv[])\n{\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \n#ifdef WINDOWS_VERSION\n	WORD wVersionRequested;\n	WSADATA wsaData;\n	wVersionRequested = MAKEWORD(2, 2);\n	WSAStartup(wVersionRequested, &wsaData);\n#endif\n\n	// Windows 中的父进程，Linux 中的父、子进程\n	if(argc == 1)  \n	{\n		total = 0;	//初始化 total 为 0 \n\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\n#ifdef WINDOWS_VERSION\n		//1 个信号量，初始为 1\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\n#else\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\n		union semun x;\n		x.val = 1;\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\n#endif\n  \n		//初始化网络环境，完成服务器的准备工作\n		init_socket();\n\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\n#else\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\n		//	void  *arg	//要传给线程执行函数的参数\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\n#endif\n\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\n#ifdef WINDOWS_VERSION\n		STARTUPINFO si;\n		PROCESS_INFORMATION pi;\n		int i;\n		for(i=0; i<10; i++)\n		{\n			//处理命令行字符串\n			char *p = GetCommandLine();\n			char strCmdLine[256];\n			strcpy(strCmdLine, p);\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\n\n			ZeroMemory( &si, sizeof(si) );\n			si.cb = sizeof(si);\n			ZeroMemory( &pi, sizeof(pi) );\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\n		}\n		//等待 10 个线程结束\n		for(i=0; i<10; i++)\n			WaitForSingleObject(g_hThread[i], INFINITE);\n#else\n		char is_child = 0;\n		int i;\n		for(i=0; i<10; i++)\n		{\n			pid_t pid = fork();\n			if(pid == 0)\n			{\n				is_child = 1;\n				break;\n			}\n		}\n		if(is_child)\n		{\n			do_child(i);\n			return 0;\n		}\n		else\n		{\n			//等待 10 个线程结束\n			for(i=0; i<10; i++)\n				pthread_join(thread_id[i], NULL);\n		}\n#endif\n		printf(\"parent : all threads ended, total=%d\\n\", total);\n\n//删除信号量\n#ifdef WINDOWS_VERSION\n		CloseHandle(g_hSem);\n#else\n		semctl(semid, IPC_RMID, 0);\n#endif\n	}\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \n	{\n#ifdef WINDOWS_VERSION\n		char *p = GetCommandLine();\n		//下面 2 行从命令行中解析出端口号\n		p = strchr(p, \'-\');\n		sscanf(p+1, \"%d\", &port);\n\n		//下面 3 行从命令行中解析出子进程的序号\n		p = strchr(p+1, \'-\');\n		int index;\n		sscanf(p+1, \"%d\", &index);\n		do_child(index);\n#endif\n	}\n else\n	printf(\"启动命令不正确\\n\");\n	return 0;\n}\n```\n*输出*\n```\nparent : 服务器开始监听连接请求\nchild0: 1\nparent : 线程0接受一个连接请求\nparent : 线程0接收到一个整数1\nchild1: 4\nparent : 线程1接受一个连接请求\nparent : 线程1接收到一个整数4\nchild2: 7\nparent : 线程2接受一个连接请求\nparent : 线程2接收到一个整数7\nchild3: 0\nparent : 线程3接受一个连接请求\nparent : 线程3接收到一个整数0\nchild5: 7\nchild4: 4\nparent : 线程4接受一个连接请求\nchild6: 0\nchild7: 3\nchild8: 7\nparent : 线程4接收到一个整数7\nchild9: 0\nparent : 线程5接受一个连接请求\nparent : 线程5接收到一个整数4\nparent : 线程6接受一个连接请求\nparent : 线程6接收到一个整数0\nparent : 线程7接受一个连接请求\nparent : 线程7接收到一个整数3\nparent : 线程8接受一个连接请求\nparent : 线程8接收到一个整数7\nparent : 线程9接受一个连接请求\nparent : 线程9接收到一个整数0\nparent : all threads ended, total=33\n```\n\n### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\n\n- 功能：\n建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。\n文件存在于各个客户端上，而不在服务器上。\n要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\n- 思路：\n1.服务器至少应该开放3个TCP端口供客户端连接。\n(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。\n(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。\n(3)第三个用来提供文件传输的中转服务，叫做传输端口。\n2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量\n应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。\n3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。\n其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。\n4.服务器和客户端都要大量使用多线程。\n5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，\n第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，\n二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和\n退出时都要被修改，所以必须有并发控制。\n6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是\n共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以\n防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。\n7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，\n然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。\n客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的\n“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个\n“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的\n文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传\n的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。\n- 考查：\n1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。\n2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，\n使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。\n3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。\n4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示\n这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时\n也会下载不成功，而且服务器有不确定的动作。试进行debug。\n\n```\n#include \"stdafx.h\"\n#include \"stdio.h\"\n#include <map>\n#include <vector>\n#include \"Winsock2.h\"\n#pragma comment(lib, \"ws2_32.lib\")\n\n\n//宏定义\n//********************************************************************************************************-\n#define SERVER_NOTIFY_PORT		1024	//通知端口\n#define SERVER_REFRESH_PORT		1025	//刷新端口\n#define SERVER_TRANSFER_PORT	1026	//传输端口\n#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令\n#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令\n//********************************************************************************************************-\n\n\n//结构体定义\n//********************************************************************************************************-\n#pragma pack(4)  //设置结构体按照4字节对齐\nstruct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到\n{\n	char				filename[100];	//文件名\n	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址\n	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字\n};\nstruct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传\n{\n	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传\n	union\n	{\n		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体\n		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字\n	};\n};\nstruct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件\n{\n	SOCKET	sock;						//告诉客户端是谁想下载他的文件\n	char	filename[100];				//告诉客户端想下载他的哪个文件\n};\n#pragma pack()  //取消结构体的字节对齐\n//********************************************************************************************************-\n\n\n//全局变量\n//********************************************************************************************************-\n//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体\nstd::multimap<SOCKET, SHARED_FILE>		g_shared_files;\n//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝\nstd::vector<SHARED_FILE>				g_files_list;\nstd::vector<SHARED_FILE>				g_files_list2;\nunsigned int							g_serverip;				//服务器的IP，网络字节序表示	\nHANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问\nHANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问\n//********************************************************************************************************-\n\n\nint mysend(SOCKET sock, char *buf, int len, int flags)\n{\n	int sent = 0, remain = len;\n	while (remain > 0)\n	{\n		int n = send(sock, buf + sent, remain, flags);\n		if (n == -1)  //出错的最大可能是对方关闭了套接字\n			break;\n		remain -= n;\n		sent += n;\n	}\n	return sent;\n}\n\nint myrecv(SOCKET sock, char *buf, int len, int flags)\n{\n	int received = 0, remain = len;\n	while (remain > 0)\n	{\n		int n = recv(sock, buf + received, remain, flags);\n		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出\n			break;\n		remain -= n;\n		received += n;\n	}\n	return received;\n}\n\n//******************************************************************************************************-\n//功能：服务器用于判断某个客户端是否下线\n//参数：服务器上对应于某个客户端的通知套接字\n//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线\n//创建者：server_notify_thread()\nDWORD WINAPI server_quit_thread(LPVOID lpParam)\n{\n	SOCKET comm_sock = (SOCKET)lpParam;\n\n	while (1)\n	{\n		char c;\n		int ret = recv(comm_sock, &c, 1, 0);\n		if (ret == 0 || ret == -1)\n			break;\n	}\n	printf(\"有一个客户端退出了\\n\");\n\n	//删除g_shared_files中的信息\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\n	g_shared_files.erase(comm_sock);\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：服务器把最新共享文件列表发给客户端\n//参数：服务器在刷新端口上的监听套接字\n//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端\n//创建者：main()\nDWORD WINAPI server_refresh_thread(LPVOID lpParam)\n{\n	SOCKET server_refresh_sock = (SOCKET)lpParam;\n\n	sockaddr_in client_addr;\n	int size = sizeof(client_addr);\n	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);\n	//创建线程，用来等待下一个连接请求\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\n\n	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\n	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;\n	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)\n		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\n\n	//最后发一个空文件名告诉客户端已发完\n	SHARED_FILE sf;\n	sf.filename[0] = \'\\0\';\n	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);\n\n	closesocket(comm_sock);\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：服务器接受一个客户端上线\n//参数：服务器在通知端口上的监听套接字\n//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射\n//创建者：main()\nDWORD WINAPI server_notify_thread(LPVOID lpParam)\n{\n	SOCKET server_notify_sock = (SOCKET)lpParam;\n\n	sockaddr_in client_addr;\n	int size = sizeof(client_addr);\n	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);\n	printf(\"有一个客户端上线了\\n\");\n\n	//创建线程，用来等待下一个连接请求\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\n\n	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\n	char buf[100];\n	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字\n	sf.client_addr = client_addr;\n	sf.notify_sock = comm_sock;\n	while (1)\n	{\n		myrecv(comm_sock, buf, 100, 0);\n		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名\n			break;\n		strcpy(sf.filename, buf);\n\n		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p\n		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息\n		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v\n	}\n\n	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：服务器为文件传输做中转服务\n//参数：服务器在传输端口上的监听套接字\n//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转\n//创建者：main()\nDWORD WINAPI server_transfer_thread(LPVOID lpParam)\n{\n	SOCKET server_transfer_sock = (SOCKET)lpParam;\n\n	sockaddr_in client_addr;\n	int size = sizeof(client_addr);\n	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);\n\n	//创建线程，用来等待下一个连接请求\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\n\n	//接收一个“传输头部”\n	TRANSFER_HEADER th;\n	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\n	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件\n	{\n		//构造一个“通知头部”准备发给被下载方\n		NOTIFY_HEADER nh;\n		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字\n		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方\n\n		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字\n		SOCKET client_notify_sock = th.shared_file.notify_sock;\n\n		//向这个通知套接字发送“通知头部”\n		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\n		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出\n			closesocket(comm_sock);\n	}\n	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件\n	{\n		//从“传输头部”中取出下载方对应的套接字\n		SOCKET download_client_sock = th.sock;\n\n		//循环接收数据并转发给下载方\n		char buf[1024];\n		while (1)\n		{\n			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节\n			if (i > 0)\n				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节\n			else\n			{\n				closesocket(download_client_sock);\n				break;\n			}\n		}\n	}\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：客户端每隔10秒向服务器请求最新共享文件列表\n//参数：NULL\n//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示\n//创建者：main()\nDWORD WINAPI client_refresh_thread(LPVOID lpParam)\n{\n	sockaddr_in server_addr;\n	server_addr.sin_family = AF_INET;\n	server_addr.sin_addr.s_addr = g_serverip;\n	server_addr.sin_port = htons(SERVER_REFRESH_PORT);\n\n	while (1)\n	{\n		//创建流套接字并连接到服务器的刷新端口\n		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\n		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n\n		//接收最新共享文件列表\n		while (1)\n		{\n			SHARED_FILE sf;\n			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体\n\n			if (sf.filename[0] != \'\\0\')  //如果不是空文件名\n				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面\n			else  //空文件名，表示服务器本次发送共享文件列表已经完毕\n				break;\n		}\n\n\n		closesocket(refresh_sock);\n\n		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\n		g_files_list2.clear();\n		g_files_list2 = g_files_list;\n		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\n		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表\n		printf(\"最新共享文件列表：\\n\");\n\n		std::vector<SHARED_FILE>::const_iterator it;\n		int i = 1;\n		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)\n		{\n			printf(\"%d - %s:%d上的%s\", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);\n			printf(\"\\n\");\n		}\n		printf(\"请输入文件的序号进行下载（0-退出）：\\n\");\n\n		Sleep(10000);\n	}\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：客户端进行文件上传\n//参数：指向“通知头部”的指针\n//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件\n//创建者：client_notify_thread()\nDWORD WINAPI client_upload_thread(LPVOID lpParam)\n{\n	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;\n\n\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\n	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);\n	sockaddr_in server_addr;\n	server_addr.sin_family = AF_INET;\n	server_addr.sin_addr.s_addr = g_serverip;\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\n	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n\n	//构造一个表示上传的“传输头部”并发送给服务器\n	TRANSFER_HEADER th;\n	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传\n	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字\n	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\n\n	FILE *fp = fopen(pnh->filename, \"rb\");\n	if (fp != NULL)\n		printf(\"开始上传文件%s\\n\", pnh->filename);\n	else\n	{\n		printf(\"找不到文件%s，上传失败\\n\", pnh->filename);\n		closesocket(client_upload_sock);\n		delete pnh;\n		return 0;\n	}\n\n	//循环读取文件数据并上传\n	char buf[1024];\n	while (1)\n	{\n		int i = fread(buf, 1, 1024, fp);\n		mysend(client_upload_sock, buf, i, 0);\n		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了\n			break;\n	}\n	fclose(fp);\n	closesocket(client_upload_sock);\n	printf(\"文件%s上传完成\\n\", pnh->filename);\n\n	delete pnh;\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：客户端响应服务器发来的通知\n//参数：客户端已经同服务器的通知端口建立连接的通知套接字\n//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传\n//创建者：main()\nDWORD WINAPI client_notify_thread(LPVOID lpParam)\n{\n	SOCKET client_notify_sock = (SOCKET)lpParam;\n\n	while (1)\n	{\n		//接收一个“通知头部”\n		NOTIFY_HEADER nh;\n		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\n		printf(\"收到一个下载%s的通知\\n\", nh.filename);\n\n		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖\n		*pnh = nh;\n		//创建线程，用来上传文件\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);\n	}\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：客户端进行指定文件的下载\n//参数：指向想下载的共享文件结构体的指针\n//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘\n//创建者：client_userinput_thread()\nDWORD WINAPI client_download_thread(LPVOID lpParam)\n{\n	SHARED_FILE *psf = (SHARED_FILE *)lpParam;\n\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\n	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);\n	sockaddr_in server_addr;\n	server_addr.sin_family = AF_INET;\n	server_addr.sin_addr.s_addr = g_serverip;\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\n	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n\n	//构造一个表示下载的“传输头部”并发送给服务器\n	TRANSFER_HEADER th;\n	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载\n	th.shared_file = *psf;  //指明想下载哪一个文件\n	delete psf;\n	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\n\n	printf(\"开始下载%s:%d的%s\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\n\n	FILE *fp = fopen(th.shared_file.filename, \"wb\");\n	//循环接收数据并写入文件\n	char buf[1024];\n	while (1)\n	{\n		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()\n		if (i > 0)\n			fwrite(buf, 1, i, fp);\n		else\n			break;\n	}\n	fclose(fp);\n	closesocket(client_download_sock);\n	printf(\"%s:%d的%s下载完毕\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\n\n	return 0;\n}\n//******************************************************************************************************-\n\n//******************************************************************************************************-\n//功能：客户端接收并处理用户的键盘输入\n//参数：NULL\n//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载\n//创建者：main()\nDWORD WINAPI client_userinput_thread(LPVOID lpParam)\n{\n	int number;\n	while (1)\n	{\n		scanf(\"%d\", &number);\n		//客户端退出的方式是用户按下0\n		if (number == 0)\n		{\n			CloseHandle(g_client_semaphore);\n			exit(0);\n		}\n\n		//为防止此时正在刷新 g_files_list2，进行并发控制\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\n		if (number > g_files_list2.size())\n			printf(\"请输入正确的序号\\n\");\n		else\n		{\n			SHARED_FILE *psf = new SHARED_FILE;\n			*psf = g_files_list2[number - 1];\n\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n			struct sockaddr_in clientAddr;\n			int clientAddrLen = sizeof(clientAddr);\n			//用于获取与某个套接字关联的本地协议地址\n			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\n			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数\n\n			SHARED_FILE	sel_file = *psf;\n\n			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数\n			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))\n			{\n				printf(\"不能下载自己的文件\\n\");\n			}\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n			else\n			{\n				//创建线程，用来完成下载任务\n				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);\n			}\n\n			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\n		}\n	}\n\n	return 0;\n}\n//******************************************************************************************************-\n\nint main(int argc, char* argv[])\n{\n	if (argc == 1)\n	{\n		printf(\"使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n\");\n		return 0;\n	}\n\n	//下面4行进行Windows网络环境的初始化。Linux中不需要\n	WORD wVersionRequested;\n	WSADATA wsaData;\n	wVersionRequested = MAKEWORD(2, 2);\n	WSAStartup(wVersionRequested, &wsaData);\n\n	if (argc == 2 && strcmp(argv[1], \"-server\") == 0)\n	{\n		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改\n		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\n\n		//创建通知端口的监听套接字\n		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\n		sockaddr_in server_addr;\n		server_addr.sin_family = AF_INET;\n		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\n		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n		listen(server_notify_sock, 5);\n		//创建线程，用来在通知端口上接受连接请求\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\n\n		//创建刷新端口的监听套接字\n		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\n		server_addr.sin_port = htons(SERVER_REFRESH_PORT);\n		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n		listen(server_refresh_sock, 5);\n		//创建线程，用来在刷新端口上接受连接请求\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\n\n		//创建传输端口的监听套接字\n		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);\n		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\n		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n		listen(server_transfer_sock, 5);\n		//创建线程，用来在传输端口上接受连接请求\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\n\n		printf(\"服务器在3个端口开始监听连接请求\\n\");\n\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\n		MSG msg;\n		while (GetMessage(&msg, 0, 0, 0))\n		{\n			TranslateMessage(&msg);\n			DispatchMessage(&msg);\n		}\n	}\n	else if (argc >= 3 && strcmp(argv[1], \"-client\") == 0) //xx.exe -client s_ip xxx xxx\n	{\n		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写\n		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\n\n		g_serverip = inet_addr(argv[2]);\n\n		//创建用于连接到服务器通知端口的套接字\n		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\n		sockaddr_in server_addr;\n		server_addr.sin_family = AF_INET;\n		server_addr.sin_addr.s_addr = g_serverip;\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\n		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\n		printf(\"客户端请求连接成功\\n\");\n\n		//发送共享文件名，文件名长度与服务器约定为100字节\n		char buf[100];\n		int i;\n		for (i = 3; i<argc; i++)\n		{\n			strcpy(buf, argv[i]);\n			mysend(client_notify_sock, buf, 100, 0);\n		}\n		//最后发送一个空文件名告诉服务器共享文件名已发完\n		buf[0] = \'\\0\';\n		mysend(client_notify_sock, buf, 100, 0);\n		printf(\"客户端发送共享文件名成功\\n\");\n\n		//创建线程，用来接收服务器发来的“通知头部”\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);\n\n		//创建线程，每隔10秒向服务器请求最新的共享文件列表\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);\n\n		//创建线程，用来接收用户的键盘输入\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);\n\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\n		MSG msg;\n		while (GetMessage(&msg, 0, 0, 0))\n		{\n			TranslateMessage(&msg);\n			DispatchMessage(&msg);\n		}\n	}\n	else\n		printf(\"启动参数不正确\\n\");\n\n	return 0;\n}\n\n\n/*\n服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。\n	通知\n		等待连接：server_notify_sock\n		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\n\n		创建线程 server_quit_thread：\n			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)\n\n	刷新\n		等待连接：server_refresh_sock\n		- 向客户端发送共享文件列表\n\n	传输\n		等待连接：server_transfer_sock\n		- 服务器接收一个“传输头部”，判断是下载还是上传\n			下载：\n				构造一个“通知头部”发给被下载方\n				client_notify_thread：...\n			上传：	\n				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方\n				client_download_thread：循环接收数据并写入文件\n\n**********************************************************************\n客户端： xx.exe -client s_ip xxx xxx\n\n	连接服务器通知端口告知上线，发送共享文件名\n		服务器：接收客户端发来的共享文件名\n				server_quit_thread\n\n	创建 3 个线程：\n\n	client_refresh_thread：\n		创建流套接字并连接到服务器的刷新端口\n		接收最新共享文件列表\n\n	client_userinput_thread：\n		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，\n			client_download_thread：\n				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...\n				给服务器发送表示下载的“传输头部”\n				循环接收数据并写入文件\n\n	client_notify_thread：\n		接收一个“通知头部”\n		创建线程，client_upload_thread：\n			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口\n			构造一个表示上传的“传输头部”并发送给服务器\n			循环读取文件数据并上传\n\n*/\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.002096s ]
---------------------------------------------------------------
[ 2018-11-16T21:12:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/1.html
[ info ] qingrang.top/daily/admin/note/shownote/id/1.html [运行时间：0.052268s][吞吐率：19.13req/s] [内存消耗：2,095.59kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000444s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001455s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000564s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001250s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000385s ]
---------------------------------------------------------------
[ 2018-11-16T21:13:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/248.html
[ info ] qingrang.top/daily/admin/note/editnote/id/248.html [运行时间：0.069204s][吞吐率：14.45req/s] [内存消耗：2,081.98kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '248',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001116s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002757s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 248 LIMIT 1 [ RunTime:0.000864s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001093s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000336s ]
---------------------------------------------------------------
[ 2018-11-16T21:15:49+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/248.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/248.html [运行时间：0.070351s][吞吐率：14.21req/s] [内存消耗：2,269.71kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '67329',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/248.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Linux C 编程 - 文件下载（Windows）
```
/*----------------------------------------------------------------------------------------------------------
功能：
建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。
文件存在于各个客户端上，而不在服务器上。
要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
思路：
1.服务器至少应该开放3个TCP端口供客户端连接。
(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。
(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。
(3)第三个用来提供文件传输的中转服务，叫做传输端口。
2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量
应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。
3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。
其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。
4.服务器和客户端都要大量使用多线程。
5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，
第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，
二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和
退出时都要被修改，所以必须有并发控制。
6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是
共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以
防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。
7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，
然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。
客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的
“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个
“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的
文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传
的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。
考查：
1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。
2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，
使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。
3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。
4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示
这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时
也会下载不成功，而且服务器有不确定的动作。试进行debug。
----------------------------------------------------------------------------------------------------------*/


#include "stdafx.h"
#include "stdio.h"
#include <map>
#include <vector>
#include "Winsock2.h"
#pragma comment(lib, "ws2_32.lib")


//宏定义
//---------------------------------------------------------------------------------------------------------
#define SERVER_NOTIFY_PORT		1024	//通知端口
#define SERVER_REFRESH_PORT		1025	//刷新端口
#define SERVER_TRANSFER_PORT	1026	//传输端口
#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令
#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令
//---------------------------------------------------------------------------------------------------------


//结构体定义
//---------------------------------------------------------------------------------------------------------
#pragma pack(4)  //设置结构体按照4字节对齐
struct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到
{
	char				filename[100];	//文件名
	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址
	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字
};
struct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传
{
	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传
	union
	{
		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体
		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字
	};
};
struct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件
{
	SOCKET	sock;						//告诉客户端是谁想下载他的文件
	char	filename[100];				//告诉客户端想下载他的哪个文件
};
#pragma pack()  //取消结构体的字节对齐
//---------------------------------------------------------------------------------------------------------


//全局变量
//---------------------------------------------------------------------------------------------------------
//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体
std::multimap<SOCKET, SHARED_FILE>		g_shared_files;
//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝
std::vector<SHARED_FILE>				g_files_list;
std::vector<SHARED_FILE>				g_files_list2;
unsigned int							g_serverip;				//服务器的IP，网络字节序表示	
HANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问
HANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问
//---------------------------------------------------------------------------------------------------------


int mysend(SOCKET sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while (remain > 0)
	{
		int n = send(sock, buf + sent, remain, flags);
		if (n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

int myrecv(SOCKET sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while (remain > 0)
	{
		int n = recv(sock, buf + received, remain, flags);
		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出
			break;
		remain -= n;
		received += n;
	}
	return received;
}

//-------------------------------------------------------------------------------------------------------
//功能：服务器用于判断某个客户端是否下线
//参数：服务器上对应于某个客户端的通知套接字
//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线
//创建者：server_notify_thread()
DWORD WINAPI server_quit_thread(LPVOID lpParam)
{
	SOCKET comm_sock = (SOCKET)lpParam;

	while (1)
	{
		char c;
		int ret = recv(comm_sock, &c, 1, 0);
		if (ret == 0 || ret == -1)
			break;
	}
	printf("有一个客户端退出了\\n");

	//删除g_shared_files中的信息
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	g_shared_files.erase(comm_sock);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器把最新共享文件列表发给客户端
//参数：服务器在刷新端口上的监听套接字
//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端
//创建者：main()
DWORD WINAPI server_refresh_thread(LPVOID lpParam)
{
	SOCKET server_refresh_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);
	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制
	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量
	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;
	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)
		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);
	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量

	//最后发一个空文件名告诉客户端已发完
	SHARED_FILE sf;
	sf.filename[0] = \'\\0\';
	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);

	closesocket(comm_sock);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器接受一个客户端上线
//参数：服务器在通知端口上的监听套接字
//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射
//创建者：main()
DWORD WINAPI server_notify_thread(LPVOID lpParam)
{
	SOCKET server_notify_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);
	printf("有一个客户端上线了\\n");

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存
	char buf[100];
	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字
	sf.client_addr = client_addr;
	sf.notify_sock = comm_sock;
	while (1)
	{
		myrecv(comm_sock, buf, 100, 0);
		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名
			break;
		strcpy(sf.filename, buf);

		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p
		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息
		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v
	}

	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：服务器为文件传输做中转服务
//参数：服务器在传输端口上的监听套接字
//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转
//创建者：main()
DWORD WINAPI server_transfer_thread(LPVOID lpParam)
{
	SOCKET server_transfer_sock = (SOCKET)lpParam;

	sockaddr_in client_addr;
	int size = sizeof(client_addr);
	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);

	//创建线程，用来等待下一个连接请求
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

	//接收一个“传输头部”
	TRANSFER_HEADER th;
	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);
	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件
	{
		//构造一个“通知头部”准备发给被下载方
		NOTIFY_HEADER nh;
		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字
		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方

		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字
		SOCKET client_notify_sock = th.shared_file.notify_sock;

		//向这个通知套接字发送“通知头部”
		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出
			closesocket(comm_sock);
	}
	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件
	{
		//从“传输头部”中取出下载方对应的套接字
		SOCKET download_client_sock = th.sock;

		//循环接收数据并转发给下载方
		char buf[1024];
		while (1)
		{
			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节
			if (i > 0)
				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节
			else
			{
				closesocket(download_client_sock);
				break;
			}
		}
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端每隔10秒向服务器请求最新共享文件列表
//参数：NULL
//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示
//创建者：main()
DWORD WINAPI client_refresh_thread(LPVOID lpParam)
{
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_REFRESH_PORT);

	while (1)
	{
		//创建流套接字并连接到服务器的刷新端口
		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

		//接收最新共享文件列表
		while (1)
		{
			SHARED_FILE sf;
			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体

			if (sf.filename[0] != \'\\0\')  //如果不是空文件名
				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面
			else  //空文件名，表示服务器本次发送共享文件列表已经完毕
				break;
		}


		closesocket(refresh_sock);

		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		g_files_list2.clear();
		g_files_list2 = g_files_list;
		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表
		printf("最新共享文件列表：\\n");

		std::vector<SHARED_FILE>::const_iterator it;
		int i = 1;
		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)
		{
			printf("%d - %s:%d上的%s", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);
			printf("\\n");
		}
		printf("请输入文件的序号进行下载（0-退出）：\\n");

		Sleep(10000);
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端进行文件上传
//参数：指向“通知头部”的指针
//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件
//创建者：client_notify_thread()
DWORD WINAPI client_upload_thread(LPVOID lpParam)
{
	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;


	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示上传的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传
	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字
	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	FILE *fp = fopen(pnh->filename, "rb");
	if (fp != NULL)
		printf("开始上传文件%s\\n", pnh->filename);
	else
	{
		printf("找不到文件%s，上传失败\\n", pnh->filename);
		closesocket(client_upload_sock);
		delete pnh;
		return 0;
	}

	//循环读取文件数据并上传
	char buf[1024];
	while (1)
	{
		int i = fread(buf, 1, 1024, fp);
		mysend(client_upload_sock, buf, i, 0);
		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了
			break;
	}
	fclose(fp);
	closesocket(client_upload_sock);
	printf("文件%s上传完成\\n", pnh->filename);

	delete pnh;
	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端响应服务器发来的通知
//参数：客户端已经同服务器的通知端口建立连接的通知套接字
//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传
//创建者：main()
DWORD WINAPI client_notify_thread(LPVOID lpParam)
{
	SOCKET client_notify_sock = (SOCKET)lpParam;

	while (1)
	{
		//接收一个“通知头部”
		NOTIFY_HEADER nh;
		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);
		printf("收到一个下载%s的通知\\n", nh.filename);

		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖
		*pnh = nh;
		//创建线程，用来上传文件
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端进行指定文件的下载
//参数：指向想下载的共享文件结构体的指针
//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘
//创建者：client_userinput_thread()
DWORD WINAPI client_download_thread(LPVOID lpParam)
{
	SHARED_FILE *psf = (SHARED_FILE *)lpParam;

	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口
	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);
	sockaddr_in server_addr;
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = g_serverip;
	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));

	//构造一个表示下载的“传输头部”并发送给服务器
	TRANSFER_HEADER th;
	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载
	th.shared_file = *psf;  //指明想下载哪一个文件
	delete psf;
	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);

	printf("开始下载%s:%d的%s\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	FILE *fp = fopen(th.shared_file.filename, "wb");
	//循环接收数据并写入文件
	char buf[1024];
	while (1)
	{
		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()
		if (i > 0)
			fwrite(buf, 1, i, fp);
		else
			break;
	}
	fclose(fp);
	closesocket(client_download_sock);
	printf("%s:%d的%s下载完毕\\n", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);

	return 0;
}
//-------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//功能：客户端接收并处理用户的键盘输入
//参数：NULL
//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载
//创建者：main()
DWORD WINAPI client_userinput_thread(LPVOID lpParam)
{
	int number;
	while (1)
	{
		scanf("%d", &number);
		//客户端退出的方式是用户按下0
		if (number == 0)
		{
			CloseHandle(g_client_semaphore);
			exit(0);
		}

		//为防止此时正在刷新 g_files_list2，进行并发控制
		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量
		if (number > g_files_list2.size())
			printf("请输入正确的序号\\n");
		else
		{
			SHARED_FILE *psf = new SHARED_FILE;
			*psf = g_files_list2[number - 1];

			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			struct sockaddr_in clientAddr;
			int clientAddrLen = sizeof(clientAddr);
			//用于获取与某个套接字关联的本地协议地址
			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数

			SHARED_FILE	sel_file = *psf;

			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数
			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))
			{
				printf("不能下载自己的文件\\n");
			}
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			else
			{
				//创建线程，用来完成下载任务
				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);
			}

			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量
		}
	}

	return 0;
}
//-------------------------------------------------------------------------------------------------------

int main(int argc, char* argv[])
{
	if (argc == 1)
	{
		printf("使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n");
		return 0;
	}

	//下面4行进行Windows网络环境的初始化。Linux中不需要
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);

	if (argc == 2 && strcmp(argv[1], "-server") == 0)
	{
		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改
		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		//创建通知端口的监听套接字
		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_notify_sock, 5);
		//创建线程，用来在通知端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);

		//创建刷新端口的监听套接字
		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_REFRESH_PORT);
		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_refresh_sock, 5);
		//创建线程，用来在刷新端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);

		//创建传输端口的监听套接字
		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);
		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);
		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		listen(server_transfer_sock, 5);
		//创建线程，用来在传输端口上接受连接请求
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);

		printf("服务器在3个端口开始监听连接请求\\n");

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else if (argc >= 3 && strcmp(argv[1], "-client") == 0) //xx.exe -client s_ip xxx xxx
	{
		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写
		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);

		g_serverip = inet_addr(argv[2]);

		//创建用于连接到服务器通知端口的套接字
		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);
		sockaddr_in server_addr;
		server_addr.sin_family = AF_INET;
		server_addr.sin_addr.s_addr = g_serverip;
		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);
		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
		printf("客户端请求连接成功\\n");

		//发送共享文件名，文件名长度与服务器约定为100字节
		char buf[100];
		int i;
		for (i = 3; i<argc; i++)
		{
			strcpy(buf, argv[i]);
			mysend(client_notify_sock, buf, 100, 0);
		}
		//最后发送一个空文件名告诉服务器共享文件名已发完
		buf[0] = \'\\0\';
		mysend(client_notify_sock, buf, 100, 0);
		printf("客户端发送共享文件名成功\\n");

		//创建线程，用来接收服务器发来的“通知头部”
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，每隔10秒向服务器请求最新的共享文件列表
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);

		//创建线程，用来接收用户的键盘输入
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);

		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	else
		printf("启动参数不正确\\n");

	return 0;
}


/*
服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。
	通知
		等待连接：server_notify_sock
		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存

		创建线程 server_quit_thread：
			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)

	刷新
		等待连接：server_refresh_sock
		- 向客户端发送共享文件列表

	传输
		等待连接：server_transfer_sock
		- 服务器接收一个“传输头部”，判断是下载还是上传
			下载：
				构造一个“通知头部”发给被下载方
				client_notify_thread：...
			上传：	
				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方
				client_download_thread：循环接收数据并写入文件

----------------------------------------------------------------------
客户端： xx.exe -client s_ip xxx xxx

	连接服务器通知端口告知上线，发送共享文件名
		服务器：接收客户端发来的共享文件名
				server_quit_thread

	创建 3 个线程：

	client_refresh_thread：
		创建流套接字并连接到服务器的刷新端口
		接收最新共享文件列表

	client_userinput_thread：
		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，
			client_download_thread：
				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...
				给服务器发送表示下载的“传输头部”
				循环接收数据并写入文件

	client_notify_thread：
		接收一个“通知头部”
		创建线程，client_upload_thread：
			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口
			构造一个表示上传的“传输头部”并发送给服务器
			循环读取文件数据并上传

*/
```',
  'groups' => 'Linux',
  'showsel' => '0',
  'showse2' => '1',
  'id' => '248',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000664s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001507s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 248 LIMIT 1 [ RunTime:0.000548s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 248 LIMIT 1 [ RunTime:0.000309s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001083s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000390s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000330s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=248,`p_id`=2,`title`='Linux C 编程 - 文件下载（Windows）\r',`content`='# Linux C 编程 - 文件下载（Windows）\r\n```\r\n/*----------------------------------------------------------------------------------------------------------\r\n功能：\r\n建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。\r\n文件存在于各个客户端上，而不在服务器上。\r\n要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\n思路：\r\n1.服务器至少应该开放3个TCP端口供客户端连接。\r\n(1)第一个用来接收客户端发来的共享文件名以及向客户端发送别人想要下载他的文件的通知，不妨把这个端口叫做通知端口。\r\n(2)第二个用来向客户端每隔10秒发送最新共享文件列表，把它叫做刷新端口。\r\n(3)第三个用来提供文件传输的中转服务，叫做传输端口。\r\n2.本系统是围绕着共享文件而工作的，为了方便起见，应该把一个共享文件的全部信息封装成“共享文件结构体”，成员变量\r\n应该包括文件名、文件所在客户端的地址、服务器对应于这个客户端的通知套接字。\r\n3.通知端口和传输端口应该设计各自的长度固定的头部（可设计成结构体），叫做“通知头部”和“传输头部”。\r\n其中“传输头部”又有下载和上传两种。这样这两个端口的recv()函数就可以指定固定的接收长度了。\r\n4.服务器和客户端都要大量使用多线程。\r\n5.服务器可以用c++stl的multimap来保存共享文件列表，multimap的第一个字段是服务器上面对应于文件所在客户端的通知套接字，\r\n第二字段是共享文件结构体。这样设计一来是为了在客户端退出的时候能最方便地从multimap中删除这个客户端的所有共享文件信息，\r\n二来是为了在用户指定要下载哪个文件时不用通过搜索就知道该向哪个客户端发送通知。由于这个数据结构在客户端登录和\r\n退出时都要被修改，所以必须有并发控制。\r\n6.客户端的数据结构可以简单地用c++stl的vector来保存服务器发来的最新共享文件列表。vector中每个元素都是\r\n共享文件结构体。为防止用户选择文件时正好在刷新共享文件列表，也需要有并发控制。但应知道，这里的并发控制可以\r\n防止程序的运行出错，但并不能杜绝下载到非指定文件的可能性。\r\n7.系统的工作流程大致如下：服务器在3个端口上等待，客户端首先连接到通知端口，在这条连接上发送自己的共享文件名，\r\n然后同样在这条连接上准备接收“通知头部”。接着客户端每隔10秒连接到刷新端口并接收最新共享文件列表。\r\n客户端还需要用一个线程来准备读入用户的键盘输入，当用户有输入时，客户端连接到传输端口并发送一个表示下载的\r\n“传输头部”（其中最重要的就是一个共享文件结构体），然后在这条连接上准备接收文件数据。服务器收到这个\r\n“传输头部”后从中得到文件所在客户端的套接字，并构造一个“通知头部”（包括想下载文件的客户端的套接字和想下载的\r\n文件名）发送到这个套接字上。被下载方在通知端口上收到“通知头部”后，也连接到传输端口，先发送一个表示上传\r\n的“传输头部”（其中最重要的就是下载方的套接字），以便让服务器知道该把文件转发给谁，接着就可以开始上传文件了。\r\n考查：\r\n1.结合源代码和注释，搞懂这个系统的结构和流程，掌握套接字编程和多线程编程的相关技术，准备回答问题。\r\n2.已知：getsockname()函数可以获得套接字所使用的地址。自行查阅这个函数的原型，并在源程序基础上添加代码，\r\n使用户试图下载自己的文件时能阻止并提示“这个文件是你自己的”。\r\n3.按照本源程序的方案，分析在大负荷的情况下系统会有什么表现？应怎么改进？动手改源程序或者准备回答问题。\r\n4.本源程序除了未进行差错处理和用户指定下载一个前10秒之内退出系统的客户端上的文件时会得不到正确提示\r\n这些小问题外，故意留有一个真正的bug，此bug如果被激发，不仅会导致系统在一切正常并且被下载方没有退出时\r\n也会下载不成功，而且服务器有不确定的动作。试进行debug。\r\n----------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n#include \"stdafx.h\"\r\n#include \"stdio.h\"\r\n#include <map>\r\n#include <vector>\r\n#include \"Winsock2.h\"\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\n\r\n//宏定义\r\n//---------------------------------------------------------------------------------------------------------\r\n#define SERVER_NOTIFY_PORT		1024	//通知端口\r\n#define SERVER_REFRESH_PORT		1025	//刷新端口\r\n#define SERVER_TRANSFER_PORT	1026	//传输端口\r\n#define COMMAND_DOWNLOAD		0		//“传输头部”中表示下载的命令\r\n#define COMMAND_UPLOAD			1		//“传输头部”中表示上传的命令\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\n//结构体定义\r\n//---------------------------------------------------------------------------------------------------------\r\n#pragma pack(4)  //设置结构体按照4字节对齐\r\nstruct SHARED_FILE						//共享文件结构体，封装一个共享文件的所有信息。服务器端和客户端都要用到\r\n{\r\n	char				filename[100];	//文件名\r\n	struct sockaddr_in	client_addr;	//文件所在的客户端的网络地址\r\n	SOCKET				notify_sock;	//服务器上面对应于这个客户端的通知套接字\r\n};\r\nstruct TRANSFER_HEADER					//“传输头部”，由客户端发往服务器，准备开始一次下载或上传\r\n{\r\n	int cmd;							//命令，指明本次传输是为了下载还是上传，0-下载，1-上传\r\n	union\r\n	{\r\n		SHARED_FILE	shared_file;		//如果是下载，需要告诉服务器想下载的共享文件结构体\r\n		SOCKET		sock;				//如果是上传，需要告诉服务器想下载这个文件的客户端的套接字\r\n	};\r\n};\r\nstruct NOTIFY_HEADER					//“通知头部”，由服务器发往客户端，通知他有人想下载他的某个文件\r\n{\r\n	SOCKET	sock;						//告诉客户端是谁想下载他的文件\r\n	char	filename[100];				//告诉客户端想下载他的哪个文件\r\n};\r\n#pragma pack()  //取消结构体的字节对齐\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\n//全局变量\r\n//---------------------------------------------------------------------------------------------------------\r\n//服务器端的核心数据结构（多映射），用来保存所有共享文件的信息。映射的第一个字段是服务器上面对应于客户端的通知套接字，第二个字段是客户端的一个共享文件结构体\r\nstd::multimap<SOCKET, SHARED_FILE>		g_shared_files;\r\n//客户端的两个核心数据结构（数组），第一个用来暂存服务器发来的最新共享文件列表，第二个是第一个的拷贝\r\nstd::vector<SHARED_FILE>				g_files_list;\r\nstd::vector<SHARED_FILE>				g_files_list2;\r\nunsigned int							g_serverip;				//服务器的IP，网络字节序表示	\r\nHANDLE									g_server_semaphore;		//服务器使用的信号量，用于控制对 g_shared_files 的并发访问\r\nHANDLE									g_client_semaphore;		//客户端使用的信号量，用于控制对 g_files_list2 的并发访问\r\n//---------------------------------------------------------------------------------------------------------\r\n\r\n\r\nint mysend(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = send(sock, buf + sent, remain, flags);\r\n		if (n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\nint myrecv(SOCKET sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while (remain > 0)\r\n	{\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if (n == 0 || n == -1)  //0是对方调用closesocket()，-1是对方直接退出\r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器用于判断某个客户端是否下线\r\n//参数：服务器上对应于某个客户端的通知套接字\r\n//原理：由于通知端口的TCP连接是一直保持的，所以服务器在这个端口上调用recv()将会一直阻塞，直到客户端下线\r\n//创建者：server_notify_thread()\r\nDWORD WINAPI server_quit_thread(LPVOID lpParam)\r\n{\r\n	SOCKET comm_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		char c;\r\n		int ret = recv(comm_sock, &c, 1, 0);\r\n		if (ret == 0 || ret == -1)\r\n			break;\r\n	}\r\n	printf(\"有一个客户端退出了\\n\");\r\n\r\n	//删除g_shared_files中的信息\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	g_shared_files.erase(comm_sock);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器把最新共享文件列表发给客户端\r\n//参数：服务器在刷新端口上的监听套接字\r\n//原理：服务器在刷新端口上等待连接，建立连接后通过通信套接字把最新共享文件列表发给客户端\r\n//创建者：main()\r\nDWORD WINAPI server_refresh_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_refresh_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_refresh_sock, (struct sockaddr *)&client_addr, &size);\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n	//向客户端发送共享文件列表。为防止遍历的过程中有客户端登录或退出，要进行并发控制\r\n	WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量\r\n	std::multimap<SOCKET, SHARED_FILE>::const_iterator it;\r\n	for (it = g_shared_files.begin(); it != g_shared_files.end(); it++)\r\n		mysend(comm_sock, (char *)&(it->second), sizeof(SHARED_FILE), 0);\r\n	ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量\r\n\r\n	//最后发一个空文件名告诉客户端已发完\r\n	SHARED_FILE sf;\r\n	sf.filename[0] = \'\\0\';\r\n	mysend(comm_sock, (char *)&sf, sizeof(SHARED_FILE), 0);\r\n\r\n	closesocket(comm_sock);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器接受一个客户端上线\r\n//参数：服务器在通知端口上的监听套接字\r\n//原理：服务器在通知端口上等待连接，建立连接后接收客户端发来的共享文件名，并构造结构体存入多映射\r\n//创建者：main()\r\nDWORD WINAPI server_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_notify_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_notify_sock, (struct sockaddr *)&client_addr, &size);\r\n	printf(\"有一个客户端上线了\\n\");\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n	//接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n	char buf[100];\r\n	SHARED_FILE sf;	//文件名，客户端网络地址，客户端通知套接字\r\n	sf.client_addr = client_addr;\r\n	sf.notify_sock = comm_sock;\r\n	while (1)\r\n	{\r\n		myrecv(comm_sock, buf, 100, 0);\r\n		if (buf[0] == \'\\0\')  //空文件名，说明客户端已发完所有共享文件名\r\n			break;\r\n		strcpy(sf.filename, buf);\r\n\r\n		WaitForSingleObject(g_server_semaphore, INFINITE);  //获取信号量,p\r\n		g_shared_files.insert(std::make_pair(comm_sock, sf));//共享文件信息\r\n		ReleaseSemaphore(g_server_semaphore, 1, NULL);  //释放信号量,v\r\n	}\r\n\r\n	//创建线程，用来接收这个客户端退出的通知，以便及时从g_shared_files中删除信息\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_quit_thread, (void *)comm_sock, 0, NULL);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：服务器为文件传输做中转服务\r\n//参数：服务器在传输端口上的监听套接字\r\n//原理：服务器在传输端口上等待连接，建立连接后接收一个“传输头部”，并根据下载还是上传做相应中转\r\n//创建者：main()\r\nDWORD WINAPI server_transfer_thread(LPVOID lpParam)\r\n{\r\n	SOCKET server_transfer_sock = (SOCKET)lpParam;\r\n\r\n	sockaddr_in client_addr;\r\n	int size = sizeof(client_addr);\r\n	SOCKET comm_sock = accept(server_transfer_sock, (struct sockaddr *)&client_addr, &size);\r\n\r\n	//创建线程，用来等待下一个连接请求\r\n	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n	//接收一个“传输头部”\r\n	TRANSFER_HEADER th;\r\n	myrecv(comm_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n	if (th.cmd == COMMAND_DOWNLOAD)  //如果这个连接是为了下载文件\r\n	{\r\n		//构造一个“通知头部”准备发给被下载方\r\n		NOTIFY_HEADER nh;\r\n		nh.sock = comm_sock;  //将下载方的套接字告诉被下载方，以便将来他上传文件时回传这个套接字\r\n		strcpy(nh.filename, th.shared_file.filename);  //将文件名告诉被下载方\r\n\r\n		//从“传输头部”的共享文件结构体中取出被下载方对应的通知套接字\r\n		SOCKET client_notify_sock = th.shared_file.notify_sock;\r\n\r\n		//向这个通知套接字发送“通知头部”\r\n		int ret = mysend(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		if (ret != sizeof(NOTIFY_HEADER))  //说明被下载方已退出\r\n			closesocket(comm_sock);\r\n	}\r\n	else if (th.cmd == COMMAND_UPLOAD)  //如果这个连接是为了上传文件\r\n	{\r\n		//从“传输头部”中取出下载方对应的套接字\r\n		SOCKET download_client_sock = th.sock;\r\n\r\n		//循环接收数据并转发给下载方\r\n		char buf[1024];\r\n		while (1)\r\n		{\r\n			int i = recv(comm_sock, buf, 1024, 0);  //不需要调用myrecv()，因为不强求收满1024个字节\r\n			if (i > 0)\r\n				mysend(download_client_sock, buf, i, 0);  //但转发一定要保证发完i个字节\r\n			else\r\n			{\r\n				closesocket(download_client_sock);\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端每隔10秒向服务器请求最新共享文件列表\r\n//参数：NULL\r\n//原理：客户端每隔10秒创建一个套接字，连接到服务器的刷新端口，然后循环接收数据，每次接收一个共享文件结构体，接收完成后断开连接并进行屏幕显示\r\n//创建者：main()\r\nDWORD WINAPI client_refresh_thread(LPVOID lpParam)\r\n{\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n\r\n	while (1)\r\n	{\r\n		//创建流套接字并连接到服务器的刷新端口\r\n		SOCKET refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		connect(refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n		//接收最新共享文件列表\r\n		while (1)\r\n		{\r\n			SHARED_FILE sf;\r\n			myrecv(refresh_sock, (char *)&sf, sizeof(SHARED_FILE), 0);  //接收一个 SHARED_FILE 结构体\r\n\r\n			if (sf.filename[0] != \'\\0\')  //如果不是空文件名\r\n				g_files_list.push_back(sf);  //加入g_files_list保存，push_back：将一个新的元素加到 vector 的最后面\r\n			else  //空文件名，表示服务器本次发送共享文件列表已经完毕\r\n				break;\r\n		}\r\n\r\n\r\n		closesocket(refresh_sock);\r\n\r\n		//为防止此时用户正在选择 g_files_list2 中的某个文件，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		g_files_list2.clear();\r\n		g_files_list2 = g_files_list;\r\n		ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		g_files_list.clear();  //清空 g_files_list，准备下一次接收共享文件列表\r\n		printf(\"最新共享文件列表：\\n\");\r\n\r\n		std::vector<SHARED_FILE>::const_iterator it;\r\n		int i = 1;\r\n		for (it = g_files_list2.begin(); it != g_files_list2.end(); it++, i++)\r\n		{\r\n			printf(\"%d - %s:%d上的%s\", i, inet_ntoa(it->client_addr.sin_addr), ntohs(it->client_addr.sin_port), it->filename);\r\n			printf(\"\\n\");\r\n		}\r\n		printf(\"请输入文件的序号进行下载（0-退出）：\\n\");\r\n\r\n		Sleep(10000);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端进行文件上传\r\n//参数：指向“通知头部”的指针\r\n//原理：客户端从“通知头部”中得知是谁想下载他的文件以及想下载哪个文件，然后构造出表示上传的“传输头部”，连接到服务器的传输端口，首先发送“传输头部”然后发送文件\r\n//创建者：client_notify_thread()\r\nDWORD WINAPI client_upload_thread(LPVOID lpParam)\r\n{\r\n	NOTIFY_HEADER *pnh = (NOTIFY_HEADER *)lpParam;\r\n\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_upload_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_upload_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示上传的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_UPLOAD;  //指明这个连接是为了上传\r\n	th.sock = pnh->sock;  //指明想下载这个文件的客户端套接字\r\n	mysend(client_upload_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	FILE *fp = fopen(pnh->filename, \"rb\");\r\n	if (fp != NULL)\r\n		printf(\"开始上传文件%s\\n\", pnh->filename);\r\n	else\r\n	{\r\n		printf(\"找不到文件%s，上传失败\\n\", pnh->filename);\r\n		closesocket(client_upload_sock);\r\n		delete pnh;\r\n		return 0;\r\n	}\r\n\r\n	//循环读取文件数据并上传\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = fread(buf, 1, 1024, fp);\r\n		mysend(client_upload_sock, buf, i, 0);\r\n		if (i < 1024)  //fread()没读满1024个字节表示是最后一次读文件了\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_upload_sock);\r\n	printf(\"文件%s上传完成\\n\", pnh->filename);\r\n\r\n	delete pnh;\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端响应服务器发来的通知\r\n//参数：客户端已经同服务器的通知端口建立连接的通知套接字\r\n//原理：客户端在已经同服务器的通知端口建立了连接的通知套接字上等待接收“通知头部”，收到后以这个“通知头部”为参数启动client_upload_thread线程进行文件的上传\r\n//创建者：main()\r\nDWORD WINAPI client_notify_thread(LPVOID lpParam)\r\n{\r\n	SOCKET client_notify_sock = (SOCKET)lpParam;\r\n\r\n	while (1)\r\n	{\r\n		//接收一个“通知头部”\r\n		NOTIFY_HEADER nh;\r\n		myrecv(client_notify_sock, (char *)&nh, sizeof(NOTIFY_HEADER), 0);\r\n		printf(\"收到一个下载%s的通知\\n\", nh.filename);\r\n\r\n		NOTIFY_HEADER *pnh = new NOTIFY_HEADER;  //不能直接把nh的指针传给新线程，因为nh在本线程的栈中，随时可能被覆盖\r\n		*pnh = nh;\r\n		//创建线程，用来上传文件\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_upload_thread, (void *)pnh, 0, NULL);\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端进行指定文件的下载\r\n//参数：指向想下载的共享文件结构体的指针\r\n//原理：客户端根据想下载的共享文件结构体构造出表示下载的“传输头部”，连接到服务器的传输端口并发送这个“传输头部”，然后循环等待接收文件数据并存盘\r\n//创建者：client_userinput_thread()\r\nDWORD WINAPI client_download_thread(LPVOID lpParam)\r\n{\r\n	SHARED_FILE *psf = (SHARED_FILE *)lpParam;\r\n\r\n	//创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口\r\n	SOCKET client_download_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n	sockaddr_in server_addr;\r\n	server_addr.sin_family = AF_INET;\r\n	server_addr.sin_addr.s_addr = g_serverip;\r\n	server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n	connect(client_download_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n\r\n	//构造一个表示下载的“传输头部”并发送给服务器\r\n	TRANSFER_HEADER th;\r\n	th.cmd = COMMAND_DOWNLOAD;  //指明这个连接是为了下载\r\n	th.shared_file = *psf;  //指明想下载哪一个文件\r\n	delete psf;\r\n	mysend(client_download_sock, (char *)&th, sizeof(TRANSFER_HEADER), 0);\r\n\r\n	printf(\"开始下载%s:%d的%s\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	FILE *fp = fopen(th.shared_file.filename, \"wb\");\r\n	//循环接收数据并写入文件\r\n	char buf[1024];\r\n	while (1)\r\n	{\r\n		int i = recv(client_download_sock, buf, 1024, 0);  //不需要调用myrecv()\r\n		if (i > 0)\r\n			fwrite(buf, 1, i, fp);\r\n		else\r\n			break;\r\n	}\r\n	fclose(fp);\r\n	closesocket(client_download_sock);\r\n	printf(\"%s:%d的%s下载完毕\\n\", inet_ntoa(th.shared_file.client_addr.sin_addr), ntohs(th.shared_file.client_addr.sin_port), th.shared_file.filename);\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\n//-------------------------------------------------------------------------------------------------------\r\n//功能：客户端接收并处理用户的键盘输入\r\n//参数：NULL\r\n//原理：客户端等待用户的键盘输入，收到输入后从共享文件结构体数组中取出相应的结构体，并以此为参数启动client_download_thread线程进行文件的下载\r\n//创建者：main()\r\nDWORD WINAPI client_userinput_thread(LPVOID lpParam)\r\n{\r\n	int number;\r\n	while (1)\r\n	{\r\n		scanf(\"%d\", &number);\r\n		//客户端退出的方式是用户按下0\r\n		if (number == 0)\r\n		{\r\n			CloseHandle(g_client_semaphore);\r\n			exit(0);\r\n		}\r\n\r\n		//为防止此时正在刷新 g_files_list2，进行并发控制\r\n		WaitForSingleObject(g_client_semaphore, INFINITE);  //获取信号量\r\n		if (number > g_files_list2.size())\r\n			printf(\"请输入正确的序号\\n\");\r\n		else\r\n		{\r\n			SHARED_FILE *psf = new SHARED_FILE;\r\n			*psf = g_files_list2[number - 1];\r\n\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			struct sockaddr_in clientAddr;\r\n			int clientAddrLen = sizeof(clientAddr);\r\n			//用于获取与某个套接字关联的本地协议地址\r\n			//int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\n			getsockname((SOCKET)lpParam, (struct sockaddr *)&clientAddr, &clientAddrLen);//添加getsockname函数\r\n\r\n			SHARED_FILE	sel_file = *psf;\r\n\r\n			//char FAR* inet_ntoa(struct in_addr in); 地址转换函数\r\n			if (!strcmp(inet_ntoa(clientAddr.sin_addr), inet_ntoa(sel_file.client_addr.sin_addr)) && ntohs(clientAddr.sin_port) == ntohs(sel_file.client_addr.sin_port))\r\n			{\r\n				printf(\"不能下载自己的文件\\n\");\r\n			}\r\n			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n			else\r\n			{\r\n				//创建线程，用来完成下载任务\r\n				CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_download_thread, (void *)psf, 0, NULL);\r\n			}\r\n\r\n			ReleaseSemaphore(g_client_semaphore, 1, NULL);  //释放信号量\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n//-------------------------------------------------------------------------------------------------------\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	if (argc == 1)\r\n	{\r\n		printf(\"使用方法 : \\nfilename -server\\n或\\nfilename -client 服务器IP [共享文件名1] ...\\n\");\r\n		return 0;\r\n	}\r\n\r\n	//下面4行进行Windows网络环境的初始化。Linux中不需要\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n\r\n	if (argc == 2 && strcmp(argv[1], \"-server\") == 0)\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_shared_files 的并发修改\r\n		g_server_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		//创建通知端口的监听套接字\r\n		SOCKET server_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		bind(server_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_notify_sock, 5);\r\n		//创建线程，用来在通知端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_notify_thread, (void *)server_notify_sock, 0, NULL);\r\n\r\n		//创建刷新端口的监听套接字\r\n		SOCKET server_refresh_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_REFRESH_PORT);\r\n		bind(server_refresh_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_refresh_sock, 5);\r\n		//创建线程，用来在刷新端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_refresh_thread, (void *)server_refresh_sock, 0, NULL);\r\n\r\n		//创建传输端口的监听套接字\r\n		SOCKET server_transfer_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		server_addr.sin_port = htons(SERVER_TRANSFER_PORT);\r\n		bind(server_transfer_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		listen(server_transfer_sock, 5);\r\n		//创建线程，用来在传输端口上接受连接请求\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)server_transfer_thread, (void *)server_transfer_sock, 0, NULL);\r\n\r\n		printf(\"服务器在3个端口开始监听连接请求\\n\");\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else if (argc >= 3 && strcmp(argv[1], \"-client\") == 0) //xx.exe -client s_ip xxx xxx\r\n	{\r\n		//创建信号量，初值为1，用来控制对 g_files_list2 的并发读写\r\n		g_client_semaphore = CreateSemaphore(NULL, 1, 1, NULL);\r\n\r\n		g_serverip = inet_addr(argv[2]);\r\n\r\n		//创建用于连接到服务器通知端口的套接字\r\n		SOCKET client_notify_sock = socket(AF_INET, SOCK_STREAM, 0);\r\n		sockaddr_in server_addr;\r\n		server_addr.sin_family = AF_INET;\r\n		server_addr.sin_addr.s_addr = g_serverip;\r\n		server_addr.sin_port = htons(SERVER_NOTIFY_PORT);\r\n		connect(client_notify_sock, (struct sockaddr *)&server_addr, sizeof(server_addr));\r\n		printf(\"客户端请求连接成功\\n\");\r\n\r\n		//发送共享文件名，文件名长度与服务器约定为100字节\r\n		char buf[100];\r\n		int i;\r\n		for (i = 3; i<argc; i++)\r\n		{\r\n			strcpy(buf, argv[i]);\r\n			mysend(client_notify_sock, buf, 100, 0);\r\n		}\r\n		//最后发送一个空文件名告诉服务器共享文件名已发完\r\n		buf[0] = \'\\0\';\r\n		mysend(client_notify_sock, buf, 100, 0);\r\n		printf(\"客户端发送共享文件名成功\\n\");\r\n\r\n		//创建线程，用来接收服务器发来的“通知头部”\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_notify_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，每隔10秒向服务器请求最新的共享文件列表\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_refresh_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//创建线程，用来接收用户的键盘输入\r\n		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)client_userinput_thread, (void *)client_notify_sock, 0, NULL);\r\n\r\n		//消息循环，目的是不让主线程退出。Linux中换成while(1) pause();\r\n		MSG msg;\r\n		while (GetMessage(&msg, 0, 0, 0))\r\n		{\r\n			TranslateMessage(&msg);\r\n			DispatchMessage(&msg);\r\n		}\r\n	}\r\n	else\r\n		printf(\"启动参数不正确\\n\");\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n/*\r\n服务器：-server ，创建了 3 个端口的套接字，并分别创建了 3 个线程用于等待连接。\r\n	通知\r\n		等待连接：server_notify_sock\r\n		- 接收客户端发来的共享文件名，构造成共享文件结构体并加入 g_shared_files 保存\r\n\r\n		创建线程 server_quit_thread：\r\n			服务器在这个端口上调用recv()将一直阻塞，直到客户端下线(返回0/-1)\r\n\r\n	刷新\r\n		等待连接：server_refresh_sock\r\n		- 向客户端发送共享文件列表\r\n\r\n	传输\r\n		等待连接：server_transfer_sock\r\n		- 服务器接收一个“传输头部”，判断是下载还是上传\r\n			下载：\r\n				构造一个“通知头部”发给被下载方\r\n				client_notify_thread：...\r\n			上传：	\r\n				从“传输头部”中取出下载方对应的套接字，循环接收数据并转发给下载方\r\n				client_download_thread：循环接收数据并写入文件\r\n\r\n----------------------------------------------------------------------\r\n客户端： xx.exe -client s_ip xxx xxx\r\n\r\n	连接服务器通知端口告知上线，发送共享文件名\r\n		服务器：接收客户端发来的共享文件名\r\n				server_quit_thread\r\n\r\n	创建 3 个线程：\r\n\r\n	client_refresh_thread：\r\n		创建流套接字并连接到服务器的刷新端口\r\n		接收最新共享文件列表\r\n\r\n	client_userinput_thread：\r\n		键盘输入，客户端创建线程，用来完成下载任务，执行线程函数 client_download_thread ，\r\n			client_download_thread：\r\n				创建套接字并连接到服务器的 SERVER_TRANSFER_PORT 端口 ...\r\n				给服务器发送表示下载的“传输头部”\r\n				循环接收数据并写入文件\r\n\r\n	client_notify_thread：\r\n		接收一个“通知头部”\r\n		创建线程，client_upload_thread：\r\n			创建套接字并连接到服务器的SERVER_TRANSFER_PORT端口\r\n			构造一个表示上传的“传输头部”并发送给服务器\r\n			循环读取文件数据并上传\r\n\r\n*/\r\n```',`groups`='Linux',`is_show`=0,`publish`=1,`summary`=''  WHERE  `id` = 248 [ RunTime:0.001617s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001587s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=13  WHERE  `groups` = 'Default' [ RunTime:0.000471s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001161s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=12  WHERE  `groups` = 'Linux' [ RunTime:0.000381s ]
---------------------------------------------------------------
[ 2018-11-16T21:15:50+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/248.html
[ info ] qingrang.top/daily/admin/note/shownote/id/248.html [运行时间：0.082136s][吞吐率：12.17req/s] [内存消耗：2,030.29kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/248.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '248',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000678s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001874s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 248 LIMIT 1 [ RunTime:0.000674s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001414s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000439s ]
---------------------------------------------------------------
[ 2018-11-16T21:16:23+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.067109s][吞吐率：14.90req/s] [内存消耗：2,399.80kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '113892',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
*输出*
```
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33
```

### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
http://qingrang.top/daily/admin/note/shownote/id/248.html',
  'groups' => 'Linux',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000561s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001334s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000722s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000324s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000996s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000310s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000393s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验：fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n========================================================================*/\r\n\r\n```\r\n\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n>不 sleep 的输出：\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n----------------------------------------------------------\r\n>sleep() 后的输出：\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n========================================================================*/\r\n```\r\n\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验：李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n### 信号量\r\n#### 信号量的概念\r\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\r\n1. 测试控制该资源的信号量。\r\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\r\n\r\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\r\n\r\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\r\n\r\n#### 信号量的创建与打开 semget\r\n函数声明：`int semget(key_t key,int nsems,int semflg)`\r\n\r\nkey：所创建或打开的信号量集合的键\r\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\r\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\r\n\r\n返回：\r\n- 成功：返回信号量ID\r\n- 失败：-1，并设置 errno\r\n\r\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\r\n\r\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\r\n\r\n#### 对信号量的控制 semctl\r\n\r\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\r\n\r\nsemid：为信号量集合的标识符。\r\nsemnum：用于指明某个特定信号量。\r\ncmd：表示调用该函数希望执行的命令\r\ncmd 的常用设置：\r\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\r\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\r\n\r\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\r\n```\r\nunion semen{\r\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\r\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\r\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\r\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\r\n};\r\n```\r\n\r\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\r\n```\r\nushort semid_ds{\r\n	struct ipc_perm sem_perm;	//所有者和标致权限\r\n	time_t sem_otime;	//最后操作时间\r\n	time_t sem_ctime;	//最后更改时间\r\n	unsigned short sem_nsems;	//信号集中的信号数量\r\n}\r\n```\r\n\r\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\r\n#### 对信号量的操作——semop\r\n改变信号量的值\r\n\r\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\r\n\r\nsemid：为信号量集合的ID\r\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\r\n```\r\nstruct sembuf{\r\n	short sem_num;	//信号量在信号集中的编号\r\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\r\n	short sem_flag;	//标志位\r\n};\r\n```\r\nnops：参数 sops 所指数组中元素的个数\r\n\r\n返回：若成功则为 0，若出错则为 -1。\r\n\r\n### 共享内存\r\n#### 共享内存的概念\r\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\r\n\r\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\r\n\r\n#### 共享内存的创建和打开 shmget\r\n函数声明：`int shmget(key_t key, int size, int flag) ;`\r\n\r\nkey：表示所创建或打开的共享内存的键\r\nsize：表示共享内存区域的大小\r\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\r\n\r\n返回：若成功则为共享内存ID，若出错则为 -1。\r\n\r\n#### 共享内存的附加 shmat\r\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\r\n\r\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\r\n`\r\n\r\nshmid：表示要附加的共享内存段的ID\r\naddr：虚拟地址\r\nflag：用于表示函数的操作方式\r\n\r\n返回：若成功则为指向共享内存段的指针，若出错则为-1\r\n\r\n#### 共享内存的分离 shmdt\r\n解除物理内存与进程虚拟地址空间的映射关系\r\n\r\n函数声明：`int shmdt(void *addr) ;`\r\n\r\naddr：是以前调用 shmat 时的返回值。\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n#### 共享内存的控制 shmctl\r\n对共享内存段执行多种操作。\r\n\r\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\r\n`\r\nshmid：为共享内存的标识符\r\ncmd：表示调用该函数希望执行的操作\r\n\r\n---\r\ncmd 的取值和对应操作如下：\r\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\r\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\r\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\r\n\r\n---\r\nbuf：指向 shmid_ds 结构体的指针\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。	\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n//semun 共用体\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;//信号量ID\r\nint shmid;//共享内存ID\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\n// P操作，获取信号量，-1\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\r\n	semop(semid, &buf, 1);	//改变信号量的值\r\n}\r\n\r\n// V操作，释放信号量，+1\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\r\n	\r\n	//删除信号量\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n\r\n	//删除共享内存\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	//int semget(key_t key,int nsems,int semflg)\r\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\r\n	//成功：返回信号量ID，失败：-1\r\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\r\n\r\n	if(semid == -1)	//信号量创建失败\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	 //返回信号量ID\r\n		printf(\"create semaphore ok\\n\");\r\n	}\r\n\r\n	//semun 共用体\r\n	union semun x;\r\n	x.val = 1;  //信号量初值应为多少？为1\r\n\r\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\r\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\r\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\r\n	\r\n	//int shmget(key_t key, int size, int flag);\r\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\r\n	//若成功则为共享内存ID，若出错则为 -1\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\r\n	if(shmid == -1)	\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	//返回共享内存ID\r\n		printf(\"create shared-memory ok\\n\");\r\n	}\r\n\r\n	//void *shmat(int shmid, void *addr, int flag) ;\r\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\r\n	//成功则为指向共享内存段的指针，若出错则为-1\r\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\r\n\r\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\r\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\r\n\r\n	//flag 是否是子进程\r\n	char is_child = 0;\r\n	int i;\r\n	//循环创建 10 个进程\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork(); \r\n		if(pid == 0)	//子进程\r\n		{\r\n			is_child = 1;  //设置子进程中 is_child 为 1\r\n			break;  //退出循环\r\n		}\r\n	}\r\n\r\n	//子进程\r\n	if(is_child)\r\n	{\r\n		p(semid);  // P操作，获取信号量（-1）\r\n\r\n		srand(time(NULL) + i);	//设置随机种子数\r\n		int num = rand()%10;	//取 0-9 随机数\r\n\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\r\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作，释放信号量（+1）\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\r\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();//挂起，等待信号唤醒\r\n	}\r\n\r\n	return 0;\r\n}\r\n/*========================================================================\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n========================================================================*/\r\n```\r\n## socket 编程接口\r\n### 套接口概念\r\n套接口实际就是网络进程的 PID（Process ID）。\r\n\r\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\r\n### 阻塞模式和非阻塞模式（同步和异步）\r\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\r\n\r\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\r\n\r\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\r\n\r\n### getsockname/getpeername\r\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\r\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\r\n*函数定义*\r\n```\r\n#include<sys/socket.h>\r\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\r\n```\r\n\r\n### 字节序转换\r\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\r\n\r\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\r\n\r\n#### 返回网络字节序 htons/htonl\r\n`u_short htons(u_short hostshort);`\r\n\r\n`u_long htonl(u_long hostlong);`\r\n\r\n#### 返回主机字节序 ntohs/ntohl\r\n`u_short ntohs(u_short netshort);`\r\n\r\n`u_long ntohl(u_long netlong);`\r\n\r\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\r\n### 地址转换函数\r\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\r\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\r\n要实现两者之间的转换，就要用到以下两个函数：\r\n\r\n`unsigned long inet_addr(const char FAR* cp);`\r\n\r\n成功：返回 32 位二进制的网络字节序地址\r\n出错：返回 INADDR_NONE。\r\n\r\n`char FAR* inet_ntoa(struct in_addr in);`\r\n\r\n成功：返回字符串的指针\r\n失败：返回 NULL\r\n\r\n### 流套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\r\n客户端：创建套接字——请求连接。\r\n\r\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\r\n\r\n最后，通信完毕，任意一方都可关闭套接字。\r\n### 数据报套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\r\n客户端：创建套接字——直接进行数据的发送。\r\n\r\n通信完毕，任意一方都可关闭套接字。\r\n\r\n### sockaddr 和 sockaddr_in 结构体\r\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\r\n\r\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\r\n\r\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\r\n```\r\nstruct sockaddr\r\n{\r\n	unit8_t	sa_len;\r\n	sa_family_t	sa_family;	//协议族名\r\n	char	sa_data[14];\r\n}\r\n```\r\n\r\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\r\n```\r\nstruct sockaddr_in\r\n{\r\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\r\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\r\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\r\n	struct in_addr sin_addr;\r\n	char	sin_zero[8];	//备用的域名，未使用\r\n};\r\nstruct in_addr\r\n{\r\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\r\n};\r\n```\r\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\r\n\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\r\n\r\n### 套接口函数\r\n#### 总结步骤\r\n>一个服务器进程中系统调用的顺序通常如下\r\n\r\nsocket();\r\nbind();\r\nlisten();\r\naccept();\r\n>而客户端进程的调用则比较简单\r\n\r\nsocket();\r\nconnect();\r\n#### 创建套接字 socket\r\n\r\n`int socket(int family,int type,int protocol);`\r\n\r\nfamily：指明协议族\r\ntype：指明套接口类型\r\nprotocol：一般为 0\r\n\r\n成功：返回值为非负描述字\r\n失败：返回值为负值\r\n\r\n>参数 family 的取值范围\r\n\r\nAF_LOCAL：UNIX 协议族\r\nAF_ROUTE：路由套接口\r\nAF_INET：IPv4 协议\r\nAF_INET6：IPV6 协议\r\nAF_KEY：密钥套接口\r\n\r\n>参数 type 的取值范围\r\n\r\nSOCK_STREAM：TCP 套接口\r\nSOCK_DGRAM：UDP 套接口\r\nSOCK_PACKET：支持数据链路访问\r\nSOCK_RAM：原始套接口\r\n\r\n#### 绑定套接口 bind\r\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\r\n\r\nsockfd：套接字\r\nmyaddr：是一个指向特定协议地址结构体的指针\r\naddrlen：是地址结构体的长度。\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\r\n\r\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\r\n\r\n#### 连接 connect\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\nsockfd：套接口描述字\r\nserv_addr：目的端口和IP地址的套接口\r\naddrlen：目的套接口的长度\r\n\r\n成功：返回 0\r\n失败：返回 -l\r\n\r\n#### 监听 listen\r\n`int listen(int sockfd,int backlog);`\r\n\r\nsockfd：套接字\r\nbacklog：规定内核为此套接口排队的最大选择个数\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 接受连接 accept (阻塞函数)\r\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\r\n\r\ncliaddr：远程客户的套接口地址\r\naddrlen：套接口地址长度\r\nsockfd：监听套接字，它由函数 socket() 生成\r\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\r\n\r\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\r\n失败：返回 -1\r\n\r\n>客户套接和监听套接字的区别：\r\n\r\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\r\n\r\n>accept()是一个阻塞函数\r\n\r\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\r\n\r\n#### 关闭 close\r\n`int close(int sockfd);`\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 发送 send/sendto (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int send(int sockfd,const void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\r\n\r\n#### 接收 recv/recvfrom (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int recv(int sockfd,void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\r\n\r\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\r\n\r\n>Mysend 方法\r\n\r\n```\r\nint Mysend(SOCKET s, const char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iSendCount = 0:\r\n	int iLength = len:\r\n	while (iLength > 0)\r\n	{\r\n		int n = send(s, buf* iSendCount, iLength, flags);\r\n		if(n == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= n:\r\n		iSendCount += n:\r\n	}\r\n	return iSendCount\r\n}\r\n```\r\n\r\n>Myrecv 方法\r\n\r\n```\r\nint Myrecv(SOCKET s, char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iRecvCount = 0;\r\n	int iLength = len;\r\n	while (iLength > 0)\r\n	{\r\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\r\n		if(nReU == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= nRev;\r\n		iRecuCount += nRev;\r\n	}\r\n	return iRecvCount;\r\n}\r\n```\r\n## 多线程\r\n### 线程函数的原型\r\n#### Windows\r\n`DWOED ThreadProc(LPVOID lpParameter);`\r\n### 创建新线程\r\n#### Windows - CreateThread\r\nWin32 API 函数 ：CreateThread()\r\n```\r\nHANDLE CreateThread(\r\n	LPSECURITY_ATTRIBUTES lpsa,\r\n	DWORD cbStack,\r\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\r\n	LPVOID lpvThreadParam,	//传给线程函数的参数\r\n	DWORD fdwCreate,\r\n	LPDWORD lpIDThread\r\n);\r\n```\r\n#### Unix - pthread_create\r\n```\r\n#include  <pthread.h>\r\nint  pthread_create（\r\n	pthread_t  *thread,	//待传入线程的线程ID指针\r\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n	void  *arg	//要传给线程执行函数的参数\r\n）\r\n```\r\n### 一个线程等待另一个线程结束的方法\r\n#### Unix - pthread_join\r\n```\r\n#include  <pthread.h>\r\nint pthread_join(\r\n	pthread_t thread,\r\n	void **retval\r\n);\r\n```\r\n### Linux 中编译多线程程序的方法\r\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\r\n\r\n### 线程的并发（同步）问题\r\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\r\n\r\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\r\n\r\nWindows 中主要函数有：\r\n```\r\nCreateSemaphore() //创建信号量\r\nWaitForSingleObject() //获取信号量，P\r\nReleaseSemaphore() //释放信号量，V\r\nCloseHandle() //关闭一个内核对象\r\n```\r\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\r\n```\r\n/*------------------------------------------------------------------------------------------------\r\n任务：\r\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\r\n思路：\r\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\r\n-------------------------------------------------------------------------------*/\r\n\r\n//=======================================================================================\r\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \r\n//=======================================================================================\r\n\r\n///*------------------------ Windows 的头文件 ----------------------------\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <time.h>\r\n#include <Winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\r\n//----------------------------------------------------------------------*/\r\n\r\n/*------------------------- Linux 的头文件 -----------------------------\r\n#include <sys/types.h>\r\n#include <sys/ipc.h>\r\n#include <sys/sem.h>\r\n#include <pthread.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h> \r\n#include <netinet/in.h> \r\n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\r\n-----------------------------------------------------------------------*/\r\n\r\n//=========================================\r\n//            	全局变量\r\n//=========================================\r\n\r\n//-------------------------- 判断平台 -------------------------\r\n#ifdef WINDOWS_VERSION //windows 平台\r\n	HANDLE  g_hSem;    //信号量的句柄\r\n	HANDLE  g_hThread[10];  //10个线程的句柄\r\n#else //Linux 平台\r\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\r\n	{\r\n		int val;\r\n		struct semid_ds *buf;\r\n		ushort *array;\r\n	};\r\n	int   semid;    //信号量的ID\r\n	pthread_t thread_id[10];  //10个线程的ID\r\n#endif\r\n	int  total;      //和\r\n	int  listen_sock;    //用于监听的套接字\r\n	short port;      //端口\r\n//----------------------------------------------------\r\n\r\n/**\r\n * 发送\r\n */\r\nint mysend(int sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int send(int sockfd,const void *buffer,int length,int flags);\r\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\r\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\n/**\r\n * 接收一个整数(阻塞函数)\r\n */\r\nint myrecv(int sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int recv(int sockfd,void *buffer,int length,int flags);\r\n		//返回：0是对方调用close()，-1是对方直接退出\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if(n == 0 || n == -1)  \r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n/**\r\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\r\n * \r\n * @param num 进程编号\r\n */\r\nvoid send_num_to_parent(int num)\r\n{\r\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET;\r\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\r\n	server_addr.sin_port  = htons(port);\r\n \r\n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\r\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\r\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\r\n\r\n	mysend(sock, (char *)&num, 4, 0);\r\n\r\n#ifdef WINDOWS_VERSION\r\n	closesocket(sock);\r\n#else\r\n	close(sock);\r\n#endif\r\n}\r\n\r\n#ifndef WINDOWS_VERSION\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n#endif\r\n\r\n\r\n#ifdef WINDOWS_VERSION\r\n	DWORD WINAPI thread_function(void *arg) \r\n#else\r\n	/**\r\n	 * 线程函数\r\n	 * 处理 accept，并创建下一个线程\r\n	 */\r\n	void *thread_function(void *arg)\r\n#endif\r\n	{ \r\n		int index = (int)arg;	//序号\r\n\r\n		//准备接受连接请求\r\n		struct sockaddr_in peer_addr;//套接口地址结构体\r\n		int size = sizeof(struct sockaddr_in);\r\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\r\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\r\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\r\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\r\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\r\n \r\n		//accept 完毕，创建下一个线程\r\n		if(index < 9)\r\n#ifdef WINDOWS_VERSION\r\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\r\n#else\r\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\r\n#endif\r\n\r\n		//自己，服务端\r\n		int num;\r\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\r\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\r\n\r\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\r\n#ifdef WINDOWS_VERSION\r\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\r\n		total += num;\r\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\r\n		closesocket(comm_sock);\r\n		// ExitThread(0);\r\n		return 0;//线程结束\r\n#else\r\n		p(semid);\r\n		total += num;\r\n		v(semid);\r\n		//int close(int sockfd);\r\n		//成功：返回 0，失败：返回 -1\r\n		close(comm_sock);\r\n		pthread_exit(NULL);\r\n#endif\r\n	}\r\n\r\n/**\r\n * 父进程(服务器)\r\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\r\n */\r\nvoid init_socket()\r\n{\r\n	//int socket(int family,int type,int protocol);\r\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\r\n	//成功：返回值为非负描述字，失败：返回值为负值\r\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\r\n\r\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET; //IP_V4\r\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\r\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\r\n\r\n	//随机产生一个端口号，但要大于1024才行\r\n	srand(time(NULL));  \r\n	port = rand()%10000;\r\n	while(port < 1024)\r\n		port = rand()%10000;\r\n\r\n	//htons：将主机的无符号短整形数转换为网络字节顺序\r\n	server_addr.sin_port = htons(port);\r\n\r\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\r\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\r\n	//成功：返回 0，失败：返回 -1\r\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\r\n\r\n	//int listen(int sockfd,int backlog);\r\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\r\n	//成功：返回 0，失败：返回 -1\r\n	listen(listen_sock, 5);//将套接字置于监听状态\r\n\r\n	printf(\"parent : 服务器开始监听连接请求\\n\");\r\n}\r\n\r\n/**\r\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\r\n * @param i 线程编号	\r\n */\r\nvoid do_child(int i)\r\n{\r\n	srand(time(NULL) + i);\r\n	int num = rand()%10;\r\n\r\n	printf(\"child%d: %d\\n\", i, num);\r\n\r\n	send_num_to_parent(num);\r\n}\r\n\r\n/**\r\n * 主函数\r\n *\r\n * @param  argc 命令行输入的参数个数\r\n * @param  argv 字符二维数组\r\n */\r\nint main(int argc, char* argv[])\r\n{\r\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \r\n#ifdef WINDOWS_VERSION\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n#endif\r\n\r\n	// Windows 中的父进程，Linux 中的父、子进程\r\n	if(argc == 1)  \r\n	{\r\n		total = 0;	//初始化 total 为 0 \r\n\r\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\r\n#ifdef WINDOWS_VERSION\r\n		//1 个信号量，初始为 1\r\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\r\n#else\r\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\r\n		union semun x;\r\n		x.val = 1;\r\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\r\n#endif\r\n  \r\n		//初始化网络环境，完成服务器的准备工作\r\n		init_socket();\r\n\r\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\r\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\r\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\r\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\r\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\r\n#else\r\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\r\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\r\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n		//	void  *arg	//要传给线程执行函数的参数\r\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\r\n#endif\r\n\r\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\r\n#ifdef WINDOWS_VERSION\r\n		STARTUPINFO si;\r\n		PROCESS_INFORMATION pi;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			//处理命令行字符串\r\n			char *p = GetCommandLine();\r\n			char strCmdLine[256];\r\n			strcpy(strCmdLine, p);\r\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\r\n\r\n			ZeroMemory( &si, sizeof(si) );\r\n			si.cb = sizeof(si);\r\n			ZeroMemory( &pi, sizeof(pi) );\r\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\r\n		}\r\n		//等待 10 个线程结束\r\n		for(i=0; i<10; i++)\r\n			WaitForSingleObject(g_hThread[i], INFINITE);\r\n#else\r\n		char is_child = 0;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			pid_t pid = fork();\r\n			if(pid == 0)\r\n			{\r\n				is_child = 1;\r\n				break;\r\n			}\r\n		}\r\n		if(is_child)\r\n		{\r\n			do_child(i);\r\n			return 0;\r\n		}\r\n		else\r\n		{\r\n			//等待 10 个线程结束\r\n			for(i=0; i<10; i++)\r\n				pthread_join(thread_id[i], NULL);\r\n		}\r\n#endif\r\n		printf(\"parent : all threads ended, total=%d\\n\", total);\r\n\r\n//删除信号量\r\n#ifdef WINDOWS_VERSION\r\n		CloseHandle(g_hSem);\r\n#else\r\n		semctl(semid, IPC_RMID, 0);\r\n#endif\r\n	}\r\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \r\n	{\r\n#ifdef WINDOWS_VERSION\r\n		char *p = GetCommandLine();\r\n		//下面 2 行从命令行中解析出端口号\r\n		p = strchr(p, \'-\');\r\n		sscanf(p+1, \"%d\", &port);\r\n\r\n		//下面 3 行从命令行中解析出子进程的序号\r\n		p = strchr(p+1, \'-\');\r\n		int index;\r\n		sscanf(p+1, \"%d\", &index);\r\n		do_child(index);\r\n#endif\r\n	}\r\n else\r\n	printf(\"启动命令不正确\\n\");\r\n	return 0;\r\n}\r\n```\r\n*输出*\r\n```\r\nparent : 服务器开始监听连接请求\r\nchild0: 1\r\nparent : 线程0接受一个连接请求\r\nparent : 线程0接收到一个整数1\r\nchild1: 4\r\nparent : 线程1接受一个连接请求\r\nparent : 线程1接收到一个整数4\r\nchild2: 7\r\nparent : 线程2接受一个连接请求\r\nparent : 线程2接收到一个整数7\r\nchild3: 0\r\nparent : 线程3接受一个连接请求\r\nparent : 线程3接收到一个整数0\r\nchild5: 7\r\nchild4: 4\r\nparent : 线程4接受一个连接请求\r\nchild6: 0\r\nchild7: 3\r\nchild8: 7\r\nparent : 线程4接收到一个整数7\r\nchild9: 0\r\nparent : 线程5接受一个连接请求\r\nparent : 线程5接收到一个整数4\r\nparent : 线程6接受一个连接请求\r\nparent : 线程6接收到一个整数0\r\nparent : 线程7接受一个连接请求\r\nparent : 线程7接收到一个整数3\r\nparent : 线程8接受一个连接请求\r\nparent : 线程8接收到一个整数7\r\nparent : 线程9接受一个连接请求\r\nparent : 线程9接收到一个整数0\r\nparent : all threads ended, total=33\r\n```\r\n\r\n### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\nhttp://qingrang.top/daily/admin/note/shownote/id/248.html',`groups`='Linux',`is_show`=1,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识'  WHERE  `id` = 212 [ RunTime:0.001684s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001071s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=12  WHERE  `groups` = 'Linux' [ RunTime:0.000397s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000940s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=12  WHERE  `groups` = 'Linux' [ RunTime:0.000304s ]
---------------------------------------------------------------
[ 2018-11-16T21:16:24+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.061154s][吞吐率：16.35req/s] [内存消耗：2,062.52kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000529s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001971s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000693s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001021s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000308s ]
---------------------------------------------------------------
[ 2018-11-16T21:16:37+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.077783s][吞吐率：12.86req/s] [内存消耗：2,356.54kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000819s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001493s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001974s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000592s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000981s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000408s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000562s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001006s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000379s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000510s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000367s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001140s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000227s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001097s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000664s ]
---------------------------------------------------------------
[ 2018-11-16T21:23:14+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/212.html
[ info ] qingrang.top/daily/admin/note/editnote/id/212.html [运行时间：0.065071s][吞吐率：15.37req/s] [内存消耗：2,114.72kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000605s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001648s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000610s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001069s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000336s ]
---------------------------------------------------------------
[ 2018-11-16T21:23:20+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/212.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/212.html [运行时间：0.075867s][吞吐率：13.18req/s] [内存消耗：2,399.78kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '113892',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => 'Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识',
  'content' => '# Linux - C 编程
[TOC]
## 进程
### 孤儿进程 和 僵尸进程
Linux 系统中有两种特殊的进程：孤儿进程和僵尸进程。

父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。

当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。

### 进程标识符
下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`
```
//头文件
#include <sys/types.h>
#include <unistd.h>

//返回:调用进程的 进程ID
pid_t getpid(void)	

//返回:调用进程的 父进程ID
pid_t getppid(void);

//返回:调用进程的 实际用户ID
uid_t getuid(void)

//返回:调用进程的 有效用户ID
uid_t geteuid(void)

//返回:调用进程的 实际组ID
gid_t getgid (void)

//返回:调用进程的 有效组ID
gid_t getegid(void)
```
### 进程同步
Linux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。
```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status) ;
pid_t waitpid(pid_t pid , int * status, int options) ;
//两个函数返回：若成功则为 进程ID，若出错则为 -1。
```
### 实验：fork() 函数的使用
fork() 函数:
创建成功，父进程返回子进程的 id ，子进程返回 0
创建失败，父进程返回 -1
>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能

```
/*---------------------------------------------------
使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
	//调用fork()函数创建子进程
	pid_t pid = fork();
	if (pid == -1)	//创建失败
	{
		perror("fork error");
		exit(1);	//退出进程，指定返回值1
	}
	else if (pid > 0)	//创建成功 - 父进程
	{
		printf("父进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	else if (pid == 0)	//创建成功 - 子进程
	{
		printf("子进程,pid=%d,ppid=%d\\n", getpid(), getppid());
	}
	printf("........finish..........\\n");
	return 0;
}

/*========================================================================
父进程,pid=3720,ppid=3514
........finish..........
子进程,pid=3721,ppid=2012
........finish..........
========================================================================*/

```

- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?
答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。

>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid

```
/*---------------------------------------------------
使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid
-----------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int i;
	//循环创建进程
	for (i = 0; i<5; i++){				
		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环
			break;
	}
	if (pid == -1){
		perror("fork error");
		exit(1);
	}
	else if (pid>0){	//父进程
		//sleep(5);	//父进程等待所有子进程执行结束后再执行
		printf("parent process:pid=%d\\n", getpid());
	}
	else if (pid == 0){		//子进程
		//sleep(i);	//每个子进程分别沉睡不同的时间
		printf("I am child=%d,pid=%d\\n", i + 1, getpid());
	}
	return 0;
}

/*========================================================================
>不 sleep 的输出：
zhangliren@ubuntu:~/Documents$ ./a.out 
I am child=2,pid=3814
parent process:pid=3812
I am child=1,pid=3813
I am child=4,pid=3816
zhangliren@ubuntu:~/Documents$ I am child=5,pid=3817
I am child=3,pid=3815
|(终端提示符)
----------------------------------------------------------
>sleep() 后的输出：
I am child=1,pid=3843
I am child=2,pid=3844
I am child=3,pid=3845
I am child=4,pid=3846
I am child=5,pid=3847
parent process:pid=3842
========================================================================*/
```

- 观察输出结果,会发现输出结果有以下问题
（1）子进程的编号不是递增的
（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁
这是为什么?

答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。
（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。

## 信号和信号处理
### 信号的概念
信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。

可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：
1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。
2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。
3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。

### 常见函数
#### kill
给指定进程发送信号

函数声明：`int kill(pid_t,int sig)`
pid：接收信号的进程ID
sig：要发送的信号编号
#### raise
发送指定信号给当前进程自身

函数声明：`int raise(int sig)`

#### pause
暂停进程，接收到任何信号后恢复

函数声明：`int pause()`

#### alarm
计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。

函数声明：`unsigned int alarm(unsigned int seconds)`

#### signal
捕获信号后，执行指定函数

函数声明：
`typedef void (* sighandler_t)(int);`
`sighandler_t signal(int signum,sighandler_t handler);`

signum：信号编号
handler：自定义信号处理函数的函数指针

### 实验：李纳斯的第一个程序
```
/*---------------------------------------------------------------------------------------------------------
李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。
---------------------------------------------------------------------------------------------------------*/
#include "stdio.h"
#include "sys/types.h"
#include "signal.h"

pid_t pid;

//自定义信号处理函数。
//父进程打印 AAA，子进程打印 BBB
void sigusr1_handler(int n)
{
	if(pid > 0)
		printf("AAAA\\n");
	else
		printf("BBBB\\n");

	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程
}

void sigalrm_handler(int n)
{
	if(pid > 0){	//父进程
		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程
	}
	else{	//子进程
		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程
	}
}

int main()
{
	//在fork()之前设置的信号处理函数会被子进程继承
	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler
	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	pid = fork();
	if (pid > 0)	//父进程
		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程

	while(1)
		pause();	//进程挂起，等待信号唤醒

	return 0;
}
```
## 进程间通信
### 信号量
#### 信号量的概念
信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：
1. 测试控制该资源的信号量。
1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。

这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。

常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。

#### 信号量的创建与打开 semget
函数声明：`int semget(key_t key,int nsems,int semflg)`

key：所创建或打开的信号量集合的键
nsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效
semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示

返回：
- 成功：返回信号量ID
- 失败：-1，并设置 errno

>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：

- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。
- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。
- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。

#### 对信号量的控制 semctl

函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`

semid：为信号量集合的标识符。
semnum：用于指明某个特定信号量。
cmd：表示调用该函数希望执行的命令
cmd 的常用设置：
- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置
- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量

arg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：
```
union semen{
	int val;	//cmd 为 SETVAL 时，用于指定信号量值
	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效
	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效
	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效
};
```

该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：
```
ushort semid_ds{
	struct ipc_perm sem_perm;	//所有者和标致权限
	time_t sem_otime;	//最后操作时间
	time_t sem_ctime;	//最后更改时间
	unsigned short sem_nsems;	//信号集中的信号数量
}
```

返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。
#### 对信号量的操作——semop
改变信号量的值

函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `

semid：为信号量集合的ID
semoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：
```
struct sembuf{
	short sem_num;	//信号量在信号集中的编号
	short sem_op;	//信号量操作,-1 P操作，+1 V操作
	short sem_flag;	//标志位
};
```
nops：参数 sops 所指数组中元素的个数

返回：若成功则为 0，若出错则为 -1。

### 共享内存
#### 共享内存的概念
共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。

共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。

#### 共享内存的创建和打开 shmget
函数声明：`int shmget(key_t key, int size, int flag) ;`

key：表示所创建或打开的共享内存的键
size：表示共享内存区域的大小
flag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示

返回：若成功则为共享内存ID，若出错则为 -1。

#### 共享内存的附加 shmat
进行地址映射，将共享内存映射到进程虚拟地址空间中。

函数声明：`void *shmat(int shmid, void *addr, int flag) ;
`

shmid：表示要附加的共享内存段的ID
addr：虚拟地址
flag：用于表示函数的操作方式

返回：若成功则为指向共享内存段的指针，若出错则为-1

#### 共享内存的分离 shmdt
解除物理内存与进程虚拟地址空间的映射关系

函数声明：`int shmdt(void *addr) ;`

addr：是以前调用 shmat 时的返回值。

返回：若成功则为0，若出错则为 -1。

#### 共享内存的控制 shmctl
对共享内存段执行多种操作。

函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;
`
shmid：为共享内存的标识符
cmd：表示调用该函数希望执行的操作

---
cmd 的取值和对应操作如下：
- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。
- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。
- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。
- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。

---
buf：指向 shmid_ds 结构体的指针

返回：若成功则为0，若出错则为 -1。

### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和
```
/*---------------------------------------------------------------------------------------------------------
功能：
    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。

思路：
    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，
父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，
应使用信号量进行并发控制。	
---------------------------------------------------------------------------------------------------------*/

#include "stdio.h"
#include "sys/types.h"
#include "signal.h"
#include "sys/ipc.h"
#include "sys/sem.h"
#include "sys/shm.h"

//semun 共用体
union semun
{
	int val;
	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 
	ushort *array;
};


int semid;//信号量ID
int shmid;//共享内存ID
char *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址

// P操作，获取信号量，-1
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	//int semop(int semid, struct sembuf *sops, unsigned nops) ;
	semop(semid, &buf, 1);	//改变信号量的值
}

// V操作，释放信号量，+1
void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}

void sigusr1_handler(int n)
{
	printf("count = %d, total = %d\\n", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和
	
	//删除信号量
	if(semctl(semid, IPC_RMID, 0) == -1)  
		printf("remove semaphore fail\\n");
	else
		printf("remove semaphore ok\\n");
	
	shmdt(shm_virtualaddr);  //解除共享内存的关联

	//删除共享内存
	if(shmctl(shmid, IPC_RMID, 0) == -1)  
		printf("remove shared-memory fail\\n");
	else
		printf("remove shared-memory ok\\n");

	exit(0);
}

int main()
{
	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler

	//int semget(key_t key,int nsems,int semflg)
	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限
	//成功：返回信号量ID，失败：-1
	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量

	if(semid == -1)	//信号量创建失败
	{
		printf("create semaphore fail\\n");
		return 0;
	}
	else{	 //返回信号量ID
		printf("create semaphore ok\\n");
	}

	//semun 共用体
	union semun x;
	x.val = 1;  //信号量初值应为多少？为1

	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;
	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，
	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1
	
	//int shmget(key_t key, int size, int flag);
	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限
	//若成功则为共享内存ID，若出错则为 -1
	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total
	if(shmid == -1)	
	{
		printf("create shared-memory fail\\n");
		return 0;
	}
	else{	//返回共享内存ID
		printf("create shared-memory ok\\n");
	}

	//void *shmat(int shmid, void *addr, int flag) ;
	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式
	//成功则为指向共享内存段的指针，若出错则为-1
	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上

	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值
	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和

	//flag 是否是子进程
	char is_child = 0;
	int i;
	//循环创建 10 个进程
	for(i=0; i<10; i++)
	{
		pid_t pid = fork(); 
		if(pid == 0)	//子进程
		{
			is_child = 1;  //设置子进程中 is_child 为 1
			break;  //退出循环
		}
	}

	//子进程
	if(is_child)
	{
		p(semid);  // P操作，获取信号量（-1）

		srand(time(NULL) + i);	//设置随机种子数
		int num = rand()%10;	//取 0-9 随机数

		(*(int *)shm_virtualaddr)++;  //进程编号自增
		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加

		printf("child%d: %d\\n", i, num);

		v(semid);  //V操作，释放信号量（+1）

		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作
			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 
	}
	else
	{
		while(1)
			pause();//挂起，等待信号唤醒
	}

	return 0;
}
/*========================================================================
create semaphore ok
create shared-memory ok
child0: 8
child1: 8
child5: 9
child4: 0
child6: 2
child3: 9
child7: 6
child8: 4
child9: 1
child2: 9
count = 10, total = 56
remove semaphore ok
remove shared-memory ok
========================================================================*/
```
## socket 编程接口
### 套接口概念
套接口实际就是网络进程的 PID（Process ID）。

网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。
### 阻塞模式和非阻塞模式（同步和异步）
阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。

非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。

无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。

### getsockname/getpeername
getsockname 函数：用于获取与某个套接字关联的本地协议地址
getpeername 函数：用于获取与某个套接字关联的外地协议地址
*函数定义*
```
#include<sys/socket.h>
int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

### 字节序转换
计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。

网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。

#### 返回网络字节序 htons/htonl
`u_short htons(u_short hostshort);`

`u_long htonl(u_long hostlong);`

#### 返回主机字节序 ntohs/ntohl
`u_short ntohs(u_short netshort);`

`u_long ntohl(u_long netlong);`

一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。
### 地址转换函数
在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。
在套接口地址中则是使用 32 位的网络字节序的二进制数值。
要实现两者之间的转换，就要用到以下两个函数：

`unsigned long inet_addr(const char FAR* cp);`

成功：返回 32 位二进制的网络字节序地址
出错：返回 INADDR_NONE。

`char FAR* inet_ntoa(struct in_addr in);`

成功：返回字符串的指针
失败：返回 NULL

### 流套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。
客户端：创建套接字——请求连接。

双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。

最后，通信完毕，任意一方都可关闭套接字。
### 数据报套接字编程模型
服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。
客户端：创建套接字——直接进行数据的发送。

通信完毕，任意一方都可关闭套接字。

### sockaddr 和 sockaddr_in 结构体
通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。

每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。

除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：
```
struct sockaddr
{
	unit8_t	sa_len;
	sa_family_t	sa_family;	//协议族名
	char	sa_data[14];
}
```

IPv4 套接口地址结构体 `sockaddr_in` 的形式如下：
```
struct sockaddr_in
{
	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；
	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；
	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序
	struct in_addr sin_addr;
	char	sin_zero[8];	//备用的域名，未使用
};
struct in_addr
{
	in_addr_t s_addr;	//32 位 IP 地址，网络字节序
};
```
在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：

`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。

### 套接口函数
#### 总结步骤
>一个服务器进程中系统调用的顺序通常如下

socket();
bind();
listen();
accept();
>而客户端进程的调用则比较简单

socket();
connect();
#### 创建套接字 socket

`int socket(int family,int type,int protocol);`

family：指明协议族
type：指明套接口类型
protocol：一般为 0

成功：返回值为非负描述字
失败：返回值为负值

>参数 family 的取值范围

AF_LOCAL：UNIX 协议族
AF_ROUTE：路由套接口
AF_INET：IPv4 协议
AF_INET6：IPV6 协议
AF_KEY：密钥套接口

>参数 type 的取值范围

SOCK_STREAM：TCP 套接口
SOCK_DGRAM：UDP 套接口
SOCK_PACKET：支持数据链路访问
SOCK_RAM：原始套接口

#### 绑定套接口 bind
`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`

sockfd：套接字
myaddr：是一个指向特定协议地址结构体的指针
addrlen：是地址结构体的长度。

成功：返回 0
失败：返回 -1

这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。

只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。

#### 连接 connect
`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`

sockfd：套接口描述字
serv_addr：目的端口和IP地址的套接口
addrlen：目的套接口的长度

成功：返回 0
失败：返回 -l

#### 监听 listen
`int listen(int sockfd,int backlog);`

sockfd：套接字
backlog：规定内核为此套接口排队的最大选择个数

成功：返回 0
失败：返回 -1

#### 接受连接 accept (阻塞函数)
`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`

cliaddr：远程客户的套接口地址
addrlen：套接口地址长度
sockfd：监听套接字，它由函数 socket() 生成
如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针

成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)
失败：返回 -1

>客户套接和监听套接字的区别：

监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。

>accept()是一个阻塞函数

即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。

#### 关闭 close
`int close(int sockfd);`

成功：返回 0
失败：返回 -1

#### 发送 send/sendto (阻塞函数)
面向连接的套接口（TCP）:

`int send(int sockfd,const void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`

#### 接收 recv/recvfrom (阻塞函数)
面向连接的套接口（TCP）:

`int recv(int sockfd,void *buffer,int length,int flags);`

无连接的套接口（UDP）:

`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`

因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**

>Mysend 方法

```
int Mysend(SOCKET s, const char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iSendCount = 0:
	int iLength = len:
	while (iLength > 0)
	{
		int n = send(s, buf* iSendCount, iLength, flags);
		if(n == SOCKET_ERROR)
			return 0:
		iLength -= n:
		iSendCount += n:
	}
	return iSendCount
}
```

>Myrecv 方法

```
int Myrecv(SOCKET s, char *buf, int len, int flags)
{
	if(buf == NULL)
		return 0;
	int iRecvCount = 0;
	int iLength = len;
	while (iLength > 0)
	{
		int nRev = recv(s, buf + iRecvCount, iLength, flags);
		if(nReU == SOCKET_ERROR)
			return 0:
		iLength -= nRev;
		iRecuCount += nRev;
	}
	return iRecvCount;
}
```
## 多线程
### 线程函数的原型
#### Windows
`DWOED ThreadProc(LPVOID lpParameter);`
### 创建新线程
#### Windows - CreateThread
Win32 API 函数 ：CreateThread()
```
HANDLE CreateThread(
	LPSECURITY_ATTRIBUTES lpsa,
	DWORD cbStack,
	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行
	LPVOID lpvThreadParam,	//传给线程函数的参数
	DWORD fdwCreate,
	LPDWORD lpIDThread
);
```
#### Unix - pthread_create
```
#include  <pthread.h>
int  pthread_create（
	pthread_t  *thread,	//待传入线程的线程ID指针
	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
	void  *arg	//要传给线程执行函数的参数
）
```
### 一个线程等待另一个线程结束的方法
#### Unix - pthread_join
```
#include  <pthread.h>
int pthread_join(
	pthread_t thread,
	void **retval
);
```
### Linux 中编译多线程程序的方法
由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`

### 线程的并发（同步）问题
属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。

并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。

Windows 中主要函数有：
```
CreateSemaphore() //创建信号量
WaitForSingleObject() //获取信号量，P
ReleaseSemaphore() //释放信号量，V
CloseHandle() //关闭一个内核对象
```
### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)
```
/*------------------------------------------------------------------------------------------------
任务：
    10个子进程求和问题。用套接字进行父子进程间数据的通信。
思路：
    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。
-------------------------------------------------------------------------------*/

//=======================================================================================
//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 
//=======================================================================================

///*------------------------ Windows 的头文件 ----------------------------
#include "stdafx.h"
#include <stdio.h>
#include <time.h>
#include <Winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本
//----------------------------------------------------------------------*/

/*------------------------- Linux 的头文件 -----------------------------
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>  //inet_ntoa()函数的头文件
-----------------------------------------------------------------------*/

//=========================================
//            	全局变量
//=========================================

//-------------------------- 判断平台 -------------------------
#ifdef WINDOWS_VERSION //windows 平台
	HANDLE  g_hSem;    //信号量的句柄
	HANDLE  g_hThread[10];  //10个线程的句柄
#else //Linux 平台
	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数
	{
		int val;
		struct semid_ds *buf;
		ushort *array;
	};
	int   semid;    //信号量的ID
	pthread_t thread_id[10];  //10个线程的ID
#endif
	int  total;      //和
	int  listen_sock;    //用于监听的套接字
	short port;      //端口
//----------------------------------------------------

/**
 * 发送
 */
int mysend(int sock, char *buf, int len, int flags)
{
	int sent = 0, remain = len;
	while(remain > 0)
	{
		//int send(int sockfd,const void *buffer,int length,int flags);
		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数
		if(n == -1)  //出错的最大可能是对方关闭了套接字
			break;
		remain -= n;
		sent += n;
	}
	return sent;
}

/**
 * 接收一个整数(阻塞函数)
 */
int myrecv(int sock, char *buf, int len, int flags)
{
	int received = 0, remain = len;
	while(remain > 0)
	{
		//int recv(int sockfd,void *buffer,int length,int flags);
		//返回：0是对方调用close()，-1是对方直接退出
		int n = recv(sock, buf + received, remain, flags);
		if(n == 0 || n == -1)  
			break;
		remain -= n;
		received += n;
	}
	return received;
}

/**
 * Linux：子进程(客户端)发送随机数给父进程(服务端)
 * 
 * @param num 进程编号
 */
void send_num_to_parent(int num)
{
	int sock = socket(AF_INET, SOCK_STREAM, 0);

	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //将字符串表示的IP地址转换成网络字节序整数
	server_addr.sin_port  = htons(port);
 
 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);
 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度
	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止

	mysend(sock, (char *)&num, 4, 0);

#ifdef WINDOWS_VERSION
	closesocket(sock);
#else
	close(sock);
#endif
}

#ifndef WINDOWS_VERSION
void p(int semid)
{
	struct sembuf buf = {0, -1, 0};
	semop(semid, &buf, 1);
}

void v(int semid)
{
	struct sembuf buf = {0, 1, 0};
	semop(semid, &buf, 1);
}
#endif


#ifdef WINDOWS_VERSION
	DWORD WINAPI thread_function(void *arg) 
#else
	/**
	 * 线程函数
	 * 处理 accept，并创建下一个线程
	 */
	void *thread_function(void *arg)
#endif
	{ 
		int index = (int)arg;	//序号

		//准备接受连接请求
		struct sockaddr_in peer_addr;//套接口地址结构体
		int size = sizeof(struct sockaddr_in);
		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);
		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度
		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1
		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行
		printf("parent : 线程%d接受一个连接请求\\n", index);
 
		//accept 完毕，创建下一个线程
		if(index < 9)
#ifdef WINDOWS_VERSION
			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);
#else
			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));
#endif

		//自己，服务端
		int num;
		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数
		printf("parent : 线程%d接收到一个整数%d\\n", index, num);

//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制
#ifdef WINDOWS_VERSION
		WaitForSingleObject(g_hSem, INFINITE);//p操作
		total += num;
		ReleaseSemaphore(g_hSem, 1, NULL);//v操作
		closesocket(comm_sock);
		// ExitThread(0);
		return 0;//线程结束
#else
		p(semid);
		total += num;
		v(semid);
		//int close(int sockfd);
		//成功：返回 0，失败：返回 -1
		close(comm_sock);
		pthread_exit(NULL);
#endif
	}

/**
 * 父进程(服务器)
 * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]
 */
void init_socket()
{
	//int socket(int family,int type,int protocol);
	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0
	//成功：返回值为非负描述字，失败：返回值为负值
	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求

	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序
	struct sockaddr_in server_addr;
	server_addr.sin_family  = AF_INET; //IP_V4
	//htonl：将主机的无符号长整形数转换为网络字节顺序
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP

	//随机产生一个端口号，但要大于1024才行
	srand(time(NULL));  
	port = rand()%10000;
	while(port < 1024)
		port = rand()%10000;

	//htons：将主机的无符号短整形数转换为网络字节顺序
	server_addr.sin_port = htons(port);

	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);
	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。
	//成功：返回 0，失败：返回 -1
	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16

	//int listen(int sockfd,int backlog);
	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数
	//成功：返回 0，失败：返回 -1
	listen(listen_sock, 5);//将套接字置于监听状态

	printf("parent : 服务器开始监听连接请求\\n");
}

/**
 * 子线程(客户端)：生成随机数，发给父进程(服务器)	
 * @param i 线程编号	
 */
void do_child(int i)
{
	srand(time(NULL) + i);
	int num = rand()%10;

	printf("child%d: %d\\n", i, num);

	send_num_to_parent(num);
}

/**
 * 主函数
 *
 * @param  argc 命令行输入的参数个数
 * @param  argv 字符二维数组
 */
int main(int argc, char* argv[])
{
//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP 
#ifdef WINDOWS_VERSION
	WORD wVersionRequested;
	WSADATA wsaData;
	wVersionRequested = MAKEWORD(2, 2);
	WSAStartup(wVersionRequested, &wsaData);
#endif

	// Windows 中的父进程，Linux 中的父、子进程
	if(argc == 1)  
	{
		total = 0;	//初始化 total 为 0 

//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改
#ifdef WINDOWS_VERSION
		//1 个信号量，初始为 1
		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);
#else
		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量
		union semun x;
		x.val = 1;
		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1
#endif
  
		//初始化网络环境，完成服务器的准备工作
		init_socket();

		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]
		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。
#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台
		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]
		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);
#else
		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)
		//	pthread_t  *thread,	//待传入线程的线程ID指针
		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性
		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数
		//	void  *arg	//要传给线程执行函数的参数
		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);
#endif

//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了
#ifdef WINDOWS_VERSION
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		int i;
		for(i=0; i<10; i++)
		{
			//处理命令行字符串
			char *p = GetCommandLine();
			char strCmdLine[256];
			strcpy(strCmdLine, p);
			sprintf(strCmdLine + strlen(strCmdLine), " -%d -%d", port, i);

			ZeroMemory( &si, sizeof(si) );
			si.cb = sizeof(si);
			ZeroMemory( &pi, sizeof(pi) );
			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);
		}
		//等待 10 个线程结束
		for(i=0; i<10; i++)
			WaitForSingleObject(g_hThread[i], INFINITE);
#else
		char is_child = 0;
		int i;
		for(i=0; i<10; i++)
		{
			pid_t pid = fork();
			if(pid == 0)
			{
				is_child = 1;
				break;
			}
		}
		if(is_child)
		{
			do_child(i);
			return 0;
		}
		else
		{
			//等待 10 个线程结束
			for(i=0; i<10; i++)
				pthread_join(thread_id[i], NULL);
		}
#endif
		printf("parent : all threads ended, total=%d\\n", total);

//删除信号量
#ifdef WINDOWS_VERSION
		CloseHandle(g_hSem);
#else
		semctl(semid, IPC_RMID, 0);
#endif
	}
	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] 
	{
#ifdef WINDOWS_VERSION
		char *p = GetCommandLine();
		//下面 2 行从命令行中解析出端口号
		p = strchr(p, \'-\');
		sscanf(p+1, "%d", &port);

		//下面 3 行从命令行中解析出子进程的序号
		p = strchr(p+1, \'-\');
		int index;
		sscanf(p+1, "%d", &index);
		do_child(index);
#endif
	}
 else
	printf("启动命令不正确\\n");
	return 0;
}
```
*输出*
```
parent : 服务器开始监听连接请求
child0: 1
parent : 线程0接受一个连接请求
parent : 线程0接收到一个整数1
child1: 4
parent : 线程1接受一个连接请求
parent : 线程1接收到一个整数4
child2: 7
parent : 线程2接受一个连接请求
parent : 线程2接收到一个整数7
child3: 0
parent : 线程3接受一个连接请求
parent : 线程3接收到一个整数0
child5: 7
child4: 4
parent : 线程4接受一个连接请求
child6: 0
child7: 3
child8: 7
parent : 线程4接收到一个整数7
child9: 0
parent : 线程5接受一个连接请求
parent : 线程5接收到一个整数4
parent : 线程6接受一个连接请求
parent : 线程6接收到一个整数0
parent : 线程7接受一个连接请求
parent : 线程7接收到一个整数3
parent : 线程8接受一个连接请求
parent : 线程8接收到一个整数7
parent : 线程9接受一个连接请求
parent : 线程9接收到一个整数0
parent : all threads ended, total=33
```

### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。
http://qingrang.top/daily/admin/note/shownote/id/248.html',
  'groups' => 'Linux',
  'showsel' => '0',
  'showse2' => '1',
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000458s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001207s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000657s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000599s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001121s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000278s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=212,`p_id`=2,`title`='Linux - C 编程\r',`content`='# Linux - C 编程\r\n[TOC]\r\n## 进程\r\n### 孤儿进程 和 僵尸进程\r\nLinux 系统中有两种特殊的进程：孤儿进程和僵尸进程。\r\n\r\n父进程应负责子进程的回收工作，但父子进程是异步运行的，父进程不知道什么时候接收子进程，父进程甚至会在子进程结束之前结束。若父进程在子进程退出之前退出，子进程就会变成孤儿进程，此时子进程会被进程 init 收养，之后 init 会代替其原本的父进程完成状态收集工作。\r\n\r\n当进程调用了 exit() 函数后，该进程并不是马上消失，而是留下一个称为僵尸进程的数据结构。僵尸进程是 Linux 系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息供父进程收集。若父进程中没有回收子进程的代码，子进程将会一直处于僵尸态。\r\n\r\n### 进程标识符\r\n下列函数返回这些标识符，其返回值类型 pid_t，uid_t，gid_t 等都是宏定义，实质是 `unsigned int`\r\n```\r\n//头文件\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n//返回:调用进程的 进程ID\r\npid_t getpid(void)	\r\n\r\n//返回:调用进程的 父进程ID\r\npid_t getppid(void);\r\n\r\n//返回:调用进程的 实际用户ID\r\nuid_t getuid(void)\r\n\r\n//返回:调用进程的 有效用户ID\r\nuid_t geteuid(void)\r\n\r\n//返回:调用进程的 实际组ID\r\ngid_t getgid (void)\r\n\r\n//返回:调用进程的 有效组ID\r\ngid_t getegid(void)\r\n```\r\n### 进程同步\r\nLinux 提供了 wait() 函数和 waitpid() 函数来获取进程状态，实现进程同步。这两个函数用于父、子进程之间的同步，即确保子进程一定先于父进程执行并终止。\r\n```\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\npid_t wait(int *status) ;\r\npid_t waitpid(pid_t pid , int * status, int options) ;\r\n//两个函数返回：若成功则为 进程ID，若出错则为 -1。\r\n```\r\n### 实验：fork() 函数的使用\r\nfork() 函数:\r\n创建成功，父进程返回子进程的 id ，子进程返回 0\r\n创建失败，父进程返回 -1\r\n>使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数创建一个进程，进程创建成功后使父进程和子进程分别执行不同的功能\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\nint main()\r\n{\r\n	//调用fork()函数创建子进程\r\n	pid_t pid = fork();\r\n	if (pid == -1)	//创建失败\r\n	{\r\n		perror(\"fork error\");\r\n		exit(1);	//退出进程，指定返回值1\r\n	}\r\n	else if (pid > 0)	//创建成功 - 父进程\r\n	{\r\n		printf(\"父进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	else if (pid == 0)	//创建成功 - 子进程\r\n	{\r\n		printf(\"子进程,pid=%d,ppid=%d\\n\", getpid(), getppid());\r\n	}\r\n	printf(\"........finish..........\\n\");\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n父进程,pid=3720,ppid=3514\r\n........finish..........\r\n子进程,pid=3721,ppid=2012\r\n........finish..........\r\n========================================================================*/\r\n\r\n```\r\n\r\n- 多次执行文件 test_fork会发现这种情况: child process 后输出的 ppid 不等于 parent process 的 pid,而等于1。这是什么原因?\r\n答：父进程先于子进程终止,子进程变为“孤儿进程”,后由进程 init 接收。\r\n\r\n>使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n\r\n```\r\n/*---------------------------------------------------\r\n使用 fork() 函数在循环中创建 5 个子进程，使子进程分别打印各自的编号和 pid\r\n-----------------------------------------------------*/\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main()\r\n{\r\n	pid_t pid;\r\n	int i;\r\n	//循环创建进程\r\n	for (i = 0; i<5; i++){				\r\n		if ((pid = fork()) == 0)	//若当前进程为子进程，便跳出循环\r\n			break;\r\n	}\r\n	if (pid == -1){\r\n		perror(\"fork error\");\r\n		exit(1);\r\n	}\r\n	else if (pid>0){	//父进程\r\n		//sleep(5);	//父进程等待所有子进程执行结束后再执行\r\n		printf(\"parent process:pid=%d\\n\", getpid());\r\n	}\r\n	else if (pid == 0){		//子进程\r\n		//sleep(i);	//每个子进程分别沉睡不同的时间\r\n		printf(\"I am child=%d,pid=%d\\n\", i + 1, getpid());\r\n	}\r\n	return 0;\r\n}\r\n\r\n/*========================================================================\r\n>不 sleep 的输出：\r\nzhangliren@ubuntu:~/Documents$ ./a.out \r\nI am child=2,pid=3814\r\nparent process:pid=3812\r\nI am child=1,pid=3813\r\nI am child=4,pid=3816\r\nzhangliren@ubuntu:~/Documents$ I am child=5,pid=3817\r\nI am child=3,pid=3815\r\n|(终端提示符)\r\n----------------------------------------------------------\r\n>sleep() 后的输出：\r\nI am child=1,pid=3843\r\nI am child=2,pid=3844\r\nI am child=3,pid=3845\r\nI am child=4,pid=3846\r\nI am child=5,pid=3847\r\nparent process:pid=3842\r\n========================================================================*/\r\n```\r\n\r\n- 观察输出结果,会发现输出结果有以下问题\r\n（1）子进程的编号不是递增的\r\n（2）终端提示符后面仍有子进程信息打印,而命令提示符在最后一行的开头闪烁\r\n这是为什么?\r\n\r\n答：（1）父进程先于子进程终止。在 Linux 系统中,子进程应由父进程回收,但是当子进程被创建后,它与父进程及其他进程共同竟争系统资源,所以父子进程执行的顺序是不确定的,终止的先后顺序也是不确定的。此处创建了 5 个子进程,这 5 个子进程与父进程共同竞争资源。6 个进程使用 CPU 的顺序不确定,因此子进程的编号不是递增关系,父进程在子进程尚未全部终止前便终止。\r\n（2）父进程是一个前台进程。当它终止退出后,会释放命令提示符,输出当前工作路径及端提示符[ thelma@ localhost~],但此时尚有子进程仍在执行,终端仍有信息输出,因此命令提示符会出现在输出结果最后一行的开头。\r\n\r\n## 信号和信号处理\r\n### 信号的概念\r\n信号的本质是软件中断。很多比较重要的应用程序都需处理信号。信号是异步事件的典型实例，即产生信号的事件对进程而言是随机出现的。进程不能只是测试一个变量(例如errno)来判别是否发生了一个信号，而是必须告诉内核「在此信号发生时，请执行指定操作」。\r\n\r\n可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作：\r\n1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。它们是：SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向超级用户提供一种使进程终止或停止的可靠方法。\r\n2. 捕捉信号。为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。\r\n3. 执行系统默认动作。每一种信号都有系统默认动作。注意，对大多数信号的系统默认动作是终止该进程。\r\n\r\n### 常见函数\r\n#### kill\r\n给指定进程发送信号\r\n\r\n函数声明：`int kill(pid_t,int sig)`\r\npid：接收信号的进程ID\r\nsig：要发送的信号编号\r\n#### raise\r\n发送指定信号给当前进程自身\r\n\r\n函数声明：`int raise(int sig)`\r\n\r\n#### pause\r\n暂停进程，接收到任何信号后恢复\r\n\r\n函数声明：`int pause()`\r\n\r\n#### alarm\r\n计时器，驱使内核在指定秒数后发送 SIGALRM 信号到调用该函数的进程，进程收到该信号后默认终止运行。\r\n\r\n函数声明：`unsigned int alarm(unsigned int seconds)`\r\n\r\n#### signal\r\n捕获信号后，执行指定函数\r\n\r\n函数声明：\r\n`typedef void (* sighandler_t)(int);`\r\n`sighandler_t signal(int signum,sighandler_t handler);`\r\n\r\nsignum：信号编号\r\nhandler：自定义信号处理函数的函数指针\r\n\r\n### 实验：李纳斯的第一个程序\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n李纳斯的第一个程序：两个进程，一个向屏幕输出 A，一个向屏幕输出 B，两进程轮换输出，中间间隔 1 秒钟。如此反复，直到用户按下 ctl + c 结束两个进程（ctl + c 就是向当前正在运行的所有进程发送SIGINT信号）。\r\n---------------------------------------------------------------------------------------------------------*/\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n\r\npid_t pid;\r\n\r\n//自定义信号处理函数。\r\n//父进程打印 AAA，子进程打印 BBB\r\nvoid sigusr1_handler(int n)\r\n{\r\n	if(pid > 0)\r\n		printf(\"AAAA\\n\");\r\n	else\r\n		printf(\"BBBB\\n\");\r\n\r\n	alarm(1);//计时器，1s 后发送 SIGALRM 信号到进程\r\n}\r\n\r\nvoid sigalrm_handler(int n)\r\n{\r\n	if(pid > 0){	//父进程\r\n		kill(pid, SIGUSR1); //发送 SIGUSR1 信号给 pid 进程\r\n	}\r\n	else{	//子进程\r\n		kill(getppid(), SIGUSR1);//发送 SIGUSR1 信号给 父进程\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	//在fork()之前设置的信号处理函数会被子进程继承\r\n	signal(SIGALRM, sigalrm_handler);//捕获 SIGALRM 信号，执行 sigalrm_handler\r\n	signal(SIGUSR1, sigusr1_handler);//用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	pid = fork();\r\n	if (pid > 0)	//父进程\r\n		raise(SIGUSR1);	//发送 SIGUSR1 信号给当前进程\r\n\r\n	while(1)\r\n		pause();	//进程挂起，等待信号唤醒\r\n\r\n	return 0;\r\n}\r\n```\r\n## 进程间通信\r\n### 信号量\r\n#### 信号量的概念\r\n信号量是一个计数器，用于多进程对共享数据对象的存取。为了获得共享资源，进程需要执行下列操作：\r\n1. 测试控制该资源的信号量。\r\n1. 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减 1（P 操作），表示它使用了一个资源单位。若此信号量的值为 0，则进程进入睡眠状态，直至信号量值大于 0。若进程被唤醒后，它返回至第 1 步。当进程不再使用由一个信息量控制的共享资源时，该信号量值增 1（V 操作）。如果有进程正在睡眠等待此信号量，则唤醒它们中的一个。\r\n\r\n这两个过程也叫做 p、v 操作。 p、v操作是原子操作。为此，信号量通常是在内核中实现的。\r\n\r\n常用的信号量形式是让它控制单个资源，所以其初始值为 1。但是，一般而言，信号量的初值可以是任一正值，该值说明有多少个共享资源单位可供共享应用。\r\n\r\n#### 信号量的创建与打开 semget\r\n函数声明：`int semget(key_t key,int nsems,int semflg)`\r\n\r\nkey：所创建或打开的信号量集合的键\r\nnsems：创建的信号量集合中信号量的个数，此参数只在创建一个新的信号量集合时有效\r\nsemflg：调用函数的操作类型，也可用于设置信号量集合的访问权限，两者通过逻辑或表示\r\n\r\n返回：\r\n- 成功：返回信号量ID\r\n- 失败：-1，并设置 errno\r\n\r\n>调用函数 semget 的作用由参数 key 和 flag 决定，相应约定如下：\r\n\r\n- 当 key 为 IPC_PRIVATE 时，创建一个新的信号量集合。此时参数 flag 的取值对函数的操作不起仟何作用。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 设置了 IPC_CREAT 位，而没有设置 IPC_EXCL 位，则执行操作由 key 值决定：如果 key 为内核中某个已存在的信号量集合的键，则执行打开这个键的操作；反之，则执行创建信号量集合的操作。\r\n- 当 key 不为 IPC_PRIVATE，且 flag 中同时设置了 IPC_CREAT 位和 IPC_EXCL 位，则执行创建信号量集合的操作。参数 key 的取值应与内核中已存在的任何信号量集合的键值都不相同，否则函数调用失败。\r\n\r\n#### 对信号量的控制 semctl\r\n\r\n函数声明：`int semctl(int semid, int semnum, int cmd, [union semun arg]) ;`\r\n\r\nsemid：为信号量集合的标识符。\r\nsemnum：用于指明某个特定信号量。\r\ncmd：表示调用该函数希望执行的命令\r\ncmd 的常用设置：\r\n- SETVAL：表示 semctl() 的功能为初始化信号量的值，信号量值通过可选参数传入，在使用信号量前应先对信号量值进行设置\r\n- IPC_RMID：表示 semctl() 的功能为从系统中删除指定信号量\r\n\r\narg：是一个 semun 共用体，该共用体中各个成员的具体含义和使用情况与参数 cmd 的取值有关。该共用体的定义如下：\r\n```\r\nunion semen{\r\n	int val;	//cmd 为 SETVAL 时，用于指定信号量值\r\n	struct semid_ds *buf;	//cmd 为 IPC_STAT 时或 IPC_SET 时生效\r\n	unsigned short *array;	//cmd 为 GETALL 或 SETALL 时生效\r\n	struct seminfo *_buf;	//cmd 为 GETALL 或 SETALL 时生效\r\n};\r\n```\r\n\r\n该共用体中的 struct semid_ds 是一个由内核维护的记录信号量属性信息的结构体，该结构体的定义如下：\r\n```\r\nushort semid_ds{\r\n	struct ipc_perm sem_perm;	//所有者和标致权限\r\n	time_t sem_otime;	//最后操作时间\r\n	time_t sem_ctime;	//最后更改时间\r\n	unsigned short sem_nsems;	//信号集中的信号数量\r\n}\r\n```\r\n\r\n返回：由参数 cmd 决定。对于除 GETALL 以外的所有 GET 命令，都返回相应值，通常为非负数。否则返回 -1。\r\n#### 对信号量的操作——semop\r\n改变信号量的值\r\n\r\n函数声明：`int semop(int semid, struct sembuf *sops, unsigned nops) ; `\r\n\r\nsemid：为信号量集合的ID\r\nsemoparray：是一个 struct sembuf 类型的数组指针，该数组中的每个元素设置了要对信号量集中的哪个型号做哪种操作，struct sembuf 结构体定义如下：\r\n```\r\nstruct sembuf{\r\n	short sem_num;	//信号量在信号集中的编号\r\n	short sem_op;	//信号量操作,-1 P操作，+1 V操作\r\n	short sem_flag;	//标志位\r\n};\r\n```\r\nnops：参数 sops 所指数组中元素的个数\r\n\r\n返回：若成功则为 0，若出错则为 -1。\r\n\r\n### 共享内存\r\n#### 共享内存的概念\r\n共享内存是进程问通信的一种最基本、最快速的机制。共享内存是两个或多个进程共享同一块内存区域，并通过该内存区域实现数据交换的进程问通信机制。通常是由一个进程开辟一块共享内存区域，然后允许多个进程对此区域进行访问。由于不需使用中间介质，而是数据由内存直接映射到进程空间，因此共享内存是最快速的进程间通信机制。\r\n\r\n共享内存的最大不足在于，由于多个进程对同一块内存区域具有访问的权限，各个进程之间的同步问题显得尤为突出。必须控制同一时刻只有一个进程对共享内存区域写入数据，否则将造成数据的混乱。这可通过结合使用信号量来解决。\r\n\r\n#### 共享内存的创建和打开 shmget\r\n函数声明：`int shmget(key_t key, int size, int flag) ;`\r\n\r\nkey：表示所创建或打开的共享内存的键\r\nsize：表示共享内存区域的大小\r\nflag：表示函数的操作类型，也可用于设置共享内存的访问权限，两者通过逻辑或表示\r\n\r\n返回：若成功则为共享内存ID，若出错则为 -1。\r\n\r\n#### 共享内存的附加 shmat\r\n进行地址映射，将共享内存映射到进程虚拟地址空间中。\r\n\r\n函数声明：`void *shmat(int shmid, void *addr, int flag) ;\r\n`\r\n\r\nshmid：表示要附加的共享内存段的ID\r\naddr：虚拟地址\r\nflag：用于表示函数的操作方式\r\n\r\n返回：若成功则为指向共享内存段的指针，若出错则为-1\r\n\r\n#### 共享内存的分离 shmdt\r\n解除物理内存与进程虚拟地址空间的映射关系\r\n\r\n函数声明：`int shmdt(void *addr) ;`\r\n\r\naddr：是以前调用 shmat 时的返回值。\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n#### 共享内存的控制 shmctl\r\n对共享内存段执行多种操作。\r\n\r\n函数声明：`int shmctl(int shmid, int cmd, struct shmid_ds *buf) ;\r\n`\r\nshmid：为共享内存的标识符\r\ncmd：表示调用该函数希望执行的操作\r\n\r\n---\r\ncmd 的取值和对应操作如下：\r\n- IPC_STAT：对此段取 shmid_ds 结构，并存放在由 buf 指向的结构体中。\r\n- IPC_SET：按 buf 指向的结构体中的值设置与此段相关结构体中的下列三个字段：shm_perm.uid、shm_perm.gid以及shm_perm.mode。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- IPC_RMID：从系统中删除该共享内存段。此命令只能由下列两种进程执行：一种是其有效用户ID等于shm_perm.cuid或shm_perm.uid的进程；另一种是具有超级用户特权的进程。\r\n- SHM_LOCK：锁住共享内存段。此命令只能由超级用户执行。\r\n- SHM_UNLOCK：解锁共享内存段。此命令只能由超级用户执行。\r\n\r\n---\r\nbuf：指向 shmid_ds 结构体的指针\r\n\r\n返回：若成功则为0，若出错则为 -1。\r\n\r\n### 实验：父进程产生10个子进程，并打印出子进程产生的随机数的和\r\n```\r\n/*---------------------------------------------------------------------------------------------------------\r\n功能：\r\n    父进程产生10个子进程，并打印出子进程产生的随机数的和。要求用信号机制、信号量以及共享内存实现。\r\n\r\n思路：\r\n    子进程将自己产生的随机数累加到共享内存。当10个子进程都累加完后，用信号机制通知父进程，\r\n父进程就可以从共享内存中读取数据了。为了避免10个子进程向共享内存中写入数据时发生冲突，\r\n应使用信号量进行并发控制。	\r\n---------------------------------------------------------------------------------------------------------*/\r\n\r\n#include \"stdio.h\"\r\n#include \"sys/types.h\"\r\n#include \"signal.h\"\r\n#include \"sys/ipc.h\"\r\n#include \"sys/sem.h\"\r\n#include \"sys/shm.h\"\r\n\r\n//semun 共用体\r\nunion semun\r\n{\r\n	int val;\r\n	struct semid_ds *buf;	//一个由内核维护的记录信号量属性信息的结构体 \r\n	ushort *array;\r\n};\r\n\r\n\r\nint semid;//信号量ID\r\nint shmid;//共享内存ID\r\nchar *shm_virtualaddr;  //共享内存关联到进程后的虚拟地址\r\n\r\n// P操作，获取信号量，-1\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	//int semop(int semid, struct sembuf *sops, unsigned nops) ;\r\n	semop(semid, &buf, 1);	//改变信号量的值\r\n}\r\n\r\n// V操作，释放信号量，+1\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid sigusr1_handler(int n)\r\n{\r\n	printf(\"count = %d, total = %d\\n\", *(int *)shm_virtualaddr, *(int *)(shm_virtualaddr+4));  //打印进程编号（不是进程ID）和随机数和\r\n	\r\n	//删除信号量\r\n	if(semctl(semid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove semaphore fail\\n\");\r\n	else\r\n		printf(\"remove semaphore ok\\n\");\r\n	\r\n	shmdt(shm_virtualaddr);  //解除共享内存的关联\r\n\r\n	//删除共享内存\r\n	if(shmctl(shmid, IPC_RMID, 0) == -1)  \r\n		printf(\"remove shared-memory fail\\n\");\r\n	else\r\n		printf(\"remove shared-memory ok\\n\");\r\n\r\n	exit(0);\r\n}\r\n\r\nint main()\r\n{\r\n	signal(SIGUSR1, sigusr1_handler);  //用户定义的信号，用于捕获 SIGUSR1 信号执行处理函数 sigusr1_handler\r\n\r\n	//int semget(key_t key,int nsems,int semflg)\r\n	//key：所创建或打开的信号量集合的键，nsems：创建的信号量集合中信号量的个数，semflg：调用函数的操作类型，也可用于设置信号量集合的访问权限\r\n	//成功：返回信号量ID，失败：-1\r\n	semid = semget(IPC_PRIVATE, 1, 0666);	//创建并初始化信号量\r\n\r\n	if(semid == -1)	//信号量创建失败\r\n	{\r\n		printf(\"create semaphore fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	 //返回信号量ID\r\n		printf(\"create semaphore ok\\n\");\r\n	}\r\n\r\n	//semun 共用体\r\n	union semun x;\r\n	x.val = 1;  //信号量初值应为多少？为1\r\n\r\n	//int semctl(int semid, int semnum, int cmd, [union semun arg]) ;\r\n	//semid：信号量集合，semnum：用于指明某个特定信号量，cmd：表示调用该函数希望执行的命令，arg：是一个 semun 共用体，\r\n	semctl(semid, 0, SETVAL, x);	//初始化信号量为 1\r\n	\r\n	//int shmget(key_t key, int size, int flag);\r\n	//key：表示所创建或打开的共享内存的键，size：表示共享内存区域的大小，flag：表示函数的操作类型，也可用于设置共享内存的访问权限\r\n	//若成功则为共享内存ID，若出错则为 -1\r\n	shmid = shmget(IPC_PRIVATE, 8, 0666);  //创建并关联到共享内存，共享内存一共 8 字节，前 4 字节存放 count，后 4 字节存放 total\r\n	if(shmid == -1)	\r\n	{\r\n		printf(\"create shared-memory fail\\n\");\r\n		return 0;\r\n	}\r\n	else{	//返回共享内存ID\r\n		printf(\"create shared-memory ok\\n\");\r\n	}\r\n\r\n	//void *shmat(int shmid, void *addr, int flag) ;\r\n	//shmid：表示要附加的共享内存段的ID，addr：虚拟地址，flag：用于表示函数的操作方式\r\n	//成功则为指向共享内存段的指针，若出错则为-1\r\n	shm_virtualaddr = shmat(shmid, 0, 0);//共享内存的附加，地址映射，addr 为 0，此共享内存段附加到由内核选择的第一个可用地址上\r\n\r\n	*(int *)shm_virtualaddr = 0;  //初始化进程编号，将指针转成int*，然后取该指针指向地址的值\r\n	*(int *)(shm_virtualaddr + 4) = 0;  //初始化随机数和\r\n\r\n	//flag 是否是子进程\r\n	char is_child = 0;\r\n	int i;\r\n	//循环创建 10 个进程\r\n	for(i=0; i<10; i++)\r\n	{\r\n		pid_t pid = fork(); \r\n		if(pid == 0)	//子进程\r\n		{\r\n			is_child = 1;  //设置子进程中 is_child 为 1\r\n			break;  //退出循环\r\n		}\r\n	}\r\n\r\n	//子进程\r\n	if(is_child)\r\n	{\r\n		p(semid);  // P操作，获取信号量（-1）\r\n\r\n		srand(time(NULL) + i);	//设置随机种子数\r\n		int num = rand()%10;	//取 0-9 随机数\r\n\r\n		(*(int *)shm_virtualaddr)++;  //进程编号自增\r\n		*(int *)(shm_virtualaddr + 4) += num;  //随机数相加\r\n\r\n		printf(\"child%d: %d\\n\", i, num);\r\n\r\n		v(semid);  //V操作，释放信号量（+1）\r\n\r\n		if(*(int *)shm_virtualaddr == 10)  //if(i==10)最后一个子进程，善后操作\r\n			kill(getppid(), SIGUSR1);  //向父进程发送 SIGUSER1 信号 \r\n	}\r\n	else\r\n	{\r\n		while(1)\r\n			pause();//挂起，等待信号唤醒\r\n	}\r\n\r\n	return 0;\r\n}\r\n/*========================================================================\r\ncreate semaphore ok\r\ncreate shared-memory ok\r\nchild0: 8\r\nchild1: 8\r\nchild5: 9\r\nchild4: 0\r\nchild6: 2\r\nchild3: 9\r\nchild7: 6\r\nchild8: 4\r\nchild9: 1\r\nchild2: 9\r\ncount = 10, total = 56\r\nremove semaphore ok\r\nremove shared-memory ok\r\n========================================================================*/\r\n```\r\n## socket 编程接口\r\n### 套接口概念\r\n套接口实际就是网络进程的 PID（Process ID）。\r\n\r\n网络通信，归根到底就是进程间的通信。套接口的描述符称为套接字，即 socket。有的资料中也叫套接口句柄。\r\n### 阻塞模式和非阻塞模式（同步和异步）\r\n阻塞模式：指调用了套接字的读、写函数后，函数不会立即返回，线程此时被置为等待状态，直到读、写操作完成为止。\r\n\r\n非阻塞模式：指调用了套接字的读、写函数后，函数立即返回，不用等到读、写操作完成。\r\n\r\n无论在 Windows 中还是 UNIX/LINUX 中，套接字被创建后默认都是阻塞模式的。\r\n\r\n### getsockname/getpeername\r\ngetsockname 函数：用于获取与某个套接字关联的本地协议地址\r\ngetpeername 函数：用于获取与某个套接字关联的外地协议地址\r\n*函数定义*\r\n```\r\n#include<sys/socket.h>\r\nint getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);\r\nint getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);\r\n```\r\n\r\n### 字节序转换\r\n计算机在内存中的数据存储方式有两种：一种是小端字节序，即内存低地址存储数据低字节，高地址存储数据高字节；另一种是大端字节序，即内存低地址存储数据高字节，而高地址存储数据低字节。\r\n\r\n网络字节序使用的是大端字节序，而主机字节序可能是小端字节序，也可能是大端字节序。所有套接字函数中涉及 IP 地址和端口号时都用网络字节序，因此要用到主机字节序和网络字节序之间相互转换功能的函数。\r\n\r\n#### 返回网络字节序 htons/htonl\r\n`u_short htons(u_short hostshort);`\r\n\r\n`u_long htonl(u_long hostlong);`\r\n\r\n#### 返回主机字节序 ntohs/ntohl\r\n`u_short ntohs(u_short netshort);`\r\n\r\n`u_long ntohl(u_long netlong);`\r\n\r\n一般情况下，使用 htons 和 ntohs 转换 端口号，使用 htonl 和 ntohl 转换 IP 地址。\r\n### 地址转换函数\r\n在 TCP/IP 网络上，使用 ASCII 地址，即使用以“．”隔开的四个十进制的数表示。\r\n在套接口地址中则是使用 32 位的网络字节序的二进制数值。\r\n要实现两者之间的转换，就要用到以下两个函数：\r\n\r\n`unsigned long inet_addr(const char FAR* cp);`\r\n\r\n成功：返回 32 位二进制的网络字节序地址\r\n出错：返回 INADDR_NONE。\r\n\r\n`char FAR* inet_ntoa(struct in_addr in);`\r\n\r\n成功：返回字符串的指针\r\n失败：返回 NULL\r\n\r\n### 流套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——进入监听模式并准备接受连接。\r\n客户端：创建套接字——请求连接。\r\n\r\n双方建立连接后就可以开始数据通信了，双方都可以进行数据的发送和接收。\r\n\r\n最后，通信完毕，任意一方都可关闭套接字。\r\n### 数据报套接字编程模型\r\n服务器端：创建套接字——将本地地址绑定到套接字——直接进行数据的接收。\r\n客户端：创建套接字——直接进行数据的发送。\r\n\r\n通信完毕，任意一方都可关闭套接字。\r\n\r\n### sockaddr 和 sockaddr_in 结构体\r\n通常，把网络应用程序中所用到的网络地址和端口号信息放在一个结构体中，这就是**套接口地址结构体**。\r\n\r\n每个协议族都定义了它自己的套接口地址结构体，套接口地址结构体都以 `sockaddr_` 开头，并以每个协议族名中的两个字母作为结尾，例如`sockaddr_in`表示 IPv4 协议族的套接口地址结构体。\r\n\r\n除此之外，还有一个通用套接口地址结构体，它以`sockaddr` 表示。通用套接口地址结构体 sockaddr 与具体协议族无关，形式为：\r\n```\r\nstruct sockaddr\r\n{\r\n	unit8_t	sa_len;\r\n	sa_family_t	sa_family;	//协议族名\r\n	char	sa_data[14];\r\n}\r\n```\r\n\r\nIPv4 套接口地址结构体 `sockaddr_in` 的形式如下：\r\n```\r\nstruct sockaddr_in\r\n{\r\n	unit8	sin_len;	//数据长度成员，固定长度为16字节，一般不用设置它；\r\n	sa_family_t	sin_family;	//协议族名，IPv4 为 AF_INET；\r\n	in_port_t sin_port;	//TCP 或 UDP 协议的端口号，16 位端口号，网络字节序\r\n	struct in_addr sin_addr;\r\n	char	sin_zero[8];	//备用的域名，未使用\r\n};\r\nstruct in_addr\r\n{\r\n	in_addr_t s_addr;	//32 位 IP 地址，网络字节序\r\n};\r\n```\r\n在对套接口进行操作的函数中，如果需要套接口地址参数，都是以通用套接口地址结构体表示的，例如连接函数 connect：\r\n\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\n因此需要将**指向特定协议的套接口地址结构体的指针**转换成**指向通用套接口地址结构体的指针**，即使用`(struct sockaddr *)`进行类型转换。否则编译时会出现警告信息。\r\n\r\n### 套接口函数\r\n#### 总结步骤\r\n>一个服务器进程中系统调用的顺序通常如下\r\n\r\nsocket();\r\nbind();\r\nlisten();\r\naccept();\r\n>而客户端进程的调用则比较简单\r\n\r\nsocket();\r\nconnect();\r\n#### 创建套接字 socket\r\n\r\n`int socket(int family,int type,int protocol);`\r\n\r\nfamily：指明协议族\r\ntype：指明套接口类型\r\nprotocol：一般为 0\r\n\r\n成功：返回值为非负描述字\r\n失败：返回值为负值\r\n\r\n>参数 family 的取值范围\r\n\r\nAF_LOCAL：UNIX 协议族\r\nAF_ROUTE：路由套接口\r\nAF_INET：IPv4 协议\r\nAF_INET6：IPV6 协议\r\nAF_KEY：密钥套接口\r\n\r\n>参数 type 的取值范围\r\n\r\nSOCK_STREAM：TCP 套接口\r\nSOCK_DGRAM：UDP 套接口\r\nSOCK_PACKET：支持数据链路访问\r\nSOCK_RAM：原始套接口\r\n\r\n#### 绑定套接口 bind\r\n`int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);`\r\n\r\nsockfd：套接字\r\nmyaddr：是一个指向特定协议地址结构体的指针\r\naddrlen：是地址结构体的长度。\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n这个调用不是必须执行的。尤其是在客户端，很少使用这个系统调用。用 socket() 得到套接口后可以直接调用函数 connect() 或者 listen()，这时内核会自动给套接口分配一个地址和端口号，这是常用的方式。\r\n\r\n只有在希望进程使用某个特定的网络地址和端口时，才会使用函数 bind()。\r\n\r\n#### 连接 connect\r\n`int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);`\r\n\r\nsockfd：套接口描述字\r\nserv_addr：目的端口和IP地址的套接口\r\naddrlen：目的套接口的长度\r\n\r\n成功：返回 0\r\n失败：返回 -l\r\n\r\n#### 监听 listen\r\n`int listen(int sockfd,int backlog);`\r\n\r\nsockfd：套接字\r\nbacklog：规定内核为此套接口排队的最大选择个数\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 接受连接 accept (阻塞函数)\r\n`int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);`\r\n\r\ncliaddr：远程客户的套接口地址\r\naddrlen：套接口地址长度\r\nsockfd：监听套接字，它由函数 socket() 生成\r\n如果不需要客户的套接口地址，可将第二个和第三个参数设置为空指针\r\n\r\n成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)\r\n失败：返回 -1\r\n\r\n>客户套接和监听套接字的区别：\r\n\r\n监听套接字只有一个，而且一直存在；而每一个连接都有自己的客户套接字，专用于服务器与该连接对应的远程客户进行通信。当连接断开时就关闭该客户套接字。\r\n\r\n>accept()是一个阻塞函数\r\n\r\n即调用它的线程将被操作系统置于阻塞状态，直到有远程客户向该IP地址的该端口发起connect()调用为止。\r\n\r\n#### 关闭 close\r\n`int close(int sockfd);`\r\n\r\n成功：返回 0\r\n失败：返回 -1\r\n\r\n#### 发送 send/sendto (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int send(int sockfd,const void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int sendto(int sockfd,const void *message,int length,int flags,const struct sock_addr *dest_addr,int dest_len);`\r\n\r\n#### 接收 recv/recvfrom (阻塞函数)\r\n面向连接的套接口（TCP）:\r\n\r\n`int recv(int sockfd,void *buffer,int length,int flags);`\r\n\r\n无连接的套接口（UDP）:\r\n\r\n`int recvfrom(int sockfd,void *message,int length,int flags,const struct sock_addr *send_addr,int *send_len);`\r\n\r\n因为发送和接收函数进行一次传输的字节数可能比要求的数量少，所以需要多次调用这些函数以便发送或接收指定的字节数。所以，套**接口的数据传输通常都由一个循环结构来实现。**\r\n\r\n>Mysend 方法\r\n\r\n```\r\nint Mysend(SOCKET s, const char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iSendCount = 0:\r\n	int iLength = len:\r\n	while (iLength > 0)\r\n	{\r\n		int n = send(s, buf* iSendCount, iLength, flags);\r\n		if(n == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= n:\r\n		iSendCount += n:\r\n	}\r\n	return iSendCount\r\n}\r\n```\r\n\r\n>Myrecv 方法\r\n\r\n```\r\nint Myrecv(SOCKET s, char *buf, int len, int flags)\r\n{\r\n	if(buf == NULL)\r\n		return 0;\r\n	int iRecvCount = 0;\r\n	int iLength = len;\r\n	while (iLength > 0)\r\n	{\r\n		int nRev = recv(s, buf + iRecvCount, iLength, flags);\r\n		if(nReU == SOCKET_ERROR)\r\n			return 0:\r\n		iLength -= nRev;\r\n		iRecuCount += nRev;\r\n	}\r\n	return iRecvCount;\r\n}\r\n```\r\n## 多线程\r\n### 线程函数的原型\r\n#### Windows\r\n`DWOED ThreadProc(LPVOID lpParameter);`\r\n### 创建新线程\r\n#### Windows - CreateThread\r\nWin32 API 函数 ：CreateThread()\r\n```\r\nHANDLE CreateThread(\r\n	LPSECURITY_ATTRIBUTES lpsa,\r\n	DWORD cbStack,\r\n	LPTHREAD_START_ROUTINE lpstartAddr, //指向线程函数的指针，那个函数将做为一个新的线程而运行\r\n	LPVOID lpvThreadParam,	//传给线程函数的参数\r\n	DWORD fdwCreate,\r\n	LPDWORD lpIDThread\r\n);\r\n```\r\n#### Unix - pthread_create\r\n```\r\n#include  <pthread.h>\r\nint  pthread_create（\r\n	pthread_t  *thread,	//待传入线程的线程ID指针\r\n	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n	void  *arg	//要传给线程执行函数的参数\r\n）\r\n```\r\n### 一个线程等待另一个线程结束的方法\r\n#### Unix - pthread_join\r\n```\r\n#include  <pthread.h>\r\nint pthread_join(\r\n	pthread_t thread,\r\n	void **retval\r\n);\r\n```\r\n### Linux 中编译多线程程序的方法\r\n由于 pthread 库不是 Linux 系统默认的库，所以多线程的程序在编译时需要告诉编译器将这个库链接进来，编译命令应这样输入：`gcc xxx.c -lpthread`\r\n\r\n### 线程的并发（同步）问题\r\n属于同一个进程的所有线程可以共享全局数据和主线程中尚在生存期内的数据，如果没有并发控制，就会产生异常。\r\n\r\n并发控制的方法有多种，只要求掌握使用信号量来进行并发控制。\r\n\r\nWindows 中主要函数有：\r\n```\r\nCreateSemaphore() //创建信号量\r\nWaitForSingleObject() //获取信号量，P\r\nReleaseSemaphore() //释放信号量，V\r\nCloseHandle() //关闭一个内核对象\r\n```\r\n### 实验：结合网络编程和多线程技术实现父进程产生10个子进程，并打印出子进程产生的随机数的和，要求能跨平台执行(Windows,Linux)\r\n```\r\n/*------------------------------------------------------------------------------------------------\r\n任务：\r\n    10个子进程求和问题。用套接字进行父子进程间数据的通信。\r\n思路：\r\n    父进程做服务器，完成网络的初始化工作后就进入等待连接状态。子进程做客户端，连接到服务器后就发送自己的随机数。父进程接收到随机数后进行累加。要注意的是，由于accept()和recv()都是阻塞函数，所以服务器要用单独的线程来调用这两个函数，所以服务器将产生10个线程来分别为10个子进程服务。另外，10 个线程都要修改全局变量total，所以要进行并发控制。\r\n-------------------------------------------------------------------------------*/\r\n\r\n//=======================================================================================\r\n//    跨平台程序设计，针对平台打开对应的头文件，根据宏 WINDOWS_VERSION 进行判断 \r\n//=======================================================================================\r\n\r\n///*------------------------ Windows 的头文件 ----------------------------\r\n#include \"stdafx.h\"\r\n#include <stdio.h>\r\n#include <time.h>\r\n#include <Winsock2.h>\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n#define WINDOWS_VERSION //宏定义，表示当前为 windows 版本\r\n//----------------------------------------------------------------------*/\r\n\r\n/*------------------------- Linux 的头文件 -----------------------------\r\n#include <sys/types.h>\r\n#include <sys/ipc.h>\r\n#include <sys/sem.h>\r\n#include <pthread.h>\r\n#include <sys/socket.h>\r\n#include <netdb.h> \r\n#include <netinet/in.h> \r\n#include <arpa/inet.h>  //inet_ntoa()函数的头文件\r\n-----------------------------------------------------------------------*/\r\n\r\n//=========================================\r\n//            	全局变量\r\n//=========================================\r\n\r\n//-------------------------- 判断平台 -------------------------\r\n#ifdef WINDOWS_VERSION //windows 平台\r\n	HANDLE  g_hSem;    //信号量的句柄\r\n	HANDLE  g_hThread[10];  //10个线程的句柄\r\n#else //Linux 平台\r\n	union send_num_to_parent //共用体，作为初始化信号量的值传入 semctl 函数\r\n	{\r\n		int val;\r\n		struct semid_ds *buf;\r\n		ushort *array;\r\n	};\r\n	int   semid;    //信号量的ID\r\n	pthread_t thread_id[10];  //10个线程的ID\r\n#endif\r\n	int  total;      //和\r\n	int  listen_sock;    //用于监听的套接字\r\n	short port;      //端口\r\n//----------------------------------------------------\r\n\r\n/**\r\n * 发送\r\n */\r\nint mysend(int sock, char *buf, int len, int flags)\r\n{\r\n	int sent = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int send(int sockfd,const void *buffer,int length,int flags);\r\n		int n = send(sock, buf + sent, remain, flags);	//返回实际发送的字节数\r\n		if(n == -1)  //出错的最大可能是对方关闭了套接字\r\n			break;\r\n		remain -= n;\r\n		sent += n;\r\n	}\r\n	return sent;\r\n}\r\n\r\n/**\r\n * 接收一个整数(阻塞函数)\r\n */\r\nint myrecv(int sock, char *buf, int len, int flags)\r\n{\r\n	int received = 0, remain = len;\r\n	while(remain > 0)\r\n	{\r\n		//int recv(int sockfd,void *buffer,int length,int flags);\r\n		//返回：0是对方调用close()，-1是对方直接退出\r\n		int n = recv(sock, buf + received, remain, flags);\r\n		if(n == 0 || n == -1)  \r\n			break;\r\n		remain -= n;\r\n		received += n;\r\n	}\r\n	return received;\r\n}\r\n\r\n/**\r\n * Linux：子进程(客户端)发送随机数给父进程(服务端)\r\n * \r\n * @param num 进程编号\r\n */\r\nvoid send_num_to_parent(int num)\r\n{\r\n	int sock = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n	//下面4行进行地址结构体的赋值。注意IP地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET;\r\n	server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");  //将字符串表示的IP地址转换成网络字节序整数\r\n	server_addr.sin_port  = htons(port);\r\n \r\n 	//int connect(int sockfd,const struct sockaddr *serv_addr,int addrlen);\r\n 	//sockfd：套接口描述字，serv_addr：目的端口和IP地址的套接口，addrlen：目的套接口的长度\r\n	connect(sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));  //connect()是阻塞函数，直到3次握手完成为止，或是超时为止\r\n\r\n	mysend(sock, (char *)&num, 4, 0);\r\n\r\n#ifdef WINDOWS_VERSION\r\n	closesocket(sock);\r\n#else\r\n	close(sock);\r\n#endif\r\n}\r\n\r\n#ifndef WINDOWS_VERSION\r\nvoid p(int semid)\r\n{\r\n	struct sembuf buf = {0, -1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n\r\nvoid v(int semid)\r\n{\r\n	struct sembuf buf = {0, 1, 0};\r\n	semop(semid, &buf, 1);\r\n}\r\n#endif\r\n\r\n\r\n#ifdef WINDOWS_VERSION\r\n	DWORD WINAPI thread_function(void *arg) \r\n#else\r\n	/**\r\n	 * 线程函数\r\n	 * 处理 accept，并创建下一个线程\r\n	 */\r\n	void *thread_function(void *arg)\r\n#endif\r\n	{ \r\n		int index = (int)arg;	//序号\r\n\r\n		//准备接受连接请求\r\n		struct sockaddr_in peer_addr;//套接口地址结构体\r\n		int size = sizeof(struct sockaddr_in);\r\n		//int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);\r\n		//sockfd：监听套接字，它由函数 socket() 生成，cliaddr：远程客户的套接口地址，addrlen：套接口地址长度\r\n		//成功：返回非负描述字，返回值即为新建立的连接的套接口描述字(客户套接字)，失败：返回 -1\r\n		int comm_sock = accept(listen_sock, (struct sockaddr *)&peer_addr, &size);  //accept()是阻塞函数，直到有客户端向本地址发起连接请求。注意返回值就是对应客户端的套接字，将来的数据收发都在这个套接字上进行\r\n		printf(\"parent : 线程%d接受一个连接请求\\n\", index);\r\n \r\n		//accept 完毕，创建下一个线程\r\n		if(index < 9)\r\n#ifdef WINDOWS_VERSION\r\n			g_hThread[index + 1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)(index + 1), 0, NULL);\r\n#else\r\n			pthread_create(&thread_id[index + 1], NULL, (void *)thread_function, (void *)(index + 1));\r\n#endif\r\n\r\n		//自己，服务端\r\n		int num;\r\n		myrecv(comm_sock, (char *)&num, 4, 0);	//接收一个整数\r\n		printf(\"parent : 线程%d接收到一个整数%d\\n\", index, num);\r\n\r\n//累加到全局变量。由于 10 个线程可能形成竞争，所以必须进行并发控制\r\n#ifdef WINDOWS_VERSION\r\n		WaitForSingleObject(g_hSem, INFINITE);//p操作\r\n		total += num;\r\n		ReleaseSemaphore(g_hSem, 1, NULL);//v操作\r\n		closesocket(comm_sock);\r\n		// ExitThread(0);\r\n		return 0;//线程结束\r\n#else\r\n		p(semid);\r\n		total += num;\r\n		v(semid);\r\n		//int close(int sockfd);\r\n		//成功：返回 0，失败：返回 -1\r\n		close(comm_sock);\r\n		pthread_exit(NULL);\r\n#endif\r\n	}\r\n\r\n/**\r\n * 父进程(服务器)\r\n * 初始化网络环境，完成服务器的准备工作 [accept 函数会阻塞线程，所以此处不处理，之后新开线程处理]\r\n */\r\nvoid init_socket()\r\n{\r\n	//int socket(int family,int type,int protocol);\r\n	//family：指明协议族-IPv4 协议，type：指明套接口类型-TCP 套接口，protocol：一般为 0\r\n	//成功：返回值为非负描述字，失败：返回值为负值\r\n	listen_sock = socket(AF_INET, SOCK_STREAM, 0);	//创建流式套接字，用于监听子进程发出的连接请求\r\n\r\n	//下面 4 行进行地址结构体的赋值。注意 IP 地址和端口号都要转换成网络字节序\r\n	struct sockaddr_in server_addr;\r\n	server_addr.sin_family  = AF_INET; //IP_V4\r\n	//htonl：将主机的无符号长整形数转换为网络字节顺序\r\n	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //INADDR_ANY 表示请操作系统自动选一个可用的本机 IP\r\n\r\n	//随机产生一个端口号，但要大于1024才行\r\n	srand(time(NULL));  \r\n	port = rand()%10000;\r\n	while(port < 1024)\r\n		port = rand()%10000;\r\n\r\n	//htons：将主机的无符号短整形数转换为网络字节顺序\r\n	server_addr.sin_port = htons(port);\r\n\r\n	//int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);\r\n	//sockfd：套接字，myaddr：是一个指向特定协议地址结构体的指针，addrlen：是地址结构体的长度。\r\n	//成功：返回 0，失败：返回 -1\r\n	bind(listen_sock, (struct sockaddr *)&server_addr, sizeof(struct sockaddr));//将套接字绑定到指定的地址 //16\r\n\r\n	//int listen(int sockfd,int backlog);\r\n	//sockfd：套接字，backlog：规定内核为此套接口排队的最大选择个数\r\n	//成功：返回 0，失败：返回 -1\r\n	listen(listen_sock, 5);//将套接字置于监听状态\r\n\r\n	printf(\"parent : 服务器开始监听连接请求\\n\");\r\n}\r\n\r\n/**\r\n * 子线程(客户端)：生成随机数，发给父进程(服务器)	\r\n * @param i 线程编号	\r\n */\r\nvoid do_child(int i)\r\n{\r\n	srand(time(NULL) + i);\r\n	int num = rand()%10;\r\n\r\n	printf(\"child%d: %d\\n\", i, num);\r\n\r\n	send_num_to_parent(num);\r\n}\r\n\r\n/**\r\n * 主函数\r\n *\r\n * @param  argc 命令行输入的参数个数\r\n * @param  argv 字符二维数组\r\n */\r\nint main(int argc, char* argv[])\r\n{\r\n//下面 4 行：进行 Windows 网络环境的初始化。UNIX 中不需要，因为 UNIX 内置了 TCP/IP \r\n#ifdef WINDOWS_VERSION\r\n	WORD wVersionRequested;\r\n	WSADATA wsaData;\r\n	wVersionRequested = MAKEWORD(2, 2);\r\n	WSAStartup(wVersionRequested, &wsaData);\r\n#endif\r\n\r\n	// Windows 中的父进程，Linux 中的父、子进程\r\n	if(argc == 1)  \r\n	{\r\n		total = 0;	//初始化 total 为 0 \r\n\r\n//创建并初始化信号量，用于控制 10 个线程对 total 的并发修改\r\n#ifdef WINDOWS_VERSION\r\n		//1 个信号量，初始为 1\r\n		g_hSem = CreateSemaphore(NULL, 1, 1, NULL);\r\n#else\r\n		semid = semget(IPC_PRIVATE, 1, 0);	//创建信号量\r\n		union semun x;\r\n		x.val = 1;\r\n		semctl(semid, 0, SETVAL, x);	//信号量赋初值 1\r\n#endif\r\n  \r\n		//初始化网络环境，完成服务器的准备工作\r\n		init_socket();\r\n\r\n		//创建用于接受连接请求的第一个线程，将来由第一个去创建第二个，第二个创建第三个，以此类推。[任何时刻只能有一个线程在调用 accept ]\r\n		//要保存线程的句柄或ID，因为后面主线程要等待 10 个子线程结束。\r\n#ifdef WINDOWS_VERSION	//线程函数原型不同，需区分平台\r\n		//3p：指向线程函数的指针，4p：线程函数的参数(需强转为空指针)，[告诉线程你是第几个线程]\r\n		g_hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_function, (void *)0, 0, NULL);\r\n#else\r\n		//int pthread_create(pthread_t  *thread,pthread_attr_t  *attr,void  *(*start_routine)(void  *),void  *arg)\r\n		//	pthread_t  *thread,	//待传入线程的线程ID指针\r\n		//	pthread_attr_t  *attr,	//带创建线程的属性，通常为NULL，表示使用默认属性\r\n		//	void  *（*start_routine）（void  *）,	//函数指针，待创建线程的执行函数\r\n		//	void  *arg	//要传给线程执行函数的参数\r\n		pthread_create(&thread_id[0], NULL, (void *)thread_function, (void *)0);\r\n#endif\r\n\r\n//服务器已准备就绪(线程，信号量)，可以创建 10 个子进程了\r\n#ifdef WINDOWS_VERSION\r\n		STARTUPINFO si;\r\n		PROCESS_INFORMATION pi;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			//处理命令行字符串\r\n			char *p = GetCommandLine();\r\n			char strCmdLine[256];\r\n			strcpy(strCmdLine, p);\r\n			sprintf(strCmdLine + strlen(strCmdLine), \" -%d -%d\", port, i);\r\n\r\n			ZeroMemory( &si, sizeof(si) );\r\n			si.cb = sizeof(si);\r\n			ZeroMemory( &pi, sizeof(pi) );\r\n			CreateProcess(NULL, strCmdLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi);\r\n		}\r\n		//等待 10 个线程结束\r\n		for(i=0; i<10; i++)\r\n			WaitForSingleObject(g_hThread[i], INFINITE);\r\n#else\r\n		char is_child = 0;\r\n		int i;\r\n		for(i=0; i<10; i++)\r\n		{\r\n			pid_t pid = fork();\r\n			if(pid == 0)\r\n			{\r\n				is_child = 1;\r\n				break;\r\n			}\r\n		}\r\n		if(is_child)\r\n		{\r\n			do_child(i);\r\n			return 0;\r\n		}\r\n		else\r\n		{\r\n			//等待 10 个线程结束\r\n			for(i=0; i<10; i++)\r\n				pthread_join(thread_id[i], NULL);\r\n		}\r\n#endif\r\n		printf(\"parent : all threads ended, total=%d\\n\", total);\r\n\r\n//删除信号量\r\n#ifdef WINDOWS_VERSION\r\n		CloseHandle(g_hSem);\r\n#else\r\n		semctl(semid, IPC_RMID, 0);\r\n#endif\r\n	}\r\n	else if(argc == 3)  //Windows中的子进程，命令行格式为:filename -端口号 -[0-9] \r\n	{\r\n#ifdef WINDOWS_VERSION\r\n		char *p = GetCommandLine();\r\n		//下面 2 行从命令行中解析出端口号\r\n		p = strchr(p, \'-\');\r\n		sscanf(p+1, \"%d\", &port);\r\n\r\n		//下面 3 行从命令行中解析出子进程的序号\r\n		p = strchr(p+1, \'-\');\r\n		int index;\r\n		sscanf(p+1, \"%d\", &index);\r\n		do_child(index);\r\n#endif\r\n	}\r\n else\r\n	printf(\"启动命令不正确\\n\");\r\n	return 0;\r\n}\r\n```\r\n*输出*\r\n```\r\nparent : 服务器开始监听连接请求\r\nchild0: 1\r\nparent : 线程0接受一个连接请求\r\nparent : 线程0接收到一个整数1\r\nchild1: 4\r\nparent : 线程1接受一个连接请求\r\nparent : 线程1接收到一个整数4\r\nchild2: 7\r\nparent : 线程2接受一个连接请求\r\nparent : 线程2接收到一个整数7\r\nchild3: 0\r\nparent : 线程3接受一个连接请求\r\nparent : 线程3接收到一个整数0\r\nchild5: 7\r\nchild4: 4\r\nparent : 线程4接受一个连接请求\r\nchild6: 0\r\nchild7: 3\r\nchild8: 7\r\nparent : 线程4接收到一个整数7\r\nchild9: 0\r\nparent : 线程5接受一个连接请求\r\nparent : 线程5接收到一个整数4\r\nparent : 线程6接受一个连接请求\r\nparent : 线程6接收到一个整数0\r\nparent : 线程7接受一个连接请求\r\nparent : 线程7接收到一个整数3\r\nparent : 线程8接受一个连接请求\r\nparent : 线程8接收到一个整数7\r\nparent : 线程9接受一个连接请求\r\nparent : 线程9接收到一个整数0\r\nparent : all threads ended, total=33\r\n```\r\n\r\n### 实验：建立C/S结构的文件下载系统。每个客户端可以提供不定数目的文件用于共享，也可以下载别人共享出来的文件。文件存在于各个客户端上，而不在服务器上。要允许一个客户端同时下载多个文件，也要允许同时被多个别的客户端下载。\r\nhttp://qingrang.top/daily/admin/note/shownote/id/248.html',`groups`='Linux',`is_show`=0,`publish`=1,`summary`='Linux 编程基础，包含进程，信号，进程间通信，网络编程等基础知识'  WHERE  `id` = 212 [ RunTime:0.002738s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001286s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=12  WHERE  `groups` = 'Linux' [ RunTime:0.000553s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Linux' LIMIT 1 [ RunTime:0.001446s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=12  WHERE  `groups` = 'Linux' [ RunTime:0.000369s ]
---------------------------------------------------------------
[ 2018-11-16T21:23:20+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/212.html
[ info ] qingrang.top/daily/admin/note/shownote/id/212.html [运行时间：0.066156s][吞吐率：15.12req/s] [内存消耗：2,062.52kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/212.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '212',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000542s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001429s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 212 LIMIT 1 [ RunTime:0.000641s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001366s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000479s ]
---------------------------------------------------------------
[ 2018-11-16T21:23:27+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.072488s][吞吐率：13.80req/s] [内存消耗：2,304.79kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=fv7q855fkbdrsrnb75f9bq48d0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000530s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001506s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001595s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000679s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000988s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000478s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000526s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001383s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000297s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000547s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000348s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001008s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000302s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001123s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000674s ]
