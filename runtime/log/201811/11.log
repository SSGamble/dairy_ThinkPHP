---------------------------------------------------------------
[ 2018-11-11T11:35:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/show/shownote/id/210.html
[ info ] qingrang.top/daily/admin/show/shownote/id/210.html [运行时间：0.070004s][吞吐率：14.28req/s] [内存消耗：1,965.44kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'show',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'connection' => 'keep-alive',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Linux; Android 8.1.0; OE106 Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/62.0.3202.84 Mobile Safari/537.36',
  'x-requested-with' => 'XBrowser',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,ko-KR;q=0.9,ja-JP;q=0.8,zh-TW;q=0.7,en-US;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540344543; Hm_lpvt_1769181352e9adc950166aada465644e=1540344543; PHPSESSID=srurfvlfi16u5e3smajhka1ir2',
)
[ info ] [ PARAM ] array (
  'id' => '210',
)
[ info ] [ RUN ] app\admin\controller\Show->showNote[ /var/www/html/daily/application/admin/controller/Show.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/show/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002752s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002875s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 210 LIMIT 1 [ RunTime:0.001010s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001119s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000437s ]
---------------------------------------------------------------
[ 2018-11-11T12:04:55+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.054089s][吞吐率：18.49req/s] [内存消耗：1,428.32kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-11T12:04:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.047585s][吞吐率：21.02req/s] [内存消耗：1,340.69kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=mei86l89d0otq0e3s26tn3qis5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-11T12:05:02+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.055998s][吞吐率：17.86req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=mei86l89d0otq0e3s26tn3qis5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001147s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002493s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000705s ]
---------------------------------------------------------------
[ 2018-11-11T12:05:03+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.093128s][吞吐率：10.74req/s] [内存消耗：2,351.69kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=mei86l89d0otq0e3s26tn3qis5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002367s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001513s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003305s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000621s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001097s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000312s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000563s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000999s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000286s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000436s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000351s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000346s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000938s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000220s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001153s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000802s ]
---------------------------------------------------------------
[ 2018-11-11T12:16:52+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.033967s][吞吐率：29.44req/s] [内存消耗：1,339.90kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-11T12:18:10+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.038659s][吞吐率：25.87req/s] [内存消耗：1,428.44kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-11T12:18:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.070207s][吞吐率：14.24req/s] [内存消耗：1,340.69kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-11T12:18:16+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.050642s][吞吐率：19.75req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000550s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001314s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000345s ]
---------------------------------------------------------------
[ 2018-11-11T12:18:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.078123s][吞吐率：12.80req/s] [内存消耗：2,351.78kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000641s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001916s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002669s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal' ORDER BY id desc LIMIT 5 [ RunTime:0.000709s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001333s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000343s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000465s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001132s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000400s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000568s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000327s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000398s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001163s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000223s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001284s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000659s ]
---------------------------------------------------------------
[ 2018-11-11T12:18:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/4.html
[ info ] qingrang.top/daily/admin/note/editnote/id/4.html [运行时间：0.069022s][吞吐率：14.49req/s] [内存消耗：2,027.98kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '4',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002274s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001390s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 4 LIMIT 1 [ RunTime:0.000406s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000846s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000281s ]
---------------------------------------------------------------
[ 2018-11-11T12:30:07+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/4.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/4.html [运行时间：0.073291s][吞吐率：13.64req/s] [内存消耗：2,049.59kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '668',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/4.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# 待办事项
## 种草
荒川尚也溪流杯
俞家年糕

## 书
最后的耍猴人
礼物的流动 - 阎云翔
见识/态度/大学之路 - 吴军
人性的弱点


## 未去地
江浙云贵川
',
  'groups' => 'Default',
  'showsel' => '0',
  'showse2' => '0',
  'id' => '4',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002026s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001589s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 4 LIMIT 1 [ RunTime:0.000396s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 4 LIMIT 1 [ RunTime:0.000290s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000894s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000289s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 0 LIMIT 1 [ RunTime:0.000305s ]
[ sql ] [ SQL ] SELECT `id` FROM `groups` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000274s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=4,`p_id`=1,`title`='待办事项\r',`content`='# 待办事项\r\n## 种草\r\n荒川尚也溪流杯\r\n俞家年糕\r\n\r\n## 书\r\n最后的耍猴人\r\n礼物的流动 - 阎云翔\r\n见识/态度/大学之路 - 吴军\r\n人性的弱点\r\n\r\n\r\n## 未去地\r\n江浙云贵川\r\n',`groups`='Default',`is_show`=0,`publish`=0,`summary`=''  WHERE  `id` = 4 [ RunTime:0.000556s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001467s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=13  WHERE  `groups` = 'Default' [ RunTime:0.000322s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.000890s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=13  WHERE  `groups` = 'Default' [ RunTime:0.000395s ]
---------------------------------------------------------------
[ 2018-11-11T12:30:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/4.html
[ info ] qingrang.top/daily/admin/note/shownote/id/4.html [运行时间：0.071774s][吞吐率：13.93req/s] [内存消耗：1,979.98kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/4.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '4',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002236s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001946s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 4 LIMIT 1 [ RunTime:0.000568s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001184s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000319s ]
---------------------------------------------------------------
[ 2018-11-11T17:11:40+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/1.html
[ info ] qingrang.top/daily/admin/note/editnote/id/1.html [运行时间：0.078580s][吞吐率：12.73req/s] [内存消耗：2,100.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002704s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002586s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.001085s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000883s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000314s ]
---------------------------------------------------------------
[ 2018-11-11T17:11:42+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.059087s][吞吐率：16.92req/s] [内存消耗：2,107.28kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000582s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001617s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000796s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000899s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000272s ]
---------------------------------------------------------------
[ 2018-11-11T19:36:20+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.071432s][吞吐率：14.00req/s] [内存消耗：2,430.29kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '96813',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```
## 查询缓存
查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。

MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。

myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。

无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。

但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

#### 一级查询缓存的存在性证明
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。
#### 从缓存读取数据的依据是 Sql 的 id
缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。

*MyTest.java*
```
@Test
public void test02() {
	//使用了不同的查询语句，查询相同的记录 id
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 增删改对一级查询缓存的影响
增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。

*MyTest.java*
```
@Test
public void test03() {
	Country country = dao.selectCountryById(2);
	System.out.println(country);

	// 增删改操作都会清空一级缓存，无论是否提交
	dao.insertCountry(new Country(3,"USA"));

	Country country2 = dao.selectCountryById(2);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: 3(Integer), USA(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]
```

### 内置二级缓存
使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。

#### 开启内置的二级缓存步骤
1）对实体进行序列化
2）在映射文件中添加 `<cache/>` 标签

*Country.java - 实例化*
```
public class Country implements Serializable { }
```

*mybatis.xml - 添加 <cache/> 标签*
```
<mapper namespace="top.qingrang.sql_session_cache.dao.ICountryDao">
	<cache/>
</mapper>
```

*MyTest.java*
```
@Test
public void test01() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	//关闭 sqlSession，一级缓存会刷新
	sqlSession.close();
	//二级缓存会伴随整个生命周期
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
#### 增删改对二级缓存的影响
1. 增删改同样也会清空二级缓存
2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除
3. 从 DB 中进行 select 查询的条件是：
1)缓存中根本就不存在这个 key
2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null

*MyTest.java*
```
@Test
public void test02() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById2(2);
	System.out.println(country);
	sqlSession.close();
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	dao.insertCountry(new Country("Japan"));
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: null, Japan(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 二级缓存的配置
为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。

`<cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/>`

- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：
- FIFO： First In First Out， 先进先出
- LRU： Least Recently Used，未被使用时间最长的
- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。
- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。
- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。

#### 二级缓存的关闭
二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。
##### 全局关闭
所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。
```
<settings>
    <setting name="cacheEnabled" value="false" />
</settings>
```
##### 局部关闭
整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。

`useCache="false"`

```
<select id="selectCountryById" useCache="false" resultType="Country">
		select cid,cname from country where cid=#{xxx}
	</select>
```

### ehcache 二级查询缓存
使用 ehcache 二级缓存，实体类无需实现序列化接口。

将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`

*pom.xml*
```
<!--ehcache 相关包 -->
<dependency>
  <groupId>net.sf.ehcache</groupId>
  <artifactId>ehcache</artifactId>
  <version>2.7.5</version>
</dependency>
<dependency>
  <groupId>org.mybatis.caches</groupId>
  <artifactId>mybatis-ehcache</artifactId>
  <version>1.1.0</version>
</dependency>
```

*mapper.xml*
```
<mapper namespace="com.bjpowernode.dao.IStudentDao">
	<cache type="org.mybatis.caches.ehcache.EhcacheCache">
		<property name="timeToIdleSeconds" value="60"/>
	</cache>
</mapper>
```',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001337s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002309s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```\n\n### 延迟加载\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\n\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\n\n#### 关联对象加载时机\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\n\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\n\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\n\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\n\n#### 延迟加载的总开关\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\n\n*mybatis.xml*\n```\n<configuration>\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 设置整个应用所使用的常量 -->\n    <settings>\n        <!-- 延迟加载的总开关 -->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    </settings>\n\n    <typeAliases>\n		...\n    </typeAliases>\n</configuration>\n```\n\n#### 直接加载\n*mybatis.xml*\n```\n<settings>\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\n</settings>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\n	System.out.println(country.getCname());\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 直接加载（√）：查询 country，查询 minister ---\nChina\nTotal：3\n```\n\n#### 侵入式延迟加载\n*mybatis.xml*\n```\n<!-- 设置整个应用所使用的常量 -->\n<settings>\n    <!-- 延迟加载的总开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!-- 侵入式延迟加载 -->\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\n</settings>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\n	System.out.println(country.getCname());\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 侵入式延迟加载（X）：查询 country ---\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\nChina\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\nTotal：3\n```\n#### 深度延迟加载\n*mybatis.xml*\n```\n<!-- 设置整个应用所使用的常量 -->\n<settings>\n    <!-- 延迟加载的总开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n</settings>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\n	System.out.println(country.getCname());\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 深度延迟加载（X）：查询 country ---\nChina\n---- 深度延迟加载（X）：访问主加载对象 ---\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\nTotal：3\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\n```\n## 查询缓存\n查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。\n\nMyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。\n\nmyBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。\n\n无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。\n\n但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。\n\n### 一级查询缓存\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \n\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\n\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\n\n### 一级查询缓存\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \n\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\n\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\n\n#### 一级查询缓存的存在性证明\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(country);\n	Country country2 = dao.selectCountryById(1);\n	System.out.println(country2);\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\nCountry [cid=1, cname=China]\n```\n只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。\n#### 从缓存读取数据的依据是 Sql 的 id\n缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。\n\n*MyTest.java*\n```\n@Test\npublic void test02() {\n	//使用了不同的查询语句，查询相同的记录 id\n	Country country = dao.selectCountryById(1);\n	System.out.println(country);\n	\n	Country country2 = dao.selectCountryById2(1);\n	System.out.println(country2);\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n```\n#### 增删改对一级查询缓存的影响\n增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。\n\n*MyTest.java*\n```\n@Test\npublic void test03() {\n	Country country = dao.selectCountryById(2);\n	System.out.println(country);\n\n	// 增删改操作都会清空一级缓存，无论是否提交\n	dao.insertCountry(new Country(3,\"USA\"));\n\n	Country country2 = dao.selectCountryById(2);\n	System.out.println(country2);\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 2(Integer)\nCountry [cid=2, cname=England]\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\n[DEBUG] ==> Parameters: 3(Integer), USA(String)\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\n[DEBUG] ==> Parameters: 2(Integer)\nCountry [cid=2, cname=England]\n```\n\n### 内置二级缓存\n使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。\n\n#### 开启内置的二级缓存步骤\n1）对实体进行序列化\n2）在映射文件中添加 `<cache/>` 标签\n\n*Country.java - 实例化*\n```\npublic class Country implements Serializable { }\n```\n\n*mybatis.xml - 添加 <cache/> 标签*\n```\n<mapper namespace=\"top.qingrang.sql_session_cache.dao.ICountryDao\">\n	<cache/>\n</mapper>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	Country country = dao.selectCountryById(1);\n	System.out.println(country);\n	//关闭 sqlSession，一级缓存会刷新\n	sqlSession.close();\n	//二级缓存会伴随整个生命周期\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	Country country2 = dao.selectCountryById(1);\n	System.out.println(country2);\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\nCountry [cid=1, cname=China]\n```\n#### 增删改对二级缓存的影响\n1. 增删改同样也会清空二级缓存\n2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除\n3. 从 DB 中进行 select 查询的条件是：\n1)缓存中根本就不存在这个 key\n2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null\n\n*MyTest.java*\n```\n@Test\npublic void test02() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	Country country = dao.selectCountryById2(2);\n	System.out.println(country);\n	sqlSession.close();\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	dao.insertCountry(new Country(\"Japan\"));\n	Country country2 = dao.selectCountryById2(1);\n	System.out.println(country2);\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\n[DEBUG] ==> Parameters: null, Japan(String)\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n```\n#### 二级缓存的配置\n为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。\n\n`<cache eviction=\"FIFO\" flushInterval=\"10800000\" readOnly=\"true\" size=\"512\"/>`\n\n- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：\n- FIFO： First In First Out， 先进先出\n- LRU： Least Recently Used，未被使用时间最长的\n- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。\n- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。\n- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。\n\n#### 二级缓存的关闭\n二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。\n##### 全局关闭\n所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。\n```\n<settings>\n    <setting name=\"cacheEnabled\" value=\"false\" />\n</settings>\n```\n##### 局部关闭\n整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。\n\n`useCache=\"false\"`\n\n```\n<select id=\"selectCountryById\" useCache=\"false\" resultType=\"Country\">\n		select cid,cname from country where cid=#{xxx}\n	</select>\n```\n\n### ehcache 二级查询缓存\n使用 ehcache 二级缓存，实体类无需实现序列化接口。\n\n将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`\n\n*pom.xml*\n```\n<!--ehcache 相关包 -->\n<dependency>\n  <groupId>net.sf.ehcache</groupId>\n  <artifactId>ehcache</artifactId>\n  <version>2.7.5</version>\n</dependency>\n<dependency>\n  <groupId>org.mybatis.caches</groupId>\n  <artifactId>mybatis-ehcache</artifactId>\n  <version>1.1.0</version>\n</dependency>\n```\n\n*mapper.xml*\n```\n<mapper namespace=\"com.bjpowernode.dao.IStudentDao\">\n	<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\">\n		<property name=\"timeToIdleSeconds\" value=\"60\"/>\n	</cache>\n</mapper>\n```',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.002519s ]
---------------------------------------------------------------
[ 2018-11-11T19:54:17+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.061169s][吞吐率：16.35req/s] [内存消耗：2,430.30kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '96822',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```
## 查询缓存
查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。

MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。

myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。

无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。

但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

#### 一级查询缓存的存在性证明
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。
#### 从缓存读取数据的依据是 Sql 的 id
缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。

*MyTest.java*
```
@Test
public void test02() {
	//使用了不同的查询语句，查询相同的记录 id
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 增删改对一级查询缓存的影响
增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。

*MyTest.java*
```
@Test
public void test03() {
	Country country = dao.selectCountryById(2);
	System.out.println(country);

	// 增删改操作都会清空一级缓存，无论是否提交
	dao.insertCountry(new Country(3,"USA"));

	Country country2 = dao.selectCountryById(2);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: 3(Integer), USA(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]
```

### 内置二级缓存
使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。

#### 开启内置的二级缓存步骤
1）对实体进行序列化
2）在映射文件中添加 `<cache/>` 标签

*Country.java - 实例化*
```
public class Country implements Serializable { }
```

*mybatis.xml - 添加 <cache/> 标签*
```
<mapper namespace="top.qingrang.sql_session_cache.dao.ICountryDao">
	<cache/>
</mapper>
```

*MyTest.java*
```
@Test
public void test01() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	//关闭 sqlSession，一级缓存会刷新
	sqlSession.close();
	//二级缓存会伴随整个生命周期
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
#### 增删改对二级缓存的影响
1. 增删改同样也会清空二级缓存
2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除
3. 从 DB 中进行 select 查询的条件是：
1)缓存中根本就不存在这个 key
2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null

*MyTest.java*
```
@Test
public void test02() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById2(2);
	System.out.println(country);
	sqlSession.close();
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	dao.insertCountry(new Country("Japan"));
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: null, Japan(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 二级缓存的配置
为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。

`<cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/>`

- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：
- FIFO： First In First Out， 先进先出
- LRU： Least Recently Used，未被使用时间最长的
- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。
- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。
- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。

#### 二级缓存的关闭
二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。
##### 全局关闭
所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。
```
<settings>
    <setting name="cacheEnabled" value="false" />
</settings>
```
##### 局部关闭
整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。

`useCache="false"`

```
<select id="selectCountryById" useCache="false" resultType="Country">
		select cid,cname from country where cid=#{xxx}
	</select>
```

### ehcache 二级查询缓存
使用 ehcache 二级缓存，实体类无需实现序列化接口。

将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`

*pom.xml*
```
<!--ehcache 相关包 -->
<dependency>
  <groupId>net.sf.ehcache</groupId>
  <artifactId>ehcache</artifactId>
  <version>2.7.5</version>
</dependency>
<dependency>
  <groupId>org.mybatis.caches</groupId>
  <artifactId>mybatis-ehcache</artifactId>
  <version>1.1.0</version>
</dependency>
```

*mapper.xml*
```
<mapper namespace="com.bjpowernode.dao.IStudentDao">
	<cache type="org.mybatis.caches.ehcache.EhcacheCache">
		<property name="timeToIdleSeconds" value="60"/>
	</cache>
</mapper>
```


',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000645s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001315s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Mybatis',`content`='# Mybatis\n[TOC]\n## Mybatis 体系结构和工作原理\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\n\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\n## 第一个 MyBaits 程序\n### 主配置文件详解\n1. 注册数据库连接四要素属性文件\n`<properties resource=\"jdbc_mysql.properties\"/>`\n1. 定义类型别名\n```\n<typeAliases>\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\n	<package name=\"top.qingrang.beans\"/>\n</typeAliases>\n```\n1. 配置运行环境\n```\n<environments default=\"XXX2\">\n	<!-- 环境，eg：上线环境 -->\n	<environment id=\"XXX1\">\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\n		<transactionManager type=\"JDBC\"/>\n		<!-- 数据源，数据库连接池 -->\n		<dataSource type=\"POOLED\">\n			<!-- 数据库连接四要素 -->\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\n			<property name=\"url\" value=\"${jdbc.url}\"/>\n			<property name=\"username\" value=\"${jdbc.user}\"/>\n			<property name=\"password\" value=\"${jdbc.password}\"/>\n		</dataSource>\n	</environment>\n\n	<!-- 另一个环境，eg：本地测试的环境 -->\n	<environment id=\"XXX2\">\n		...\n	</environment>\n</environments>\n```\n1. 注册映射文件\n```\n<mappers>\n	<!-- 配置文件路径 -->\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n</mappers>\n```\n\n>问题？\n\n1. environments 下为什么可以配置多个 environment？\n方便切换运行环境，只需要改变 `default` 即可\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\n1. 什么是数据库连接池？\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\n\n*mybatis.xml*\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 注册数据库连接四要素属性文件 -->\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 定义类型别名 -->\n    <typeAliases>\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\n        <package name=\"top.qingrang.beans\"/>\n    </typeAliases>\n\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\n    <environments default=\"onlineEM\">\n        <!-- 上线以后的环境 -->\n        <environment id=\"onlineEM\">\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据源，数据库连接池 -->\n            <dataSource type=\"POOLED\">\n                <!-- 数据库连接四要素 -->\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.user}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n        <!-- 本地测试的环境 -->\n        <environment id=\"testEM\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"111\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 注册映射文件 -->\n    <mappers>\n        <!-- 配置文件路径 -->\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n### 核心代码\n利用 sqlSession 对象，执行相关操作。\n```\nprivate SqlSession sqlSession;\n\n@Override\npublic void insertStu(Student student) {\n	try {\n		// 1.加载主配置文件\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n		// 2.创建 SqlSessionFactory 对象\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n		// 3.创建 sqlSession 对象\n		sqlSession = sqlSessionFactory.openSession();\n		// 4.执行相关操作\n		sqlSession.insert(\"insertStudent\", student);\n		// 5.提交\n		sqlSession.commit();\n	} catch (IOException e) {\n		e.printStackTrace();\n	} finally {\n		if(sqlSession != null) {\n			// 6.关闭\n			sqlSession.close();\n		}\n	}\n}\n```\n### 封装 MyBatis 工具类\n*MyBatisUtils.java*\n```\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * MyBatis 工具类\n */\npublic class MyBatisUtils {\n\n	private static SqlSessionFactory sqlSessionFactory;\n\n	/**\n	 * 得到 SqlSession 对象\n	 */\n	public static SqlSession getSqlSession() {\n		try {\n			// 1.加载主配置文件\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\n			if (sqlSessionFactory == null) {\n				// 2.创建 SqlSessionFactory 对象\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n			}\n			// 3.返回 SqlSession 对象\n			return sqlSessionFactory.openSession();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n		return null;\n	}\n}\n```\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n}\n```\n### 源码分析\n#### 输入流的关闭\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\n\n#### SqlSession 的创建\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\n\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\n\n>dirty 详解\n\ntrue：和数据库中的数据不一致(脏)\nfalse：和数据库中的数据一致(不脏)\n\n#### 增删改的执行\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\n\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\n\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\n\n#### SqlSession 的提交 commit()\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\n\n#### SqlSession 的关闭\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\n\n\n\n\n\n\n\n\n\n## 单表的 CURD 操作\n### 常用的增删改查\n*mapper.xml*\n```\n<!-- parameterType 可以省略 -->\n<insert id=\"insertStudent\" parameterType=\"Student\">\n	<!-- 这里的 #{} 是属性 -->\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<!-- 插入后用新 id 初始化被插入对象 -->\n<insert id=\"insertStudentCacheId\">\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\n		select @@identity\n	</selectKey>\n</insert>\n\n<delete id=\"deleteStudentById\">\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\n	DELETE FROM student WHERE id = #{id}\n</delete>\n\n<update id=\"updateStudent\">\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\n</update>\n\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n\n<!-- 模糊查询 -->\n<select id=\"selectStudentsByName\" resultType=\"Student\">\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\n</select>\n```\n\n*StudentDaoImpl.java*\n```\npublic class StudentDaoImpl implements IStudentDao {\n	private SqlSession sqlSession;\n\n	@Override\n	public void insertStudent(Student student) {\n		try {\n			// 创建 SqlSession 对象\n			sqlSession = MyBatisUtils.getSqlSession();\n			// 执行相关操作\n			sqlSession.insert(\"insertStudent\", student);\n			// 提交\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void insertStudentCacheId(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.insert(\"insertStudentCacheId\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void deleteStudentById(int id) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.delete(\"deleteStudentById\", id);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			sqlSession.update(\"updateStudent\", student);\n			sqlSession.commit();\n		}finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectAllStudents\");\n			//查询不需要 sqlSession.commit();\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n\n	@Override\n	public Map<String, Object> selectAllStudentsMap() {\n		Map<String, Object> map = new HashMap<>();\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return map;\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		Student student = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			student = sqlSession.selectOne(\"selectStudentById\", id);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return student;\n	}\n\n	@Override\n	public List<Student> selectStudentsByName(String name) {\n		List<Student> students = null;\n		try {\n			sqlSession = MyBatisUtils.getSqlSession();\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\n		} finally {\n			if(sqlSession != null) {\n				sqlSession.close();\n			}\n		}\n		return students;\n	}\n}\n```\n\n### 属性名与查询字段名不相同\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\n```\n<!-- resultType=\"Student\"，封装成 Student 类 -->\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select id,name,age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select id,name,age,score from student where id=#{xxx}\n</select>\n```\n#### 解决方案一：查询字段使用别名\n```\n<insert id=\"insertStudent\">\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\n</insert>\n\n<select id=\"selectAllStudents\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student\n</select>\n\n<select id=\"selectStudentById\" resultType=\"Student\">\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\n</select>\n```\n#### 解决方案二：使用结果映射 resultMap\n```\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"tid\" property=\"id\"/>\n	<result column=\"tname\" property=\"name\"/>\n 	<result column=\"tage\" property=\"age\"/>\n</resultMap>\n\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student\n</select>\n\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select tid,tname,tage,score from student where tid=#{jjj}\n</select>\n```\n### Mapper 动态代理\n#### 修改映射文件的 namespace 属性值\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\n通过接口名即可定位到映射文件 mapper.\n#### 删除 IStudentDaoImpl 实现类\n#### 修改 MyText.java 测试方法\n*MyTex.java*\n```\npublic class MyTest {\n	private IStudentDao dao;\n	private SqlSession sqlSession;\n\n	@Before\n	public void before() {\n		sqlSession = MyBatisUtils.getSqlSession();\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n	}\n\n	@After\n	public void after() {\n		if(sqlSession != null) {\n			sqlSession.close();\n		}\n	}\n\n	@Test\n	public void testInsertStudent() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudent(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testInsertStudentCacheId() {\n		Student student = new Student(\"张三\", 23, 93.5);\n		System.out.println(\"插入前：student = \" + student);\n		dao.insertStudentCacheId(student);\n		sqlSession.commit();\n		System.out.println(\"插入后：student = \" + student);\n	}\n\n	@Test\n	public void testDeleteStudentById() {\n		dao.deleteStudentById(12);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testUpdateStudent() {\n		Student student = new Student(\"张三\", 25, 93.5);\n		student.setId(15);\n		dao.updateStudent(student);\n		sqlSession.commit();\n	}\n\n	@Test\n	public void testSelectAllStudents() {\n		List<Student> students = dao.selectAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n\n	@Test\n	public void testSelectStudentById() {\n		Student student = dao.selectStudentById(3);\n		System.out.println(student);\n	}\n\n	@Test\n	public void testSelectStudentsByName() {\n		List<Student> students = dao.selectStudentsByName(\"张\");\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n}\n```\n##### Dao 对象的获取\n```\nprivate IStudentDao dao;\nprivate SqlSession sqlSession;\n\n@Before\npublic void before() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\n}\n```\n##### sqlSession 的关闭\n```\n@After\npublic void after() {\n	if(sqlSession != null) {\n		sqlSession.close();\n	}\n}\n```\n##### sqlSession 的提交\n```\n@Test\npublic void testDeleteStudentById() {\n	dao.deleteStudentById(12);\n	sqlSession.commit();\n}\n```\n\n\n### 多条件查询\n#### 根据 Map 查询\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition(Map<String, Object> map);\n```\n*mapper.xml*\n```\n<!-- 多条件查询 -->\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\n		and age > #{ageCon}\n		and score > #{stu.score}  -- 对象.属性\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition() {\n	Student stu = new Student(\"田七\", 27, 95);\n\n	Map<String, Object> map = new HashMap<String, Object>();\n	map.put(\"nameCon\", \"张\");\n	map.put(\"ageCon\", 23);\n	map.put(\"stu\", stu);	//放入了学生对象\n\n	List<Student> students = dao.selectStudentsByCondition(map);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### 使用索引号\n>需求：找出姓张的，年龄大于 25 的\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByCondition2(String name,int age);\n```\n*mapper.xml*\n```\n<!-- 使用索引号 -->\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	where name like \'%\' #{0} \'%\' --0,1 索引号\n		and age > #{1}\n</select>\n```\n*MyText.java*\n```\n@Test\npublic void testSelectStudentsByCondition2() {\n	//参数直接对应 mapper.xml 中的索引号\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n### 总结：#{} 中可以放什么内容？\n1. 参数对象的属性\n2. 随意内容，此时的#{}是个占位符\n3. 参数为map时的key\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\n5. 参数的索引号\n\n### 动态 SQL\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\n\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\n\n#### if 和 where\n*IStudentDao.java*\n```\nList<Student> selectStudentsByWhere(Student student);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<if test=\"name != null and name != \'\'\">\n			and name like \'%\' #{name} \'%\'\n		</if>\n		<if test=\"age > 0\">\n			and age > #{age}\n		</if>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByWhere() {\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\n\n	List<Student> students = dao.selectStudentsByWhere(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n#### choose\n**类似于 switch case ，且每个 case 都自带了 break.**\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByChoose(Student student);\n```\n*mapper.xml*\n```\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\n	select id,name,age,score\n	from student\n	<where>\n		<choose>\n			<when test=\"name != null and name !=\'\'\">\n				and name like \'%\' #{name} \'%\'\n			</when>\n			<when test=\"age > 0\">\n				and age > #{age}\n			</when>\n			<otherwise>\n				1 = 2\n			</otherwise>\n		</choose>\n	</where>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByChoose() {\n	// Student stu = new Student(\"张\", 23, 0);\n	// Student stu = new Student(\"\", 23, 0);\n	Student stu = new Student(\"\", 0, 0);\n\n	List<Student> students = dao.selectStudentsByChoose(stu);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历数组\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsByForeach(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为基本类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach2(List<Integer> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach2() {\n	List<Integer> ids = new ArrayList<>();\n	ids.add(1);\n	ids.add(3);\n	List<Student> students = dao.selectStudentsByForeach2(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <foreach/>标签--遍历泛型为自定义类型的 List\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsByForeach3(List<Student> ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\n    select id,name,age,score\n    from student\n    <if test=\"list.size > 0\">\n        where id in\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\n            #{stu.id}\n        </foreach>\n    </if>\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsByForeach3() {\n	Student stu1 = new Student();\n	stu1.setId(1);\n	Student stu2 = new Student();\n	stu2.setId(3);\n	List<Student> stus = new ArrayList<>();\n	stus.add(stu1);\n	stus.add(stu2);\n	List<Student> students = dao.selectStudentsByForeach3(stus);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n#### <sql/>标签\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\n\n>需求：查询出 id 为 1 到 3 的学生信息\n\n*IStudentDao.java*\n```\nList<Student> selectStudentsBySqlFragment(int[] ids);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\n    select <include refid=\"selectColumns\"/> -- sql 片段\n    from student\n    <if test=\"array.length > 0\">\n        where id in\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\n            #{myid}\n        </foreach>\n    </if>\n</select>\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\n<sql id=\"selectColumns\">\n    id,name,age,score\n</sql>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectStudentsBySqlFragment() {\n	int[] ids = {1, 3, 4};\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\n	for (Student student : students) {\n		System.out.println(student);\n	}\n}\n```\n\n\n## 关联关系查询\n### 一对多关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	// 关联属性\n	private Set<Minister> ministers;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Minister> getMinisters() {\n		return ministers;\n	}\n	public void setMinisters(Set<Minister> ministers) {\n		this.ministers = ministers;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\n				+ ministers + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<!--多表连接查询语句-->\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname,mid,mname\n    from country,minister\n    where countryId=cid and cname=#{cname}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\n    <collection property=\"ministers\" ofType=\"Minister\">\n        <id column=\"mid\" property=\"mid\"/>\n        <result column=\"mname\" property=\"mname\"/>\n    </collection>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n#### 多表单独查询方式\n*ICountryDao*\n```\nCountry selectCountryByName(String cname);\n```\n*mapper.xml*\n```\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\n    select cid,cname from country where cname=#{xxx}\n</select>\n<resultMap type=\"Country\" id=\"countryMapper\">\n    <id column=\"cid\" property=\"cid\"/>\n    <result column=\"cname\" property=\"cname\"/>\n    <collection property=\"ministers\" \n                ofType=\"Minister\"\n                select=\"selectMinisterByCountry\"\n                column=\"cid\"/>\n</resultMap>\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\n    select mid,mname from minister where countryId=#{ooo}\n</select>\n```\n*MyTest.java*\n```\n@Test\npublic void testSelectCountryByName() {\n	Country country = dao.selectCountryByName(\"China\");\n	System.out.println(country);\n}\n```\n\n\n### 多对一关联查询\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\n需求：根据国家名，查出对应的国家和部长信息\n\n*Country.java*\n```\npublic class Country {\n	private Integer cid;\n	private String cname;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	@Override\n	public String toString() {\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Minister.java*\n```\npublic class Minister {\n	private Integer mid;\n	private String mname;\n	private Country country;	//关联属性\n\n	public Integer getMid() {\n		return mid;\n	}\n	public void setMid(Integer mid) {\n		this.mid = mid;\n	}\n	public String getMname() {\n		return mname;\n	}\n	public void setMname(String mname) {\n		this.mname = mname;\n	}\n	public Country getCountry() { return country; }\n	public void setCountry(Country country) { this.country = country; }\n\n	@Override\n	public String toString() {\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\n	}\n}\n```\n\n#### 多表连接查询方式\n*IMinisterDao*\n```\nMinister selectMinisterById(int mid);\n```\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,cid,cname\n    from minister, country\n    where countryId=cid and mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\" javaType=\"Country\">\n        <id column=\"cid\" property=\"cid\"/>\n        <result column=\"cname\" property=\"cname\"/>\n    </association>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void selectMinisterById() {\n	Minister minister = dao.selectMinisterById(2);\n	System.out.println(minister);\n}\n```\n#### 多表单独查询方式\n*mapper.xml*\n```\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\n    select mid,mname,countryId from minister where mid=#{xxx}\n</select>\n<resultMap type=\"Minister\" id=\"ministerMapper\">\n    <id column=\"mid\" property=\"mid\"/>\n    <result column=\"mname\" property=\"mname\"/>\n    <association property=\"country\"\n                 javaType=\"Country\"\n                 select=\"selectCountryById\"\n                 column=\"countryId\"/>\n</resultMap>\n<select id=\"selectCountryById\" resultType=\"Country\">\n    select cid,cname from country where cid=#{ooo}\n</select>\n```\n\n\n\n### 自关联查询\n类似于目录的递归。\n#### 以一对多方式处理\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private Set<NewsLabel> children;\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public Set<NewsLabel> getChildren() {\n		return children;\n	}\n	public void setChildren(Set<NewsLabel> children) {\n		this.children = children;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\n				+ children + \"]\";\n	}\n}\n```\n##### 查询指定栏目的所有子孙栏目\n*INewsLabelDao.java*\n```\nList<NewsLabel> selectChildrenByParent(int pid);\n```\n*mapper.xml*\n```\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\"\n				ofType=\"NewsLabel\"\n				select=\"selectChildrenByParent\"\n				column=\"id\"/>\n</resultMap>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\n	for (NewsLabel newsLabel : children) {\n		System.out.println(newsLabel);\n	}\n}\n```\n##### 查询指定栏目及其所有子孙栏目\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where id=#{xxx}\n</select>\n\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<collection property=\"children\" \n				ofType=\"NewsLabel\"\n				select=\"selectNewslabelByParent\"\n				column=\"id\"/>\n</resultMap>\n\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\n	select id,name from newslabel where pid=#{ooo}\n</select>\n\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\n	System.out.println(newslabel);\n}\n```\n#### 以多对一方式处理\n>需求：查询所有栏目及其父辈栏目\n\n*NewsLabel.java*\n```\n/**\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\n */\npublic class NewsLabel {\n	private Integer id;\n	private String name;  // 栏目名称\n	private NewsLabel parent;   // 父栏目\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public NewsLabel getParent() {\n		return parent;\n	}\n	public void setParent(NewsLabel parent) {\n		this.parent = parent;\n	}\n	@Override\n	public String toString() {\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\n				+ \"]\";\n	}\n}\n```\n\n*INewsLabelDao.java*\n```\nNewsLabel selectNewsLabelById(int id);\n```\n\n*mapper.xml*\n```\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\n	select id,name,pid from newslabel where id=#{xxx}\n</select>\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\n	<id column=\"id\" property=\"id\"/>\n	<result column=\"name\" property=\"name\"/>\n	<association property=\"parent\" \n				 javaType=\"NewsLabel\"\n				 select=\"selectNewsLabelById\"\n				 column=\"pid\"/>\n</resultMap>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\n	System.out.println(newslabel);\n}\n```\n\n### 多对多关联查询\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\n>实体类\n\n*Course.java*\n```\npublic class Course {\n	private Integer cid;\n	private String cname;\n	private Set<Student> students;\n	public Integer getCid() {\n		return cid;\n	}\n	public void setCid(Integer cid) {\n		this.cid = cid;\n	}\n	public String getCname() {\n		return cname;\n	}\n	public void setCname(String cname) {\n		this.cname = cname;\n	}\n	public Set<Student> getStudents() {\n		return students;\n	}\n	public void setStudents(Set<Student> students) {\n		this.students = students;\n	}\n	@Override\n	public String toString() {\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\n	}\n}\n```\n*Student.java*\n```\npublic class Student {\n	private Integer sid;\n	private String sname;\n	private Set<Course> courses;\n	public Integer getSid() {\n		return sid;\n	}\n	public void setSid(Integer sid) {\n		this.sid = sid;\n	}\n	public String getSname() {\n		return sname;\n	}\n	public void setSname(String sname) {\n		this.sname = sname;\n	}\n	public Set<Course> getCourses() {\n		return courses;\n	}\n	public void setCourses(Set<Course> courses) {\n		this.courses = courses;\n	}\n	@Override\n	public String toString() {\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\n				+ courses + \"]\";\n	}\n}\n```\n>Dao\n\n*IStudentDao.java*\n```\nStudent selectStudentById(int sid);\n```\n*mapper.xml*\n```\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\n	select sid,sname,cid,cname\n	from student,middle,course\n	where sid=studentId and cid=courseId and sid=#{xxx}\n</select>\n<resultMap type=\"Student\" id=\"studentMapper\">\n	<id column=\"sid\" property=\"sid\"/>\n	<result column=\"sname\" property=\"sname\"/>\n	<collection property=\"courses\" ofType=\"Course\">\n		<id column=\"cid\" property=\"cid\"/>\n		<result column=\"cname\" property=\"cname\"/>\n	</collection>\n</resultMap>\n```\n>Test\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Student student = dao.selectStudentById(1);\n	System.out.println(student);\n}\n```\n\n### 延迟加载\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\n\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\n\n#### 关联对象加载时机\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\n\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\n\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\n\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\n\n#### 延迟加载的总开关\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\n\n*mybatis.xml*\n```\n<configuration>\n    <properties resource=\"jdbc_mysql.properties\"/>\n\n    <!-- 设置整个应用所使用的常量 -->\n    <settings>\n        <!-- 延迟加载的总开关 -->\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    </settings>\n\n    <typeAliases>\n		...\n    </typeAliases>\n</configuration>\n```\n\n#### 直接加载\n*mybatis.xml*\n```\n<settings>\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\n</settings>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\n	System.out.println(country.getCname());\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 直接加载（√）：查询 country，查询 minister ---\nChina\nTotal：3\n```\n\n#### 侵入式延迟加载\n*mybatis.xml*\n```\n<!-- 设置整个应用所使用的常量 -->\n<settings>\n    <!-- 延迟加载的总开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!-- 侵入式延迟加载 -->\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\n</settings>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\n	System.out.println(country.getCname());\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 侵入式延迟加载（X）：查询 country ---\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\nChina\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\nTotal：3\n```\n#### 深度延迟加载\n*mybatis.xml*\n```\n<!-- 设置整个应用所使用的常量 -->\n<settings>\n    <!-- 延迟加载的总开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n</settings>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\n	System.out.println(country.getCname());\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\n	Set<Minister> ministers = country.getMinisters();\n	System.out.println(\"Total：\" + ministers.size());\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\n---- 深度延迟加载（X）：查询 country ---\nChina\n---- 深度延迟加载（X）：访问主加载对象 ---\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \n[DEBUG] ==> Parameters: 1(Integer)\nTotal：3\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\n```\n## 查询缓存\n查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。\n\nMyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。\n\nmyBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。\n\n无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。\n\n但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。\n\n### 一级查询缓存\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \n\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\n\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\n\n### 一级查询缓存\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \n\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\n\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\n\n#### 一级查询缓存的存在性证明\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	Country country = dao.selectCountryById(1);\n	System.out.println(country);\n	Country country2 = dao.selectCountryById(1);\n	System.out.println(country2);\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\nCountry [cid=1, cname=China]\n```\n只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。\n#### 从缓存读取数据的依据是 Sql 的 id\n缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。\n\n*MyTest.java*\n```\n@Test\npublic void test02() {\n	//使用了不同的查询语句，查询相同的记录 id\n	Country country = dao.selectCountryById(1);\n	System.out.println(country);\n	\n	Country country2 = dao.selectCountryById2(1);\n	System.out.println(country2);\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n```\n#### 增删改对一级查询缓存的影响\n增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。\n\n*MyTest.java*\n```\n@Test\npublic void test03() {\n	Country country = dao.selectCountryById(2);\n	System.out.println(country);\n\n	// 增删改操作都会清空一级缓存，无论是否提交\n	dao.insertCountry(new Country(3,\"USA\"));\n\n	Country country2 = dao.selectCountryById(2);\n	System.out.println(country2);\n}\n```\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 2(Integer)\nCountry [cid=2, cname=England]\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\n[DEBUG] ==> Parameters: 3(Integer), USA(String)\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\n[DEBUG] ==> Parameters: 2(Integer)\nCountry [cid=2, cname=England]\n```\n\n### 内置二级缓存\n使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。\n\n#### 开启内置的二级缓存步骤\n1）对实体进行序列化\n2）在映射文件中添加 `<cache/>` 标签\n\n*Country.java - 实例化*\n```\npublic class Country implements Serializable { }\n```\n\n*mybatis.xml - 添加 <cache/> 标签*\n```\n<mapper namespace=\"top.qingrang.sql_session_cache.dao.ICountryDao\">\n	<cache/>\n</mapper>\n```\n\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	Country country = dao.selectCountryById(1);\n	System.out.println(country);\n	//关闭 sqlSession，一级缓存会刷新\n	sqlSession.close();\n	//二级缓存会伴随整个生命周期\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	Country country2 = dao.selectCountryById(1);\n	System.out.println(country2);\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\nCountry [cid=1, cname=China]\n```\n#### 增删改对二级缓存的影响\n1. 增删改同样也会清空二级缓存\n2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除\n3. 从 DB 中进行 select 查询的条件是：\n1)缓存中根本就不存在这个 key\n2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null\n\n*MyTest.java*\n```\n@Test\npublic void test02() {\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	Country country = dao.selectCountryById2(2);\n	System.out.println(country);\n	sqlSession.close();\n	sqlSession = MyBatisUtils.getSqlSession();\n	dao = sqlSession.getMapper(ICountryDao.class);\n	dao.insertCountry(new Country(\"Japan\"));\n	Country country2 = dao.selectCountryById2(1);\n	System.out.println(country2);\n}\n```\n\n*调试信息*\n```\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\n[DEBUG] ==> Parameters: null, Japan(String)\n\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\n[DEBUG] ==> Parameters: 1(Integer)\nCountry [cid=1, cname=China]\n```\n#### 二级缓存的配置\n为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。\n\n`<cache eviction=\"FIFO\" flushInterval=\"10800000\" readOnly=\"true\" size=\"512\"/>`\n\n- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：\n- FIFO： First In First Out， 先进先出\n- LRU： Least Recently Used，未被使用时间最长的\n- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。\n- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。\n- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。\n\n#### 二级缓存的关闭\n二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。\n##### 全局关闭\n所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。\n```\n<settings>\n    <setting name=\"cacheEnabled\" value=\"false\" />\n</settings>\n```\n##### 局部关闭\n整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。\n\n`useCache=\"false\"`\n\n```\n<select id=\"selectCountryById\" useCache=\"false\" resultType=\"Country\">\n		select cid,cname from country where cid=#{xxx}\n	</select>\n```\n\n### ehcache 二级查询缓存\n使用 ehcache 二级缓存，实体类无需实现序列化接口。\n\n将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`\n\n*pom.xml*\n```\n<!--ehcache 相关包 -->\n<dependency>\n  <groupId>net.sf.ehcache</groupId>\n  <artifactId>ehcache</artifactId>\n  <version>2.7.5</version>\n</dependency>\n<dependency>\n  <groupId>org.mybatis.caches</groupId>\n  <artifactId>mybatis-ehcache</artifactId>\n  <version>1.1.0</version>\n</dependency>\n```\n\n*mapper.xml*\n```\n<mapper namespace=\"com.bjpowernode.dao.IStudentDao\">\n	<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\">\n		<property name=\"timeToIdleSeconds\" value=\"60\"/>\n	</cache>\n</mapper>\n```\n\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001825s ]
---------------------------------------------------------------
[ 2018-11-11T22:01:23+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/243.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/243.html [运行时间：0.072992s][吞吐率：13.70req/s] [内存消耗：2,425.47kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '103837',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```
## 查询缓存
查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。

MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。

myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。

无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。

但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

#### 一级查询缓存的存在性证明
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。
#### 从缓存读取数据的依据是 Sql 的 id
缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。

*MyTest.java*
```
@Test
public void test02() {
	//使用了不同的查询语句，查询相同的记录 id
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 增删改对一级查询缓存的影响
增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。

*MyTest.java*
```
@Test
public void test03() {
	Country country = dao.selectCountryById(2);
	System.out.println(country);

	// 增删改操作都会清空一级缓存，无论是否提交
	dao.insertCountry(new Country(3,"USA"));

	Country country2 = dao.selectCountryById(2);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: 3(Integer), USA(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]
```

### 内置二级缓存
使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。

#### 开启内置的二级缓存步骤
1）对实体进行序列化
2）在映射文件中添加 `<cache/>` 标签

*Country.java - 实例化*
```
public class Country implements Serializable { }
```

*mybatis.xml - 添加 <cache/> 标签*
```
<mapper namespace="top.qingrang.sql_session_cache.dao.ICountryDao">
	<cache/>
</mapper>
```

*MyTest.java*
```
@Test
public void test01() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	//关闭 sqlSession，一级缓存会刷新
	sqlSession.close();
	//二级缓存会伴随整个生命周期
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
#### 增删改对二级缓存的影响
1. 增删改同样也会清空二级缓存
2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除
3. 从 DB 中进行 select 查询的条件是：
1)缓存中根本就不存在这个 key
2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null

*MyTest.java*
```
@Test
public void test02() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById2(2);
	System.out.println(country);
	sqlSession.close();
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	dao.insertCountry(new Country("Japan"));
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: null, Japan(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 二级缓存的配置
为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。

`<cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/>`

- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：
- FIFO： First In First Out， 先进先出
- LRU： Least Recently Used，未被使用时间最长的
- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。
- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。
- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。

#### 二级缓存的关闭
二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。
##### 全局关闭
所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。
```
<settings>
    <setting name="cacheEnabled" value="false" />
</settings>
```
##### 局部关闭
整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。

`useCache="false"`

```
<select id="selectCountryById" useCache="false" resultType="Country">
		select cid,cname from country where cid=#{xxx}
	</select>
```

### ehcache 二级查询缓存
使用 ehcache 二级缓存，实体类无需实现序列化接口。

将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`

*pom.xml*
```
<!--ehcache 相关包 -->
<dependency>
  <groupId>net.sf.ehcache</groupId>
  <artifactId>ehcache</artifactId>
  <version>2.7.5</version>
</dependency>
<dependency>
  <groupId>org.mybatis.caches</groupId>
  <artifactId>mybatis-ehcache</artifactId>
  <version>1.1.0</version>
</dependency>
```

*mapper.xml*
```
<mapper namespace="com.bjpowernode.dao.IStudentDao">
	<cache type="org.mybatis.caches.ehcache.EhcacheCache">
		<property name="timeToIdleSeconds" value="60"/>
	</cache>
</mapper>
```


',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000887s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001630s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000801s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000366s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000965s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000643s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000406s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=243,`p_id`=2,`title`='Mybatis\r',`content`='# Mybatis\r\n[TOC]\r\n## Mybatis 体系结构和工作原理\r\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\r\n## 第一个 MyBaits 程序\r\n### 主配置文件详解\r\n1. 注册数据库连接四要素属性文件\r\n`<properties resource=\"jdbc_mysql.properties\"/>`\r\n1. 定义类型别名\r\n```\r\n<typeAliases>\r\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\r\n	<package name=\"top.qingrang.beans\"/>\r\n</typeAliases>\r\n```\r\n1. 配置运行环境\r\n```\r\n<environments default=\"XXX2\">\r\n	<!-- 环境，eg：上线环境 -->\r\n	<environment id=\"XXX1\">\r\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n		<transactionManager type=\"JDBC\"/>\r\n		<!-- 数据源，数据库连接池 -->\r\n		<dataSource type=\"POOLED\">\r\n			<!-- 数据库连接四要素 -->\r\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n			<property name=\"url\" value=\"${jdbc.url}\"/>\r\n			<property name=\"username\" value=\"${jdbc.user}\"/>\r\n			<property name=\"password\" value=\"${jdbc.password}\"/>\r\n		</dataSource>\r\n	</environment>\r\n\r\n	<!-- 另一个环境，eg：本地测试的环境 -->\r\n	<environment id=\"XXX2\">\r\n		...\r\n	</environment>\r\n</environments>\r\n```\r\n1. 注册映射文件\r\n```\r\n<mappers>\r\n	<!-- 配置文件路径 -->\r\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n>问题？\r\n\r\n1. environments 下为什么可以配置多个 environment？\r\n方便切换运行环境，只需要改变 `default` 即可\r\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\r\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\r\n1. 什么是数据库连接池？\r\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\r\n\r\n*mybatis.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 注册数据库连接四要素属性文件 -->\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 定义类型别名 -->\r\n    <typeAliases>\r\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\r\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\r\n        <package name=\"top.qingrang.beans\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\r\n    <environments default=\"onlineEM\">\r\n        <!-- 上线以后的环境 -->\r\n        <environment id=\"onlineEM\">\r\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n            <transactionManager type=\"JDBC\"/>\r\n            <!-- 数据源，数据库连接池 -->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- 数据库连接四要素 -->\r\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n                <property name=\"url\" value=\"${jdbc.url}\"/>\r\n                <property name=\"username\" value=\"${jdbc.user}\"/>\r\n                <property name=\"password\" value=\"${jdbc.password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n        <!-- 本地测试的环境 -->\r\n        <environment id=\"testEM\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"111\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <!-- 注册映射文件 -->\r\n    <mappers>\r\n        <!-- 配置文件路径 -->\r\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n    </mappers>\r\n\r\n</configuration>\r\n```\r\n### 核心代码\r\n利用 sqlSession 对象，执行相关操作。\r\n```\r\nprivate SqlSession sqlSession;\r\n\r\n@Override\r\npublic void insertStu(Student student) {\r\n	try {\r\n		// 1.加载主配置文件\r\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n		// 2.创建 SqlSessionFactory 对象\r\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n		// 3.创建 sqlSession 对象\r\n		sqlSession = sqlSessionFactory.openSession();\r\n		// 4.执行相关操作\r\n		sqlSession.insert(\"insertStudent\", student);\r\n		// 5.提交\r\n		sqlSession.commit();\r\n	} catch (IOException e) {\r\n		e.printStackTrace();\r\n	} finally {\r\n		if(sqlSession != null) {\r\n			// 6.关闭\r\n			sqlSession.close();\r\n		}\r\n	}\r\n}\r\n```\r\n### 封装 MyBatis 工具类\r\n*MyBatisUtils.java*\r\n```\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * MyBatis 工具类\r\n */\r\npublic class MyBatisUtils {\r\n\r\n	private static SqlSessionFactory sqlSessionFactory;\r\n\r\n	/**\r\n	 * 得到 SqlSession 对象\r\n	 */\r\n	public static SqlSession getSqlSession() {\r\n		try {\r\n			// 1.加载主配置文件\r\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n			if (sqlSessionFactory == null) {\r\n				// 2.创建 SqlSessionFactory 对象\r\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n			}\r\n			// 3.返回 SqlSession 对象\r\n			return sqlSessionFactory.openSession();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return null;\r\n	}\r\n}\r\n```\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n### 源码分析\r\n#### 输入流的关闭\r\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的创建\r\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\r\n\r\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\r\n\r\n>dirty 详解\r\n\r\ntrue：和数据库中的数据不一致(脏)\r\nfalse：和数据库中的数据一致(不脏)\r\n\r\n#### 增删改的执行\r\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\r\n\r\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\r\n\r\n#### SqlSession 的提交 commit()\r\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的关闭\r\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 单表的 CURD 操作\r\n### 常用的增删改查\r\n*mapper.xml*\r\n```\r\n<!-- parameterType 可以省略 -->\r\n<insert id=\"insertStudent\" parameterType=\"Student\">\r\n	<!-- 这里的 #{} 是属性 -->\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<!-- 插入后用新 id 初始化被插入对象 -->\r\n<insert id=\"insertStudentCacheId\">\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\r\n		select @@identity\r\n	</selectKey>\r\n</insert>\r\n\r\n<delete id=\"deleteStudentById\">\r\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\r\n	DELETE FROM student WHERE id = #{id}\r\n</delete>\r\n\r\n<update id=\"updateStudent\">\r\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\r\n</update>\r\n\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n\r\n<!-- 模糊查询 -->\r\n<select id=\"selectStudentsByName\" resultType=\"Student\">\r\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\r\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\r\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\r\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\r\n</select>\r\n```\r\n\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void insertStudentCacheId(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.insert(\"insertStudentCacheId\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void deleteStudentById(int id) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.delete(\"deleteStudentById\", id);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.update(\"updateStudent\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectAllStudents\");\r\n			//查询不需要 sqlSession.commit();\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n\r\n	@Override\r\n	public Map<String, Object> selectAllStudentsMap() {\r\n		Map<String, Object> map = new HashMap<>();\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return map;\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		Student student = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			student = sqlSession.selectOne(\"selectStudentById\", id);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return student;\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectStudentsByName(String name) {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n}\r\n```\r\n\r\n### 属性名与查询字段名不相同\r\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\r\n```\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n```\r\n#### 解决方案一：查询字段使用别名\r\n```\r\n<insert id=\"insertStudent\">\r\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n#### 解决方案二：使用结果映射 resultMap\r\n```\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"tid\" property=\"id\"/>\r\n	<result column=\"tname\" property=\"name\"/>\r\n 	<result column=\"tage\" property=\"age\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n### Mapper 动态代理\r\n#### 修改映射文件的 namespace 属性值\r\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\r\n通过接口名即可定位到映射文件 mapper.\r\n#### 删除 IStudentDaoImpl 实现类\r\n#### 修改 MyText.java 测试方法\r\n*MyTex.java*\r\n```\r\npublic class MyTest {\r\n	private IStudentDao dao;\r\n	private SqlSession sqlSession;\r\n\r\n	@Before\r\n	public void before() {\r\n		sqlSession = MyBatisUtils.getSqlSession();\r\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n	}\r\n\r\n	@After\r\n	public void after() {\r\n		if(sqlSession != null) {\r\n			sqlSession.close();\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudent() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudent(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudentCacheId() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudentCacheId(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testDeleteStudentById() {\r\n		dao.deleteStudentById(12);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testUpdateStudent() {\r\n		Student student = new Student(\"张三\", 25, 93.5);\r\n		student.setId(15);\r\n		dao.updateStudent(student);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testSelectAllStudents() {\r\n		List<Student> students = dao.selectAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentById() {\r\n		Student student = dao.selectStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentsByName() {\r\n		List<Student> students = dao.selectStudentsByName(\"张\");\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n}\r\n```\r\n##### Dao 对象的获取\r\n```\r\nprivate IStudentDao dao;\r\nprivate SqlSession sqlSession;\r\n\r\n@Before\r\npublic void before() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n}\r\n```\r\n##### sqlSession 的关闭\r\n```\r\n@After\r\npublic void after() {\r\n	if(sqlSession != null) {\r\n		sqlSession.close();\r\n	}\r\n}\r\n```\r\n##### sqlSession 的提交\r\n```\r\n@Test\r\npublic void testDeleteStudentById() {\r\n	dao.deleteStudentById(12);\r\n	sqlSession.commit();\r\n}\r\n```\r\n\r\n\r\n### 多条件查询\r\n#### 根据 Map 查询\r\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition(Map<String, Object> map);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 多条件查询 -->\r\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\r\n		and age > #{ageCon}\r\n		and score > #{stu.score}  -- 对象.属性\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition() {\r\n	Student stu = new Student(\"田七\", 27, 95);\r\n\r\n	Map<String, Object> map = new HashMap<String, Object>();\r\n	map.put(\"nameCon\", \"张\");\r\n	map.put(\"ageCon\", 23);\r\n	map.put(\"stu\", stu);	//放入了学生对象\r\n\r\n	List<Student> students = dao.selectStudentsByCondition(map);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### 使用索引号\r\n>需求：找出姓张的，年龄大于 25 的\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition2(String name,int age);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 使用索引号 -->\r\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{0} \'%\' --0,1 索引号\r\n		and age > #{1}\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition2() {\r\n	//参数直接对应 mapper.xml 中的索引号\r\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n### 总结：#{} 中可以放什么内容？\r\n1. 参数对象的属性\r\n2. 随意内容，此时的#{}是个占位符\r\n3. 参数为map时的key\r\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\r\n5. 参数的索引号\r\n\r\n### 动态 SQL\r\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\r\n\r\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\r\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\r\n\r\n#### if 和 where\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByWhere(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<if test=\"name != null and name != \'\'\">\r\n			and name like \'%\' #{name} \'%\'\r\n		</if>\r\n		<if test=\"age > 0\">\r\n			and age > #{age}\r\n		</if>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByWhere() {\r\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\r\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\r\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\r\n\r\n	List<Student> students = dao.selectStudentsByWhere(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n#### choose\r\n**类似于 switch case ，且每个 case 都自带了 break.**\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByChoose(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\r\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<choose>\r\n			<when test=\"name != null and name !=\'\'\">\r\n				and name like \'%\' #{name} \'%\'\r\n			</when>\r\n			<when test=\"age > 0\">\r\n				and age > #{age}\r\n			</when>\r\n			<otherwise>\r\n				1 = 2\r\n			</otherwise>\r\n		</choose>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByChoose() {\r\n	// Student stu = new Student(\"张\", 23, 0);\r\n	// Student stu = new Student(\"\", 23, 0);\r\n	Student stu = new Student(\"\", 0, 0);\r\n\r\n	List<Student> students = dao.selectStudentsByChoose(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历数组\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsByForeach(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为基本类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach2(List<Integer> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach2() {\r\n	List<Integer> ids = new ArrayList<>();\r\n	ids.add(1);\r\n	ids.add(3);\r\n	List<Student> students = dao.selectStudentsByForeach2(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为自定义类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach3(List<Student> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\r\n            #{stu.id}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach3() {\r\n	Student stu1 = new Student();\r\n	stu1.setId(1);\r\n	Student stu2 = new Student();\r\n	stu2.setId(3);\r\n	List<Student> stus = new ArrayList<>();\r\n	stus.add(stu1);\r\n	stus.add(stu2);\r\n	List<Student> students = dao.selectStudentsByForeach3(stus);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <sql/>标签\r\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\r\n\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsBySqlFragment(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\r\n    select <include refid=\"selectColumns\"/> -- sql 片段\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\r\n<sql id=\"selectColumns\">\r\n    id,name,age,score\r\n</sql>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsBySqlFragment() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n## 关联关系查询\r\n### 一对多关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	// 关联属性\r\n	private Set<Minister> ministers;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Minister> getMinisters() {\r\n		return ministers;\r\n	}\r\n	public void setMinisters(Set<Minister> ministers) {\r\n		this.ministers = ministers;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\r\n				+ ministers + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<!--多表连接查询语句-->\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname,mid,mname\r\n    from country,minister\r\n    where countryId=cid and cname=#{cname}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\r\n    <collection property=\"ministers\" ofType=\"Minister\">\r\n        <id column=\"mid\" property=\"mid\"/>\r\n        <result column=\"mname\" property=\"mname\"/>\r\n    </collection>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname from country where cname=#{xxx}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <collection property=\"ministers\" \r\n                ofType=\"Minister\"\r\n                select=\"selectMinisterByCountry\"\r\n                column=\"cid\"/>\r\n</resultMap>\r\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\r\n    select mid,mname from minister where countryId=#{ooo}\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n\r\n\r\n### 多对一关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	private Country country;	//关联属性\r\n\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	public Country getCountry() { return country; }\r\n	public void setCountry(Country country) { this.country = country; }\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*IMinisterDao*\r\n```\r\nMinister selectMinisterById(int mid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,cid,cname\r\n    from minister, country\r\n    where countryId=cid and mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\" javaType=\"Country\">\r\n        <id column=\"cid\" property=\"cid\"/>\r\n        <result column=\"cname\" property=\"cname\"/>\r\n    </association>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void selectMinisterById() {\r\n	Minister minister = dao.selectMinisterById(2);\r\n	System.out.println(minister);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,countryId from minister where mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\"\r\n                 javaType=\"Country\"\r\n                 select=\"selectCountryById\"\r\n                 column=\"countryId\"/>\r\n</resultMap>\r\n<select id=\"selectCountryById\" resultType=\"Country\">\r\n    select cid,cname from country where cid=#{ooo}\r\n</select>\r\n```\r\n\r\n\r\n\r\n### 自关联查询\r\n类似于目录的递归。\r\n#### 以一对多方式处理\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private Set<NewsLabel> children;\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public Set<NewsLabel> getChildren() {\r\n		return children;\r\n	}\r\n	public void setChildren(Set<NewsLabel> children) {\r\n		this.children = children;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\r\n				+ children + \"]\";\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目的所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nList<NewsLabel> selectChildrenByParent(int pid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\"\r\n				ofType=\"NewsLabel\"\r\n				select=\"selectChildrenByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\r\n	for (NewsLabel newsLabel : children) {\r\n		System.out.println(newsLabel);\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目及其所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where id=#{xxx}\r\n</select>\r\n\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\" \r\n				ofType=\"NewsLabel\"\r\n				select=\"selectNewslabelByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{ooo}\r\n</select>\r\n\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n#### 以多对一方式处理\r\n>需求：查询所有栏目及其父辈栏目\r\n\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private NewsLabel parent;   // 父栏目\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public NewsLabel getParent() {\r\n		return parent;\r\n	}\r\n	public void setParent(NewsLabel parent) {\r\n		this.parent = parent;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name,pid from newslabel where id=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<association property=\"parent\" \r\n				 javaType=\"NewsLabel\"\r\n				 select=\"selectNewsLabelById\"\r\n				 column=\"pid\"/>\r\n</resultMap>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n\r\n### 多对多关联查询\r\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\r\n>实体类\r\n\r\n*Course.java*\r\n```\r\npublic class Course {\r\n	private Integer cid;\r\n	private String cname;\r\n	private Set<Student> students;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Student> getStudents() {\r\n		return students;\r\n	}\r\n	public void setStudents(Set<Student> students) {\r\n		this.students = students;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private Integer sid;\r\n	private String sname;\r\n	private Set<Course> courses;\r\n	public Integer getSid() {\r\n		return sid;\r\n	}\r\n	public void setSid(Integer sid) {\r\n		this.sid = sid;\r\n	}\r\n	public String getSname() {\r\n		return sname;\r\n	}\r\n	public void setSname(String sname) {\r\n		this.sname = sname;\r\n	}\r\n	public Set<Course> getCourses() {\r\n		return courses;\r\n	}\r\n	public void setCourses(Set<Course> courses) {\r\n		this.courses = courses;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\r\n				+ courses + \"]\";\r\n	}\r\n}\r\n```\r\n>Dao\r\n\r\n*IStudentDao.java*\r\n```\r\nStudent selectStudentById(int sid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select sid,sname,cid,cname\r\n	from student,middle,course\r\n	where sid=studentId and cid=courseId and sid=#{xxx}\r\n</select>\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"sid\" property=\"sid\"/>\r\n	<result column=\"sname\" property=\"sname\"/>\r\n	<collection property=\"courses\" ofType=\"Course\">\r\n		<id column=\"cid\" property=\"cid\"/>\r\n		<result column=\"cname\" property=\"cname\"/>\r\n	</collection>\r\n</resultMap>\r\n```\r\n>Test\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Student student = dao.selectStudentById(1);\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n### 延迟加载\r\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\r\n\r\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\r\n\r\n#### 关联对象加载时机\r\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\r\n\r\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\r\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\r\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\r\n\r\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\r\n\r\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\r\n\r\n#### 延迟加载的总开关\r\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\r\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\r\n\r\n*mybatis.xml*\r\n```\r\n<configuration>\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 设置整个应用所使用的常量 -->\r\n    <settings>\r\n        <!-- 延迟加载的总开关 -->\r\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    </settings>\r\n\r\n    <typeAliases>\r\n		...\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n\r\n#### 直接加载\r\n*mybatis.xml*\r\n```\r\n<settings>\r\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\r\n</settings>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\r\n	System.out.println(country.getCname());\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 直接加载（√）：查询 country，查询 minister ---\r\nChina\r\nTotal：3\r\n```\r\n\r\n#### 侵入式延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 侵入式延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 侵入式延迟加载（X）：查询 country ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nChina\r\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\r\nTotal：3\r\n```\r\n#### 深度延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 深度延迟加载（X）：查询 country ---\r\nChina\r\n---- 深度延迟加载（X）：访问主加载对象 ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nTotal：3\r\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\r\n```\r\n## 查询缓存\r\n查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。\r\n\r\nMyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。\r\n\r\nmyBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。\r\n\r\n无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。\r\n\r\n但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n\r\n#### 一级查询缓存的存在性证明\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	Country country2 = dao.selectCountryById(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\nCountry [cid=1, cname=China]\r\n```\r\n只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。\r\n#### 从缓存读取数据的依据是 Sql 的 id\r\n缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test02() {\r\n	//使用了不同的查询语句，查询相同的记录 id\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	\r\n	Country country2 = dao.selectCountryById2(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 增删改对一级查询缓存的影响\r\n增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test03() {\r\n	Country country = dao.selectCountryById(2);\r\n	System.out.println(country);\r\n\r\n	// 增删改操作都会清空一级缓存，无论是否提交\r\n	dao.insertCountry(new Country(3,\"USA\"));\r\n\r\n	Country country2 = dao.selectCountryById(2);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 2(Integer)\r\nCountry [cid=2, cname=England]\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\r\n[DEBUG] ==> Parameters: 3(Integer), USA(String)\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 2(Integer)\r\nCountry [cid=2, cname=England]\r\n```\r\n\r\n### 内置二级缓存\r\n使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。\r\n\r\n#### 开启内置的二级缓存步骤\r\n1）对实体进行序列化\r\n2）在映射文件中添加 `<cache/>` 标签\r\n\r\n*Country.java - 实例化*\r\n```\r\npublic class Country implements Serializable { }\r\n```\r\n\r\n*mybatis.xml - 添加 <cache/> 标签*\r\n```\r\n<mapper namespace=\"top.qingrang.sql_session_cache.dao.ICountryDao\">\r\n	<cache/>\r\n</mapper>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	//关闭 sqlSession，一级缓存会刷新\r\n	sqlSession.close();\r\n	//二级缓存会伴随整个生命周期\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country2 = dao.selectCountryById(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 增删改对二级缓存的影响\r\n1. 增删改同样也会清空二级缓存\r\n2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除\r\n3. 从 DB 中进行 select 查询的条件是：\r\n1)缓存中根本就不存在这个 key\r\n2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test02() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country = dao.selectCountryById2(2);\r\n	System.out.println(country);\r\n	sqlSession.close();\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	dao.insertCountry(new Country(\"Japan\"));\r\n	Country country2 = dao.selectCountryById2(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\r\n[DEBUG] ==> Parameters: null, Japan(String)\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 二级缓存的配置\r\n为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。\r\n\r\n`<cache eviction=\"FIFO\" flushInterval=\"10800000\" readOnly=\"true\" size=\"512\"/>`\r\n\r\n- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：\r\n- FIFO： First In First Out， 先进先出\r\n- LRU： Least Recently Used，未被使用时间最长的\r\n- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。\r\n- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。\r\n- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。\r\n\r\n#### 二级缓存的关闭\r\n二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。\r\n##### 全局关闭\r\n所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。\r\n```\r\n<settings>\r\n    <setting name=\"cacheEnabled\" value=\"false\" />\r\n</settings>\r\n```\r\n##### 局部关闭\r\n整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。\r\n\r\n`useCache=\"false\"`\r\n\r\n```\r\n<select id=\"selectCountryById\" useCache=\"false\" resultType=\"Country\">\r\n		select cid,cname from country where cid=#{xxx}\r\n	</select>\r\n```\r\n\r\n### ehcache 二级查询缓存\r\n使用 ehcache 二级缓存，实体类无需实现序列化接口。\r\n\r\n将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`\r\n\r\n*pom.xml*\r\n```\r\n<!--ehcache 相关包 -->\r\n<dependency>\r\n  <groupId>net.sf.ehcache</groupId>\r\n  <artifactId>ehcache</artifactId>\r\n  <version>2.7.5</version>\r\n</dependency>\r\n<dependency>\r\n  <groupId>org.mybatis.caches</groupId>\r\n  <artifactId>mybatis-ehcache</artifactId>\r\n  <version>1.1.0</version>\r\n</dependency>\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<mapper namespace=\"com.bjpowernode.dao.IStudentDao\">\r\n	<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\">\r\n		<property name=\"timeToIdleSeconds\" value=\"60\"/>\r\n	</cache>\r\n</mapper>\r\n```\r\n\r\n\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 243 [ RunTime:0.002108s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001921s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000329s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000922s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000301s ]
---------------------------------------------------------------
[ 2018-11-11T22:01:25+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/243.html
[ info ] qingrang.top/daily/admin/note/shownote/id/243.html [运行时间：0.075845s][吞吐率：13.18req/s] [内存消耗：2,072.69kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000670s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001401s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000758s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000913s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000295s ]
---------------------------------------------------------------
[ 2018-11-11T22:28:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.071518s][吞吐率：13.98req/s] [内存消耗：2,128.81kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'purpose' => 'prefetch',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002456s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001870s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000778s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001160s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000295s ]
---------------------------------------------------------------
[ 2018-11-11T22:28:58+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/243.html
[ info ] qingrang.top/daily/admin/note/editnote/id/243.html [运行时间：0.092136s][吞吐率：10.85req/s] [内存消耗：2,128.29kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000686s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002036s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.001074s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001424s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000411s ]
---------------------------------------------------------------
[ 2018-11-11T22:29:23+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/1.html
[ info ] qingrang.top/daily/admin/note/editnote/id/1.html [运行时间：0.055623s][吞吐率：17.98req/s] [内存消耗：2,119.12kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '1',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000551s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001391s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000630s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001126s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000359s ]
---------------------------------------------------------------
[ 2018-11-11T22:34:31+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/243.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/243.html [运行时间：0.079968s][吞吐率：12.51req/s] [内存消耗：2,437.35kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '107200',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Mybatis
[TOC]
## Mybatis 体系结构和工作原理
![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*

![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*
## 第一个 MyBaits 程序
### 主配置文件详解
1. 注册数据库连接四要素属性文件
`<properties resource="jdbc_mysql.properties"/>`
1. 定义类型别名
```
<typeAliases>
	<!-- 将指定包中所有类的简单类名当作其别名 -->
	<package name="top.qingrang.beans"/>
</typeAliases>
```
1. 配置运行环境
```
<environments default="XXX2">
	<!-- 环境，eg：上线环境 -->
	<environment id="XXX1">
		<!-- 事务管理器，使用 JDBC 的事务管理 -->
		<transactionManager type="JDBC"/>
		<!-- 数据源，数据库连接池 -->
		<dataSource type="POOLED">
			<!-- 数据库连接四要素 -->
			<property name="driver" value="${jdbc.driver}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.user}"/>
			<property name="password" value="${jdbc.password}"/>
		</dataSource>
	</environment>

	<!-- 另一个环境，eg：本地测试的环境 -->
	<environment id="XXX2">
		...
	</environment>
</environments>
```
1. 注册映射文件
```
<mappers>
	<!-- 配置文件路径 -->
	<mapper resource="top/qingrang/dao/mapper.xml"/>
</mappers>
```

>问题？

1. environments 下为什么可以配置多个 environment？
方便切换运行环境，只需要改变 `default` 即可
1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？
如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource="jdbc_mysql.properties"/>` 即可
1. 什么是数据库连接池？
数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。

*mybatis.xml*

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 注册数据库连接四要素属性文件 -->
    <properties resource="jdbc_mysql.properties"/>

    <!-- 定义类型别名 -->
    <typeAliases>
        <!-- <typeAlias type="top.qingrang.beans.Student" alias="Student"/> -->
        <!-- 将指定包中所有类的简单类名当作其别名 -->
        <package name="top.qingrang.beans"/>
    </typeAliases>

    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->
    <environments default="onlineEM">
        <!-- 上线以后的环境 -->
        <environment id="onlineEM">
            <!-- 事务管理器，使用 JDBC 的事务管理 -->
            <transactionManager type="JDBC"/>
            <!-- 数据源，数据库连接池 -->
            <dataSource type="POOLED">
                <!-- 数据库连接四要素 -->
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.user}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
        <!-- 本地测试的环境 -->
        <environment id="testEM">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://127.0.0.1:3366/test"/>
                <property name="username" value="root"/>
                <property name="password" value="111"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 注册映射文件 -->
    <mappers>
        <!-- 配置文件路径 -->
        <mapper resource="top/qingrang/dao/mapper.xml"/>
    </mappers>

</configuration>
```
### 核心代码
利用 sqlSession 对象，执行相关操作。
```
private SqlSession sqlSession;

@Override
public void insertStu(Student student) {
	try {
		// 1.加载主配置文件
		InputStream is = Resources.getResourceAsStream("mybatis.xml");
		// 2.创建 SqlSessionFactory 对象
		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
		// 3.创建 sqlSession 对象
		sqlSession = sqlSessionFactory.openSession();
		// 4.执行相关操作
		sqlSession.insert("insertStudent", student);
		// 5.提交
		sqlSession.commit();
	} catch (IOException e) {
		e.printStackTrace();
	} finally {
		if(sqlSession != null) {
			// 6.关闭
			sqlSession.close();
		}
	}
}
```
### 封装 MyBatis 工具类
*MyBatisUtils.java*
```
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

/**
 * MyBatis 工具类
 */
public class MyBatisUtils {

	private static SqlSessionFactory sqlSessionFactory;

	/**
	 * 得到 SqlSession 对象
	 */
	public static SqlSession getSqlSession() {
		try {
			// 1.加载主配置文件
			InputStream is = Resources.getResourceAsStream("mybatis.xml");
			if (sqlSessionFactory == null) {
				// 2.创建 SqlSessionFactory 对象
				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
			}
			// 3.返回 SqlSession 对象
			return sqlSessionFactory.openSession();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```
*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}
}
```
### 源码分析
#### 输入流的关闭
在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*

#### SqlSession 的创建
SqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*

从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。

>dirty 详解

true：和数据库中的数据不一致(脏)
false：和数据库中的数据一致(不脏)

#### 增删改的执行
对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。

![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*

从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。

#### SqlSession 的提交 commit()
执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*

#### SqlSession 的关闭
在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。
![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*









## 单表的 CURD 操作
### 常用的增删改查
*mapper.xml*
```
<!-- parameterType 可以省略 -->
<insert id="insertStudent" parameterType="Student">
	<!-- 这里的 #{} 是属性 -->
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
</insert>

<!-- 插入后用新 id 初始化被插入对象 -->
<insert id="insertStudentCacheId">
	insert into student(name,age,score) values(#{name}, #{age}, #{score})
	<selectKey resultType="int" keyProperty="id" order="AFTER">
		select @@identity
	</selectKey>
</insert>

<delete id="deleteStudentById">
	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->
	DELETE FROM student WHERE id = #{id}
</delete>

<update id="updateStudent">
	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}
</update>

<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>

<!-- 模糊查询 -->
<select id="selectStudentsByName" resultType="Student">
	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'
	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->
	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->
	<!-- select id,name,age,score from student where name like \'%${value}%\' -->
</select>
```

*StudentDaoImpl.java*
```
public class StudentDaoImpl implements IStudentDao {
	private SqlSession sqlSession;

	@Override
	public void insertStudent(Student student) {
		try {
			// 创建 SqlSession 对象
			sqlSession = MyBatisUtils.getSqlSession();
			// 执行相关操作
			sqlSession.insert("insertStudent", student);
			// 提交
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void insertStudentCacheId(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.insert("insertStudentCacheId", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void deleteStudentById(int id) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.delete("deleteStudentById", id);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public void updateStudent(Student student) {
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			sqlSession.update("updateStudent", student);
			sqlSession.commit();
		}finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
	}

	@Override
	public List<Student> selectAllStudents() {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectAllStudents");
			//查询不需要 sqlSession.commit();
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}

	@Override
	public Map<String, Object> selectAllStudentsMap() {
		Map<String, Object> map = new HashMap<>();
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			map = sqlSession.selectMap("selectAllStudents", "name");
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return map;
	}

	@Override
	public Student selectStudentById(int id) {
		Student student = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			student = sqlSession.selectOne("selectStudentById", id);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return student;
	}

	@Override
	public List<Student> selectStudentsByName(String name) {
		List<Student> students = null;
		try {
			sqlSession = MyBatisUtils.getSqlSession();
			students = sqlSession.selectList("selectStudentsByName", name);
		} finally {
			if(sqlSession != null) {
				sqlSession.close();
			}
		}
		return students;
	}
}
```

### 属性名与查询字段名不相同
若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。
```
<!-- resultType="Student"，封装成 Student 类 -->
<select id="selectAllStudents" resultType="Student">
	select id,name,age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select id,name,age,score from student where id=#{xxx}
</select>
```
#### 解决方案一：查询字段使用别名
```
<insert id="insertStudent">
	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})
</insert>

<select id="selectAllStudents" resultType="Student">
	select tid id,tname name,tage age,score from student
</select>

<select id="selectStudentById" resultType="Student">
	select tid id,tname name,tage age,score from student where tid=#{jjj}
</select>
```
#### 解决方案二：使用结果映射 resultMap
```
<resultMap type="Student" id="studentMapper">
	<id column="tid" property="id"/>
	<result column="tname" property="name"/>
 	<result column="tage" property="age"/>
</resultMap>

<select id="selectAllStudents" resultMap="studentMapper">
	select tid,tname,tage,score from student
</select>

<select id="selectStudentById" resultMap="studentMapper">
	select tid,tname,tage,score from student where tid=#{jjj}
</select>
```
### Mapper 动态代理
#### 修改映射文件的 namespace 属性值
`<mapper namespace="top.qingrang.dao.IStudentDao">`
通过接口名即可定位到映射文件 mapper.
#### 删除 IStudentDaoImpl 实现类
#### 修改 MyText.java 测试方法
*MyTex.java*
```
public class MyTest {
	private IStudentDao dao;
	private SqlSession sqlSession;

	@Before
	public void before() {
		sqlSession = MyBatisUtils.getSqlSession();
		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
	}

	@After
	public void after() {
		if(sqlSession != null) {
			sqlSession.close();
		}
	}

	@Test
	public void testInsertStudent() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudent(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testInsertStudentCacheId() {
		Student student = new Student("张三", 23, 93.5);
		System.out.println("插入前：student = " + student);
		dao.insertStudentCacheId(student);
		sqlSession.commit();
		System.out.println("插入后：student = " + student);
	}

	@Test
	public void testDeleteStudentById() {
		dao.deleteStudentById(12);
		sqlSession.commit();
	}

	@Test
	public void testUpdateStudent() {
		Student student = new Student("张三", 25, 93.5);
		student.setId(15);
		dao.updateStudent(student);
		sqlSession.commit();
	}

	@Test
	public void testSelectAllStudents() {
		List<Student> students = dao.selectAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}

	@Test
	public void testSelectStudentById() {
		Student student = dao.selectStudentById(3);
		System.out.println(student);
	}

	@Test
	public void testSelectStudentsByName() {
		List<Student> students = dao.selectStudentsByName("张");
		for (Student student : students) {
			System.out.println(student);
		}
	}
}
```
##### Dao 对象的获取
```
private IStudentDao dao;
private SqlSession sqlSession;

@Before
public void before() {
	sqlSession = MyBatisUtils.getSqlSession();
	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。
	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。
}
```
##### sqlSession 的关闭
```
@After
public void after() {
	if(sqlSession != null) {
		sqlSession.close();
	}
}
```
##### sqlSession 的提交
```
@Test
public void testDeleteStudentById() {
	dao.deleteStudentById(12);
	sqlSession.commit();
}
```


### 多条件查询
#### 根据 Map 查询
>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生

*IStudentDao.java*
```
List<Student> selectStudentsByCondition(Map<String, Object> map);
```
*mapper.xml*
```
<!-- 多条件查询 -->
<select id="selectStudentsByCondition" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{nameCon} \'%\' -- 模糊查询
		and age > #{ageCon}
		and score > #{stu.score}  -- 对象.属性
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition() {
	Student stu = new Student("田七", 27, 95);

	Map<String, Object> map = new HashMap<String, Object>();
	map.put("nameCon", "张");
	map.put("ageCon", 23);
	map.put("stu", stu);	//放入了学生对象

	List<Student> students = dao.selectStudentsByCondition(map);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### 使用索引号
>需求：找出姓张的，年龄大于 25 的

*IStudentDao.java*
```
List<Student> selectStudentsByCondition2(String name,int age);
```
*mapper.xml*
```
<!-- 使用索引号 -->
<select id="selectStudentsByCondition2" resultType="Student">
	select id,name,age,score
	from student
	where name like \'%\' #{0} \'%\' --0,1 索引号
		and age > #{1}
</select>
```
*MyText.java*
```
@Test
public void testSelectStudentsByCondition2() {
	//参数直接对应 mapper.xml 中的索引号
	List<Student> students = dao.selectStudentsByCondition2("张",25);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


### 总结：#{} 中可以放什么内容？
1. 参数对象的属性
2. 随意内容，此时的#{}是个占位符
3. 参数为map时的key
4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入
5. 参数的索引号

### 动态 SQL
动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。

>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。
思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。

#### if 和 where
*IStudentDao.java*
```
List<Student> selectStudentsByWhere(Student student);
```
*mapper.xml*
```
<select id="selectStudentsByWhere" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<if test="name != null and name != \'\'">
			and name like \'%\' #{name} \'%\'
		</if>
		<if test="age > 0">
			and age > #{age}
		</if>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByWhere() {
	Student stu = new Student("张", 23, 0);	//指定两个条件
	// Student stu = new Student("", 23, 0);	//指定一个条件
	// Student stu = new Student("", 0, 0);	//不指定条件

	List<Student> students = dao.selectStudentsByWhere(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```

#### choose
**类似于 switch case ，且每个 case 都自带了 break.**

*IStudentDao.java*
```
List<Student> selectStudentsByChoose(Student student);
```
*mapper.xml*
```
<!-- 类似于 switch case ，且每个 case 都自带了 break -->
<select id="selectStudentsByChoose" resultType="Student">
	select id,name,age,score
	from student
	<where>
		<choose>
			<when test="name != null and name !=\'\'">
				and name like \'%\' #{name} \'%\'
			</when>
			<when test="age > 0">
				and age > #{age}
			</when>
			<otherwise>
				1 = 2
			</otherwise>
		</choose>
	</where>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByChoose() {
	// Student stu = new Student("张", 23, 0);
	// Student stu = new Student("", 23, 0);
	Student stu = new Student("", 0, 0);

	List<Student> students = dao.selectStudentsByChoose(stu);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历数组
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsByForeach(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为基本类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach2(List<Integer> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach2" resultType="Student">
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach2() {
	List<Integer> ids = new ArrayList<>();
	ids.add(1);
	ids.add(3);
	List<Student> students = dao.selectStudentsByForeach2(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <foreach/>标签--遍历泛型为自定义类型的 List
>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsByForeach3(List<Student> ids);
```
*mapper.xml*
```
<select id="selectStudentsByForeach3" resultType="Student">
    <!-- select id,name,age,score from student where id in (1,3,5) -->
    select id,name,age,score
    from student
    <if test="list.size > 0">
        where id in
        <foreach collection="list" item="stu" open="(" close=")" separator=",">
            #{stu.id}
        </foreach>
    </if>
</select>
```
*MyTest.java*
```
@Test
public void testSelectStudentsByForeach3() {
	Student stu1 = new Student();
	stu1.setId(1);
	Student stu2 = new Student();
	stu2.setId(3);
	List<Student> stus = new ArrayList<>();
	stus.add(stu1);
	stus.add(stu2);
	List<Student> students = dao.selectStudentsByForeach3(stus);
	for (Student student : students) {
		System.out.println(student);
	}
}
```
#### <sql/>标签
`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。

>需求：查询出 id 为 1 到 3 的学生信息

*IStudentDao.java*
```
List<Student> selectStudentsBySqlFragment(int[] ids);
```
*mapper.xml*
```
<select id="selectStudentsBySqlFragment" resultType="Student">
    select <include refid="selectColumns"/> -- sql 片段
    from student
    <if test="array.length > 0">
        where id in
        <foreach collection="array" item="myid" open="(" close=")" separator=",">
            #{myid}
        </foreach>
    </if>
</select>
<!-- sql 片段，可用于替换 sql 语句的任何部分 -->
<sql id="selectColumns">
    id,name,age,score
</sql>
```
*MyTest.java*
```
@Test
public void testSelectStudentsBySqlFragment() {
	int[] ids = {1, 3, 4};
	List<Student> students = dao.selectStudentsBySqlFragment(ids);
	for (Student student : students) {
		System.out.println(student);
	}
}
```


## 关联关系查询
### 一对多关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	// 关联属性
	private Set<Minister> ministers;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Minister> getMinisters() {
		return ministers;
	}
	public void setMinisters(Set<Minister> ministers) {
		this.ministers = ministers;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + ", ministers="
				+ ministers + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + "]";
	}
}
```

#### 多表连接查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<!--多表连接查询语句-->
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname,mid,mname
    from country,minister
    where countryId=cid and cname=#{cname}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->
    <collection property="ministers" ofType="Minister">
        <id column="mid" property="mid"/>
        <result column="mname" property="mname"/>
    </collection>
</resultMap>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```
#### 多表单独查询方式
*ICountryDao*
```
Country selectCountryByName(String cname);
```
*mapper.xml*
```
<select id="selectCountryByName" resultMap="countryMapper">
    select cid,cname from country where cname=#{xxx}
</select>
<resultMap type="Country" id="countryMapper">
    <id column="cid" property="cid"/>
    <result column="cname" property="cname"/>
    <collection property="ministers" 
                ofType="Minister"
                select="selectMinisterByCountry"
                column="cid"/>
</resultMap>
<select id="selectMinisterByCountry" resultType="Minister">
    select mid,mname from minister where countryId=#{ooo}
</select>
```
*MyTest.java*
```
@Test
public void testSelectCountryByName() {
	Country country = dao.selectCountryByName("China");
	System.out.println(country);
}
```


### 多对一关联查询
>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。
需求：根据国家名，查出对应的国家和部长信息

*Country.java*
```
public class Country {
	private Integer cid;
	private String cname;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	@Override
	public String toString() {
		return "Country [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Minister.java*
```
public class Minister {
	private Integer mid;
	private String mname;
	private Country country;	//关联属性

	public Integer getMid() {
		return mid;
	}
	public void setMid(Integer mid) {
		this.mid = mid;
	}
	public String getMname() {
		return mname;
	}
	public void setMname(String mname) {
		this.mname = mname;
	}
	public Country getCountry() { return country; }
	public void setCountry(Country country) { this.country = country; }

	@Override
	public String toString() {
		return "Minister [mid=" + mid + ", mname=" + mname + ", country=" + country + "]";
	}
}
```

#### 多表连接查询方式
*IMinisterDao*
```
Minister selectMinisterById(int mid);
```
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,cid,cname
    from minister, country
    where countryId=cid and mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country" javaType="Country">
        <id column="cid" property="cid"/>
        <result column="cname" property="cname"/>
    </association>
</resultMap>
```
*MyTest.java*
```
@Test
public void selectMinisterById() {
	Minister minister = dao.selectMinisterById(2);
	System.out.println(minister);
}
```
#### 多表单独查询方式
*mapper.xml*
```
<select id="selectMinisterById" resultMap="ministerMapper">
    select mid,mname,countryId from minister where mid=#{xxx}
</select>
<resultMap type="Minister" id="ministerMapper">
    <id column="mid" property="mid"/>
    <result column="mname" property="mname"/>
    <association property="country"
                 javaType="Country"
                 select="selectCountryById"
                 column="countryId"/>
</resultMap>
<select id="selectCountryById" resultType="Country">
    select cid,cname from country where cid=#{ooo}
</select>
```



### 自关联查询
类似于目录的递归。
#### 以一对多方式处理
*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private Set<NewsLabel> children;
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Set<NewsLabel> getChildren() {
		return children;
	}
	public void setChildren(Set<NewsLabel> children) {
		this.children = children;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", children="
				+ children + "]";
	}
}
```
##### 查询指定栏目的所有子孙栏目
*INewsLabelDao.java*
```
List<NewsLabel> selectChildrenByParent(int pid);
```
*mapper.xml*
```
<select id="selectChildrenByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children"
				ofType="NewsLabel"
				select="selectChildrenByParent"
				column="id"/>
</resultMap>
```
*MyTest.java*
```
@Test
public void test01() {
	List<NewsLabel> children = dao.selectChildrenByParent(2);
	for (NewsLabel newsLabel : children) {
		System.out.println(newsLabel);
	}
}
```
##### 查询指定栏目及其所有子孙栏目
*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```
*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name from newslabel where id=#{xxx}
</select>

<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<collection property="children" 
				ofType="NewsLabel"
				select="selectNewslabelByParent"
				column="id"/>
</resultMap>

<select id="selectNewslabelByParent" resultMap="newslabelMapper">
	select id,name from newslabel where pid=#{ooo}
</select>

```
*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(2);
	System.out.println(newslabel);
}
```
#### 以多对一方式处理
>需求：查询所有栏目及其父辈栏目

*NewsLabel.java*
```
/**
 * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目
 */
public class NewsLabel {
	private Integer id;
	private String name;  // 栏目名称
	private NewsLabel parent;   // 父栏目
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public NewsLabel getParent() {
		return parent;
	}
	public void setParent(NewsLabel parent) {
		this.parent = parent;
	}
	@Override
	public String toString() {
		return "NewsLabel [id=" + id + ", name=" + name + ", parent=" + parent
				+ "]";
	}
}
```

*INewsLabelDao.java*
```
NewsLabel selectNewsLabelById(int id);
```

*mapper.xml*
```
<select id="selectNewsLabelById" resultMap="newslabelMapper">
	select id,name,pid from newslabel where id=#{xxx}
</select>
<resultMap type="NewsLabel" id="newslabelMapper">
	<id column="id" property="id"/>
	<result column="name" property="name"/>
	<association property="parent" 
				 javaType="NewsLabel"
				 select="selectNewsLabelById"
				 column="pid"/>
</resultMap>
```

*MyTest.java*
```
@Test
public void test01() {
	NewsLabel newslabel = dao.selectNewsLabelById(7);
	System.out.println(newslabel);
}
```

### 多对多关联查询
一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。
>实体类

*Course.java*
```
public class Course {
	private Integer cid;
	private String cname;
	private Set<Student> students;
	public Integer getCid() {
		return cid;
	}
	public void setCid(Integer cid) {
		this.cid = cid;
	}
	public String getCname() {
		return cname;
	}
	public void setCname(String cname) {
		this.cname = cname;
	}
	public Set<Student> getStudents() {
		return students;
	}
	public void setStudents(Set<Student> students) {
		this.students = students;
	}
	@Override
	public String toString() {
		return "Course [cid=" + cid + ", cname=" + cname + "]";
	}
}
```
*Student.java*
```
public class Student {
	private Integer sid;
	private String sname;
	private Set<Course> courses;
	public Integer getSid() {
		return sid;
	}
	public void setSid(Integer sid) {
		this.sid = sid;
	}
	public String getSname() {
		return sname;
	}
	public void setSname(String sname) {
		this.sname = sname;
	}
	public Set<Course> getCourses() {
		return courses;
	}
	public void setCourses(Set<Course> courses) {
		this.courses = courses;
	}
	@Override
	public String toString() {
		return "Student [sid=" + sid + ", sname=" + sname + ", courses="
				+ courses + "]";
	}
}
```
>Dao

*IStudentDao.java*
```
Student selectStudentById(int sid);
```
*mapper.xml*
```
<select id="selectStudentById" resultMap="studentMapper">
	select sid,sname,cid,cname
	from student,middle,course
	where sid=studentId and cid=courseId and sid=#{xxx}
</select>
<resultMap type="Student" id="studentMapper">
	<id column="sid" property="sid"/>
	<result column="sname" property="sname"/>
	<collection property="courses" ofType="Course">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
	</collection>
</resultMap>
```
>Test

*MyTest.java*
```
@Test
public void test01() {
	Student student = dao.selectStudentById(1);
	System.out.println(student);
}
```

### 延迟加载
MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。

延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。

#### 关联对象加载时机
MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。

- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。
- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。

需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。

MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。

#### 延迟加载的总开关
**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。
多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**

*mybatis.xml*
```
<configuration>
    <properties resource="jdbc_mysql.properties"/>

    <!-- 设置整个应用所使用的常量 -->
    <settings>
        <!-- 延迟加载的总开关 -->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>

    <typeAliases>
		...
    </typeAliases>
</configuration>
```

#### 直接加载
*mybatis.xml*
```
<settings>
	<setting name="lazyLoadingEnabled" value="false"/>
</settings>
```
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 直接加载（√）：查询 country，查询 minister ---");
	System.out.println(country.getCname());
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 直接加载（√）：查询 country，查询 minister ---
China
Total：3
```

#### 侵入式延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 侵入式延迟加载 -->
    <setting name="aggressiveLazyLoading" value="true"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 侵入式延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 侵入式延迟加载（X）：查询 country ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
China
---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---
Total：3
```
#### 深度延迟加载
*mybatis.xml*
```
<!-- 设置整个应用所使用的常量 -->
<settings>
    <!-- 延迟加载的总开关 -->
    <setting name="lazyLoadingEnabled" value="true"/>
    <!-- 关闭侵入式延迟，则为深度延迟加载 -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println("---- 深度延迟加载（X）：查询 country ---");
	System.out.println(country.getCname());
	System.out.println("---- 深度延迟加载（X）：访问主加载对象 ---");
	Set<Minister> ministers = country.getMinisters();
	System.out.println("Total：" + ministers.size());
	System.out.println("---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---");
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
---- 深度延迟加载（X）：查询 country ---
China
---- 深度延迟加载（X）：访问主加载对象 ---
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]
[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? 
[DEBUG] ==> Parameters: 1(Integer)
Total：3
---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---
```
## 查询缓存
查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。

MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。

myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。

无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。

但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

### 一级查询缓存
MyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 

**myBatis 默认一级查询缓存是开启状态，且不能关闭。**

![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*

#### 一级查询缓存的存在性证明
*MyTest.java*
```
@Test
public void test01() {
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。
#### 从缓存读取数据的依据是 Sql 的 id
缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。

*MyTest.java*
```
@Test
public void test02() {
	//使用了不同的查询语句，查询相同的记录 id
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 增删改对一级查询缓存的影响
增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。

*MyTest.java*
```
@Test
public void test03() {
	Country country = dao.selectCountryById(2);
	System.out.println(country);

	// 增删改操作都会清空一级缓存，无论是否提交
	dao.insertCountry(new Country(3,"USA"));

	Country country2 = dao.selectCountryById(2);
	System.out.println(country2);
}
```
*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: 3(Integer), USA(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 2(Integer)
Country [cid=2, cname=England]
```

### 内置二级缓存
使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。

#### 开启内置的二级缓存步骤
1）对实体进行序列化
2）在映射文件中添加 `<cache/>` 标签

*Country.java - 实例化*
```
public class Country implements Serializable { }
```

*mybatis.xml - 添加 <cache/> 标签*
```
<mapper namespace="top.qingrang.sql_session_cache.dao.ICountryDao">
	<cache/>
</mapper>
```

*MyTest.java*
```
@Test
public void test01() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById(1);
	System.out.println(country);
	//关闭 sqlSession，一级缓存会刷新
	sqlSession.close();
	//二级缓存会伴随整个生命周期
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country2 = dao.selectCountryById(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=? 
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
Country [cid=1, cname=China]
```
#### 增删改对二级缓存的影响
1. 增删改同样也会清空二级缓存
2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除
3. 从 DB 中进行 select 查询的条件是：
1)缓存中根本就不存在这个 key
2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null

*MyTest.java*
```
@Test
public void test02() {
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	Country country = dao.selectCountryById2(2);
	System.out.println(country);
	sqlSession.close();
	sqlSession = MyBatisUtils.getSqlSession();
	dao = sqlSession.getMapper(ICountryDao.class);
	dao.insertCountry(new Country("Japan"));
	Country country2 = dao.selectCountryById2(1);
	System.out.println(country2);
}
```

*调试信息*
```
[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)
[DEBUG] ==> Parameters: null, Japan(String)

[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]
[DEBUG] ==>  Preparing: select cid,cname from country where cid=?
[DEBUG] ==> Parameters: 1(Integer)
Country [cid=1, cname=China]
```
#### 二级缓存的配置
为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。

`<cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/>`

- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：
- FIFO： First In First Out， 先进先出
- LRU： Least Recently Used，未被使用时间最长的
- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。
- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。
- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。

#### 二级缓存的关闭
二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。
##### 全局关闭
所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。
```
<settings>
    <setting name="cacheEnabled" value="false" />
</settings>
```
##### 局部关闭
整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。

`useCache="false"`

```
<select id="selectCountryById" useCache="false" resultType="Country">
		select cid,cname from country where cid=#{xxx}
	</select>
```

### ehcache 二级查询缓存
使用 ehcache 二级缓存，实体类无需实现序列化接口。

将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`

*pom.xml*
```
<!--ehcache 相关包 -->
<dependency>
  <groupId>net.sf.ehcache</groupId>
  <artifactId>ehcache</artifactId>
  <version>2.7.5</version>
</dependency>
<dependency>
  <groupId>org.mybatis.caches</groupId>
  <artifactId>mybatis-ehcache</artifactId>
  <version>1.1.0</version>
</dependency>
```

*mapper.xml*
```
<mapper namespace="com.bjpowernode.dao.IStudentDao">
	<cache type="org.mybatis.caches.ehcache.EhcacheCache">
		<property name="timeToIdleSeconds" value="60"/>
	</cache>
</mapper>
```



## 注解
mybatis 的注解，主要是用于替换映射文件。而映射文件中无非存放着增、删、改、查的 SQL 映射标签。所以， mybatis 注解，就是要替换映射文件中的 SQL 标签。mybatis 官方文档中指出，若要真正想发挥 mybatis 功能，还是要用映射文件。即 mybatis官方并不建议通过注解方式来使用 mybatis。

由于 MyBatis 注解替换的是映射文件，所以这里就不需要映射文件了，将其直接删除。由于没有了映射文件，所以主配置文件中不能使用 `<mapper/>` 注册 mapper 的位置了。需要使用`<package/>` 标签。

*mybatis.xml*
```
<mappers>
	<package name="com.bjpowernode.dao"/>
</mappers>

```

*IStudentDao.java*
```
public interface IStudentDao {
	@Insert(value={"insert into student(name,age,score) values(#{name}, #{age}, #{score})"})
	void insertStudent(Student student);
	
	@Insert("insert into student(name,age,score) values(#{name}, #{age}, #{score})")
	@SelectKey(statement="select @@identity", resultType=int.class, keyProperty="id", before=false)
	void insertStudentCacheId(Student student);
	
	@Delete(value="delete from student where id=#{xxx}")
	void deleteStudentById(int id);
	
	@Update("update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}")
	void updateStudent(Student student);
	
	@Select("select id,name,age,score from student")
	List<Student> selectAllStudents();
	
	@Select("select id,name,age,score from student where id=#{jjj}")
	Student selectStudentById(int id);
	
	@Select("select id,name,age,score from student where name like \'%\' #{xxx} \'%\'")
	List<Student> selectStudentsByName(String name);
}
```',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.002172s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001773s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000820s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000331s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001214s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000327s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000424s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=243,`p_id`=2,`title`='Mybatis\r',`content`='# Mybatis\r\n[TOC]\r\n## Mybatis 体系结构和工作原理\r\n![原理图](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/B5G3lA8d1A.png)*原理图*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-2.png)*Mybatis 体系结构*\r\n\r\n![mark](http://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-06-3.png)*Mybatis工作原理*\r\n## 第一个 MyBaits 程序\r\n### 主配置文件详解\r\n1. 注册数据库连接四要素属性文件\r\n`<properties resource=\"jdbc_mysql.properties\"/>`\r\n1. 定义类型别名\r\n```\r\n<typeAliases>\r\n	<!-- 将指定包中所有类的简单类名当作其别名 -->\r\n	<package name=\"top.qingrang.beans\"/>\r\n</typeAliases>\r\n```\r\n1. 配置运行环境\r\n```\r\n<environments default=\"XXX2\">\r\n	<!-- 环境，eg：上线环境 -->\r\n	<environment id=\"XXX1\">\r\n		<!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n		<transactionManager type=\"JDBC\"/>\r\n		<!-- 数据源，数据库连接池 -->\r\n		<dataSource type=\"POOLED\">\r\n			<!-- 数据库连接四要素 -->\r\n			<property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n			<property name=\"url\" value=\"${jdbc.url}\"/>\r\n			<property name=\"username\" value=\"${jdbc.user}\"/>\r\n			<property name=\"password\" value=\"${jdbc.password}\"/>\r\n		</dataSource>\r\n	</environment>\r\n\r\n	<!-- 另一个环境，eg：本地测试的环境 -->\r\n	<environment id=\"XXX2\">\r\n		...\r\n	</environment>\r\n</environments>\r\n```\r\n1. 注册映射文件\r\n```\r\n<mappers>\r\n	<!-- 配置文件路径 -->\r\n	<mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n>问题？\r\n\r\n1. environments 下为什么可以配置多个 environment？\r\n方便切换运行环境，只需要改变 `default` 即可\r\n1. 为什么要将「注册数据库连接四要素」抽取到单独的属性文件？\r\n如果使用了很多不同的数据库，在切换时，只需要修改 `<properties resource=\"jdbc_mysql.properties\"/>` 即可\r\n1. 什么是数据库连接池？\r\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。\r\n\r\n*mybatis.xml*\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 注册数据库连接四要素属性文件 -->\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 定义类型别名 -->\r\n    <typeAliases>\r\n        <!-- <typeAlias type=\"top.qingrang.beans.Student\" alias=\"Student\"/> -->\r\n        <!-- 将指定包中所有类的简单类名当作其别名 -->\r\n        <package name=\"top.qingrang.beans\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置运行环境，有多个 environment 是为了方便切换 -->\r\n    <environments default=\"onlineEM\">\r\n        <!-- 上线以后的环境 -->\r\n        <environment id=\"onlineEM\">\r\n            <!-- 事务管理器，使用 JDBC 的事务管理 -->\r\n            <transactionManager type=\"JDBC\"/>\r\n            <!-- 数据源，数据库连接池 -->\r\n            <dataSource type=\"POOLED\">\r\n                <!-- 数据库连接四要素 -->\r\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\r\n                <property name=\"url\" value=\"${jdbc.url}\"/>\r\n                <property name=\"username\" value=\"${jdbc.user}\"/>\r\n                <property name=\"password\" value=\"${jdbc.password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n        <!-- 本地测试的环境 -->\r\n        <environment id=\"testEM\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3366/test\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"111\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <!-- 注册映射文件 -->\r\n    <mappers>\r\n        <!-- 配置文件路径 -->\r\n        <mapper resource=\"top/qingrang/dao/mapper.xml\"/>\r\n    </mappers>\r\n\r\n</configuration>\r\n```\r\n### 核心代码\r\n利用 sqlSession 对象，执行相关操作。\r\n```\r\nprivate SqlSession sqlSession;\r\n\r\n@Override\r\npublic void insertStu(Student student) {\r\n	try {\r\n		// 1.加载主配置文件\r\n		InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n		// 2.创建 SqlSessionFactory 对象\r\n		SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n		// 3.创建 sqlSession 对象\r\n		sqlSession = sqlSessionFactory.openSession();\r\n		// 4.执行相关操作\r\n		sqlSession.insert(\"insertStudent\", student);\r\n		// 5.提交\r\n		sqlSession.commit();\r\n	} catch (IOException e) {\r\n		e.printStackTrace();\r\n	} finally {\r\n		if(sqlSession != null) {\r\n			// 6.关闭\r\n			sqlSession.close();\r\n		}\r\n	}\r\n}\r\n```\r\n### 封装 MyBatis 工具类\r\n*MyBatisUtils.java*\r\n```\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * MyBatis 工具类\r\n */\r\npublic class MyBatisUtils {\r\n\r\n	private static SqlSessionFactory sqlSessionFactory;\r\n\r\n	/**\r\n	 * 得到 SqlSession 对象\r\n	 */\r\n	public static SqlSession getSqlSession() {\r\n		try {\r\n			// 1.加载主配置文件\r\n			InputStream is = Resources.getResourceAsStream(\"mybatis.xml\");\r\n			if (sqlSessionFactory == null) {\r\n				// 2.创建 SqlSessionFactory 对象\r\n				sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n			}\r\n			// 3.返回 SqlSession 对象\r\n			return sqlSessionFactory.openSession();\r\n		} catch (IOException e) {\r\n			e.printStackTrace();\r\n		}\r\n		return null;\r\n	}\r\n}\r\n```\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n}\r\n```\r\n### 源码分析\r\n#### 输入流的关闭\r\n在输入流对象使用完毕后，不用手工进行流的关闭。因为在输入流被使用完毕后， SqlSessionFactoryBuilder 对象的 build() 方法会自动将输入流关闭。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-42-16.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的创建\r\nSqlSession 对象的创建，需要使用 SqlSessionFactory 接口对象的 openSession()方法。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-51-58.png)*MyBaits 源码*\r\n\r\n从以上源码可以看到，无参的 openSession()方法，将事务的自动提交直接赋值为 false。而所谓创建 SqlSession，就是加载了主配置文件，创建了一个执行器对象（将来用于执行映射文件中的 SQL 语句），初始化了一个 DB 数据被修改的标志变量 dirty，关闭了事务的自动提交功能。\r\n\r\n>dirty 详解\r\n\r\ntrue：和数据库中的数据不一致(脏)\r\nfalse：和数据库中的数据一致(不脏)\r\n\r\n#### 增删改的执行\r\n对于 SqlSession 的 insert()、 delete()、 update()方法，其底层均是调用执行了 update()方法。\r\n\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-10-56-49.png)*MyBaits 源码*\r\n\r\n从以上源码可知，无论执行增、删还是改，均是对数据进行修改，均将 dirty 变量设置为了 true，且在获取到映射文件中指定 id 的 SQL 语句后，由执行器 executor 执行。\r\n\r\n#### SqlSession 的提交 commit()\r\n执行 SqlSession 的无参 commit()方法，最终会将事务进行提交。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-05-09.png)*MyBaits 源码*\r\n\r\n#### SqlSession 的关闭\r\n在 SqlSession 进行关闭时，会将事务回滚后关闭。所以，对于 MyBatis 程序，无需通过显式地对 SqlSession 进行回滚，达到事务回滚的目的。\r\n![MyBaits 源码](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-09-11-12-30.png)*MyBaits 源码*\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 单表的 CURD 操作\r\n### 常用的增删改查\r\n*mapper.xml*\r\n```\r\n<!-- parameterType 可以省略 -->\r\n<insert id=\"insertStudent\" parameterType=\"Student\">\r\n	<!-- 这里的 #{} 是属性 -->\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<!-- 插入后用新 id 初始化被插入对象 -->\r\n<insert id=\"insertStudentCacheId\">\r\n	insert into student(name,age,score) values(#{name}, #{age}, #{score})\r\n	<selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\">\r\n		select @@identity\r\n	</selectKey>\r\n</insert>\r\n\r\n<delete id=\"deleteStudentById\">\r\n	<!-- 这里的#{}仅仅是个占位符，里面放什么都可以 -->\r\n	DELETE FROM student WHERE id = #{id}\r\n</delete>\r\n\r\n<update id=\"updateStudent\">\r\n	update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\r\n</update>\r\n\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n\r\n<!-- 模糊查询 -->\r\n<select id=\"selectStudentsByName\" resultType=\"Student\">\r\n	select id,name,age,score from student where name like \'%\'#{xxx}\'%\'\r\n	<!-- select id,name,age,score from student where name like concat(\'%\', #{xxx}, \'%\') -->\r\n	<!-- $ 与 # 的区别，# 为占位符，$ 为字符串拼接符(存在 SQL 注入问题) -->\r\n	<!-- select id,name,age,score from student where name like \'%${value}%\' -->\r\n</select>\r\n```\r\n\r\n*StudentDaoImpl.java*\r\n```\r\npublic class StudentDaoImpl implements IStudentDao {\r\n	private SqlSession sqlSession;\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		try {\r\n			// 创建 SqlSession 对象\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			// 执行相关操作\r\n			sqlSession.insert(\"insertStudent\", student);\r\n			// 提交\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void insertStudentCacheId(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.insert(\"insertStudentCacheId\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void deleteStudentById(int id) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.delete(\"deleteStudentById\", id);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			sqlSession.update(\"updateStudent\", student);\r\n			sqlSession.commit();\r\n		}finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectAllStudents\");\r\n			//查询不需要 sqlSession.commit();\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n\r\n	@Override\r\n	public Map<String, Object> selectAllStudentsMap() {\r\n		Map<String, Object> map = new HashMap<>();\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			map = sqlSession.selectMap(\"selectAllStudents\", \"name\");\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return map;\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		Student student = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			student = sqlSession.selectOne(\"selectStudentById\", id);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return student;\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectStudentsByName(String name) {\r\n		List<Student> students = null;\r\n		try {\r\n			sqlSession = MyBatisUtils.getSqlSession();\r\n			students = sqlSession.selectList(\"selectStudentsByName\", name);\r\n		} finally {\r\n			if(sqlSession != null) {\r\n				sqlSession.close();\r\n			}\r\n		}\r\n		return students;\r\n	}\r\n}\r\n```\r\n\r\n### 属性名与查询字段名不相同\r\n若数据表中的字段为 `tid`,`tname`，而实体类中的属性为 `id`，`name`，进行以下的操作则不会成功。\r\n```\r\n<!-- resultType=\"Student\"，封装成 Student 类 -->\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select id,name,age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select id,name,age,score from student where id=#{xxx}\r\n</select>\r\n```\r\n#### 解决方案一：查询字段使用别名\r\n```\r\n<insert id=\"insertStudent\">\r\n	insert into student(tname,tage,score) values(#{name}, #{age}, #{score})\r\n</insert>\r\n\r\n<select id=\"selectAllStudents\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultType=\"Student\">\r\n	select tid id,tname name,tage age,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n#### 解决方案二：使用结果映射 resultMap\r\n```\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"tid\" property=\"id\"/>\r\n	<result column=\"tname\" property=\"name\"/>\r\n 	<result column=\"tage\" property=\"age\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectAllStudents\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student\r\n</select>\r\n\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select tid,tname,tage,score from student where tid=#{jjj}\r\n</select>\r\n```\r\n### Mapper 动态代理\r\n#### 修改映射文件的 namespace 属性值\r\n`<mapper namespace=\"top.qingrang.dao.IStudentDao\">`\r\n通过接口名即可定位到映射文件 mapper.\r\n#### 删除 IStudentDaoImpl 实现类\r\n#### 修改 MyText.java 测试方法\r\n*MyTex.java*\r\n```\r\npublic class MyTest {\r\n	private IStudentDao dao;\r\n	private SqlSession sqlSession;\r\n\r\n	@Before\r\n	public void before() {\r\n		sqlSession = MyBatisUtils.getSqlSession();\r\n		//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n		dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n	}\r\n\r\n	@After\r\n	public void after() {\r\n		if(sqlSession != null) {\r\n			sqlSession.close();\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudent() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudent(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testInsertStudentCacheId() {\r\n		Student student = new Student(\"张三\", 23, 93.5);\r\n		System.out.println(\"插入前：student = \" + student);\r\n		dao.insertStudentCacheId(student);\r\n		sqlSession.commit();\r\n		System.out.println(\"插入后：student = \" + student);\r\n	}\r\n\r\n	@Test\r\n	public void testDeleteStudentById() {\r\n		dao.deleteStudentById(12);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testUpdateStudent() {\r\n		Student student = new Student(\"张三\", 25, 93.5);\r\n		student.setId(15);\r\n		dao.updateStudent(student);\r\n		sqlSession.commit();\r\n	}\r\n\r\n	@Test\r\n	public void testSelectAllStudents() {\r\n		List<Student> students = dao.selectAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentById() {\r\n		Student student = dao.selectStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n\r\n	@Test\r\n	public void testSelectStudentsByName() {\r\n		List<Student> students = dao.selectStudentsByName(\"张\");\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n}\r\n```\r\n##### Dao 对象的获取\r\n```\r\nprivate IStudentDao dao;\r\nprivate SqlSession sqlSession;\r\n\r\n@Before\r\npublic void before() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	//调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。\r\n	dao = sqlSession.getMapper(IStudentDao.class);//该方法的参数为指定 Dao 接口类的 class 值。\r\n}\r\n```\r\n##### sqlSession 的关闭\r\n```\r\n@After\r\npublic void after() {\r\n	if(sqlSession != null) {\r\n		sqlSession.close();\r\n	}\r\n}\r\n```\r\n##### sqlSession 的提交\r\n```\r\n@Test\r\npublic void testDeleteStudentById() {\r\n	dao.deleteStudentById(12);\r\n	sqlSession.commit();\r\n}\r\n```\r\n\r\n\r\n### 多条件查询\r\n#### 根据 Map 查询\r\n>需求：找出姓张的，年龄大于 23 的，且比田七分数的高的学生\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition(Map<String, Object> map);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 多条件查询 -->\r\n<select id=\"selectStudentsByCondition\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{nameCon} \'%\' -- 模糊查询\r\n		and age > #{ageCon}\r\n		and score > #{stu.score}  -- 对象.属性\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition() {\r\n	Student stu = new Student(\"田七\", 27, 95);\r\n\r\n	Map<String, Object> map = new HashMap<String, Object>();\r\n	map.put(\"nameCon\", \"张\");\r\n	map.put(\"ageCon\", 23);\r\n	map.put(\"stu\", stu);	//放入了学生对象\r\n\r\n	List<Student> students = dao.selectStudentsByCondition(map);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### 使用索引号\r\n>需求：找出姓张的，年龄大于 25 的\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByCondition2(String name,int age);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 使用索引号 -->\r\n<select id=\"selectStudentsByCondition2\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	where name like \'%\' #{0} \'%\' --0,1 索引号\r\n		and age > #{1}\r\n</select>\r\n```\r\n*MyText.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByCondition2() {\r\n	//参数直接对应 mapper.xml 中的索引号\r\n	List<Student> students = dao.selectStudentsByCondition2(\"张\",25);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n### 总结：#{} 中可以放什么内容？\r\n1. 参数对象的属性\r\n2. 随意内容，此时的#{}是个占位符\r\n3. 参数为map时的key\r\n4. 参数为map时，若key所对应的value为对象，则可将该对象的属性放入\r\n5. 参数的索引号\r\n\r\n### 动态 SQL\r\n动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。\r\n\r\n>需求：查询出满足用户提交查询条件的所有学生。用户提交的查询条件可以包含一个姓名的模糊查询，同时还可以包含一个年龄的下限。当然，用户在提交表单时可能两个条件均做出了设定，也可能两个条件均不做设定，也可以只做其中一项设定。\r\n思路：查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。\r\n\r\n#### if 和 where\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByWhere(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByWhere\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<if test=\"name != null and name != \'\'\">\r\n			and name like \'%\' #{name} \'%\'\r\n		</if>\r\n		<if test=\"age > 0\">\r\n			and age > #{age}\r\n		</if>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByWhere() {\r\n	Student stu = new Student(\"张\", 23, 0);	//指定两个条件\r\n	// Student stu = new Student(\"\", 23, 0);	//指定一个条件\r\n	// Student stu = new Student(\"\", 0, 0);	//不指定条件\r\n\r\n	List<Student> students = dao.selectStudentsByWhere(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n#### choose\r\n**类似于 switch case ，且每个 case 都自带了 break.**\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByChoose(Student student);\r\n```\r\n*mapper.xml*\r\n```\r\n<!-- 类似于 switch case ，且每个 case 都自带了 break -->\r\n<select id=\"selectStudentsByChoose\" resultType=\"Student\">\r\n	select id,name,age,score\r\n	from student\r\n	<where>\r\n		<choose>\r\n			<when test=\"name != null and name !=\'\'\">\r\n				and name like \'%\' #{name} \'%\'\r\n			</when>\r\n			<when test=\"age > 0\">\r\n				and age > #{age}\r\n			</when>\r\n			<otherwise>\r\n				1 = 2\r\n			</otherwise>\r\n		</choose>\r\n	</where>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByChoose() {\r\n	// Student stu = new Student(\"张\", 23, 0);\r\n	// Student stu = new Student(\"\", 23, 0);\r\n	Student stu = new Student(\"\", 0, 0);\r\n\r\n	List<Student> students = dao.selectStudentsByChoose(stu);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历数组\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsByForeach(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为基本类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach2(List<Integer> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach2\" resultType=\"Student\">\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach2() {\r\n	List<Integer> ids = new ArrayList<>();\r\n	ids.add(1);\r\n	ids.add(3);\r\n	List<Student> students = dao.selectStudentsByForeach2(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <foreach/>标签--遍历泛型为自定义类型的 List\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsByForeach3(List<Student> ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsByForeach3\" resultType=\"Student\">\r\n    <!-- select id,name,age,score from student where id in (1,3,5) -->\r\n    select id,name,age,score\r\n    from student\r\n    <if test=\"list.size > 0\">\r\n        where id in\r\n        <foreach collection=\"list\" item=\"stu\" open=\"(\" close=\")\" separator=\",\">\r\n            #{stu.id}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsByForeach3() {\r\n	Student stu1 = new Student();\r\n	stu1.setId(1);\r\n	Student stu2 = new Student();\r\n	stu2.setId(3);\r\n	List<Student> stus = new ArrayList<>();\r\n	stus.add(stu1);\r\n	stus.add(stu2);\r\n	List<Student> students = dao.selectStudentsByForeach3(stus);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n#### <sql/>标签\r\n`<sql/>`标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 `<include/>` 子标签。 该 `<sql/>` 标签可以定义 SQL 语句中的任何部分，所以 `<include/>` 子标签可以放在动态 SQL 的任何位置。\r\n\r\n>需求：查询出 id 为 1 到 3 的学生信息\r\n\r\n*IStudentDao.java*\r\n```\r\nList<Student> selectStudentsBySqlFragment(int[] ids);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentsBySqlFragment\" resultType=\"Student\">\r\n    select <include refid=\"selectColumns\"/> -- sql 片段\r\n    from student\r\n    <if test=\"array.length > 0\">\r\n        where id in\r\n        <foreach collection=\"array\" item=\"myid\" open=\"(\" close=\")\" separator=\",\">\r\n            #{myid}\r\n        </foreach>\r\n    </if>\r\n</select>\r\n<!-- sql 片段，可用于替换 sql 语句的任何部分 -->\r\n<sql id=\"selectColumns\">\r\n    id,name,age,score\r\n</sql>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectStudentsBySqlFragment() {\r\n	int[] ids = {1, 3, 4};\r\n	List<Student> students = dao.selectStudentsBySqlFragment(ids);\r\n	for (Student student : students) {\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n\r\n\r\n## 关联关系查询\r\n### 一对多关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	// 关联属性\r\n	private Set<Minister> ministers;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Minister> getMinisters() {\r\n		return ministers;\r\n	}\r\n	public void setMinisters(Set<Minister> ministers) {\r\n		this.ministers = ministers;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \", ministers=\"\r\n				+ ministers + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<!--多表连接查询语句-->\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname,mid,mname\r\n    from country,minister\r\n    where countryId=cid and cname=#{cname}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <!--关联属性的映射关系，对应 ministers 集合 ，封装成 Minister 类-->\r\n    <collection property=\"ministers\" ofType=\"Minister\">\r\n        <id column=\"mid\" property=\"mid\"/>\r\n        <result column=\"mname\" property=\"mname\"/>\r\n    </collection>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*ICountryDao*\r\n```\r\nCountry selectCountryByName(String cname);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectCountryByName\" resultMap=\"countryMapper\">\r\n    select cid,cname from country where cname=#{xxx}\r\n</select>\r\n<resultMap type=\"Country\" id=\"countryMapper\">\r\n    <id column=\"cid\" property=\"cid\"/>\r\n    <result column=\"cname\" property=\"cname\"/>\r\n    <collection property=\"ministers\" \r\n                ofType=\"Minister\"\r\n                select=\"selectMinisterByCountry\"\r\n                column=\"cid\"/>\r\n</resultMap>\r\n<select id=\"selectMinisterByCountry\" resultType=\"Minister\">\r\n    select mid,mname from minister where countryId=#{ooo}\r\n</select>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void testSelectCountryByName() {\r\n	Country country = dao.selectCountryByName(\"China\");\r\n	System.out.println(country);\r\n}\r\n```\r\n\r\n\r\n### 多对一关联查询\r\n>数据库：现有两张表，[country 国家：含有 cid, cname]，[minister 部长：含有 mid，mname，countryId]，一个国家可以有多位部长，一个部长对应一个国家。\r\n需求：根据国家名，查出对应的国家和部长信息\r\n\r\n*Country.java*\r\n```\r\npublic class Country {\r\n	private Integer cid;\r\n	private String cname;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Country [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Minister.java*\r\n```\r\npublic class Minister {\r\n	private Integer mid;\r\n	private String mname;\r\n	private Country country;	//关联属性\r\n\r\n	public Integer getMid() {\r\n		return mid;\r\n	}\r\n	public void setMid(Integer mid) {\r\n		this.mid = mid;\r\n	}\r\n	public String getMname() {\r\n		return mname;\r\n	}\r\n	public void setMname(String mname) {\r\n		this.mname = mname;\r\n	}\r\n	public Country getCountry() { return country; }\r\n	public void setCountry(Country country) { this.country = country; }\r\n\r\n	@Override\r\n	public String toString() {\r\n		return \"Minister [mid=\" + mid + \", mname=\" + mname + \", country=\" + country + \"]\";\r\n	}\r\n}\r\n```\r\n\r\n#### 多表连接查询方式\r\n*IMinisterDao*\r\n```\r\nMinister selectMinisterById(int mid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,cid,cname\r\n    from minister, country\r\n    where countryId=cid and mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\" javaType=\"Country\">\r\n        <id column=\"cid\" property=\"cid\"/>\r\n        <result column=\"cname\" property=\"cname\"/>\r\n    </association>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void selectMinisterById() {\r\n	Minister minister = dao.selectMinisterById(2);\r\n	System.out.println(minister);\r\n}\r\n```\r\n#### 多表单独查询方式\r\n*mapper.xml*\r\n```\r\n<select id=\"selectMinisterById\" resultMap=\"ministerMapper\">\r\n    select mid,mname,countryId from minister where mid=#{xxx}\r\n</select>\r\n<resultMap type=\"Minister\" id=\"ministerMapper\">\r\n    <id column=\"mid\" property=\"mid\"/>\r\n    <result column=\"mname\" property=\"mname\"/>\r\n    <association property=\"country\"\r\n                 javaType=\"Country\"\r\n                 select=\"selectCountryById\"\r\n                 column=\"countryId\"/>\r\n</resultMap>\r\n<select id=\"selectCountryById\" resultType=\"Country\">\r\n    select cid,cname from country where cid=#{ooo}\r\n</select>\r\n```\r\n\r\n\r\n\r\n### 自关联查询\r\n类似于目录的递归。\r\n#### 以一对多方式处理\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是一方，即父栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private Set<NewsLabel> children;\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public Set<NewsLabel> getChildren() {\r\n		return children;\r\n	}\r\n	public void setChildren(Set<NewsLabel> children) {\r\n		this.children = children;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", children=\"\r\n				+ children + \"]\";\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目的所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nList<NewsLabel> selectChildrenByParent(int pid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectChildrenByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\"\r\n				ofType=\"NewsLabel\"\r\n				select=\"selectChildrenByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	List<NewsLabel> children = dao.selectChildrenByParent(2);\r\n	for (NewsLabel newsLabel : children) {\r\n		System.out.println(newsLabel);\r\n	}\r\n}\r\n```\r\n##### 查询指定栏目及其所有子孙栏目\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where id=#{xxx}\r\n</select>\r\n\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<collection property=\"children\" \r\n				ofType=\"NewsLabel\"\r\n				select=\"selectNewslabelByParent\"\r\n				column=\"id\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectNewslabelByParent\" resultMap=\"newslabelMapper\">\r\n	select id,name from newslabel where pid=#{ooo}\r\n</select>\r\n\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(2);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n#### 以多对一方式处理\r\n>需求：查询所有栏目及其父辈栏目\r\n\r\n*NewsLabel.java*\r\n```\r\n/**\r\n * 新闻栏目：当前的新闻栏目被看作是多方，即子栏目\r\n */\r\npublic class NewsLabel {\r\n	private Integer id;\r\n	private String name;  // 栏目名称\r\n	private NewsLabel parent;   // 父栏目\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public NewsLabel getParent() {\r\n		return parent;\r\n	}\r\n	public void setParent(NewsLabel parent) {\r\n		this.parent = parent;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"NewsLabel [id=\" + id + \", name=\" + name + \", parent=\" + parent\r\n				+ \"]\";\r\n	}\r\n}\r\n```\r\n\r\n*INewsLabelDao.java*\r\n```\r\nNewsLabel selectNewsLabelById(int id);\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<select id=\"selectNewsLabelById\" resultMap=\"newslabelMapper\">\r\n	select id,name,pid from newslabel where id=#{xxx}\r\n</select>\r\n<resultMap type=\"NewsLabel\" id=\"newslabelMapper\">\r\n	<id column=\"id\" property=\"id\"/>\r\n	<result column=\"name\" property=\"name\"/>\r\n	<association property=\"parent\" \r\n				 javaType=\"NewsLabel\"\r\n				 select=\"selectNewsLabelById\"\r\n				 column=\"pid\"/>\r\n</resultMap>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	NewsLabel newslabel = dao.selectNewsLabelById(7);\r\n	System.out.println(newslabel);\r\n}\r\n```\r\n\r\n### 多对多关联查询\r\n一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个**中间表**来建立， 例如选课表。\r\n>实体类\r\n\r\n*Course.java*\r\n```\r\npublic class Course {\r\n	private Integer cid;\r\n	private String cname;\r\n	private Set<Student> students;\r\n	public Integer getCid() {\r\n		return cid;\r\n	}\r\n	public void setCid(Integer cid) {\r\n		this.cid = cid;\r\n	}\r\n	public String getCname() {\r\n		return cname;\r\n	}\r\n	public void setCname(String cname) {\r\n		this.cname = cname;\r\n	}\r\n	public Set<Student> getStudents() {\r\n		return students;\r\n	}\r\n	public void setStudents(Set<Student> students) {\r\n		this.students = students;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Course [cid=\" + cid + \", cname=\" + cname + \"]\";\r\n	}\r\n}\r\n```\r\n*Student.java*\r\n```\r\npublic class Student {\r\n	private Integer sid;\r\n	private String sname;\r\n	private Set<Course> courses;\r\n	public Integer getSid() {\r\n		return sid;\r\n	}\r\n	public void setSid(Integer sid) {\r\n		this.sid = sid;\r\n	}\r\n	public String getSname() {\r\n		return sname;\r\n	}\r\n	public void setSname(String sname) {\r\n		this.sname = sname;\r\n	}\r\n	public Set<Course> getCourses() {\r\n		return courses;\r\n	}\r\n	public void setCourses(Set<Course> courses) {\r\n		this.courses = courses;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [sid=\" + sid + \", sname=\" + sname + \", courses=\"\r\n				+ courses + \"]\";\r\n	}\r\n}\r\n```\r\n>Dao\r\n\r\n*IStudentDao.java*\r\n```\r\nStudent selectStudentById(int sid);\r\n```\r\n*mapper.xml*\r\n```\r\n<select id=\"selectStudentById\" resultMap=\"studentMapper\">\r\n	select sid,sname,cid,cname\r\n	from student,middle,course\r\n	where sid=studentId and cid=courseId and sid=#{xxx}\r\n</select>\r\n<resultMap type=\"Student\" id=\"studentMapper\">\r\n	<id column=\"sid\" property=\"sid\"/>\r\n	<result column=\"sname\" property=\"sname\"/>\r\n	<collection property=\"courses\" ofType=\"Course\">\r\n		<id column=\"cid\" property=\"cid\"/>\r\n		<result column=\"cname\" property=\"cname\"/>\r\n	</collection>\r\n</resultMap>\r\n```\r\n>Test\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Student student = dao.selectStudentById(1);\r\n	System.out.println(student);\r\n}\r\n```\r\n\r\n### 延迟加载\r\nMyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。\r\n\r\n延迟加载可以有效的减少数据库压力。需要注意的是， MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。\r\n\r\n#### 关联对象加载时机\r\nMyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**。\r\n\r\n- 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。\r\n- 侵入式延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。\r\n- 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。\r\n\r\n需要注意的是， 延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。\r\n\r\nMyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。\r\n\r\n#### 延迟加载的总开关\r\n**延迟加载默认关闭，当打开延迟加载后，默认为侵入式延迟加载。\r\n多表连接查询无法使用延迟加载，只有多表单独查询才可以使用延迟加载。**\r\n\r\n*mybatis.xml*\r\n```\r\n<configuration>\r\n    <properties resource=\"jdbc_mysql.properties\"/>\r\n\r\n    <!-- 设置整个应用所使用的常量 -->\r\n    <settings>\r\n        <!-- 延迟加载的总开关 -->\r\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    </settings>\r\n\r\n    <typeAliases>\r\n		...\r\n    </typeAliases>\r\n</configuration>\r\n```\r\n\r\n#### 直接加载\r\n*mybatis.xml*\r\n```\r\n<settings>\r\n	<setting name=\"lazyLoadingEnabled\" value=\"false\"/>\r\n</settings>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 直接加载（√）：查询 country，查询 minister ---\");\r\n	System.out.println(country.getCname());\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@4c762604]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 直接加载（√）：查询 country，查询 minister ---\r\nChina\r\nTotal：3\r\n```\r\n\r\n#### 侵入式延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 侵入式延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 侵入式延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 侵入式延迟加载（X）：查询 country ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nChina\r\n---- 侵入式延迟加载（√）：访问主加载对象，查询 minister ---\r\nTotal：3\r\n```\r\n#### 深度延迟加载\r\n*mybatis.xml*\r\n```\r\n<!-- 设置整个应用所使用的常量 -->\r\n<settings>\r\n    <!-- 延迟加载的总开关 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n    <!-- 关闭侵入式延迟，则为深度延迟加载 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n</settings>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(\"---- 深度延迟加载（X）：查询 country ---\");\r\n	System.out.println(country.getCname());\r\n	System.out.println(\"---- 深度延迟加载（X）：访问主加载对象 ---\");\r\n	Set<Minister> ministers = country.getMinisters();\r\n	System.out.println(\"Total：\" + ministers.size());\r\n	System.out.println(\"---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\");\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\n---- 深度延迟加载（X）：查询 country ---\r\nChina\r\n---- 深度延迟加载（X）：访问主加载对象 ---\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@28c4711c]\r\n[DEBUG] ==>  Preparing: select mid,mname from minister where countryId=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nTotal：3\r\n---- 深度延迟加载（√）：真正访问关联对象，查询 minister ---\r\n```\r\n## 查询缓存\r\n查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。\r\n\r\nMyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。\r\n\r\nmyBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper查询数据存放在同一个缓存区域。不同 namespace下的数据互不干扰。\r\n\r\n无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。\r\n\r\n但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n\r\n### 一级查询缓存\r\nMyBatis 一级查询缓存是基于 `org.apache.ibatis.cache.impl.PerpetualCache` 类的 HashMap 本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 \r\n\r\n**myBatis 默认一级查询缓存是开启状态，且不能关闭。**\r\n\r\n![执行原理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-10-21-35-09.png)*执行原理*\r\n\r\n#### 一级查询缓存的存在性证明\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	Country country2 = dao.selectCountryById(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\nCountry [cid=1, cname=China]\r\n```\r\n只执行了一次从 DB 中的查询，第二次的结果是直接输出的。说明，第二次是从 SqlSession 缓存中读取的。\r\n#### 从缓存读取数据的依据是 Sql 的 id\r\n缓存的底层实现是一个 Map，Map 的 value 是查询结果。Map 的 key，即查询依据，使用的ORM 构架不同，查询依据是不同的。MyBatis 的查询依据是：Sql 的 id + SQL 语句。\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test02() {\r\n	//使用了不同的查询语句，查询相同的记录 id\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	\r\n	Country country2 = dao.selectCountryById2(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 增删改对一级查询缓存的影响\r\n增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test03() {\r\n	Country country = dao.selectCountryById(2);\r\n	System.out.println(country);\r\n\r\n	// 增删改操作都会清空一级缓存，无论是否提交\r\n	dao.insertCountry(new Country(3,\"USA\"));\r\n\r\n	Country country2 = dao.selectCountryById(2);\r\n	System.out.println(country2);\r\n}\r\n```\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 2(Integer)\r\nCountry [cid=2, cname=England]\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\r\n[DEBUG] ==> Parameters: 3(Integer), USA(String)\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@481a15ff]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 2(Integer)\r\nCountry [cid=2, cname=England]\r\n```\r\n\r\n### 内置二级缓存\r\n使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以，二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享)，而是为了延长该查询结果的保存时间，提高系统性能。\r\n\r\n#### 开启内置的二级缓存步骤\r\n1）对实体进行序列化\r\n2）在映射文件中添加 `<cache/>` 标签\r\n\r\n*Country.java - 实例化*\r\n```\r\npublic class Country implements Serializable { }\r\n```\r\n\r\n*mybatis.xml - 添加 <cache/> 标签*\r\n```\r\n<mapper namespace=\"top.qingrang.sql_session_cache.dao.ICountryDao\">\r\n	<cache/>\r\n</mapper>\r\n```\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country = dao.selectCountryById(1);\r\n	System.out.println(country);\r\n	//关闭 sqlSession，一级缓存会刷新\r\n	sqlSession.close();\r\n	//二级缓存会伴随整个生命周期\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country2 = dao.selectCountryById(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=? \r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 增删改对二级缓存的影响\r\n1. 增删改同样也会清空二级缓存\r\n2. 对于二级缓存的清空，实质上是对所查找 key 对应的 value 置为 null，而并非将 `<key，value>` 对，即 Entry 对象删除\r\n3. 从 DB 中进行 select 查询的条件是：\r\n1)缓存中根本就不存在这个 key\r\n2)缓存中存在该 key 所对应的 Entry 对象，但其 value 为 null\r\n\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test02() {\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	Country country = dao.selectCountryById2(2);\r\n	System.out.println(country);\r\n	sqlSession.close();\r\n	sqlSession = MyBatisUtils.getSqlSession();\r\n	dao = sqlSession.getMapper(ICountryDao.class);\r\n	dao.insertCountry(new Country(\"Japan\"));\r\n	Country country2 = dao.selectCountryById2(1);\r\n	System.out.println(country2);\r\n}\r\n```\r\n\r\n*调试信息*\r\n```\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: insert into country(cid,cname) values(?, ?)\r\n[DEBUG] ==> Parameters: null, Japan(String)\r\n\r\n[DEBUG] ooo Using Connection [com.mysql.jdbc.JDBC4Connection@2f0a87b3]\r\n[DEBUG] ==>  Preparing: select cid,cname from country where cid=?\r\n[DEBUG] ==> Parameters: 1(Integer)\r\nCountry [cid=1, cname=China]\r\n```\r\n#### 二级缓存的配置\r\n为 `<cache/>` 标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。当然，若不指定设置，则均保持默认值。\r\n\r\n`<cache eviction=\"FIFO\" flushInterval=\"10800000\" readOnly=\"true\" size=\"512\"/>`\r\n\r\n- eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有：\r\n- FIFO： First In First Out， 先进先出\r\n- LRU： Least Recently Used，未被使用时间最长的\r\n- flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。\r\n- readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。\r\n- size：二级缓存中可以存放的最多对象个数。默认为 1024 个。\r\n\r\n#### 二级缓存的关闭\r\n二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。\r\n##### 全局关闭\r\n所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。\r\n```\r\n<settings>\r\n    <setting name=\"cacheEnabled\" value=\"false\" />\r\n</settings>\r\n```\r\n##### 局部关闭\r\n整个应用的二级缓存是开启的，但只是针对于某个 `<select/>` 查询，不使用二级缓存。\r\n\r\n`useCache=\"false\"`\r\n\r\n```\r\n<select id=\"selectCountryById\" useCache=\"false\" resultType=\"Country\">\r\n		select cid,cname from country where cid=#{xxx}\r\n	</select>\r\n```\r\n\r\n### ehcache 二级查询缓存\r\n使用 ehcache 二级缓存，实体类无需实现序列化接口。\r\n\r\n将其中的一个配置文件 `ehcache-failsafe.xml` 直接放到项目的 src 目录下，并更名为 `ehcache.xml`\r\n\r\n*pom.xml*\r\n```\r\n<!--ehcache 相关包 -->\r\n<dependency>\r\n  <groupId>net.sf.ehcache</groupId>\r\n  <artifactId>ehcache</artifactId>\r\n  <version>2.7.5</version>\r\n</dependency>\r\n<dependency>\r\n  <groupId>org.mybatis.caches</groupId>\r\n  <artifactId>mybatis-ehcache</artifactId>\r\n  <version>1.1.0</version>\r\n</dependency>\r\n```\r\n\r\n*mapper.xml*\r\n```\r\n<mapper namespace=\"com.bjpowernode.dao.IStudentDao\">\r\n	<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\">\r\n		<property name=\"timeToIdleSeconds\" value=\"60\"/>\r\n	</cache>\r\n</mapper>\r\n```\r\n\r\n\r\n\r\n## 注解\r\nmybatis 的注解，主要是用于替换映射文件。而映射文件中无非存放着增、删、改、查的 SQL 映射标签。所以， mybatis 注解，就是要替换映射文件中的 SQL 标签。mybatis 官方文档中指出，若要真正想发挥 mybatis 功能，还是要用映射文件。即 mybatis官方并不建议通过注解方式来使用 mybatis。\r\n\r\n由于 MyBatis 注解替换的是映射文件，所以这里就不需要映射文件了，将其直接删除。由于没有了映射文件，所以主配置文件中不能使用 `<mapper/>` 注册 mapper 的位置了。需要使用`<package/>` 标签。\r\n\r\n*mybatis.xml*\r\n```\r\n<mappers>\r\n	<package name=\"com.bjpowernode.dao\"/>\r\n</mappers>\r\n\r\n```\r\n\r\n*IStudentDao.java*\r\n```\r\npublic interface IStudentDao {\r\n	@Insert(value={\"insert into student(name,age,score) values(#{name}, #{age}, #{score})\"})\r\n	void insertStudent(Student student);\r\n	\r\n	@Insert(\"insert into student(name,age,score) values(#{name}, #{age}, #{score})\")\r\n	@SelectKey(statement=\"select @@identity\", resultType=int.class, keyProperty=\"id\", before=false)\r\n	void insertStudentCacheId(Student student);\r\n	\r\n	@Delete(value=\"delete from student where id=#{xxx}\")\r\n	void deleteStudentById(int id);\r\n	\r\n	@Update(\"update student set name=#{name}, age=#{age}, score=#{score} where id=#{id}\")\r\n	void updateStudent(Student student);\r\n	\r\n	@Select(\"select id,name,age,score from student\")\r\n	List<Student> selectAllStudents();\r\n	\r\n	@Select(\"select id,name,age,score from student where id=#{jjj}\")\r\n	Student selectStudentById(int id);\r\n	\r\n	@Select(\"select id,name,age,score from student where name like \'%\' #{xxx} \'%\'\")\r\n	List<Student> selectStudentsByName(String name);\r\n}\r\n```',`groups`='Java',`is_show`=1,`publish`=1,`summary`=''  WHERE  `id` = 243 [ RunTime:0.001900s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001057s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000350s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000930s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=18  WHERE  `groups` = 'Java' [ RunTime:0.000350s ]
---------------------------------------------------------------
[ 2018-11-11T22:34:32+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/243.html
[ info ] qingrang.top/daily/admin/note/shownote/id/243.html [运行时间：0.054441s][吞吐率：18.37req/s] [内存消耗：2,078.36kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/243.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1540982738,1541082864,1541122974,1541171416; PHPSESSID=hos0372kbv3s1q4ivqponggtl5',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '243',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000472s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001257s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 243 LIMIT 1 [ RunTime:0.000640s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001262s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000326s ]
