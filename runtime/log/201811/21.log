---------------------------------------------------------------
[ 2018-11-21T09:08:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.044972s][吞吐率：22.24req/s] [内存消耗：1,429.10kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-21T09:08:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.034786s][吞吐率：28.75req/s] [内存消耗：1,340.77kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-21T09:08:48+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.057002s][吞吐率：17.54req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000991s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.002853s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000581s ]
---------------------------------------------------------------
[ 2018-11-21T09:08:49+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.075318s][吞吐率：13.28req/s] [内存消耗：2,278.71kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000593s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001588s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003467s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` <> 1 ORDER BY gmt_modified desc LIMIT 5 [ RunTime:0.002588s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.001067s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000358s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000608s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000757s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000265s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000390s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000271s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000495s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001382s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000209s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001060s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000683s ]
---------------------------------------------------------------
[ 2018-11-21T09:08:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/250.html
[ info ] qingrang.top/daily/admin/note/shownote/id/250.html [运行时间：0.074061s][吞吐率：13.50req/s] [内存消耗：2,019.75kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000663s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001614s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000592s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000870s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000270s ]
---------------------------------------------------------------
[ 2018-11-21T09:09:42+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/250.html
[ info ] qingrang.top/daily/admin/note/editnote/id/250.html [运行时间：0.058526s][吞吐率：17.09req/s] [内存消耗：2,067.56kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000654s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001596s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000783s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000963s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000304s ]
---------------------------------------------------------------
[ 2018-11-21T09:10:09+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/250.html
[ info ] qingrang.top/daily/admin/note/editnote/id/250.html [运行时间：0.059012s][吞吐率：16.95req/s] [内存消耗：2,067.96kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000670s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001257s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000503s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000775s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000302s ]
---------------------------------------------------------------
[ 2018-11-21T10:02:16+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.050331s][吞吐率：19.87req/s] [内存消耗：2,283.89kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '67263',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring(二) - AOP（面向切面）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## AOP 简介
### 概念
AOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。

AOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。

面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。

若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。

例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。

### 利用 JDK 动态代理实现 AOP 编程
*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*SystemService.java - 交叉业务逻辑*
```
public class SystemService {
	public static void doLog() {
		System.out.println("执行日志代码");
	}

	public static void doTx() {
		System.out.println("执行事务代码");
	}
}
```
*MyTest.java*
```
@Test
public void MyTest(){
	final ISomeService target = new SomeServiceImpl();
	// 自动生成一个动态代理对象
	ISomeService service = (ISomeService) Proxy.newProxyInstance(
			target.getClass().getClassLoader(), // 目标类的类加载器
			target.getClass().getInterfaces(),  // 目标类实现的接口数组
			new InvocationHandler() { //业务增强逻辑
				// 具体加强的代码逻辑
				@Override
				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
					SystemService.doTx(); // 织入
					Object result = method.invoke(target, args); // 执行目标方法
					SystemService.doLog(); // 织入
					return result;
				}
			});
	service.doFirst();
	System.out.println("==============");
	service.doSecond();
}
```
*输出信息*
```
执行事务代码
执行doFirst()方法
执行日志代码
==============
执行事务代码
执行doSecond()方法
执行日志代码
```
## AOP 编程术语
### 切面（Aspect）
切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。
### 织入（Weaving）
织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。
### 连接点（JoinPoint）
连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。
### 切入点（Pointcut）
切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。
### 目标对象（Target）
目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。
### 通知（Advice）
通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。

**切入点定义切入的位置，通知定义切入的时间。**
### 顾问（Advisor）
顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。






## 通知 Advice
通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。

常用通知有：前置通知、后置通知、环绕通知、异常处理通知。
### 前置通知 MethodBeforeAdvice
定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：
- 在目标方法执行之前先执行。
- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*MyMethodBeforeAdvice.java - 前置通知*
```
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {

	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象
	@Override
	public void before(Method method, Object[] args, Object target) throws Throwable {
		// 对于目标方法的增强代码就应该写在这里
		System.out.println("执行前置通知方法");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop01.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop01.MyMethodBeforeAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<!-- 指定目标对象，随便用哪个 -->
    	<!-- <property name="targetName" value="someService"/> -->
    	<property name="target" ref="someService"/>
		
    	<!-- 指定切面 -->
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>
</beans>
```

### 后置通知 AfterReturningAdvice
定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：
- 在目标方法执行之后执行。
- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
### 环绕通知 MethodInterceptor
定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。

*MyMethodInterceptor.java*
```
// 环绕通知：可以修改目标方法的返回结果
public class MyMethodInterceptor implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		System.out.println("执行环绕通知：目标方法执行之前");
		// 执行目标方法
		Object result = invocation.proceed();
		System.out.println("执行环绕通知：目标方法执行之后");
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
}
```





### 异常通知 ThrowsAdvice
定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。

不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：
![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)
不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。
#### 普通异常
*SomeServiceImpl.java - 目标类*
```
@Override
public void doFirst() {
	System.out.println("执行doFirst()方法" + 3 / 0);
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("执行异常通知方法");
	}
}
```
*输出信息*
```
执行异常通知方法
java.lang.ArithmeticException: / by zero
	...
```
#### 自定义异常
异常分两种：
- 运行时异常，不进行处理，也可以通过编译。
若一个类继承自 RunTimeException，则该异常就是运行时异常
- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。
若一个类继承自 Exception，则该异常就是受查异常

*UserException.java*
```
public class UserException extends Exception {
	public UserException() {
		super();
	}

	public UserException(String message) {
		super(message);
	}
}
```
*UsernameException.java*
```
public class UsernameException extends UserException {
	public UsernameException() {
		super();
	}

	public UsernameException(String message) {
		super(message);
	}
}
```
*PasswordException.java*
```
public class PasswordException extends UserException {
	public PasswordException() {
		super();
	}

	public PasswordException(String message) {
		super(message);
	}
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出 UsernameException 异常时，执行当前方法
	public void afterThrowing(UsernameException ex) {
		System.out.println("发生用户名异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出 PasswordException 异常时，执行当前方法
	public void afterThrowing(PasswordException ex) {
		System.out.println("发生密码异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出其它异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("发生异常 ex = " + ex.getMessage());
	}
}
```
*MyTest.java*
```
@Test
public void test01() throws UserException {
	String resource = "top/qingrang/aop05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.login("beijing", "222");
}
```





### 同时使用多种通知
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop06.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myBeforeAdvice" class="top.qingrang.aop06.MyMethodBeforeAdvice"/>
    <bean id="myAfterAdvice" class="top.qingrang.aop06.MyAfterReturningAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
        <!-- 注入多种通知 -->
    	<property name="interceptorNames" value="myBeforeAdvice,myAfterAdvice"/>
    	<!-- <property name="interceptorNames">
    		<array>
    			<value>myBeforeAdvice</value>
    			<value>myAfterAdvice</value>
    		</array>
    	</property> -->
    </bean>

</beans>
```


### 无接口的 CGLIB 代理生成
若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。
*SomeService.java - 目标类*
```
public class SomeService {
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop07.SomeService"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop07.MyAfterReturningAdvice"/>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	SomeService service = (SomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	String result = service.doSecond();
	System.out.println(result);
}
```
### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性
若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。

![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)
也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。
![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)
查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。
![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)


## 顾问 Advisor
通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。

顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**

PointcutAdvisor 接口有两个较为常用的实现类：
- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问
- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问

### 名称匹配方法切入点顾问
NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。

`<property name="mappedNames"/>`

*ISomeService.java*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	String doSecond();
	// 目标方法
	void doThird();
}
```
*SomeServiceImpl.java*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}

	@Override
	public void doThird() {
		System.out.println("执行doThird()方法");
	}
}
```
*MyAfterReturningAdvice.java*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop09.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop09.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->
    	<!-- <property name="mappedName" value="doFirst"/> -->
    	 <property name="mappedNames" value="doFirst,doSecond"/>
        <!-- 使用通配符 -->
    	<!--<property name="mappedNames" value="*ir*"/>-->
    </bean>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/aop09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
}
```
*输出信息*
```
执行doFirst()方法
执行后置通知方法  returnValue = null
==================
执行doSecond()方法
执行后置通知方法  returnValue = abcde
==================
执行doThird()方法
```
### 正则表达式方法切入点顾问
RegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。

`<property name="pattern"/>`

这里的正则表达式常用的运算符有三个，如下表：

|运算符|意义|
|-|-|
|.|表示任意单个字符|
|+|表示前一个字符出现一次或多次|
|*|表示前一个字符出现零次或多次|

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop10.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop10.MyAfterReturningAdvice"/>

    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->
        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->
    	<!-- <property name="pattern" value=".*doFirst"/> -->
    	<!-- <property name="patterns" value=".*doFirst,.*doSecond"/> -->
    	<!-- <property name="pattern" value=".*doFirst|.*doSecond"/> -->
    	<property name="pattern" value=".*S.*"/>
    </bean>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
## 自动代理生成器
前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：
1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。
1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。
代理类的 id：`ISomeService service = (ISomeService) ac.getBean("serviceProxy");`
目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean("someService");`

我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。

Spring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：
- 默认 advisor 自动代理生成器
- Bean 名称自动代理生成器

需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。

自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：
![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*
### 默认 advisor 自动代理生成器
DefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。

DefaultAdvisorAutoProxyCreator 存在三个问题：
1. 不能选择目标对象
1. 不能选择切面类型，切面只能是 advisor
1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop11.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop11.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop11.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>
    
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("someService");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
	
	System.out.println("-----------------------------");
	
	ISomeService service2 = (ISomeService) ac.getBean("someService2");
	service2.doFirst();
	System.out.println("==================");
	service2.doSecond();
	System.out.println("==================");
	service2.doThird();
}
```



### Bean 名称自动代理生成器
DefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop12.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop12.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop12.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
    	<property name="beanNames" value="someService"/>
        <!-- 使用通知 -->
    	<!--<property name="interceptorNames" value="myAdvice"/>-->
        <!-- 使用顾问 -->
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>
</beans>
```



## AspectJ 对 AOP 的实现（*）
对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。

**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**
### AspectJ 的通知类型
AspectJ 中常用的通知有五种类型：
1. 前置通知
1. 后置通知
1. 环绕通知
1. 异常通知
1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。

### AspectJ 的切入点表达式
AspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：
```
execution (
	[modifiers-pattern] 访问权限类型
	ret-type-pattern 返回值类型
	[declaring-type-pattern] 全限定性类名
	name-pattern(param-pattern) 方法名(参数名)
	[throws-pattern] 抛出异常类型
)
```
切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：

|符号|意义|
|-|-|
|*|0至多个任意字符|
|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|
|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|

*举例*
```
execution(public * *(..))
指定切入点为：任意公共方法。

execution(* set *(..))
指定切入点为：任何一个以“set”开始的方法。

execution(* com.xyz.service.*.*(..))
指定切入点为：定义在 service 包里的任意类的任意方法。

execution(* com.xyz.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。

execution(* *.service.*.doSome())
指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点

execution(* *..service.*.doSome())
指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点

execution(* com.xyz.service.IAccountService.*(..))
指定切入点为： IAccountService 接口中的任意方法。

execution(* com.xyz.service.IAccountService+.*(..))
指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。

execution(* joke(String,int)))
指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。

execution(* joke(String,*)))
指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。

execution(* joke(String,..)))
指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。

execution(* joke(Object))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。

execution(* joke(Object+)))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。
```
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000757s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001413s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring(二) - AOP（面向切面）',`content`='# Spring(二) - AOP（面向切面）\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## AOP 简介\n### 概念\nAOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。\n\nAOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。\n\n面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。\n\n若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。\n\n例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。\n\n### 利用 JDK 动态代理实现 AOP 编程\n*ISomeService.java - 主业务接口*\n```\npublic interface ISomeService {\n	// 目标方法\n	void doFirst();\n	// 目标方法\n	void doSecond();\n}\n```\n*SomeServiceImpl.java - 目标类*\n```\npublic class SomeServiceImpl implements ISomeService {\n\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public void doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n	}\n}\n```\n*SystemService.java - 交叉业务逻辑*\n```\npublic class SystemService {\n	public static void doLog() {\n		System.out.println(\"执行日志代码\");\n	}\n\n	public static void doTx() {\n		System.out.println(\"执行事务代码\");\n	}\n}\n```\n*MyTest.java*\n```\n@Test\npublic void MyTest(){\n	final ISomeService target = new SomeServiceImpl();\n	// 自动生成一个动态代理对象\n	ISomeService service = (ISomeService) Proxy.newProxyInstance(\n			target.getClass().getClassLoader(), // 目标类的类加载器\n			target.getClass().getInterfaces(),  // 目标类实现的接口数组\n			new InvocationHandler() { //业务增强逻辑\n				// 具体加强的代码逻辑\n				@Override\n				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n					SystemService.doTx(); // 织入\n					Object result = method.invoke(target, args); // 执行目标方法\n					SystemService.doLog(); // 织入\n					return result;\n				}\n			});\n	service.doFirst();\n	System.out.println(\"==============\");\n	service.doSecond();\n}\n```\n*输出信息*\n```\n执行事务代码\n执行doFirst()方法\n执行日志代码\n==============\n执行事务代码\n执行doSecond()方法\n执行日志代码\n```\n## AOP 编程术语\n### 切面（Aspect）\n切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。\n### 织入（Weaving）\n织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。\n### 连接点（JoinPoint）\n连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。\n### 切入点（Pointcut）\n切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。\n### 目标对象（Target）\n目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。\n### 通知（Advice）\n通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。\n\n**切入点定义切入的位置，通知定义切入的时间。**\n### 顾问（Advisor）\n顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。\n\n\n\n\n\n\n## 通知 Advice\n通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。\n\n常用通知有：前置通知、后置通知、环绕通知、异常处理通知。\n### 前置通知 MethodBeforeAdvice\n定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：\n- 在目标方法执行之前先执行。\n- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。\n- 不改变目标方法执行的结果。\n\n*ISomeService.java - 主业务接口*\n```\npublic interface ISomeService {\n	// 目标方法\n	void doFirst();\n	// 目标方法\n	void doSecond();\n}\n```\n*SomeServiceImpl.java - 目标类*\n```\npublic class SomeServiceImpl implements ISomeService {\n\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public void doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n	}\n}\n```\n*MyMethodBeforeAdvice.java - 前置通知*\n```\npublic class MyMethodBeforeAdvice implements MethodBeforeAdvice {\n\n	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象\n	@Override\n	public void before(Method method, Object[] args, Object target) throws Throwable {\n		// 对于目标方法的增强代码就应该写在这里\n		System.out.println(\"执行前置通知方法\");\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop01.SomeServiceImpl\"/>\n\n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop01.MyMethodBeforeAdvice\"/>\n\n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<!-- 指定目标对象，随便用哪个 -->\n    	<!-- <property name=\"targetName\" value=\"someService\"/> -->\n    	<property name=\"target\" ref=\"someService\"/>\n		\n    	<!-- 指定切面 -->\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\n    </bean>\n</beans>\n```\n\n### 后置通知 AfterReturningAdvice\n定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：\n- 在目标方法执行之后执行。\n- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。\n- 不改变目标方法执行的结果。\n\n*SomeServiceImpl.java - 目标类*\n```\npublic class SomeServiceImpl implements ISomeService {\n\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n}\n```\n*MyAfterReturningAdvice.java - 后置通知*\n```\n// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\n	@Override\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\n		if (returnValue != null) {\n			returnValue = ((String) returnValue).toUpperCase();\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\n		}\n	}\n}\n```\n### 环绕通知 MethodInterceptor\n定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。\n\n*MyMethodInterceptor.java*\n```\n// 环绕通知：可以修改目标方法的返回结果\npublic class MyMethodInterceptor implements MethodInterceptor {\n	@Override\n	public Object invoke(MethodInvocation invocation) throws Throwable {\n		System.out.println(\"执行环绕通知：目标方法执行之前\");\n		// 执行目标方法\n		Object result = invocation.proceed();\n		System.out.println(\"执行环绕通知：目标方法执行之后\");\n		if(result != null) {\n			result = ((String)result).toUpperCase();\n		}\n		return result;\n	}\n}\n```\n\n\n\n\n\n### 异常通知 ThrowsAdvice\n定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。\n\n不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：\n![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)\n不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。\n#### 普通异常\n*SomeServiceImpl.java - 目标类*\n```\n@Override\npublic void doFirst() {\n	System.out.println(\"执行doFirst()方法\" + 3 / 0);\n}\n```\n*MyThrowsAdvice.java - 异常通知*\n```\npublic class MyThrowsAdvice implements ThrowsAdvice {\n	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法\n	public void afterThrowing(Exception ex) {\n		System.out.println(\"执行异常通知方法\");\n	}\n}\n```\n*输出信息*\n```\n执行异常通知方法\njava.lang.ArithmeticException: / by zero\n	...\n```\n#### 自定义异常\n异常分两种：\n- 运行时异常，不进行处理，也可以通过编译。\n若一个类继承自 RunTimeException，则该异常就是运行时异常\n- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。\n若一个类继承自 Exception，则该异常就是受查异常\n\n*UserException.java*\n```\npublic class UserException extends Exception {\n	public UserException() {\n		super();\n	}\n\n	public UserException(String message) {\n		super(message);\n	}\n}\n```\n*UsernameException.java*\n```\npublic class UsernameException extends UserException {\n	public UsernameException() {\n		super();\n	}\n\n	public UsernameException(String message) {\n		super(message);\n	}\n}\n```\n*PasswordException.java*\n```\npublic class PasswordException extends UserException {\n	public PasswordException() {\n		super();\n	}\n\n	public PasswordException(String message) {\n		super(message);\n	}\n}\n```\n*MyThrowsAdvice.java - 异常通知*\n```\npublic class MyThrowsAdvice implements ThrowsAdvice {\n	// 当目标方法抛出 UsernameException 异常时，执行当前方法\n	public void afterThrowing(UsernameException ex) {\n		System.out.println(\"发生用户名异常 ex = \" + ex.getMessage());\n	}\n	\n	// 当目标方法抛出 PasswordException 异常时，执行当前方法\n	public void afterThrowing(PasswordException ex) {\n		System.out.println(\"发生密码异常 ex = \" + ex.getMessage());\n	}\n	\n	// 当目标方法抛出其它异常时，执行当前方法\n	public void afterThrowing(Exception ex) {\n		System.out.println(\"发生异常 ex = \" + ex.getMessage());\n	}\n}\n```\n*MyTest.java*\n```\n@Test\npublic void test01() throws UserException {\n	String resource = \"top/qingrang/aop05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\n	service.login(\"beijing\", \"222\");\n}\n```\n\n\n\n\n\n### 同时使用多种通知\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop06.SomeServiceImpl\"/>\n\n    <!-- 注册切面：通知 -->\n    <bean id=\"myBeforeAdvice\" class=\"top.qingrang.aop06.MyMethodBeforeAdvice\"/>\n    <bean id=\"myAfterAdvice\" class=\"top.qingrang.aop06.MyAfterReturningAdvice\"/>\n\n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n        <!-- 注入多种通知 -->\n    	<property name=\"interceptorNames\" value=\"myBeforeAdvice,myAfterAdvice\"/>\n    	<!-- <property name=\"interceptorNames\">\n    		<array>\n    			<value>myBeforeAdvice</value>\n    			<value>myAfterAdvice</value>\n    		</array>\n    	</property> -->\n    </bean>\n\n</beans>\n```\n\n\n### 无接口的 CGLIB 代理生成\n若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。\n*SomeService.java - 目标类*\n```\npublic class SomeService {\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n}\n```\n*MyAfterReturningAdvice.java - 后置通知*\n```\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\n	@Override\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\n		if (returnValue != null) {\n			returnValue = ((String) returnValue).toUpperCase();\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\n		}\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop07.SomeService\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop07.MyAfterReturningAdvice\"/>\n    \n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	String resource = \"top/qingrang/aop07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	SomeService service = (SomeService) ac.getBean(\"serviceProxy\");\n	service.doFirst();\n	System.out.println(\"==================\");\n	String result = service.doSecond();\n	System.out.println(result);\n}\n```\n### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性\n若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。\n\n![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)\n也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。\n![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)\n查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。\n![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)\n\n\n## 顾问 Advisor\n通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。\n\n顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**\n\nPointcutAdvisor 接口有两个较为常用的实现类：\n- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问\n- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问\n\n### 名称匹配方法切入点顾问\nNameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。\n\n`<property name=\"mappedNames\"/>`\n\n*ISomeService.java*\n```\npublic interface ISomeService {\n	// 目标方法\n	void doFirst();\n	// 目标方法\n	String doSecond();\n	// 目标方法\n	void doThird();\n}\n```\n*SomeServiceImpl.java*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n\n	@Override\n	public void doThird() {\n		System.out.println(\"执行doThird()方法\");\n	}\n}\n```\n*MyAfterReturningAdvice.java*\n```\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\n	@Override\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop09.SomeServiceImpl\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop09.MyAfterReturningAdvice\"/>\n    \n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->\n    	<!-- <property name=\"mappedName\" value=\"doFirst\"/> -->\n    	 <property name=\"mappedNames\" value=\"doFirst,doSecond\"/>\n        <!-- 使用通配符 -->\n    	<!--<property name=\"mappedNames\" value=\"*ir*\"/>-->\n    </bean>\n    \n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\n    </bean>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/aop09/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\n	service.doFirst();\n	System.out.println(\"==================\");\n	service.doSecond();\n	System.out.println(\"==================\");\n	service.doThird();\n}\n```\n*输出信息*\n```\n执行doFirst()方法\n执行后置通知方法  returnValue = null\n==================\n执行doSecond()方法\n执行后置通知方法  returnValue = abcde\n==================\n执行doThird()方法\n```\n### 正则表达式方法切入点顾问\nRegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。\n\n`<property name=\"pattern\"/>`\n\n这里的正则表达式常用的运算符有三个，如下表：\n\n|运算符|意义|\n|-|-|\n|.|表示任意单个字符|\n|+|表示前一个字符出现一次或多次|\n|*|表示前一个字符出现零次或多次|\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop10.SomeServiceImpl\"/>\n\n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop10.MyAfterReturningAdvice\"/>\n\n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->\n        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->\n    	<!-- <property name=\"pattern\" value=\".*doFirst\"/> -->\n    	<!-- <property name=\"patterns\" value=\".*doFirst,.*doSecond\"/> -->\n    	<!-- <property name=\"pattern\" value=\".*doFirst|.*doSecond\"/> -->\n    	<property name=\"pattern\" value=\".*S.*\"/>\n    </bean>\n\n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\n    </bean>\n\n</beans>\n```\n## 自动代理生成器\n前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：\n1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。\n1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。\n代理类的 id：`ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");`\n目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean(\"someService\");`\n\n我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。\n\nSpring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：\n- 默认 advisor 自动代理生成器\n- Bean 名称自动代理生成器\n\n需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。\n\n自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：\n![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*\n### 默认 advisor 自动代理生成器\nDefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。\n\nDefaultAdvisorAutoProxyCreator 存在三个问题：\n1. 不能选择目标对象\n1. 不能选择切面类型，切面只能是 advisor\n1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\n    <bean id=\"someService2\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop11.MyAfterReturningAdvice\"/>\n    \n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\n    </bean>\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\n    </bean>\n    \n    <!-- 注册自动代理生成器 -->\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n    \n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	String resource = \"top/qingrang/aop11/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"someService\");\n	service.doFirst();\n	System.out.println(\"==================\");\n	service.doSecond();\n	System.out.println(\"==================\");\n	service.doThird();\n	\n	System.out.println(\"-----------------------------\");\n	\n	ISomeService service2 = (ISomeService) ac.getBean(\"someService2\");\n	service2.doFirst();\n	System.out.println(\"==================\");\n	service2.doSecond();\n	System.out.println(\"==================\");\n	service2.doThird();\n}\n```\n\n\n\n### Bean 名称自动代理生成器\nDefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\n    <bean id=\"someService2\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop12.MyAfterReturningAdvice\"/>\n    \n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\n    </bean>\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\n    </bean>\n    \n    <!-- 注册自动代理生成器 -->\n    <bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\n    	<property name=\"beanNames\" value=\"someService\"/>\n        <!-- 使用通知 -->\n    	<!--<property name=\"interceptorNames\" value=\"myAdvice\"/>-->\n        <!-- 使用顾问 -->\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\n    </bean>\n</beans>\n```\n\n\n\n## AspectJ 对 AOP 的实现（*）\n对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。\n\n**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**\n### AspectJ 的通知类型\nAspectJ 中常用的通知有五种类型：\n1. 前置通知\n1. 后置通知\n1. 环绕通知\n1. 异常通知\n1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。\n\n### AspectJ 的切入点表达式\nAspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：\n```\nexecution (\n	[modifiers-pattern] 访问权限类型\n	ret-type-pattern 返回值类型\n	[declaring-type-pattern] 全限定性类名\n	name-pattern(param-pattern) 方法名(参数名)\n	[throws-pattern] 抛出异常类型\n)\n```\n切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：\n\n|符号|意义|\n|-|-|\n|*|0至多个任意字符|\n|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|\n|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|\n\n*举例*\n```\nexecution(public * *(..))\n指定切入点为：任意公共方法。\n\nexecution(* set *(..))\n指定切入点为：任何一个以“set”开始的方法。\n\nexecution(* com.xyz.service.*.*(..))\n指定切入点为：定义在 service 包里的任意类的任意方法。\n\nexecution(* com.xyz.service..*.*(..))\n指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。\n\nexecution(* *.service.*.doSome())\n指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点\n\nexecution(* *..service.*.doSome())\n指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点\n\nexecution(* com.xyz.service.IAccountService.*(..))\n指定切入点为： IAccountService 接口中的任意方法。\n\nexecution(* com.xyz.service.IAccountService+.*(..))\n指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。\n\nexecution(* joke(String,int)))\n指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。\n\nexecution(* joke(String,*)))\n指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。\n\nexecution(* joke(String,..)))\n指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。\n\nexecution(* joke(Object))\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。\n\nexecution(* joke(Object+)))\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。\n```\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001387s ]
---------------------------------------------------------------
[ 2018-11-21T10:16:16+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/250.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/250.html [运行时间：0.063523s][吞吐率：15.74req/s] [内存消耗：2,287.28kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '70761',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(二) - AOP（面向切面）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## AOP 简介
### 概念
AOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。

AOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。

面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。

若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。

例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。

### 利用 JDK 动态代理实现 AOP 编程
*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*SystemService.java - 交叉业务逻辑*
```
public class SystemService {
	public static void doLog() {
		System.out.println("执行日志代码");
	}

	public static void doTx() {
		System.out.println("执行事务代码");
	}
}
```
*MyTest.java*
```
@Test
public void MyTest(){
	final ISomeService target = new SomeServiceImpl();
	// 自动生成一个动态代理对象
	ISomeService service = (ISomeService) Proxy.newProxyInstance(
			target.getClass().getClassLoader(), // 目标类的类加载器
			target.getClass().getInterfaces(),  // 目标类实现的接口数组
			new InvocationHandler() { //业务增强逻辑
				// 具体加强的代码逻辑
				@Override
				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
					SystemService.doTx(); // 织入
					Object result = method.invoke(target, args); // 执行目标方法
					SystemService.doLog(); // 织入
					return result;
				}
			});
	service.doFirst();
	System.out.println("==============");
	service.doSecond();
}
```
*输出信息*
```
执行事务代码
执行doFirst()方法
执行日志代码
==============
执行事务代码
执行doSecond()方法
执行日志代码
```
## AOP 编程术语
### 切面（Aspect）
切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。
### 织入（Weaving）
织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。
### 连接点（JoinPoint）
连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。
### 切入点（Pointcut）
切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。
### 目标对象（Target）
目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。
### 通知（Advice）
通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。

**切入点定义切入的位置，通知定义切入的时间。**
### 顾问（Advisor）
顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。






## 通知 Advice
通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。

常用通知有：前置通知、后置通知、环绕通知、异常处理通知。
### 前置通知 MethodBeforeAdvice
定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：
- 在目标方法执行之前先执行。
- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*MyMethodBeforeAdvice.java - 前置通知*
```
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {

	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象
	@Override
	public void before(Method method, Object[] args, Object target) throws Throwable {
		// 对于目标方法的增强代码就应该写在这里
		System.out.println("执行前置通知方法");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop01.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop01.MyMethodBeforeAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<!-- 指定目标对象，随便用哪个 -->
    	<!-- <property name="targetName" value="someService"/> -->
    	<property name="target" ref="someService"/>
		
    	<!-- 指定切面 -->
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>
</beans>
```

### 后置通知 AfterReturningAdvice
定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：
- 在目标方法执行之后执行。
- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
### 环绕通知 MethodInterceptor
定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。

*MyMethodInterceptor.java*
```
// 环绕通知：可以修改目标方法的返回结果
public class MyMethodInterceptor implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		System.out.println("执行环绕通知：目标方法执行之前");
		// 执行目标方法
		Object result = invocation.proceed();
		System.out.println("执行环绕通知：目标方法执行之后");
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
}
```





### 异常通知 ThrowsAdvice
定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。

不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：
![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)
不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。
#### 普通异常
*SomeServiceImpl.java - 目标类*
```
@Override
public void doFirst() {
	System.out.println("执行doFirst()方法" + 3 / 0);
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("执行异常通知方法");
	}
}
```
*输出信息*
```
执行异常通知方法
java.lang.ArithmeticException: / by zero
	...
```
#### 自定义异常
异常分两种：
- 运行时异常，不进行处理，也可以通过编译。
若一个类继承自 RunTimeException，则该异常就是运行时异常
- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。
若一个类继承自 Exception，则该异常就是受查异常

*UserException.java*
```
public class UserException extends Exception {
	public UserException() {
		super();
	}

	public UserException(String message) {
		super(message);
	}
}
```
*UsernameException.java*
```
public class UsernameException extends UserException {
	public UsernameException() {
		super();
	}

	public UsernameException(String message) {
		super(message);
	}
}
```
*PasswordException.java*
```
public class PasswordException extends UserException {
	public PasswordException() {
		super();
	}

	public PasswordException(String message) {
		super(message);
	}
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出 UsernameException 异常时，执行当前方法
	public void afterThrowing(UsernameException ex) {
		System.out.println("发生用户名异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出 PasswordException 异常时，执行当前方法
	public void afterThrowing(PasswordException ex) {
		System.out.println("发生密码异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出其它异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("发生异常 ex = " + ex.getMessage());
	}
}
```
*MyTest.java*
```
@Test
public void test01() throws UserException {
	String resource = "top/qingrang/aop05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.login("beijing", "222");
}
```





### 同时使用多种通知
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop06.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myBeforeAdvice" class="top.qingrang.aop06.MyMethodBeforeAdvice"/>
    <bean id="myAfterAdvice" class="top.qingrang.aop06.MyAfterReturningAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
        <!-- 注入多种通知 -->
    	<property name="interceptorNames" value="myBeforeAdvice,myAfterAdvice"/>
    	<!-- <property name="interceptorNames">
    		<array>
    			<value>myBeforeAdvice</value>
    			<value>myAfterAdvice</value>
    		</array>
    	</property> -->
    </bean>

</beans>
```


### 无接口的 CGLIB 代理生成
若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。
*SomeService.java - 目标类*
```
public class SomeService {
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop07.SomeService"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop07.MyAfterReturningAdvice"/>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	SomeService service = (SomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	String result = service.doSecond();
	System.out.println(result);
}
```
### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性
若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。

![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)
也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。
![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)
查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。
![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)


## 顾问 Advisor
通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。

顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**

PointcutAdvisor 接口有两个较为常用的实现类：
- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问
- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问

### 名称匹配方法切入点顾问
NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。

`<property name="mappedNames"/>`

*ISomeService.java*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	String doSecond();
	// 目标方法
	void doThird();
}
```
*SomeServiceImpl.java*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}

	@Override
	public void doThird() {
		System.out.println("执行doThird()方法");
	}
}
```
*MyAfterReturningAdvice.java*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop09.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop09.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->
    	<!-- <property name="mappedName" value="doFirst"/> -->
    	 <property name="mappedNames" value="doFirst,doSecond"/>
        <!-- 使用通配符 -->
    	<!--<property name="mappedNames" value="*ir*"/>-->
    </bean>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/aop09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
}
```
*输出信息*
```
执行doFirst()方法
执行后置通知方法  returnValue = null
==================
执行doSecond()方法
执行后置通知方法  returnValue = abcde
==================
执行doThird()方法
```
### 正则表达式方法切入点顾问
RegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。

`<property name="pattern"/>`

这里的正则表达式常用的运算符有三个，如下表：

|运算符|意义|
|-|-|
|.|表示任意单个字符|
|+|表示前一个字符出现一次或多次|
|*|表示前一个字符出现零次或多次|

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop10.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop10.MyAfterReturningAdvice"/>

    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->
        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->
    	<!-- <property name="pattern" value=".*doFirst"/> -->
    	<!-- <property name="patterns" value=".*doFirst,.*doSecond"/> -->
    	<!-- <property name="pattern" value=".*doFirst|.*doSecond"/> -->
    	<property name="pattern" value=".*S.*"/>
    </bean>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
## 自动代理生成器
前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：
1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。
1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。
代理类的 id：`ISomeService service = (ISomeService) ac.getBean("serviceProxy");`
目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean("someService");`

我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。

Spring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：
- 默认 advisor 自动代理生成器
- Bean 名称自动代理生成器

需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。

自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：
![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*
### 默认 advisor 自动代理生成器
DefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。

DefaultAdvisorAutoProxyCreator 存在三个问题：
1. 不能选择目标对象
1. 不能选择切面类型，切面只能是 advisor
1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop11.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop11.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop11.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>
    
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("someService");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
	
	System.out.println("-----------------------------");
	
	ISomeService service2 = (ISomeService) ac.getBean("someService2");
	service2.doFirst();
	System.out.println("==================");
	service2.doSecond();
	System.out.println("==================");
	service2.doThird();
}
```



### Bean 名称自动代理生成器
DefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop12.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop12.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop12.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
    	<property name="beanNames" value="someService"/>
        <!-- 使用通知 -->
    	<!--<property name="interceptorNames" value="myAdvice"/>-->
        <!-- 使用顾问 -->
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>
</beans>
```



## AspectJ 对 AOP 的实现（*）
对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。

**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**
### AspectJ 的通知类型
AspectJ 中常用的通知有五种类型：
1. 前置通知
1. 后置通知
1. 环绕通知
1. 异常通知
1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。
### AspectJ 的切入点表达式
AspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：
```
execution (
	[modifiers-pattern] 访问权限类型
	ret-type-pattern 返回值类型
	[declaring-type-pattern] 全限定性类名
	name-pattern(param-pattern) 方法名(参数名)
	[throws-pattern] 抛出异常类型
)
```
切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：

|符号|意义|
|-|-|
|*|0至多个任意字符|
|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|
|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|

*举例*
```
execution(public * *(..))
指定切入点为：任意公共方法。

execution(* set *(..))
指定切入点为：任何一个以“set”开始的方法。

execution(* com.xyz.service.*.*(..))
指定切入点为：定义在 service 包里的任意类的任意方法。

execution(* com.xyz.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。

execution(* *.service.*.doSome())
指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点

execution(* *..service.*.doSome())
指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点

execution(* com.xyz.service.IAccountService.*(..))
指定切入点为： IAccountService 接口中的任意方法。

execution(* com.xyz.service.IAccountService+.*(..))
指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。

execution(* joke(String,int)))
指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。

execution(* joke(String,*)))
指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。

execution(* joke(String,..)))
指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。

execution(* joke(Object))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。

execution(* joke(Object+)))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。
```

',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000750s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001585s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000684s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000296s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000812s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000303s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000314s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=250,`p_id`=2,`title`='Spring(二) - AOP（面向切面）\r',`content`='# Spring(二) - AOP（面向切面）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## AOP 简介\r\n### 概念\r\nAOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。\r\n\r\nAOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。\r\n\r\n面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。\r\n\r\n若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。\r\n\r\n例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。\r\n\r\n### 利用 JDK 动态代理实现 AOP 编程\r\n*ISomeService.java - 主业务接口*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法\r\n	void doFirst();\r\n	// 目标方法\r\n	void doSecond();\r\n}\r\n```\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public void doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n	}\r\n}\r\n```\r\n*SystemService.java - 交叉业务逻辑*\r\n```\r\npublic class SystemService {\r\n	public static void doLog() {\r\n		System.out.println(\"执行日志代码\");\r\n	}\r\n\r\n	public static void doTx() {\r\n		System.out.println(\"执行事务代码\");\r\n	}\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void MyTest(){\r\n	final ISomeService target = new SomeServiceImpl();\r\n	// 自动生成一个动态代理对象\r\n	ISomeService service = (ISomeService) Proxy.newProxyInstance(\r\n			target.getClass().getClassLoader(), // 目标类的类加载器\r\n			target.getClass().getInterfaces(),  // 目标类实现的接口数组\r\n			new InvocationHandler() { //业务增强逻辑\r\n				// 具体加强的代码逻辑\r\n				@Override\r\n				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n					SystemService.doTx(); // 织入\r\n					Object result = method.invoke(target, args); // 执行目标方法\r\n					SystemService.doLog(); // 织入\r\n					return result;\r\n				}\r\n			});\r\n	service.doFirst();\r\n	System.out.println(\"==============\");\r\n	service.doSecond();\r\n}\r\n```\r\n*输出信息*\r\n```\r\n执行事务代码\r\n执行doFirst()方法\r\n执行日志代码\r\n==============\r\n执行事务代码\r\n执行doSecond()方法\r\n执行日志代码\r\n```\r\n## AOP 编程术语\r\n### 切面（Aspect）\r\n切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。\r\n### 织入（Weaving）\r\n织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。\r\n### 连接点（JoinPoint）\r\n连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。\r\n### 切入点（Pointcut）\r\n切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。\r\n### 目标对象（Target）\r\n目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。\r\n### 通知（Advice）\r\n通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。\r\n\r\n**切入点定义切入的位置，通知定义切入的时间。**\r\n### 顾问（Advisor）\r\n顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 通知 Advice\r\n通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。\r\n\r\n常用通知有：前置通知、后置通知、环绕通知、异常处理通知。\r\n### 前置通知 MethodBeforeAdvice\r\n定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：\r\n- 在目标方法执行之前先执行。\r\n- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。\r\n- 不改变目标方法执行的结果。\r\n\r\n*ISomeService.java - 主业务接口*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法\r\n	void doFirst();\r\n	// 目标方法\r\n	void doSecond();\r\n}\r\n```\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public void doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n	}\r\n}\r\n```\r\n*MyMethodBeforeAdvice.java - 前置通知*\r\n```\r\npublic class MyMethodBeforeAdvice implements MethodBeforeAdvice {\r\n\r\n	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象\r\n	@Override\r\n	public void before(Method method, Object[] args, Object target) throws Throwable {\r\n		// 对于目标方法的增强代码就应该写在这里\r\n		System.out.println(\"执行前置通知方法\");\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop01.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop01.MyMethodBeforeAdvice\"/>\r\n\r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<!-- 指定目标对象，随便用哪个 -->\r\n    	<!-- <property name=\"targetName\" value=\"someService\"/> -->\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n		\r\n    	<!-- 指定切面 -->\r\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n### 后置通知 AfterReturningAdvice\r\n定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：\r\n- 在目标方法执行之后执行。\r\n- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。\r\n- 不改变目标方法执行的结果。\r\n\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n}\r\n```\r\n*MyAfterReturningAdvice.java - 后置通知*\r\n```\r\n// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果\r\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\r\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\r\n	@Override\r\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\r\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\r\n		if (returnValue != null) {\r\n			returnValue = ((String) returnValue).toUpperCase();\r\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\r\n		}\r\n	}\r\n}\r\n```\r\n### 环绕通知 MethodInterceptor\r\n定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。\r\n\r\n*MyMethodInterceptor.java*\r\n```\r\n// 环绕通知：可以修改目标方法的返回结果\r\npublic class MyMethodInterceptor implements MethodInterceptor {\r\n	@Override\r\n	public Object invoke(MethodInvocation invocation) throws Throwable {\r\n		System.out.println(\"执行环绕通知：目标方法执行之前\");\r\n		// 执行目标方法\r\n		Object result = invocation.proceed();\r\n		System.out.println(\"执行环绕通知：目标方法执行之后\");\r\n		if(result != null) {\r\n			result = ((String)result).toUpperCase();\r\n		}\r\n		return result;\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 异常通知 ThrowsAdvice\r\n定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。\r\n\r\n不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：\r\n![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)\r\n不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。\r\n#### 普通异常\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\n@Override\r\npublic void doFirst() {\r\n	System.out.println(\"执行doFirst()方法\" + 3 / 0);\r\n}\r\n```\r\n*MyThrowsAdvice.java - 异常通知*\r\n```\r\npublic class MyThrowsAdvice implements ThrowsAdvice {\r\n	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法\r\n	public void afterThrowing(Exception ex) {\r\n		System.out.println(\"执行异常通知方法\");\r\n	}\r\n}\r\n```\r\n*输出信息*\r\n```\r\n执行异常通知方法\r\njava.lang.ArithmeticException: / by zero\r\n	...\r\n```\r\n#### 自定义异常\r\n异常分两种：\r\n- 运行时异常，不进行处理，也可以通过编译。\r\n若一个类继承自 RunTimeException，则该异常就是运行时异常\r\n- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。\r\n若一个类继承自 Exception，则该异常就是受查异常\r\n\r\n*UserException.java*\r\n```\r\npublic class UserException extends Exception {\r\n	public UserException() {\r\n		super();\r\n	}\r\n\r\n	public UserException(String message) {\r\n		super(message);\r\n	}\r\n}\r\n```\r\n*UsernameException.java*\r\n```\r\npublic class UsernameException extends UserException {\r\n	public UsernameException() {\r\n		super();\r\n	}\r\n\r\n	public UsernameException(String message) {\r\n		super(message);\r\n	}\r\n}\r\n```\r\n*PasswordException.java*\r\n```\r\npublic class PasswordException extends UserException {\r\n	public PasswordException() {\r\n		super();\r\n	}\r\n\r\n	public PasswordException(String message) {\r\n		super(message);\r\n	}\r\n}\r\n```\r\n*MyThrowsAdvice.java - 异常通知*\r\n```\r\npublic class MyThrowsAdvice implements ThrowsAdvice {\r\n	// 当目标方法抛出 UsernameException 异常时，执行当前方法\r\n	public void afterThrowing(UsernameException ex) {\r\n		System.out.println(\"发生用户名异常 ex = \" + ex.getMessage());\r\n	}\r\n	\r\n	// 当目标方法抛出 PasswordException 异常时，执行当前方法\r\n	public void afterThrowing(PasswordException ex) {\r\n		System.out.println(\"发生密码异常 ex = \" + ex.getMessage());\r\n	}\r\n	\r\n	// 当目标方法抛出其它异常时，执行当前方法\r\n	public void afterThrowing(Exception ex) {\r\n		System.out.println(\"发生异常 ex = \" + ex.getMessage());\r\n	}\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() throws UserException {\r\n	String resource = \"top/qingrang/aop05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\r\n	service.login(\"beijing\", \"222\");\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 同时使用多种通知\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop06.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myBeforeAdvice\" class=\"top.qingrang.aop06.MyMethodBeforeAdvice\"/>\r\n    <bean id=\"myAfterAdvice\" class=\"top.qingrang.aop06.MyAfterReturningAdvice\"/>\r\n\r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n        <!-- 注入多种通知 -->\r\n    	<property name=\"interceptorNames\" value=\"myBeforeAdvice,myAfterAdvice\"/>\r\n    	<!-- <property name=\"interceptorNames\">\r\n    		<array>\r\n    			<value>myBeforeAdvice</value>\r\n    			<value>myAfterAdvice</value>\r\n    		</array>\r\n    	</property> -->\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n### 无接口的 CGLIB 代理生成\r\n若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。\r\n*SomeService.java - 目标类*\r\n```\r\npublic class SomeService {\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n}\r\n```\r\n*MyAfterReturningAdvice.java - 后置通知*\r\n```\r\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\r\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\r\n	@Override\r\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\r\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\r\n		if (returnValue != null) {\r\n			returnValue = ((String) returnValue).toUpperCase();\r\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\r\n		}\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop07.SomeService\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop07.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/aop07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	SomeService service = (SomeService) ac.getBean(\"serviceProxy\");\r\n	service.doFirst();\r\n	System.out.println(\"==================\");\r\n	String result = service.doSecond();\r\n	System.out.println(result);\r\n}\r\n```\r\n### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性\r\n若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。\r\n\r\n![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)\r\n也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。\r\n![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)\r\n查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。\r\n![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)\r\n\r\n\r\n## 顾问 Advisor\r\n通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。\r\n\r\n顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**\r\n\r\nPointcutAdvisor 接口有两个较为常用的实现类：\r\n- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问\r\n- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问\r\n\r\n### 名称匹配方法切入点顾问\r\nNameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。\r\n\r\n`<property name=\"mappedNames\"/>`\r\n\r\n*ISomeService.java*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法\r\n	void doFirst();\r\n	// 目标方法\r\n	String doSecond();\r\n	// 目标方法\r\n	void doThird();\r\n}\r\n```\r\n*SomeServiceImpl.java*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n\r\n	@Override\r\n	public void doThird() {\r\n		System.out.println(\"执行doThird()方法\");\r\n	}\r\n}\r\n```\r\n*MyAfterReturningAdvice.java*\r\n```\r\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\r\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\r\n	@Override\r\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\r\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop09.SomeServiceImpl\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop09.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->\r\n    	<!-- <property name=\"mappedName\" value=\"doFirst\"/> -->\r\n    	 <property name=\"mappedNames\" value=\"doFirst,doSecond\"/>\r\n        <!-- 使用通配符 -->\r\n    	<!--<property name=\"mappedNames\" value=\"*ir*\"/>-->\r\n    </bean>\r\n    \r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/aop09/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\r\n	service.doFirst();\r\n	System.out.println(\"==================\");\r\n	service.doSecond();\r\n	System.out.println(\"==================\");\r\n	service.doThird();\r\n}\r\n```\r\n*输出信息*\r\n```\r\n执行doFirst()方法\r\n执行后置通知方法  returnValue = null\r\n==================\r\n执行doSecond()方法\r\n执行后置通知方法  returnValue = abcde\r\n==================\r\n执行doThird()方法\r\n```\r\n### 正则表达式方法切入点顾问\r\nRegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。\r\n\r\n`<property name=\"pattern\"/>`\r\n\r\n这里的正则表达式常用的运算符有三个，如下表：\r\n\r\n|运算符|意义|\r\n|-|-|\r\n|.|表示任意单个字符|\r\n|+|表示前一个字符出现一次或多次|\r\n|*|表示前一个字符出现零次或多次|\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop10.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop10.MyAfterReturningAdvice\"/>\r\n\r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->\r\n        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->\r\n    	<!-- <property name=\"pattern\" value=\".*doFirst\"/> -->\r\n    	<!-- <property name=\"patterns\" value=\".*doFirst,.*doSecond\"/> -->\r\n    	<!-- <property name=\"pattern\" value=\".*doFirst|.*doSecond\"/> -->\r\n    	<property name=\"pattern\" value=\".*S.*\"/>\r\n    </bean>\r\n\r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n## 自动代理生成器\r\n前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：\r\n1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。\r\n1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。\r\n代理类的 id：`ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");`\r\n目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean(\"someService\");`\r\n\r\n我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。\r\n\r\nSpring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：\r\n- 默认 advisor 自动代理生成器\r\n- Bean 名称自动代理生成器\r\n\r\n需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。\r\n\r\n自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：\r\n![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*\r\n### 默认 advisor 自动代理生成器\r\nDefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。\r\n\r\nDefaultAdvisorAutoProxyCreator 存在三个问题：\r\n1. 不能选择目标对象\r\n1. 不能选择切面类型，切面只能是 advisor\r\n1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\r\n    <bean id=\"someService2\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop11.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\r\n    </bean>\r\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\r\n    </bean>\r\n    \r\n    <!-- 注册自动代理生成器 -->\r\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\r\n    \r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/aop11/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"someService\");\r\n	service.doFirst();\r\n	System.out.println(\"==================\");\r\n	service.doSecond();\r\n	System.out.println(\"==================\");\r\n	service.doThird();\r\n	\r\n	System.out.println(\"-----------------------------\");\r\n	\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"someService2\");\r\n	service2.doFirst();\r\n	System.out.println(\"==================\");\r\n	service2.doSecond();\r\n	System.out.println(\"==================\");\r\n	service2.doThird();\r\n}\r\n```\r\n\r\n\r\n\r\n### Bean 名称自动代理生成器\r\nDefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\r\n    <bean id=\"someService2\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop12.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\r\n    </bean>\r\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\r\n    </bean>\r\n    \r\n    <!-- 注册自动代理生成器 -->\r\n    <bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\r\n    	<property name=\"beanNames\" value=\"someService\"/>\r\n        <!-- 使用通知 -->\r\n    	<!--<property name=\"interceptorNames\" value=\"myAdvice\"/>-->\r\n        <!-- 使用顾问 -->\r\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n\r\n\r\n## AspectJ 对 AOP 的实现（*）\r\n对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。\r\n\r\n**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**\r\n### AspectJ 的通知类型\r\nAspectJ 中常用的通知有五种类型：\r\n1. 前置通知\r\n1. 后置通知\r\n1. 环绕通知\r\n1. 异常通知\r\n1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。\r\n### AspectJ 的切入点表达式\r\nAspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：\r\n```\r\nexecution (\r\n	[modifiers-pattern] 访问权限类型\r\n	ret-type-pattern 返回值类型\r\n	[declaring-type-pattern] 全限定性类名\r\n	name-pattern(param-pattern) 方法名(参数名)\r\n	[throws-pattern] 抛出异常类型\r\n)\r\n```\r\n切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：\r\n\r\n|符号|意义|\r\n|-|-|\r\n|*|0至多个任意字符|\r\n|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|\r\n|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|\r\n\r\n*举例*\r\n```\r\nexecution(public * *(..))\r\n指定切入点为：任意公共方法。\r\n\r\nexecution(* set *(..))\r\n指定切入点为：任何一个以“set”开始的方法。\r\n\r\nexecution(* com.xyz.service.*.*(..))\r\n指定切入点为：定义在 service 包里的任意类的任意方法。\r\n\r\nexecution(* com.xyz.service..*.*(..))\r\n指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。\r\n\r\nexecution(* *.service.*.doSome())\r\n指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点\r\n\r\nexecution(* *..service.*.doSome())\r\n指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点\r\n\r\nexecution(* com.xyz.service.IAccountService.*(..))\r\n指定切入点为： IAccountService 接口中的任意方法。\r\n\r\nexecution(* com.xyz.service.IAccountService+.*(..))\r\n指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。\r\n\r\nexecution(* joke(String,int)))\r\n指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。\r\n\r\nexecution(* joke(String,*)))\r\n指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。\r\n\r\nexecution(* joke(String,..)))\r\n指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。\r\n\r\nexecution(* joke(Object))\r\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。\r\n\r\nexecution(* joke(Object+)))\r\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。\r\n```\r\n\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 250 [ RunTime:0.001421s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001993s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000293s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001108s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000269s ]
---------------------------------------------------------------
[ 2018-11-21T10:16:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/250.html
[ info ] qingrang.top/daily/admin/note/shownote/id/250.html [运行时间：0.058536s][吞吐率：17.08req/s] [内存消耗：2,033.74kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=mgf0o2srt81u2e73hvbhas5is6',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000507s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001420s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000495s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000716s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000268s ]
---------------------------------------------------------------
[ 2018-11-21T18:04:43+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.041412s][吞吐率：24.15req/s] [内存消耗：1,429.11kb] [文件加载：49]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ VIEW ] /var/www/html/daily/thinkphp/tpl/dispatch_jump.tpl [ array (
  0 => 'code',
  1 => 'msg',
  2 => 'data',
  3 => 'url',
  4 => 'wait',
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-21T18:04:46+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.034770s][吞吐率：28.76req/s] [内存消耗：1,340.77kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-21T18:04:50+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.084165s][吞吐率：11.88req/s] [内存消耗：1,922.37kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001018s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001995s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000553s ]
---------------------------------------------------------------
[ 2018-11-21T18:04:51+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.089551s][吞吐率：11.17req/s] [内存消耗：2,298.06kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000635s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001322s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003491s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` <> 1 ORDER BY gmt_modified desc LIMIT 5 [ RunTime:0.002623s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000973s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000335s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000637s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000945s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000294s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000368s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000289s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000303s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001199s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000207s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000919s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000718s ]
---------------------------------------------------------------
[ 2018-11-21T18:04:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/250.html
[ info ] qingrang.top/daily/admin/note/editnote/id/250.html [运行时间：0.052375s][吞吐率：19.09req/s] [内存消耗：2,089.82kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000609s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001260s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000641s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000726s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000239s ]
---------------------------------------------------------------
[ 2018-11-21T18:49:32+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.055680s][吞吐率：17.96req/s] [内存消耗：2,317.52kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '75114',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring(二) - AOP（面向切面）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## AOP 简介
### 概念
AOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。

AOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。

面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。

若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。

例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。

### 利用 JDK 动态代理实现 AOP 编程
*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*SystemService.java - 交叉业务逻辑*
```
public class SystemService {
	public static void doLog() {
		System.out.println("执行日志代码");
	}

	public static void doTx() {
		System.out.println("执行事务代码");
	}
}
```
*MyTest.java*
```
@Test
public void MyTest(){
	final ISomeService target = new SomeServiceImpl();
	// 自动生成一个动态代理对象
	ISomeService service = (ISomeService) Proxy.newProxyInstance(
			target.getClass().getClassLoader(), // 目标类的类加载器
			target.getClass().getInterfaces(),  // 目标类实现的接口数组
			new InvocationHandler() { //业务增强逻辑
				// 具体加强的代码逻辑
				@Override
				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
					SystemService.doTx(); // 织入
					Object result = method.invoke(target, args); // 执行目标方法
					SystemService.doLog(); // 织入
					return result;
				}
			});
	service.doFirst();
	System.out.println("==============");
	service.doSecond();
}
```
*输出信息*
```
执行事务代码
执行doFirst()方法
执行日志代码
==============
执行事务代码
执行doSecond()方法
执行日志代码
```
## AOP 编程术语
### 切面（Aspect）
切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。
### 织入（Weaving）
织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。
### 连接点（JoinPoint）
连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。
### 切入点（Pointcut）
切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。
### 目标对象（Target）
目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。
### 通知（Advice）
通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。

**切入点定义切入的位置，通知定义切入的时间。**
### 顾问（Advisor）
顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。






## 通知 Advice
通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。

常用通知有：前置通知、后置通知、环绕通知、异常处理通知。
### 前置通知 MethodBeforeAdvice
定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：
- 在目标方法执行之前先执行。
- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*MyMethodBeforeAdvice.java - 前置通知*
```
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {

	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象
	@Override
	public void before(Method method, Object[] args, Object target) throws Throwable {
		// 对于目标方法的增强代码就应该写在这里
		System.out.println("执行前置通知方法");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop01.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop01.MyMethodBeforeAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<!-- 指定目标对象，随便用哪个 -->
    	<!-- <property name="targetName" value="someService"/> -->
    	<property name="target" ref="someService"/>
		
    	<!-- 指定切面 -->
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>
</beans>
```

### 后置通知 AfterReturningAdvice
定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：
- 在目标方法执行之后执行。
- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
### 环绕通知 MethodInterceptor
定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。

*MyMethodInterceptor.java*
```
// 环绕通知：可以修改目标方法的返回结果
public class MyMethodInterceptor implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		System.out.println("执行环绕通知：目标方法执行之前");
		// 执行目标方法
		Object result = invocation.proceed();
		System.out.println("执行环绕通知：目标方法执行之后");
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
}
```





### 异常通知 ThrowsAdvice
定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。

不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：
![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)
不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。
#### 普通异常
*SomeServiceImpl.java - 目标类*
```
@Override
public void doFirst() {
	System.out.println("执行doFirst()方法" + 3 / 0);
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("执行异常通知方法");
	}
}
```
*输出信息*
```
执行异常通知方法
java.lang.ArithmeticException: / by zero
	...
```
#### 自定义异常
异常分两种：
- 运行时异常，不进行处理，也可以通过编译。
若一个类继承自 RunTimeException，则该异常就是运行时异常
- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。
若一个类继承自 Exception，则该异常就是受查异常

*UserException.java*
```
public class UserException extends Exception {
	public UserException() {
		super();
	}

	public UserException(String message) {
		super(message);
	}
}
```
*UsernameException.java*
```
public class UsernameException extends UserException {
	public UsernameException() {
		super();
	}

	public UsernameException(String message) {
		super(message);
	}
}
```
*PasswordException.java*
```
public class PasswordException extends UserException {
	public PasswordException() {
		super();
	}

	public PasswordException(String message) {
		super(message);
	}
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出 UsernameException 异常时，执行当前方法
	public void afterThrowing(UsernameException ex) {
		System.out.println("发生用户名异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出 PasswordException 异常时，执行当前方法
	public void afterThrowing(PasswordException ex) {
		System.out.println("发生密码异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出其它异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("发生异常 ex = " + ex.getMessage());
	}
}
```
*MyTest.java*
```
@Test
public void test01() throws UserException {
	String resource = "top/qingrang/aop05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.login("beijing", "222");
}
```





### 同时使用多种通知
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop06.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myBeforeAdvice" class="top.qingrang.aop06.MyMethodBeforeAdvice"/>
    <bean id="myAfterAdvice" class="top.qingrang.aop06.MyAfterReturningAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
        <!-- 注入多种通知 -->
    	<property name="interceptorNames" value="myBeforeAdvice,myAfterAdvice"/>
    	<!-- <property name="interceptorNames">
    		<array>
    			<value>myBeforeAdvice</value>
    			<value>myAfterAdvice</value>
    		</array>
    	</property> -->
    </bean>

</beans>
```


### 无接口的 CGLIB 代理生成
若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。
*SomeService.java - 目标类*
```
public class SomeService {
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop07.SomeService"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop07.MyAfterReturningAdvice"/>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	SomeService service = (SomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	String result = service.doSecond();
	System.out.println(result);
}
```
### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性
若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。

![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)
也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。
![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)
查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。
![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)


## 顾问 Advisor
通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。

顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**

PointcutAdvisor 接口有两个较为常用的实现类：
- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问
- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问

### 名称匹配方法切入点顾问
NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。

`<property name="mappedNames"/>`

*ISomeService.java*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	String doSecond();
	// 目标方法
	void doThird();
}
```
*SomeServiceImpl.java*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}

	@Override
	public void doThird() {
		System.out.println("执行doThird()方法");
	}
}
```
*MyAfterReturningAdvice.java*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop09.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop09.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->
    	<!-- <property name="mappedName" value="doFirst"/> -->
    	 <property name="mappedNames" value="doFirst,doSecond"/>
        <!-- 使用通配符 -->
    	<!--<property name="mappedNames" value="*ir*"/>-->
    </bean>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/aop09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
}
```
*输出信息*
```
执行doFirst()方法
执行后置通知方法  returnValue = null
==================
执行doSecond()方法
执行后置通知方法  returnValue = abcde
==================
执行doThird()方法
```
### 正则表达式方法切入点顾问
RegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。

`<property name="pattern"/>`

这里的正则表达式常用的运算符有三个，如下表：

|运算符|意义|
|-|-|
|.|表示任意单个字符|
|+|表示前一个字符出现一次或多次|
|*|表示前一个字符出现零次或多次|

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop10.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop10.MyAfterReturningAdvice"/>

    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->
        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->
    	<!-- <property name="pattern" value=".*doFirst"/> -->
    	<!-- <property name="patterns" value=".*doFirst,.*doSecond"/> -->
    	<!-- <property name="pattern" value=".*doFirst|.*doSecond"/> -->
    	<property name="pattern" value=".*S.*"/>
    </bean>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
## 自动代理生成器
前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：
1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。
1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。
代理类的 id：`ISomeService service = (ISomeService) ac.getBean("serviceProxy");`
目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean("someService");`

我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。

Spring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：
- 默认 advisor 自动代理生成器
- Bean 名称自动代理生成器

需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。

自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：
![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*
### 默认 advisor 自动代理生成器
DefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。

DefaultAdvisorAutoProxyCreator 存在三个问题：
1. 不能选择目标对象
1. 不能选择切面类型，切面只能是 advisor
1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop11.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop11.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop11.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>
    
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("someService");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
	
	System.out.println("-----------------------------");
	
	ISomeService service2 = (ISomeService) ac.getBean("someService2");
	service2.doFirst();
	System.out.println("==================");
	service2.doSecond();
	System.out.println("==================");
	service2.doThird();
}
```
### Bean 名称自动代理生成器
DefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop12.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop12.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop12.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
    	<property name="beanNames" value="someService"/>
        <!-- 使用通知 -->
    	<!--<property name="interceptorNames" value="myAdvice"/>-->
        <!-- 使用顾问 -->
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>
</beans> 
```
## AspectJ 对 AOP 的实现（*）
对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。

**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**
### AspectJ 的通知类型
AspectJ 中常用的通知有五种类型：
1. 前置通知
1. 后置通知
1. 环绕通知
1. 异常通知
1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。
### AspectJ 的切入点表达式
AspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：
```
execution (
	[modifiers-pattern] 访问权限类型
	ret-type-pattern 返回值类型
	[declaring-type-pattern] 全限定性类名
	name-pattern(param-pattern) 方法名(参数名)
	[throws-pattern] 抛出异常类型
)
```
切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：

|符号|意义|
|-|-|
|*|0至多个任意字符|
|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|
|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|

*举例*
```
execution(public * *(..))
指定切入点为：任意公共方法。

execution(* set *(..))
指定切入点为：任何一个以“set”开始的方法。

execution(* com.xyz.service.*.*(..))
指定切入点为：定义在 service 包里的任意类的任意方法。

execution(* com.xyz.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。

--------------------------- 常用 --------------------------------
execution(* *.service.*.doSome())
指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点

execution(* *..service.*.doSome())
指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点
-----------------------------------------------------------

execution(* com.xyz.service.IAccountService.*(..))
指定切入点为： IAccountService 接口中的任意方法。

execution(* com.xyz.service.IAccountService+.*(..))
指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。

execution(* joke(String,int)))
指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。

execution(* joke(String,*)))
指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。

execution(* joke(String,..)))
指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。

execution(* joke(Object))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。

execution(* joke(Object+)))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。
```


### AspectJ 基于注解的 AOP 实现
*ISomeService.java - service 接口*
```
public interface ISomeService {
	// 目标方法    
	void doFirst();
	// 目标方法
	String doSecond();
	// 目标方法
	void doThird();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
	
	@Override
	public void doThird() {
		System.out.println("执行doThird()方法" + 3 / 0);
		System.out.println("执行doThird()方法");
	}
}
```
*MyAspect.java - 切面类*
```
@Aspect    // 表示当前类为切面
public class MyAspect {
	@Before("execution(* *..ISomeService.doFirst(..))")
	public void myBefore() {
		System.out.println("执行前置通知方法");
	}

	@Before("execution(* *..ISomeService.doFirst(..))")
	public void myBefore(JoinPoint jp) {
		// 可以包含一个 JoinPoint 类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。
		System.out.println("执行前置通知方法 jp = " + jp);
	}
	
	@AfterReturning("execution(* *..ISomeService.doSecond(..))")
	public void myAfterReturning() {
		System.out.println("执行后置通知方法");
	}

	// 后置通知获取返回值
	// 该注解的 returning 属性就是用于指定接收方法返回值的变量名的。该变量最好为 Object 类型，因为目标方法的返回值可能是任何类型。
	@AfterReturning(value="execution(* *..ISomeService.doSecond(..))", returning="result")
	public void myAfterReturning(Object result) {
		System.out.println("执行后置通知方法  result = " + result);
	}
	
	@Around("execution(* *..ISomeService.doSecond(..))")
	public Object myAround(ProceedingJoinPoint pjp) throws Throwable {
		System.out.println("执行环绕通知方法，目标方法执行之前");
		// 执行目标方法
		Object result = pjp.proceed();
		System.out.println("执行环绕通知方法，目标方法执行之后");
		// 修改返回值
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
	
	@AfterThrowing("execution(* *..ISomeService.doThird(..))")
	public void myAfterThrowing() {
		System.out.println("执行异常通知方法");
	}

	// 指定异常
	@AfterThrowing(value="doThirdPointcut()", throwing="ex")
	public void myAfterThrowing(Exception ex) {
		System.out.println("执行异常通知方法 ex = " + ex.getMessage());
	}
	
	@After("doThirdPointcut()")
	public void myAfter() {
		System.out.println("执行最终通知方法");
	}
	
	// 定义了一个切入点，叫 doThirdPointcut()
	@Pointcut("execution(* *..ISomeService.doThird(..))")
	public void doThirdPointcut(){}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd">

	<!-- 注册切面 -->
	<bean id="myAspect" class="top.qingrang.annotation.MyAspect"/>
	
	<!-- 注册目标对象 -->
	<bean id="someService" class="top.qingrang.annotation.SomeServiceImpl"/>
	
	<!-- 注册 AspectJ 的自动代理 -->
	<aop:aspectj-autoproxy/>

</beans>
```
*输出信息*
```
执行前置通知方法 jp = execution(void top.qingrang.annotation.ISomeService.doFirst())
执行前置通知方法
执行doFirst()方法
----------------------------
执行环绕通知方法，目标方法执行之前
执行doSecond()方法
执行环绕通知方法，目标方法执行之后
执行后置通知方法
执行后置通知方法  result = ABCDE
----------------------------
执行最终通知方法
执行异常通知方法 ex = / by zero
执行异常通知方法

java.lang.ArithmeticException: / by zero
```
### AspectJ 基于 XML 的 AOP 实现
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000760s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001218s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring(二) - AOP（面向切面）',`content`='# Spring(二) - AOP（面向切面）\n[TOC]\n\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\n## AOP 简介\n### 概念\nAOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。\n\nAOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。\n\n面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。\n\n若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。\n\n例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。\n\n### 利用 JDK 动态代理实现 AOP 编程\n*ISomeService.java - 主业务接口*\n```\npublic interface ISomeService {\n	// 目标方法\n	void doFirst();\n	// 目标方法\n	void doSecond();\n}\n```\n*SomeServiceImpl.java - 目标类*\n```\npublic class SomeServiceImpl implements ISomeService {\n\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public void doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n	}\n}\n```\n*SystemService.java - 交叉业务逻辑*\n```\npublic class SystemService {\n	public static void doLog() {\n		System.out.println(\"执行日志代码\");\n	}\n\n	public static void doTx() {\n		System.out.println(\"执行事务代码\");\n	}\n}\n```\n*MyTest.java*\n```\n@Test\npublic void MyTest(){\n	final ISomeService target = new SomeServiceImpl();\n	// 自动生成一个动态代理对象\n	ISomeService service = (ISomeService) Proxy.newProxyInstance(\n			target.getClass().getClassLoader(), // 目标类的类加载器\n			target.getClass().getInterfaces(),  // 目标类实现的接口数组\n			new InvocationHandler() { //业务增强逻辑\n				// 具体加强的代码逻辑\n				@Override\n				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n					SystemService.doTx(); // 织入\n					Object result = method.invoke(target, args); // 执行目标方法\n					SystemService.doLog(); // 织入\n					return result;\n				}\n			});\n	service.doFirst();\n	System.out.println(\"==============\");\n	service.doSecond();\n}\n```\n*输出信息*\n```\n执行事务代码\n执行doFirst()方法\n执行日志代码\n==============\n执行事务代码\n执行doSecond()方法\n执行日志代码\n```\n## AOP 编程术语\n### 切面（Aspect）\n切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。\n### 织入（Weaving）\n织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。\n### 连接点（JoinPoint）\n连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。\n### 切入点（Pointcut）\n切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。\n### 目标对象（Target）\n目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。\n### 通知（Advice）\n通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。\n\n**切入点定义切入的位置，通知定义切入的时间。**\n### 顾问（Advisor）\n顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。\n\n\n\n\n\n\n## 通知 Advice\n通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。\n\n常用通知有：前置通知、后置通知、环绕通知、异常处理通知。\n### 前置通知 MethodBeforeAdvice\n定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：\n- 在目标方法执行之前先执行。\n- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。\n- 不改变目标方法执行的结果。\n\n*ISomeService.java - 主业务接口*\n```\npublic interface ISomeService {\n	// 目标方法\n	void doFirst();\n	// 目标方法\n	void doSecond();\n}\n```\n*SomeServiceImpl.java - 目标类*\n```\npublic class SomeServiceImpl implements ISomeService {\n\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public void doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n	}\n}\n```\n*MyMethodBeforeAdvice.java - 前置通知*\n```\npublic class MyMethodBeforeAdvice implements MethodBeforeAdvice {\n\n	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象\n	@Override\n	public void before(Method method, Object[] args, Object target) throws Throwable {\n		// 对于目标方法的增强代码就应该写在这里\n		System.out.println(\"执行前置通知方法\");\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop01.SomeServiceImpl\"/>\n\n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop01.MyMethodBeforeAdvice\"/>\n\n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<!-- 指定目标对象，随便用哪个 -->\n    	<!-- <property name=\"targetName\" value=\"someService\"/> -->\n    	<property name=\"target\" ref=\"someService\"/>\n		\n    	<!-- 指定切面 -->\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\n    </bean>\n</beans>\n```\n\n### 后置通知 AfterReturningAdvice\n定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：\n- 在目标方法执行之后执行。\n- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。\n- 不改变目标方法执行的结果。\n\n*SomeServiceImpl.java - 目标类*\n```\npublic class SomeServiceImpl implements ISomeService {\n\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n}\n```\n*MyAfterReturningAdvice.java - 后置通知*\n```\n// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\n	@Override\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\n		if (returnValue != null) {\n			returnValue = ((String) returnValue).toUpperCase();\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\n		}\n	}\n}\n```\n### 环绕通知 MethodInterceptor\n定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。\n\n*MyMethodInterceptor.java*\n```\n// 环绕通知：可以修改目标方法的返回结果\npublic class MyMethodInterceptor implements MethodInterceptor {\n	@Override\n	public Object invoke(MethodInvocation invocation) throws Throwable {\n		System.out.println(\"执行环绕通知：目标方法执行之前\");\n		// 执行目标方法\n		Object result = invocation.proceed();\n		System.out.println(\"执行环绕通知：目标方法执行之后\");\n		if(result != null) {\n			result = ((String)result).toUpperCase();\n		}\n		return result;\n	}\n}\n```\n\n\n\n\n\n### 异常通知 ThrowsAdvice\n定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。\n\n不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：\n![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)\n不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。\n#### 普通异常\n*SomeServiceImpl.java - 目标类*\n```\n@Override\npublic void doFirst() {\n	System.out.println(\"执行doFirst()方法\" + 3 / 0);\n}\n```\n*MyThrowsAdvice.java - 异常通知*\n```\npublic class MyThrowsAdvice implements ThrowsAdvice {\n	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法\n	public void afterThrowing(Exception ex) {\n		System.out.println(\"执行异常通知方法\");\n	}\n}\n```\n*输出信息*\n```\n执行异常通知方法\njava.lang.ArithmeticException: / by zero\n	...\n```\n#### 自定义异常\n异常分两种：\n- 运行时异常，不进行处理，也可以通过编译。\n若一个类继承自 RunTimeException，则该异常就是运行时异常\n- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。\n若一个类继承自 Exception，则该异常就是受查异常\n\n*UserException.java*\n```\npublic class UserException extends Exception {\n	public UserException() {\n		super();\n	}\n\n	public UserException(String message) {\n		super(message);\n	}\n}\n```\n*UsernameException.java*\n```\npublic class UsernameException extends UserException {\n	public UsernameException() {\n		super();\n	}\n\n	public UsernameException(String message) {\n		super(message);\n	}\n}\n```\n*PasswordException.java*\n```\npublic class PasswordException extends UserException {\n	public PasswordException() {\n		super();\n	}\n\n	public PasswordException(String message) {\n		super(message);\n	}\n}\n```\n*MyThrowsAdvice.java - 异常通知*\n```\npublic class MyThrowsAdvice implements ThrowsAdvice {\n	// 当目标方法抛出 UsernameException 异常时，执行当前方法\n	public void afterThrowing(UsernameException ex) {\n		System.out.println(\"发生用户名异常 ex = \" + ex.getMessage());\n	}\n	\n	// 当目标方法抛出 PasswordException 异常时，执行当前方法\n	public void afterThrowing(PasswordException ex) {\n		System.out.println(\"发生密码异常 ex = \" + ex.getMessage());\n	}\n	\n	// 当目标方法抛出其它异常时，执行当前方法\n	public void afterThrowing(Exception ex) {\n		System.out.println(\"发生异常 ex = \" + ex.getMessage());\n	}\n}\n```\n*MyTest.java*\n```\n@Test\npublic void test01() throws UserException {\n	String resource = \"top/qingrang/aop05/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\n	service.login(\"beijing\", \"222\");\n}\n```\n\n\n\n\n\n### 同时使用多种通知\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop06.SomeServiceImpl\"/>\n\n    <!-- 注册切面：通知 -->\n    <bean id=\"myBeforeAdvice\" class=\"top.qingrang.aop06.MyMethodBeforeAdvice\"/>\n    <bean id=\"myAfterAdvice\" class=\"top.qingrang.aop06.MyAfterReturningAdvice\"/>\n\n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n        <!-- 注入多种通知 -->\n    	<property name=\"interceptorNames\" value=\"myBeforeAdvice,myAfterAdvice\"/>\n    	<!-- <property name=\"interceptorNames\">\n    		<array>\n    			<value>myBeforeAdvice</value>\n    			<value>myAfterAdvice</value>\n    		</array>\n    	</property> -->\n    </bean>\n\n</beans>\n```\n\n\n### 无接口的 CGLIB 代理生成\n若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。\n*SomeService.java - 目标类*\n```\npublic class SomeService {\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n}\n```\n*MyAfterReturningAdvice.java - 后置通知*\n```\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\n	@Override\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\n		if (returnValue != null) {\n			returnValue = ((String) returnValue).toUpperCase();\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\n		}\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop07.SomeService\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop07.MyAfterReturningAdvice\"/>\n    \n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\n    </bean>\n\n</beans>\n```\n*MyTest.java*\n```\n@Test\npublic void test01() {\n	String resource = \"top/qingrang/aop07/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	SomeService service = (SomeService) ac.getBean(\"serviceProxy\");\n	service.doFirst();\n	System.out.println(\"==================\");\n	String result = service.doSecond();\n	System.out.println(result);\n}\n```\n### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性\n若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。\n\n![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)\n也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。\n![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)\n查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。\n![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)\n\n\n## 顾问 Advisor\n通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。\n\n顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**\n\nPointcutAdvisor 接口有两个较为常用的实现类：\n- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问\n- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问\n\n### 名称匹配方法切入点顾问\nNameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。\n\n`<property name=\"mappedNames\"/>`\n\n*ISomeService.java*\n```\npublic interface ISomeService {\n	// 目标方法\n	void doFirst();\n	// 目标方法\n	String doSecond();\n	// 目标方法\n	void doThird();\n}\n```\n*SomeServiceImpl.java*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n\n	@Override\n	public void doThird() {\n		System.out.println(\"执行doThird()方法\");\n	}\n}\n```\n*MyAfterReturningAdvice.java*\n```\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\n	@Override\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop09.SomeServiceImpl\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop09.MyAfterReturningAdvice\"/>\n    \n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->\n    	<!-- <property name=\"mappedName\" value=\"doFirst\"/> -->\n    	 <property name=\"mappedNames\" value=\"doFirst,doSecond\"/>\n        <!-- 使用通配符 -->\n    	<!--<property name=\"mappedNames\" value=\"*ir*\"/>-->\n    </bean>\n    \n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\n    </bean>\n\n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	// 创建容器对象，加载Spring配置文件\n	String resource = \"top/qingrang/aop09/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\n	service.doFirst();\n	System.out.println(\"==================\");\n	service.doSecond();\n	System.out.println(\"==================\");\n	service.doThird();\n}\n```\n*输出信息*\n```\n执行doFirst()方法\n执行后置通知方法  returnValue = null\n==================\n执行doSecond()方法\n执行后置通知方法  returnValue = abcde\n==================\n执行doThird()方法\n```\n### 正则表达式方法切入点顾问\nRegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。\n\n`<property name=\"pattern\"/>`\n\n这里的正则表达式常用的运算符有三个，如下表：\n\n|运算符|意义|\n|-|-|\n|.|表示任意单个字符|\n|+|表示前一个字符出现一次或多次|\n|*|表示前一个字符出现零次或多次|\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop10.SomeServiceImpl\"/>\n\n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop10.MyAfterReturningAdvice\"/>\n\n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->\n        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->\n    	<!-- <property name=\"pattern\" value=\".*doFirst\"/> -->\n    	<!-- <property name=\"patterns\" value=\".*doFirst,.*doSecond\"/> -->\n    	<!-- <property name=\"pattern\" value=\".*doFirst|.*doSecond\"/> -->\n    	<property name=\"pattern\" value=\".*S.*\"/>\n    </bean>\n\n    <!-- 生成代理对象 -->\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n    	<property name=\"target\" ref=\"someService\"/>\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\n    </bean>\n\n</beans>\n```\n## 自动代理生成器\n前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：\n1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。\n1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。\n代理类的 id：`ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");`\n目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean(\"someService\");`\n\n我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。\n\nSpring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：\n- 默认 advisor 自动代理生成器\n- Bean 名称自动代理生成器\n\n需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。\n\n自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：\n![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*\n### 默认 advisor 自动代理生成器\nDefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。\n\nDefaultAdvisorAutoProxyCreator 存在三个问题：\n1. 不能选择目标对象\n1. 不能选择切面类型，切面只能是 advisor\n1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\n    <bean id=\"someService2\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop11.MyAfterReturningAdvice\"/>\n    \n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\n    </bean>\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\n    </bean>\n    \n    <!-- 注册自动代理生成器 -->\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n    \n</beans>\n```\n*Test.java - 测试*\n```\n@Test\npublic void test01() {\n	String resource = \"top/qingrang/aop11/applicationContext.xml\";\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n	ISomeService service = (ISomeService) ac.getBean(\"someService\");\n	service.doFirst();\n	System.out.println(\"==================\");\n	service.doSecond();\n	System.out.println(\"==================\");\n	service.doThird();\n	\n	System.out.println(\"-----------------------------\");\n	\n	ISomeService service2 = (ISomeService) ac.getBean(\"someService2\");\n	service2.doFirst();\n	System.out.println(\"==================\");\n	service2.doSecond();\n	System.out.println(\"==================\");\n	service2.doThird();\n}\n```\n### Bean 名称自动代理生成器\nDefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`\n\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 注册目标对象 -->\n    <bean id=\"someService\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\n    <bean id=\"someService2\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\n    \n    <!-- 注册切面：通知 -->\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop12.MyAfterReturningAdvice\"/>\n    \n    <!-- 注册切面：顾问 -->\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\n    </bean>\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\n    	<property name=\"advice\" ref=\"myAdvice\"/>\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\n    </bean>\n    \n    <!-- 注册自动代理生成器 -->\n    <bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\n    	<property name=\"beanNames\" value=\"someService\"/>\n        <!-- 使用通知 -->\n    	<!--<property name=\"interceptorNames\" value=\"myAdvice\"/>-->\n        <!-- 使用顾问 -->\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\n    </bean>\n</beans> \n```\n## AspectJ 对 AOP 的实现（*）\n对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。\n\n**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**\n### AspectJ 的通知类型\nAspectJ 中常用的通知有五种类型：\n1. 前置通知\n1. 后置通知\n1. 环绕通知\n1. 异常通知\n1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。\n### AspectJ 的切入点表达式\nAspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：\n```\nexecution (\n	[modifiers-pattern] 访问权限类型\n	ret-type-pattern 返回值类型\n	[declaring-type-pattern] 全限定性类名\n	name-pattern(param-pattern) 方法名(参数名)\n	[throws-pattern] 抛出异常类型\n)\n```\n切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：\n\n|符号|意义|\n|-|-|\n|*|0至多个任意字符|\n|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|\n|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|\n\n*举例*\n```\nexecution(public * *(..))\n指定切入点为：任意公共方法。\n\nexecution(* set *(..))\n指定切入点为：任何一个以“set”开始的方法。\n\nexecution(* com.xyz.service.*.*(..))\n指定切入点为：定义在 service 包里的任意类的任意方法。\n\nexecution(* com.xyz.service..*.*(..))\n指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。\n\n--------------------------- 常用 --------------------------------\nexecution(* *.service.*.doSome())\n指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点\n\nexecution(* *..service.*.doSome())\n指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点\n-----------------------------------------------------------\n\nexecution(* com.xyz.service.IAccountService.*(..))\n指定切入点为： IAccountService 接口中的任意方法。\n\nexecution(* com.xyz.service.IAccountService+.*(..))\n指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。\n\nexecution(* joke(String,int)))\n指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。\n\nexecution(* joke(String,*)))\n指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。\n\nexecution(* joke(String,..)))\n指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。\n\nexecution(* joke(Object))\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。\n\nexecution(* joke(Object+)))\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。\n```\n\n\n### AspectJ 基于注解的 AOP 实现\n*ISomeService.java - service 接口*\n```\npublic interface ISomeService {\n	// 目标方法    \n	void doFirst();\n	// 目标方法\n	String doSecond();\n	// 目标方法\n	void doThird();\n}\n```\n*SomeServiceImpl.java - service 实现类*\n```\npublic class SomeServiceImpl implements ISomeService {\n	@Override\n	public void doFirst() {\n		System.out.println(\"执行doFirst()方法\");\n	}\n\n	@Override\n	public String doSecond() {\n		System.out.println(\"执行doSecond()方法\");\n		return \"abcde\";\n	}\n	\n	@Override\n	public void doThird() {\n		System.out.println(\"执行doThird()方法\" + 3 / 0);\n		System.out.println(\"执行doThird()方法\");\n	}\n}\n```\n*MyAspect.java - 切面类*\n```\n@Aspect    // 表示当前类为切面\npublic class MyAspect {\n	@Before(\"execution(* *..ISomeService.doFirst(..))\")\n	public void myBefore() {\n		System.out.println(\"执行前置通知方法\");\n	}\n\n	@Before(\"execution(* *..ISomeService.doFirst(..))\")\n	public void myBefore(JoinPoint jp) {\n		// 可以包含一个 JoinPoint 类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。\n		System.out.println(\"执行前置通知方法 jp = \" + jp);\n	}\n	\n	@AfterReturning(\"execution(* *..ISomeService.doSecond(..))\")\n	public void myAfterReturning() {\n		System.out.println(\"执行后置通知方法\");\n	}\n\n	// 后置通知获取返回值\n	// 该注解的 returning 属性就是用于指定接收方法返回值的变量名的。该变量最好为 Object 类型，因为目标方法的返回值可能是任何类型。\n	@AfterReturning(value=\"execution(* *..ISomeService.doSecond(..))\", returning=\"result\")\n	public void myAfterReturning(Object result) {\n		System.out.println(\"执行后置通知方法  result = \" + result);\n	}\n	\n	@Around(\"execution(* *..ISomeService.doSecond(..))\")\n	public Object myAround(ProceedingJoinPoint pjp) throws Throwable {\n		System.out.println(\"执行环绕通知方法，目标方法执行之前\");\n		// 执行目标方法\n		Object result = pjp.proceed();\n		System.out.println(\"执行环绕通知方法，目标方法执行之后\");\n		// 修改返回值\n		if(result != null) {\n			result = ((String)result).toUpperCase();\n		}\n		return result;\n	}\n	\n	@AfterThrowing(\"execution(* *..ISomeService.doThird(..))\")\n	public void myAfterThrowing() {\n		System.out.println(\"执行异常通知方法\");\n	}\n\n	// 指定异常\n	@AfterThrowing(value=\"doThirdPointcut()\", throwing=\"ex\")\n	public void myAfterThrowing(Exception ex) {\n		System.out.println(\"执行异常通知方法 ex = \" + ex.getMessage());\n	}\n	\n	@After(\"doThirdPointcut()\")\n	public void myAfter() {\n		System.out.println(\"执行最终通知方法\");\n	}\n	\n	// 定义了一个切入点，叫 doThirdPointcut()\n	@Pointcut(\"execution(* *..ISomeService.doThird(..))\")\n	public void doThirdPointcut(){}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n	<!-- 注册切面 -->\n	<bean id=\"myAspect\" class=\"top.qingrang.annotation.MyAspect\"/>\n	\n	<!-- 注册目标对象 -->\n	<bean id=\"someService\" class=\"top.qingrang.annotation.SomeServiceImpl\"/>\n	\n	<!-- 注册 AspectJ 的自动代理 -->\n	<aop:aspectj-autoproxy/>\n\n</beans>\n```\n*输出信息*\n```\n执行前置通知方法 jp = execution(void top.qingrang.annotation.ISomeService.doFirst())\n执行前置通知方法\n执行doFirst()方法\n----------------------------\n执行环绕通知方法，目标方法执行之前\n执行doSecond()方法\n执行环绕通知方法，目标方法执行之后\n执行后置通知方法\n执行后置通知方法  result = ABCDE\n----------------------------\n执行最终通知方法\n执行异常通知方法 ex = / by zero\n执行异常通知方法\n\njava.lang.ArithmeticException: / by zero\n```\n### AspectJ 基于 XML 的 AOP 实现\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.001569s ]
---------------------------------------------------------------
[ 2018-11-21T20:38:13+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/newedit.html
[ info ] qingrang.top/daily/admin/note/newedit.html [运行时间：0.079928s][吞吐率：12.51req/s] [内存消耗：2,021.65kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'newedit',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->newEdit[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/newedit.html [ array (
  0 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.001612s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.002678s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000437s ]
---------------------------------------------------------------
[ 2018-11-21T20:38:14+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/250.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/250.html [运行时间：0.094189s][吞吐率：10.62req/s] [内存消耗：2,338.75kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '84188',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(二) - AOP（面向切面）
[TOC]

Spring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。
## AOP 简介
### 概念
AOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。

AOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。

面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。

若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。

例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。

### 利用 JDK 动态代理实现 AOP 编程
*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*SystemService.java - 交叉业务逻辑*
```
public class SystemService {
	public static void doLog() {
		System.out.println("执行日志代码");
	}

	public static void doTx() {
		System.out.println("执行事务代码");
	}
}
```
*MyTest.java*
```
@Test
public void MyTest(){
	final ISomeService target = new SomeServiceImpl();
	// 自动生成一个动态代理对象
	ISomeService service = (ISomeService) Proxy.newProxyInstance(
			target.getClass().getClassLoader(), // 目标类的类加载器
			target.getClass().getInterfaces(),  // 目标类实现的接口数组
			new InvocationHandler() { //业务增强逻辑
				// 具体加强的代码逻辑
				@Override
				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
					SystemService.doTx(); // 织入
					Object result = method.invoke(target, args); // 执行目标方法
					SystemService.doLog(); // 织入
					return result;
				}
			});
	service.doFirst();
	System.out.println("==============");
	service.doSecond();
}
```
*输出信息*
```
执行事务代码
执行doFirst()方法
执行日志代码
==============
执行事务代码
执行doSecond()方法
执行日志代码
```
## AOP 编程术语
### 切面（Aspect）
切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。
### 织入（Weaving）
织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。
### 连接点（JoinPoint）
连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。
### 切入点（Pointcut）
切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。
### 目标对象（Target）
目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。
### 通知（Advice）
通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。

**切入点定义切入的位置，通知定义切入的时间。**
### 顾问（Advisor）
顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。






## 通知 Advice
通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。

常用通知有：前置通知、后置通知、环绕通知、异常处理通知。
### 前置通知 MethodBeforeAdvice
定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：
- 在目标方法执行之前先执行。
- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*ISomeService.java - 主业务接口*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	void doSecond();
}
```
*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public void doSecond() {
		System.out.println("执行doSecond()方法");
	}
}
```
*MyMethodBeforeAdvice.java - 前置通知*
```
public class MyMethodBeforeAdvice implements MethodBeforeAdvice {

	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象
	@Override
	public void before(Method method, Object[] args, Object target) throws Throwable {
		// 对于目标方法的增强代码就应该写在这里
		System.out.println("执行前置通知方法");
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop01.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop01.MyMethodBeforeAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<!-- 指定目标对象，随便用哪个 -->
    	<!-- <property name="targetName" value="someService"/> -->
    	<property name="target" ref="someService"/>
		
    	<!-- 指定切面 -->
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>
</beans>
```

### 后置通知 AfterReturningAdvice
定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：
- 在目标方法执行之后执行。
- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。
- 不改变目标方法执行的结果。

*SomeServiceImpl.java - 目标类*
```
public class SomeServiceImpl implements ISomeService {

	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
### 环绕通知 MethodInterceptor
定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。

*MyMethodInterceptor.java*
```
// 环绕通知：可以修改目标方法的返回结果
public class MyMethodInterceptor implements MethodInterceptor {
	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		System.out.println("执行环绕通知：目标方法执行之前");
		// 执行目标方法
		Object result = invocation.proceed();
		System.out.println("执行环绕通知：目标方法执行之后");
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
}
```





### 异常通知 ThrowsAdvice
定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。

不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：
![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)
不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。
#### 普通异常
*SomeServiceImpl.java - 目标类*
```
@Override
public void doFirst() {
	System.out.println("执行doFirst()方法" + 3 / 0);
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("执行异常通知方法");
	}
}
```
*输出信息*
```
执行异常通知方法
java.lang.ArithmeticException: / by zero
	...
```
#### 自定义异常
异常分两种：
- 运行时异常，不进行处理，也可以通过编译。
若一个类继承自 RunTimeException，则该异常就是运行时异常
- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。
若一个类继承自 Exception，则该异常就是受查异常

*UserException.java*
```
public class UserException extends Exception {
	public UserException() {
		super();
	}

	public UserException(String message) {
		super(message);
	}
}
```
*UsernameException.java*
```
public class UsernameException extends UserException {
	public UsernameException() {
		super();
	}

	public UsernameException(String message) {
		super(message);
	}
}
```
*PasswordException.java*
```
public class PasswordException extends UserException {
	public PasswordException() {
		super();
	}

	public PasswordException(String message) {
		super(message);
	}
}
```
*MyThrowsAdvice.java - 异常通知*
```
public class MyThrowsAdvice implements ThrowsAdvice {
	// 当目标方法抛出 UsernameException 异常时，执行当前方法
	public void afterThrowing(UsernameException ex) {
		System.out.println("发生用户名异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出 PasswordException 异常时，执行当前方法
	public void afterThrowing(PasswordException ex) {
		System.out.println("发生密码异常 ex = " + ex.getMessage());
	}
	
	// 当目标方法抛出其它异常时，执行当前方法
	public void afterThrowing(Exception ex) {
		System.out.println("发生异常 ex = " + ex.getMessage());
	}
}
```
*MyTest.java*
```
@Test
public void test01() throws UserException {
	String resource = "top/qingrang/aop05/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.login("beijing", "222");
}
```





### 同时使用多种通知
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop06.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myBeforeAdvice" class="top.qingrang.aop06.MyMethodBeforeAdvice"/>
    <bean id="myAfterAdvice" class="top.qingrang.aop06.MyAfterReturningAdvice"/>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
        <!-- 注入多种通知 -->
    	<property name="interceptorNames" value="myBeforeAdvice,myAfterAdvice"/>
    	<!-- <property name="interceptorNames">
    		<array>
    			<value>myBeforeAdvice</value>
    			<value>myAfterAdvice</value>
    		</array>
    	</property> -->
    </bean>

</beans>
```


### 无接口的 CGLIB 代理生成
若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。
*SomeService.java - 目标类*
```
public class SomeService {
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
}
```
*MyAfterReturningAdvice.java - 后置通知*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
		if (returnValue != null) {
			returnValue = ((String) returnValue).toUpperCase();
			System.out.println("修改过的结果  returnValue = " + returnValue);
		}
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop07.SomeService"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop07.MyAfterReturningAdvice"/>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvice"/>
    </bean>

</beans>
```
*MyTest.java*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop07/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	SomeService service = (SomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	String result = service.doSecond();
	System.out.println(result);
}
```
### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性
若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。

![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)
也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。
![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)
查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。
![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)


## 顾问 Advisor
通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。

顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**

PointcutAdvisor 接口有两个较为常用的实现类：
- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问
- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问

### 名称匹配方法切入点顾问
NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。

`<property name="mappedNames"/>`

*ISomeService.java*
```
public interface ISomeService {
	// 目标方法
	void doFirst();
	// 目标方法
	String doSecond();
	// 目标方法
	void doThird();
}
```
*SomeServiceImpl.java*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}

	@Override
	public void doThird() {
		System.out.println("执行doThird()方法");
	}
}
```
*MyAfterReturningAdvice.java*
```
public class MyAfterReturningAdvice implements AfterReturningAdvice {
	// 在目标方法执行之后执行，returnValue：目标方法的返回值
	@Override
	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
		System.out.println("执行后置通知方法  returnValue = " + returnValue);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop09.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop09.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->
    	<!-- <property name="mappedName" value="doFirst"/> -->
    	 <property name="mappedNames" value="doFirst,doSecond"/>
        <!-- 使用通配符 -->
    	<!--<property name="mappedNames" value="*ir*"/>-->
    </bean>
    
    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	// 创建容器对象，加载Spring配置文件
	String resource = "top/qingrang/aop09/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("serviceProxy");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
}
```
*输出信息*
```
执行doFirst()方法
执行后置通知方法  returnValue = null
==================
执行doSecond()方法
执行后置通知方法  returnValue = abcde
==================
执行doThird()方法
```
### 正则表达式方法切入点顾问
RegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。

`<property name="pattern"/>`

这里的正则表达式常用的运算符有三个，如下表：

|运算符|意义|
|-|-|
|.|表示任意单个字符|
|+|表示前一个字符出现一次或多次|
|*|表示前一个字符出现零次或多次|

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop10.SomeServiceImpl"/>

    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop10.MyAfterReturningAdvice"/>

    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->
        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->
    	<!-- <property name="pattern" value=".*doFirst"/> -->
    	<!-- <property name="patterns" value=".*doFirst,.*doSecond"/> -->
    	<!-- <property name="pattern" value=".*doFirst|.*doSecond"/> -->
    	<property name="pattern" value=".*S.*"/>
    </bean>

    <!-- 生成代理对象 -->
    <bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    	<property name="target" ref="someService"/>
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>

</beans>
```
## 自动代理生成器
前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：
1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。
1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。
代理类的 id：`ISomeService service = (ISomeService) ac.getBean("serviceProxy");`
目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean("someService");`

我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。

Spring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：
- 默认 advisor 自动代理生成器
- Bean 名称自动代理生成器

需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。

自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：
![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*
### 默认 advisor 自动代理生成器
DefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。

DefaultAdvisorAutoProxyCreator 存在三个问题：
1. 不能选择目标对象
1. 不能选择切面类型，切面只能是 advisor
1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop11.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop11.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop11.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>
    
</beans>
```
*Test.java - 测试*
```
@Test
public void test01() {
	String resource = "top/qingrang/aop11/applicationContext.xml";
	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
	ISomeService service = (ISomeService) ac.getBean("someService");
	service.doFirst();
	System.out.println("==================");
	service.doSecond();
	System.out.println("==================");
	service.doThird();
	
	System.out.println("-----------------------------");
	
	ISomeService service2 = (ISomeService) ac.getBean("someService2");
	service2.doFirst();
	System.out.println("==================");
	service2.doSecond();
	System.out.println("==================");
	service2.doThird();
}
```
### Bean 名称自动代理生成器
DefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`

*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 注册目标对象 -->
    <bean id="someService" class="top.qingrang.aop12.SomeServiceImpl"/>
    <bean id="someService2" class="top.qingrang.aop12.SomeServiceImpl"/>
    
    <!-- 注册切面：通知 -->
    <bean id="myAdvice" class="top.qingrang.aop12.MyAfterReturningAdvice"/>
    
    <!-- 注册切面：顾问 -->
    <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doFirst"/>
    </bean>
    <bean id="myAdvisor2" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    	<property name="advice" ref="myAdvice"/>
    	<property name="mappedNames" value="doSecond"/>
    </bean>
    
    <!-- 注册自动代理生成器 -->
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
    	<property name="beanNames" value="someService"/>
        <!-- 使用通知 -->
    	<!--<property name="interceptorNames" value="myAdvice"/>-->
        <!-- 使用顾问 -->
    	<property name="interceptorNames" value="myAdvisor"/>
    </bean>
</beans>
```
## AspectJ 对 AOP 的实现（*）
对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。

**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**
### AspectJ 的通知类型
AspectJ 中常用的通知有五种类型：
1. 前置通知
1. 后置通知
1. 环绕通知
1. 异常通知
1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。
### AspectJ 的切入点表达式
AspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：
```
execution (
	[modifiers-pattern] 访问权限类型
	ret-type-pattern 返回值类型
	[declaring-type-pattern] 全限定性类名
	name-pattern(param-pattern) 方法名(参数名)
	[throws-pattern] 抛出异常类型
)
```
切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：

|符号|意义|
|-|-|
|*|0至多个任意字符|
|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|
|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|

*举例*
```
execution(public * *(..))
指定切入点为：任意公共方法。

execution(* set *(..))
指定切入点为：任何一个以“set”开始的方法。

execution(* com.xyz.service.*.*(..))
指定切入点为：定义在 service 包里的任意类的任意方法。

execution(* com.xyz.service..*.*(..))
指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。

--------------------------- 常用 --------------------------------
execution(* *.service.*.doSome())
指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点

execution(* *..service.*.doSome())
指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点
-----------------------------------------------------------

execution(* com.xyz.service.IAccountService.*(..))
指定切入点为： IAccountService 接口中的任意方法。

execution(* com.xyz.service.IAccountService+.*(..))
指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。

execution(* joke(String,int)))
指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。

execution(* joke(String,*)))
指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。

execution(* joke(String,..)))
指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。

execution(* joke(Object))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。

execution(* joke(Object+)))
指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。
```


### AspectJ 基于注解的 AOP 实现
*ISomeService.java - service 接口*
```
public interface ISomeService {
	// 目标方法    
	void doFirst();
	// 目标方法
	String doSecond();
	// 目标方法
	void doThird();
}
```
*SomeServiceImpl.java - service 实现类*
```
public class SomeServiceImpl implements ISomeService {
	@Override
	public void doFirst() {
		System.out.println("执行doFirst()方法");
	}

	@Override
	public String doSecond() {
		System.out.println("执行doSecond()方法");
		return "abcde";
	}
	
	@Override
	public void doThird() {
		System.out.println("执行doThird()方法" + 3 / 0);
		System.out.println("执行doThird()方法");
	}
}
```
*MyAspect.java - 切面类*
```
@Aspect    // 表示当前类为切面
public class MyAspect {
	@Before("execution(* *..ISomeService.doFirst(..))")
	public void myBefore() {
		System.out.println("执行前置通知方法");
	}

	@Before("execution(* *..ISomeService.doFirst(..))")
	public void myBefore(JoinPoint jp) {
		// 可以包含一个 JoinPoint 类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。
		System.out.println("执行前置通知方法 jp = " + jp);
	}
	
	@AfterReturning("execution(* *..ISomeService.doSecond(..))")
	public void myAfterReturning() {
		System.out.println("执行后置通知方法");
	}

	// 后置通知获取返回值
	// 该注解的 returning 属性就是用于指定接收方法返回值的变量名的。该变量最好为 Object 类型，因为目标方法的返回值可能是任何类型。
	@AfterReturning(value="execution(* *..ISomeService.doSecond(..))", returning="result")
	public void myAfterReturning(Object result) {
		System.out.println("执行后置通知方法  result = " + result);
	}
	
	@Around("execution(* *..ISomeService.doSecond(..))")
	public Object myAround(ProceedingJoinPoint pjp) throws Throwable {
		System.out.println("执行环绕通知方法，目标方法执行之前");
		// 执行目标方法
		Object result = pjp.proceed();
		System.out.println("执行环绕通知方法，目标方法执行之后");
		// 修改返回值
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
	
	@AfterThrowing("execution(* *..ISomeService.doThird(..))")
	public void myAfterThrowing() {
		System.out.println("执行异常通知方法");
	}

	// 指定异常
	@AfterThrowing(value="doThirdPointcut()", throwing="ex")
	public void myAfterThrowing(Exception ex) {
		System.out.println("执行异常通知方法 ex = " + ex.getMessage());
	}
	
	@After("doThirdPointcut()")
	public void myAfter() {
		System.out.println("执行最终通知方法");
	}
	
	// 定义了一个切入点，叫 doThirdPointcut()
	@Pointcut("execution(* *..ISomeService.doThird(..))")
	public void doThirdPointcut(){}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd">

	<!-- 注册切面 -->
	<bean id="myAspect" class="top.qingrang.annotation.MyAspect"/>
	
	<!-- 注册目标对象 -->
	<bean id="someService" class="top.qingrang.annotation.SomeServiceImpl"/>
	
	<!-- 注册 AspectJ 的自动代理 -->
	<aop:aspectj-autoproxy/>

</beans>
```
*输出信息*
```
执行前置通知方法 jp = execution(void top.qingrang.annotation.ISomeService.doFirst())
执行前置通知方法
执行doFirst()方法
----------------------------
执行环绕通知方法，目标方法执行之前
执行doSecond()方法
执行环绕通知方法，目标方法执行之后
执行后置通知方法
执行后置通知方法  result = ABCDE
----------------------------
执行最终通知方法
执行异常通知方法 ex = / by zero
执行异常通知方法

java.lang.ArithmeticException: / by zero
```
### AspectJ 基于 XML 的 AOP 实现
*MyAspect.java*
```
public class MyAspect {
	
	public void myBefore() {
		System.out.println("执行前置通知方法");
	}
	
	public void myBefore(JoinPoint jp) {
		System.out.println("执行前置通知方法 jp = " + jp);
	}
	
	public void myAfterReturning() {
		System.out.println("执行后置通知方法");
	}
	
	public void myAfterReturning(Object result) {
		System.out.println("执行后置通知方法  result = " + result);
	}
	
	public Object myAround(ProceedingJoinPoint pjp) throws Throwable {
		System.out.println("执行环绕通知方法，目标方法执行之前");
		// 执行目标方法
		Object result = pjp.proceed();
		System.out.println("执行环绕通知方法，目标方法执行之后");
		if(result != null) {
			result = ((String)result).toUpperCase();
		}
		return result;
	}
	
	public void myAfterThrowing() {
		System.out.println("执行异常通知方法");
	}
	
	public void myAfterThrowing(Exception ex) {
		System.out.println("执行异常通知方法 ex = " + ex.getMessage());
	}
	
	public void myAfter() {
		System.out.println("执行最终通知方法");
	}
	
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd">

	<!-- 注册切面 -->
	<bean id="myAspect" class="top.qingrang.xml.MyAspect"/>
	
	<!-- 注册目标对象 -->
	<bean id="someService" class="top.qingrang.xml.SomeServiceImpl"/>
	
	<!-- AOP 配置 -->
	<aop:config>
		<aop:pointcut expression="execution(* *..ISomeService.doFirst(..))" id="doFirstPointcut"/>
		<aop:pointcut expression="execution(* *..ISomeService.doSecond(..))" id="doSecondPointcut"/>
		<aop:pointcut expression="execution(* *..ISomeService.doThird(..))" id="doThirdPointcut"/>
		
		<aop:aspect ref="myAspect">
			<aop:before method="myBefore" pointcut-ref="doFirstPointcut"/>
			<aop:before method="myBefore(org.aspectj.lang.JoinPoint)" pointcut-ref="doFirstPointcut"/>
			
			<aop:after-returning method="myAfterReturning" pointcut-ref="doSecondPointcut"/>
			<aop:after-returning method="myAfterReturning(java.lang.Object)" pointcut-ref="doSecondPointcut" returning="result"/>

			<aop:around method="myAround" pointcut-ref="doSecondPointcut"/>

			<aop:after-throwing method="myAfterThrowing" pointcut-ref="doThirdPointcut"/>
			<aop:after-throwing method="myAfterThrowing(java.lang.Exception)" pointcut-ref="doThirdPointcut" throwing="ex"/>

			<aop:after method="myAfter" pointcut-ref="doThirdPointcut"/>
		</aop:aspect>
	</aop:config>

</beans>
```',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000720s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001716s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.001136s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000399s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001190s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000354s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000319s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=250,`p_id`=2,`title`='Spring(二) - AOP（面向切面）\r',`content`='# Spring(二) - AOP（面向切面）\r\n[TOC]\r\n\r\nSpring 是一个基于 **IOC** 和 **AOP** 的结构 J2EE 系统的框架。\r\n## AOP 简介\r\n### 概念\r\nAOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。\r\n\r\nAOP 底层，就是采用动态代理模式实现的。采用了两种代理： JDK 的动态代理，与 CGLIB 的动态代理。\r\n\r\n面向切面编程，就是将交叉业务逻辑封装成切面，利用 AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。\r\n\r\n若不使用 AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。\r\n\r\n例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，而这些业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑---转账。\r\n\r\n### 利用 JDK 动态代理实现 AOP 编程\r\n*ISomeService.java - 主业务接口*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法\r\n	void doFirst();\r\n	// 目标方法\r\n	void doSecond();\r\n}\r\n```\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public void doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n	}\r\n}\r\n```\r\n*SystemService.java - 交叉业务逻辑*\r\n```\r\npublic class SystemService {\r\n	public static void doLog() {\r\n		System.out.println(\"执行日志代码\");\r\n	}\r\n\r\n	public static void doTx() {\r\n		System.out.println(\"执行事务代码\");\r\n	}\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void MyTest(){\r\n	final ISomeService target = new SomeServiceImpl();\r\n	// 自动生成一个动态代理对象\r\n	ISomeService service = (ISomeService) Proxy.newProxyInstance(\r\n			target.getClass().getClassLoader(), // 目标类的类加载器\r\n			target.getClass().getInterfaces(),  // 目标类实现的接口数组\r\n			new InvocationHandler() { //业务增强逻辑\r\n				// 具体加强的代码逻辑\r\n				@Override\r\n				public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n					SystemService.doTx(); // 织入\r\n					Object result = method.invoke(target, args); // 执行目标方法\r\n					SystemService.doLog(); // 织入\r\n					return result;\r\n				}\r\n			});\r\n	service.doFirst();\r\n	System.out.println(\"==============\");\r\n	service.doSecond();\r\n}\r\n```\r\n*输出信息*\r\n```\r\n执行事务代码\r\n执行doFirst()方法\r\n执行日志代码\r\n==============\r\n执行事务代码\r\n执行doSecond()方法\r\n执行日志代码\r\n```\r\n## AOP 编程术语\r\n### 切面（Aspect）\r\n切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。\r\n### 织入（Weaving）\r\n织入是指将切面代码插入到目标对象的过程。上例中 MyInvocationHandler 类中的 invoke() 方法完成的工作，就可以称为织入。\r\n### 连接点（JoinPoint）\r\n连接点指可以被切面织入的方法。通常业务接口中的方法均为连接点。\r\n### 切入点（Pointcut）\r\n切入点指切面具体织入的方法。在 StudentServiceImpl 类中，若 doSome()将被增强，而doOther()不被增强，则 doSome()为切入点，而 doOther()仅为连接点。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改，不能被增强的。\r\n### 目标对象（Target）\r\n目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的 StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。\r\n### 通知（Advice）\r\n通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说，通知定义了增强码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。\r\n\r\n**切入点定义切入的位置，通知定义切入的时间。**\r\n### 顾问（Advisor）\r\n顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 通知 Advice\r\n通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。\r\n\r\n常用通知有：前置通知、后置通知、环绕通知、异常处理通知。\r\n### 前置通知 MethodBeforeAdvice\r\n定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点：\r\n- 在目标方法执行之前先执行。\r\n- 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。\r\n- 不改变目标方法执行的结果。\r\n\r\n*ISomeService.java - 主业务接口*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法\r\n	void doFirst();\r\n	// 目标方法\r\n	void doSecond();\r\n}\r\n```\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public void doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n	}\r\n}\r\n```\r\n*MyMethodBeforeAdvice.java - 前置通知*\r\n```\r\npublic class MyMethodBeforeAdvice implements MethodBeforeAdvice {\r\n\r\n	// 当前方法在目标方法执行之前执行，method:目标方法，args:目标方法的参数列表，target:目标对象\r\n	@Override\r\n	public void before(Method method, Object[] args, Object target) throws Throwable {\r\n		// 对于目标方法的增强代码就应该写在这里\r\n		System.out.println(\"执行前置通知方法\");\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop01.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop01.MyMethodBeforeAdvice\"/>\r\n\r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<!-- 指定目标对象，随便用哪个 -->\r\n    	<!-- <property name=\"targetName\" value=\"someService\"/> -->\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n		\r\n    	<!-- 指定切面 -->\r\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n### 后置通知 AfterReturningAdvice\r\n定义后置通知，需要实现接口 AfterReturningAdvice。该接口中有一个方法 afterReturning()，会在目标方法执行之后执行。后置通知的特点：\r\n- 在目标方法执行之后执行。\r\n- 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。\r\n- 不改变目标方法执行的结果。\r\n\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n}\r\n```\r\n*MyAfterReturningAdvice.java - 后置通知*\r\n```\r\n// 后置通知：可以获取到目标方法的返回结果，但无法改变目标方法的结果\r\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\r\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\r\n	@Override\r\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\r\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\r\n		if (returnValue != null) {\r\n			returnValue = ((String) returnValue).toUpperCase();\r\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\r\n		}\r\n	}\r\n}\r\n```\r\n### 环绕通知 MethodInterceptor\r\n定义环绕通知(在目标方法执行之前之后都会执行)，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。\r\n\r\n*MyMethodInterceptor.java*\r\n```\r\n// 环绕通知：可以修改目标方法的返回结果\r\npublic class MyMethodInterceptor implements MethodInterceptor {\r\n	@Override\r\n	public Object invoke(MethodInvocation invocation) throws Throwable {\r\n		System.out.println(\"执行环绕通知：目标方法执行之前\");\r\n		// 执行目标方法\r\n		Object result = invocation.proceed();\r\n		System.out.println(\"执行环绕通知：目标方法执行之后\");\r\n		if(result != null) {\r\n			result = ((String)result).toUpperCase();\r\n		}\r\n		return result;\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 异常通知 ThrowsAdvice\r\n定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。\r\n\r\n不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 `afterThrowing()`。这个方法重载了四种形式。由于使用时，一般只使用其中一种，若要都定义到接口中，则势必要使程序员在使用时必须要实现这四个方法。这是很麻烦的。所以就将该接口定义为了标识接口（没有方法的接口）。这四个方法在打开 `ThrowsAdvice` 源码后，上侧的注释部分可以看到：\r\n![afterThrowing()](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-10-59-26.png)\r\n不过，在这四种形式中，常用的形式如下： `public void afterThrowing(自定义的异常类 e)` 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。其它参数则与前面两个通知中方法的参数意义相同。\r\n#### 普通异常\r\n*SomeServiceImpl.java - 目标类*\r\n```\r\n@Override\r\npublic void doFirst() {\r\n	System.out.println(\"执行doFirst()方法\" + 3 / 0);\r\n}\r\n```\r\n*MyThrowsAdvice.java - 异常通知*\r\n```\r\npublic class MyThrowsAdvice implements ThrowsAdvice {\r\n	// 当目标方法抛出与指定类型的异常具有 is-a 关系的异常时，执行当前方法\r\n	public void afterThrowing(Exception ex) {\r\n		System.out.println(\"执行异常通知方法\");\r\n	}\r\n}\r\n```\r\n*输出信息*\r\n```\r\n执行异常通知方法\r\njava.lang.ArithmeticException: / by zero\r\n	...\r\n```\r\n#### 自定义异常\r\n异常分两种：\r\n- 运行时异常，不进行处理，也可以通过编译。\r\n若一个类继承自 RunTimeException，则该异常就是运行时异常\r\n- 编译时异常(受查异常,Checked Exception)，不进行处理，将无法通过编译。\r\n若一个类继承自 Exception，则该异常就是受查异常\r\n\r\n*UserException.java*\r\n```\r\npublic class UserException extends Exception {\r\n	public UserException() {\r\n		super();\r\n	}\r\n\r\n	public UserException(String message) {\r\n		super(message);\r\n	}\r\n}\r\n```\r\n*UsernameException.java*\r\n```\r\npublic class UsernameException extends UserException {\r\n	public UsernameException() {\r\n		super();\r\n	}\r\n\r\n	public UsernameException(String message) {\r\n		super(message);\r\n	}\r\n}\r\n```\r\n*PasswordException.java*\r\n```\r\npublic class PasswordException extends UserException {\r\n	public PasswordException() {\r\n		super();\r\n	}\r\n\r\n	public PasswordException(String message) {\r\n		super(message);\r\n	}\r\n}\r\n```\r\n*MyThrowsAdvice.java - 异常通知*\r\n```\r\npublic class MyThrowsAdvice implements ThrowsAdvice {\r\n	// 当目标方法抛出 UsernameException 异常时，执行当前方法\r\n	public void afterThrowing(UsernameException ex) {\r\n		System.out.println(\"发生用户名异常 ex = \" + ex.getMessage());\r\n	}\r\n	\r\n	// 当目标方法抛出 PasswordException 异常时，执行当前方法\r\n	public void afterThrowing(PasswordException ex) {\r\n		System.out.println(\"发生密码异常 ex = \" + ex.getMessage());\r\n	}\r\n	\r\n	// 当目标方法抛出其它异常时，执行当前方法\r\n	public void afterThrowing(Exception ex) {\r\n		System.out.println(\"发生异常 ex = \" + ex.getMessage());\r\n	}\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() throws UserException {\r\n	String resource = \"top/qingrang/aop05/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\r\n	service.login(\"beijing\", \"222\");\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 同时使用多种通知\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop06.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myBeforeAdvice\" class=\"top.qingrang.aop06.MyMethodBeforeAdvice\"/>\r\n    <bean id=\"myAfterAdvice\" class=\"top.qingrang.aop06.MyAfterReturningAdvice\"/>\r\n\r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n        <!-- 注入多种通知 -->\r\n    	<property name=\"interceptorNames\" value=\"myBeforeAdvice,myAfterAdvice\"/>\r\n    	<!-- <property name=\"interceptorNames\">\r\n    		<array>\r\n    			<value>myBeforeAdvice</value>\r\n    			<value>myAfterAdvice</value>\r\n    		</array>\r\n    	</property> -->\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n### 无接口的 CGLIB 代理生成\r\n若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理。\r\n*SomeService.java - 目标类*\r\n```\r\npublic class SomeService {\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n}\r\n```\r\n*MyAfterReturningAdvice.java - 后置通知*\r\n```\r\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\r\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\r\n	@Override\r\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\r\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\r\n		if (returnValue != null) {\r\n			returnValue = ((String) returnValue).toUpperCase();\r\n			System.out.println(\"修改过的结果  returnValue = \" + returnValue);\r\n		}\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop07.SomeService\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop07.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n    	<property name=\"interceptorNames\" value=\"myAdvice\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*MyTest.java*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/aop07/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	SomeService service = (SomeService) ac.getBean(\"serviceProxy\");\r\n	service.doFirst();\r\n	System.out.println(\"==================\");\r\n	String result = service.doSecond();\r\n	System.out.println(result);\r\n}\r\n```\r\n### 有接口的 CGLIB 代理生成 - proxyTargetClass 属性\r\n若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。\r\n\r\n![CGLIB 代理](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-44-48.png)\r\n也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。\r\n![optimize（优化）](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-22.png)\r\n查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。\r\n![后台运行情况](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-19-12-45-57.png)\r\n\r\n\r\n## 顾问 Advisor\r\n通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。\r\n\r\n顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。`PointcutAdvisor(切入点顾问)` 是顾问的一种， 可以指定具体的切入点。 **顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。**\r\n\r\nPointcutAdvisor 接口有两个较为常用的实现类：\r\n- NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问\r\n- RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问\r\n\r\n### 名称匹配方法切入点顾问\r\nNameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。\r\n\r\n`<property name=\"mappedNames\"/>`\r\n\r\n*ISomeService.java*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法\r\n	void doFirst();\r\n	// 目标方法\r\n	String doSecond();\r\n	// 目标方法\r\n	void doThird();\r\n}\r\n```\r\n*SomeServiceImpl.java*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n\r\n	@Override\r\n	public void doThird() {\r\n		System.out.println(\"执行doThird()方法\");\r\n	}\r\n}\r\n```\r\n*MyAfterReturningAdvice.java*\r\n```\r\npublic class MyAfterReturningAdvice implements AfterReturningAdvice {\r\n	// 在目标方法执行之后执行，returnValue：目标方法的返回值\r\n	@Override\r\n	public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\r\n		System.out.println(\"执行后置通知方法  returnValue = \" + returnValue);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop09.SomeServiceImpl\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop09.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<!-- 指定切入点：这里匹配的对象是简单方法名 -->\r\n    	<!-- <property name=\"mappedName\" value=\"doFirst\"/> -->\r\n    	 <property name=\"mappedNames\" value=\"doFirst,doSecond\"/>\r\n        <!-- 使用通配符 -->\r\n    	<!--<property name=\"mappedNames\" value=\"*ir*\"/>-->\r\n    </bean>\r\n    \r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	// 创建容器对象，加载Spring配置文件\r\n	String resource = \"top/qingrang/aop09/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");\r\n	service.doFirst();\r\n	System.out.println(\"==================\");\r\n	service.doSecond();\r\n	System.out.println(\"==================\");\r\n	service.doThird();\r\n}\r\n```\r\n*输出信息*\r\n```\r\n执行doFirst()方法\r\n执行后置通知方法  returnValue = null\r\n==================\r\n执行doSecond()方法\r\n执行后置通知方法  returnValue = abcde\r\n==================\r\n执行doThird()方法\r\n```\r\n### 正则表达式方法切入点顾问\r\nRegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。\r\n\r\n`<property name=\"pattern\"/>`\r\n\r\n这里的正则表达式常用的运算符有三个，如下表：\r\n\r\n|运算符|意义|\r\n|-|-|\r\n|.|表示任意单个字符|\r\n|+|表示前一个字符出现一次或多次|\r\n|*|表示前一个字符出现零次或多次|\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop10.SomeServiceImpl\"/>\r\n\r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop10.MyAfterReturningAdvice\"/>\r\n\r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<!-- 这里的正则表达式匹配的对象是「全限定性方法名」 -->\r\n        <!-- 全限定性方法名：com.bjpowernode.aop10.ISomeService.doFirst -->\r\n    	<!-- <property name=\"pattern\" value=\".*doFirst\"/> -->\r\n    	<!-- <property name=\"patterns\" value=\".*doFirst,.*doSecond\"/> -->\r\n    	<!-- <property name=\"pattern\" value=\".*doFirst|.*doSecond\"/> -->\r\n    	<property name=\"pattern\" value=\".*S.*\"/>\r\n    </bean>\r\n\r\n    <!-- 生成代理对象 -->\r\n    <bean id=\"serviceProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\r\n    	<property name=\"target\" ref=\"someService\"/>\r\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n## 自动代理生成器\r\n前面代码中所使用的代理对象，均是由 ProxyFactoryBean 代理工具类生成的。而该代理工具类存在着如下缺点：\r\n1. 一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。\r\n1. 在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的id。\r\n代理类的 id：`ISomeService service = (ISomeService) ac.getBean(\"serviceProxy\");`\r\n目标对象 Bean 的id：`ISomeService service = (ISomeService) ac.getBean(\"someService\");`\r\n\r\n我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。\r\n\r\nSpring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个：\r\n- 默认 advisor 自动代理生成器\r\n- Bean 名称自动代理生成器\r\n\r\n需要注意的是，自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。\r\n\r\n自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码：\r\n![自动代理生成器继承关系](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-09-44-02.png)*自动代理生成器，均是继承自 BeanPostProcessor*\r\n### 默认 advisor 自动代理生成器\r\nDefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。\r\n\r\nDefaultAdvisorAutoProxyCreator 存在三个问题：\r\n1. 不能选择目标对象\r\n1. 不能选择切面类型，切面只能是 advisor\r\n1. 不能选择 advisor，所以 advisor 均将被作为切面织入到目标方法\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\r\n    <bean id=\"someService2\" class=\"top.qingrang.aop11.SomeServiceImpl\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop11.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\r\n    </bean>\r\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\r\n    </bean>\r\n    \r\n    <!-- 注册自动代理生成器 -->\r\n    <bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\r\n    \r\n</beans>\r\n```\r\n*Test.java - 测试*\r\n```\r\n@Test\r\npublic void test01() {\r\n	String resource = \"top/qingrang/aop11/applicationContext.xml\";\r\n	ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n	ISomeService service = (ISomeService) ac.getBean(\"someService\");\r\n	service.doFirst();\r\n	System.out.println(\"==================\");\r\n	service.doSecond();\r\n	System.out.println(\"==================\");\r\n	service.doThird();\r\n	\r\n	System.out.println(\"-----------------------------\");\r\n	\r\n	ISomeService service2 = (ISomeService) ac.getBean(\"someService2\");\r\n	service2.doFirst();\r\n	System.out.println(\"==================\");\r\n	service2.doSecond();\r\n	System.out.println(\"==================\");\r\n	service2.doThird();\r\n}\r\n```\r\n### Bean 名称自动代理生成器\r\nDefaultAdvisorAutoProxyCreator 会为每一个目标对象织入所有匹配的 Advisor，不具有选择性，且切面只能是顾问 Advisor。而 BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且`切面既可以是顾问 Advisor 又可以是通知 Advice。`\r\n\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!-- 注册目标对象 -->\r\n    <bean id=\"someService\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\r\n    <bean id=\"someService2\" class=\"top.qingrang.aop12.SomeServiceImpl\"/>\r\n    \r\n    <!-- 注册切面：通知 -->\r\n    <bean id=\"myAdvice\" class=\"top.qingrang.aop12.MyAfterReturningAdvice\"/>\r\n    \r\n    <!-- 注册切面：顾问 -->\r\n    <bean id=\"myAdvisor\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doFirst\"/>\r\n    </bean>\r\n    <bean id=\"myAdvisor2\" class=\"org.springframework.aop.support.NameMatchMethodPointcutAdvisor\">\r\n    	<property name=\"advice\" ref=\"myAdvice\"/>\r\n    	<property name=\"mappedNames\" value=\"doSecond\"/>\r\n    </bean>\r\n    \r\n    <!-- 注册自动代理生成器 -->\r\n    <bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\r\n    	<property name=\"beanNames\" value=\"someService\"/>\r\n        <!-- 使用通知 -->\r\n    	<!--<property name=\"interceptorNames\" value=\"myAdvice\"/>-->\r\n        <!-- 使用顾问 -->\r\n    	<property name=\"interceptorNames\" value=\"myAdvisor\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n## AspectJ 对 AOP 的实现（*）\r\n对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一，可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。所以， Spring 又将 AspectJ 的对于 AOP 的实现也引入到了自己的框架中。\r\n\r\n**在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式。**\r\n### AspectJ 的通知类型\r\nAspectJ 中常用的通知有五种类型：\r\n1. 前置通知\r\n1. 后置通知\r\n1. 环绕通知\r\n1. 异常通知\r\n1. 最终通知：最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 `try..catch` 中的`finally` 代码块。\r\n### AspectJ 的切入点表达式\r\nAspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是：\r\n```\r\nexecution (\r\n	[modifiers-pattern] 访问权限类型\r\n	ret-type-pattern 返回值类型\r\n	[declaring-type-pattern] 全限定性类名\r\n	name-pattern(param-pattern) 方法名(参数名)\r\n	[throws-pattern] 抛出异常类型\r\n)\r\n```\r\n切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。 注意，表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号：\r\n\r\n|符号|意义|\r\n|-|-|\r\n|*|0至多个任意字符|\r\n|..|用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径|\r\n|+|用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类|\r\n\r\n*举例*\r\n```\r\nexecution(public * *(..))\r\n指定切入点为：任意公共方法。\r\n\r\nexecution(* set *(..))\r\n指定切入点为：任何一个以“set”开始的方法。\r\n\r\nexecution(* com.xyz.service.*.*(..))\r\n指定切入点为：定义在 service 包里的任意类的任意方法。\r\n\r\nexecution(* com.xyz.service..*.*(..))\r\n指定切入点为：定义在 service 包或者子包里的任意类的任意方法。“..”出现在类名中时，后面必须跟“*”，表示包、子包下的所有类。\r\n\r\n--------------------------- 常用 --------------------------------\r\nexecution(* *.service.*.doSome())\r\n指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点\r\n\r\nexecution(* *..service.*.doSome())\r\n指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点\r\n-----------------------------------------------------------\r\n\r\nexecution(* com.xyz.service.IAccountService.*(..))\r\n指定切入点为： IAccountService 接口中的任意方法。\r\n\r\nexecution(* com.xyz.service.IAccountService+.*(..))\r\n指定切入点为： IAccountService 若为接口，则为接口中的任意方法及其所有实现类中的任意方法；若为类，则为该类及其子类中的任意方法。\r\n\r\nexecution(* joke(String,int)))\r\n指定切入点为：所有的 joke(String,int)方法，且 joke()方法的第一个参数是 String，第二个参数是 int。如果方法中的参数类型是 java.lang 包下的类，可以直接使用类名，否则必须使用全限定类名，如 joke( java.util.List, int)。\r\n\r\nexecution(* joke(String,*)))\r\n指定切入点为：所有的 joke()方法，该方法第一个参数为 String，第二个参数可以是任意类型，如 joke(String s1,String s2)和 joke(String s1,double d2)都是，但 joke(String s1,double d2,String s3)不是。\r\n\r\nexecution(* joke(String,..)))\r\n指定切入点为：所有的 joke()方法，该方法第 一个参数为 String，后面可以有任意个参数且参数类型不限，如 joke(String s1)、 joke(String s1,String s2)和 joke(String s1,double d2,String s3)都是。\r\n\r\nexecution(* joke(Object))\r\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型。joke(Object ob)是，但， joke(String s)与 joke(User u)均不是。\r\n\r\nexecution(* joke(Object+)))\r\n指定切入点为：所有的 joke()方法，方法拥有一个参数，且参数是 Object 类型或该类的子类。不仅 joke(Object ob)是， joke(String s)和 joke(User u)也是。\r\n```\r\n\r\n\r\n### AspectJ 基于注解的 AOP 实现\r\n*ISomeService.java - service 接口*\r\n```\r\npublic interface ISomeService {\r\n	// 目标方法    \r\n	void doFirst();\r\n	// 目标方法\r\n	String doSecond();\r\n	// 目标方法\r\n	void doThird();\r\n}\r\n```\r\n*SomeServiceImpl.java - service 实现类*\r\n```\r\npublic class SomeServiceImpl implements ISomeService {\r\n	@Override\r\n	public void doFirst() {\r\n		System.out.println(\"执行doFirst()方法\");\r\n	}\r\n\r\n	@Override\r\n	public String doSecond() {\r\n		System.out.println(\"执行doSecond()方法\");\r\n		return \"abcde\";\r\n	}\r\n	\r\n	@Override\r\n	public void doThird() {\r\n		System.out.println(\"执行doThird()方法\" + 3 / 0);\r\n		System.out.println(\"执行doThird()方法\");\r\n	}\r\n}\r\n```\r\n*MyAspect.java - 切面类*\r\n```\r\n@Aspect    // 表示当前类为切面\r\npublic class MyAspect {\r\n	@Before(\"execution(* *..ISomeService.doFirst(..))\")\r\n	public void myBefore() {\r\n		System.out.println(\"执行前置通知方法\");\r\n	}\r\n\r\n	@Before(\"execution(* *..ISomeService.doFirst(..))\")\r\n	public void myBefore(JoinPoint jp) {\r\n		// 可以包含一个 JoinPoint 类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。\r\n		System.out.println(\"执行前置通知方法 jp = \" + jp);\r\n	}\r\n	\r\n	@AfterReturning(\"execution(* *..ISomeService.doSecond(..))\")\r\n	public void myAfterReturning() {\r\n		System.out.println(\"执行后置通知方法\");\r\n	}\r\n\r\n	// 后置通知获取返回值\r\n	// 该注解的 returning 属性就是用于指定接收方法返回值的变量名的。该变量最好为 Object 类型，因为目标方法的返回值可能是任何类型。\r\n	@AfterReturning(value=\"execution(* *..ISomeService.doSecond(..))\", returning=\"result\")\r\n	public void myAfterReturning(Object result) {\r\n		System.out.println(\"执行后置通知方法  result = \" + result);\r\n	}\r\n	\r\n	@Around(\"execution(* *..ISomeService.doSecond(..))\")\r\n	public Object myAround(ProceedingJoinPoint pjp) throws Throwable {\r\n		System.out.println(\"执行环绕通知方法，目标方法执行之前\");\r\n		// 执行目标方法\r\n		Object result = pjp.proceed();\r\n		System.out.println(\"执行环绕通知方法，目标方法执行之后\");\r\n		// 修改返回值\r\n		if(result != null) {\r\n			result = ((String)result).toUpperCase();\r\n		}\r\n		return result;\r\n	}\r\n	\r\n	@AfterThrowing(\"execution(* *..ISomeService.doThird(..))\")\r\n	public void myAfterThrowing() {\r\n		System.out.println(\"执行异常通知方法\");\r\n	}\r\n\r\n	// 指定异常\r\n	@AfterThrowing(value=\"doThirdPointcut()\", throwing=\"ex\")\r\n	public void myAfterThrowing(Exception ex) {\r\n		System.out.println(\"执行异常通知方法 ex = \" + ex.getMessage());\r\n	}\r\n	\r\n	@After(\"doThirdPointcut()\")\r\n	public void myAfter() {\r\n		System.out.println(\"执行最终通知方法\");\r\n	}\r\n	\r\n	// 定义了一个切入点，叫 doThirdPointcut()\r\n	@Pointcut(\"execution(* *..ISomeService.doThird(..))\")\r\n	public void doThirdPointcut(){}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/aop \r\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\r\n\r\n	<!-- 注册切面 -->\r\n	<bean id=\"myAspect\" class=\"top.qingrang.annotation.MyAspect\"/>\r\n	\r\n	<!-- 注册目标对象 -->\r\n	<bean id=\"someService\" class=\"top.qingrang.annotation.SomeServiceImpl\"/>\r\n	\r\n	<!-- 注册 AspectJ 的自动代理 -->\r\n	<aop:aspectj-autoproxy/>\r\n\r\n</beans>\r\n```\r\n*输出信息*\r\n```\r\n执行前置通知方法 jp = execution(void top.qingrang.annotation.ISomeService.doFirst())\r\n执行前置通知方法\r\n执行doFirst()方法\r\n----------------------------\r\n执行环绕通知方法，目标方法执行之前\r\n执行doSecond()方法\r\n执行环绕通知方法，目标方法执行之后\r\n执行后置通知方法\r\n执行后置通知方法  result = ABCDE\r\n----------------------------\r\n执行最终通知方法\r\n执行异常通知方法 ex = / by zero\r\n执行异常通知方法\r\n\r\njava.lang.ArithmeticException: / by zero\r\n```\r\n### AspectJ 基于 XML 的 AOP 实现\r\n*MyAspect.java*\r\n```\r\npublic class MyAspect {\r\n	\r\n	public void myBefore() {\r\n		System.out.println(\"执行前置通知方法\");\r\n	}\r\n	\r\n	public void myBefore(JoinPoint jp) {\r\n		System.out.println(\"执行前置通知方法 jp = \" + jp);\r\n	}\r\n	\r\n	public void myAfterReturning() {\r\n		System.out.println(\"执行后置通知方法\");\r\n	}\r\n	\r\n	public void myAfterReturning(Object result) {\r\n		System.out.println(\"执行后置通知方法  result = \" + result);\r\n	}\r\n	\r\n	public Object myAround(ProceedingJoinPoint pjp) throws Throwable {\r\n		System.out.println(\"执行环绕通知方法，目标方法执行之前\");\r\n		// 执行目标方法\r\n		Object result = pjp.proceed();\r\n		System.out.println(\"执行环绕通知方法，目标方法执行之后\");\r\n		if(result != null) {\r\n			result = ((String)result).toUpperCase();\r\n		}\r\n		return result;\r\n	}\r\n	\r\n	public void myAfterThrowing() {\r\n		System.out.println(\"执行异常通知方法\");\r\n	}\r\n	\r\n	public void myAfterThrowing(Exception ex) {\r\n		System.out.println(\"执行异常通知方法 ex = \" + ex.getMessage());\r\n	}\r\n	\r\n	public void myAfter() {\r\n		System.out.println(\"执行最终通知方法\");\r\n	}\r\n	\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/aop \r\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\r\n\r\n	<!-- 注册切面 -->\r\n	<bean id=\"myAspect\" class=\"top.qingrang.xml.MyAspect\"/>\r\n	\r\n	<!-- 注册目标对象 -->\r\n	<bean id=\"someService\" class=\"top.qingrang.xml.SomeServiceImpl\"/>\r\n	\r\n	<!-- AOP 配置 -->\r\n	<aop:config>\r\n		<aop:pointcut expression=\"execution(* *..ISomeService.doFirst(..))\" id=\"doFirstPointcut\"/>\r\n		<aop:pointcut expression=\"execution(* *..ISomeService.doSecond(..))\" id=\"doSecondPointcut\"/>\r\n		<aop:pointcut expression=\"execution(* *..ISomeService.doThird(..))\" id=\"doThirdPointcut\"/>\r\n		\r\n		<aop:aspect ref=\"myAspect\">\r\n			<aop:before method=\"myBefore\" pointcut-ref=\"doFirstPointcut\"/>\r\n			<aop:before method=\"myBefore(org.aspectj.lang.JoinPoint)\" pointcut-ref=\"doFirstPointcut\"/>\r\n			\r\n			<aop:after-returning method=\"myAfterReturning\" pointcut-ref=\"doSecondPointcut\"/>\r\n			<aop:after-returning method=\"myAfterReturning(java.lang.Object)\" pointcut-ref=\"doSecondPointcut\" returning=\"result\"/>\r\n\r\n			<aop:around method=\"myAround\" pointcut-ref=\"doSecondPointcut\"/>\r\n\r\n			<aop:after-throwing method=\"myAfterThrowing\" pointcut-ref=\"doThirdPointcut\"/>\r\n			<aop:after-throwing method=\"myAfterThrowing(java.lang.Exception)\" pointcut-ref=\"doThirdPointcut\" throwing=\"ex\"/>\r\n\r\n			<aop:after method=\"myAfter\" pointcut-ref=\"doThirdPointcut\"/>\r\n		</aop:aspect>\r\n	</aop:config>\r\n\r\n</beans>\r\n```',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 250 [ RunTime:0.002620s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.003542s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000472s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001820s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=21  WHERE  `groups` = 'Java' [ RunTime:0.000423s ]
---------------------------------------------------------------
[ 2018-11-21T20:38:15+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/250.html
[ info ] qingrang.top/daily/admin/note/shownote/id/250.html [运行时间：0.050324s][吞吐率：19.87req/s] [内存消耗：2,049.02kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/250.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000628s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001369s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000688s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000769s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000269s ]
---------------------------------------------------------------
[ 2018-11-21T20:38:45+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.074359s][吞吐率：13.45req/s] [内存消耗：2,308.77kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000661s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001254s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.002151s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` <> 1 ORDER BY gmt_modified desc LIMIT 5 [ RunTime:0.002932s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000915s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000372s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000589s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000959s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000271s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000383s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000365s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000383s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001354s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000275s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001130s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000594s ]
---------------------------------------------------------------
[ 2018-11-21T20:39:54+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/addnote.html
[ info ] qingrang.top/daily/admin/note/addnote.html [运行时间：0.058921s][吞吐率：16.97req/s] [内存消耗：1,977.68kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'addnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '368',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'groups' => 'Java',
  'content' => '# Spring(三) - Spring 与 DAO
',
  'test-editormd-html-code' => '<h1 id="h1-spring-spring-dao"><a name="Spring(三) - Spring 与 DAO" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Spring(三) - Spring 与 DAO</h1>',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->addNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000589s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001365s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000327s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000263s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.000998s ]
[ sql ] [ SQL ] INSERT INTO `note` (`title` , `content` , `groups` , `p_id` , `date` , `gmt_modified`) VALUES ('Spring(三) - Spring 与 DAO\r' , '# Spring(三) - Spring 与 DAO\r\n' , 'Java' , 2 , '2018-11-21' , '2018-11-21') [ RunTime:0.000880s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001295s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000394s ]
---------------------------------------------------------------
[ 2018-11-21T20:39:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.068341s][吞吐率：14.63req/s] [内存消耗：2,301.35kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/newedit.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000528s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001198s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001978s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` <> 1 ORDER BY gmt_modified desc LIMIT 5 [ RunTime:0.002414s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000891s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000281s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000437s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000748s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000299s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000388s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000256s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000315s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001087s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000208s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000916s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000550s ]
---------------------------------------------------------------
[ 2018-11-21T20:40:02+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/253.html
[ info ] qingrang.top/daily/admin/note/editnote/id/253.html [运行时间：0.053364s][吞吐率：18.74req/s] [内存消耗：2,029.03kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000557s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000384s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000876s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000250s ]
---------------------------------------------------------------
[ 2018-11-21T20:40:08+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/253.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/253.html [运行时间：0.063109s][吞吐率：15.85req/s] [内存消耗：2,048.32kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '103',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(三) - Spring 与 DAO
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000638s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002027s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000398s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000773s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000274s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000299s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=253,`p_id`=2,`title`='Spring(三) - Spring 与 DAO\r',`content`='# Spring(三) - Spring 与 DAO\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 253 [ RunTime:0.000504s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001418s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000363s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001111s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000309s ]
---------------------------------------------------------------
[ 2018-11-21T20:40:09+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/253.html
[ info ] qingrang.top/daily/admin/note/shownote/id/253.html [运行时间：0.046648s][吞吐率：21.44req/s] [内存消耗：1,980.97kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000409s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001242s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000344s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000794s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000262s ]
---------------------------------------------------------------
[ 2018-11-21T20:40:17+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.074304s][吞吐率：13.46req/s] [内存消耗：2,314.26kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000424s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001230s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.001613s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` <> 1 ORDER BY gmt_modified desc LIMIT 5 [ RunTime:0.002069s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000919s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000509s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000844s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000345s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000415s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000399s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001137s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000213s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.000939s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000572s ]
---------------------------------------------------------------
[ 2018-11-21T20:40:34+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/253.html
[ info ] qingrang.top/daily/admin/note/editnote/id/253.html [运行时间：0.055875s][吞吐率：17.90req/s] [内存消耗：2,029.04kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000599s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001550s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000573s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000878s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000287s ]
---------------------------------------------------------------
[ 2018-11-21T21:22:56+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/253.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/253.html [运行时间：0.065287s][吞吐率：15.32req/s] [内存消耗：2,050.96kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '997',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(三) - Spring 与 DAO
Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。
## Spring 与 JDBC 模板

',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000479s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001334s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000404s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000251s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000846s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000398s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000292s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=253,`p_id`=2,`title`='Spring(三) - Spring 与 DAO\r',`content`='# Spring(三) - Spring 与 DAO\r\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\r\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\r\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\r\n## Spring 与 JDBC 模板\r\n\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 253 [ RunTime:0.000448s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001146s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000295s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001108s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000321s ]
---------------------------------------------------------------
[ 2018-11-21T21:22:57+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/253.html
[ info ] qingrang.top/daily/admin/note/shownote/id/253.html [运行时间：0.047227s][吞吐率：21.17req/s] [内存消耗：1,981.33kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=ea9d31ruimf3mhjv63v6b584r0',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000437s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001097s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000372s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000763s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000245s ]
---------------------------------------------------------------
[ 2018-11-21T21:44:53+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.032765s][吞吐率：30.52req/s] [内存消耗：1,339.90kb] [文件加载：47]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/login/index.html [ array (
) ]
[ info ] [ LOG ] INIT File
---------------------------------------------------------------
[ 2018-11-21T21:45:06+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/login/index.html
[ info ] qingrang.top/daily/admin/login/index.html [运行时间：0.048245s][吞吐率：20.73req/s] [内存消耗：1,922.41kb] [文件加载：54]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'login',
    2 => 'index',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '8',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'pwd' => 'shao',
)
[ info ] [ RUN ] app\admin\controller\Login->index[ /var/www/html/daily/application/admin/controller/Login.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000675s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `admin` [ RunTime:0.001438s ]
[ sql ] [ SQL ] SELECT * FROM `admin` WHERE  `id` = 1 LIMIT 1 [ RunTime:0.000348s ]
---------------------------------------------------------------
[ 2018-11-21T21:45:08+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note
[ info ] qingrang.top/daily/admin/note [运行时间：0.071744s][吞吐率：13.94req/s] [内存消耗：2,315.11kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => NULL,
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/login/index.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->notelst[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/notelst.html [ array (
  0 => 'stickList',
  1 => 'hide',
  2 => 'list',
  3 => 'list_new',
  4 => 'groups',
  5 => 'groups0',
  6 => 'groups1',
  7 => 'groups2',
  8 => 'count',
  9 => 'year',
  10 => 'default_num',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000519s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001227s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` = 1 ORDER BY date desc,id desc [ RunTime:0.003120s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `groups` <> 'Personal'  AND `is_show` <> 1 ORDER BY gmt_modified desc LIMIT 5 [ RunTime:0.002898s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `config` [ RunTime:0.000954s ]
[ sql ] [ SQL ] SELECT * FROM `config` WHERE  `name` = 'hide' LIMIT 1 [ RunTime:0.000307s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` < 5 [ RunTime:0.000492s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000890s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000280s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 0  AND `id` <> 2 ORDER BY `groups` [ RunTime:0.000373s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `parent_id` = 1 [ RunTime:0.000339s ]
[ sql ] [ SQL ] SELECT * FROM `groups` WHERE  `parent_id` = 2 ORDER BY `groups` [ RunTime:0.000325s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Default' LIMIT 1 [ RunTime:0.001141s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` LIMIT 1 [ RunTime:0.000216s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `yearlist` [ RunTime:0.001015s ]
[ sql ] [ SQL ] SELECT DISTINCT  `year` FROM `yearlist` ORDER BY year desc [ RunTime:0.000588s ]
---------------------------------------------------------------
[ 2018-11-21T21:45:14+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/253.html
[ info ] qingrang.top/daily/admin/note/editnote/id/253.html [运行时间：0.048373s][吞吐率：20.67req/s] [内存消耗：2,029.41kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000470s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001465s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000352s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000891s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000281s ]
---------------------------------------------------------------
[ 2018-11-21T21:50:19+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.062051s][吞吐率：16.12req/s] [内存消耗：2,077.09kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '11165',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring(三) - Spring 与 DAO
Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。

## Spring 与 JDBC 模板
*Student.java - 实体类*
```
public class Student {
	private Integer id;
	private String name;
	private int age;
	public Student() {
		super();
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
}
```
*IStudentDao.java - 接口*
```
public interface IStudentDao {
	void insertStudent(Student student);
	void deleteById(int id);
	void updateStudent(Student student);
	
	List<String> selectAllStudentsNames();
	String selectStudentNameById(int id);
	
	List<Student> selectAllStudents();
	Student selectStudentById(int id);
}
```
*StudentDaoImpl.java - 实现类*
```
public class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {

	@Override
	public void insertStudent(Student student) {
		String sql = "insert into student(name,age) values(?,?)";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());
	}

	@Override
	public void deleteById(int id) {
		String sql = "delete from student where id=?";
		this.getJdbcTemplate().update(sql, id);
	}

	@Override
	public void updateStudent(Student student) {
		String sql = "update student set name=?, age=? where id=?";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());
	}

	@Override
	public List<String> selectAllStudentsNames() {
		String sql = "select name from student";
		return this.getJdbcTemplate().queryForList(sql, String.class);
	}

	@Override
	public String selectStudentNameById(int id) {
		String sql = "select name from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, String.class, id);
	}

	@Override
	public List<Student> selectAllStudents() {
		String sql = "select id,name,age from student";
		return this.getJdbcTemplate().query(sql, new StudentRowMapper());
	}

	@Override
	public Student selectStudentById(int id) {
		String sql = "select id,name,age from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);
	}

}
```
*StudentRowMapper.java*
```
public class StudentRowMapper implements RowMapper<Student> {
	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到
	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度
	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的
	@Override
	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setId(rs.getInt("id"));
		student.setName(rs.getString("name"));
		student.setAge(rs.getInt("age"));
		return student;
	}
}
```
*IStudentService.java*
```
public interface IStudentService {
	void addStudent(Student student);
	void removeById(int id);
	void modifyStudent(Student student);
	
	List<String> findAllStudentsNames();
	String findStudentNameById(int id);
	
	List<Student> findAllStudents();
	Student findStudentById(int id);
}
```
*StudentServiceImpl.java*
```
public class StudentServiceImpl implements IStudentService {
	private IStudentDao dao;
	
	public void setDao(IStudentDao dao) {
		this.dao = dao;
	}

	@Override
	public void addStudent(Student student) {
		dao.insertStudent(student);
	}

	@Override
	public void removeById(int id) {
		dao.deleteById(id);
	}

	@Override
	public void modifyStudent(Student student) {
		dao.updateStudent(student);
	}

	@Override
	public List<String> findAllStudentsNames() {
		return dao.selectAllStudentsNames();
	}

	@Override
	public String findStudentNameById(int id) {
		return dao.selectStudentNameById(id);
	}

	@Override
	public List<Student> findAllStudents() {
		return dao.selectAllStudents();
	}

	@Override
	public Student findStudentById(int id) {
		return dao.selectStudentById(id);
	}

}
```
*MyTest.java*
```
public class MyTest {
	
	private IStudentService service;

	@Before
	public void before() {
		// 创建容器对象，加载Spring配置文件
		String resource = "applicationContext.xml";
		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
		service = (IStudentService) ac.getBean("studentService");
	}
	
	@Test
	public void test01() {
		Student student = new Student("张三", 23);
		service.addStudent(student);
	}
	
	@Test
	public void test02() {
		service.removeById(2);
	}
	
	@Test
	public void test03() {
		Student student = new Student("张三", 23);
		student.setId(3);
		service.modifyStudent(student);
	}
	
	@Test
	public void test04() {
		List<String> names = service.findAllStudentsNames();
		System.out.println(names);
	}
	
	@Test
	public void test05() {
		String name = service.findStudentNameById(3);
		System.out.println(name);
	}
	
	@Test
	public void test06() {
		List<Student> students = service.findAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}
	
	@Test
	public void test07() {
		Student student = service.findStudentById(3);
		System.out.println(student);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 注册数据源：Spring内置连接池 -->
	<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 注册属性文件：方式一 -->
	<!-- 
	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:jdbc.properties"/>
	</bean>
	 -->

	<!-- 注册属性文件：方式二 -->
	<context:property-placeholder location="classpath:jdbc.properties"/>
	
	<!-- 注册 Dao -->
	<bean id="studentDao" class="top.qingrang.dao.StudentDaoImpl">
		<property name="dataSource" ref="myDataSource"/>
	</bean>
	
	<!-- 注册 Service -->
	<bean id="studentService" class="top.qingrang.service.StudentServiceImpl">
		<property name="dao" ref="studentDao"/>
	</bean>

</beans>
```
## Spring 的事务管理
',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000557s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001226s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring(三) - Spring 与 DAO',`content`='# Spring(三) - Spring 与 DAO\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\n\n## Spring 与 JDBC 模板\n*Student.java - 实体类*\n```\npublic class Student {\n	private Integer id;\n	private String name;\n	private int age;\n	public Student() {\n		super();\n	}\n	public Student(String name, int age) {\n		super();\n		this.name = name;\n		this.age = age;\n	}\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public int getAge() {\n		return age;\n	}\n	public void setAge(int age) {\n		this.age = age;\n	}\n	@Override\n	public String toString() {\n		return \"Student [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\";\n	}\n}\n```\n*IStudentDao.java - 接口*\n```\npublic interface IStudentDao {\n	void insertStudent(Student student);\n	void deleteById(int id);\n	void updateStudent(Student student);\n	\n	List<String> selectAllStudentsNames();\n	String selectStudentNameById(int id);\n	\n	List<Student> selectAllStudents();\n	Student selectStudentById(int id);\n}\n```\n*StudentDaoImpl.java - 实现类*\n```\npublic class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {\n\n	@Override\n	public void insertStudent(Student student) {\n		String sql = \"insert into student(name,age) values(?,?)\";\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());\n	}\n\n	@Override\n	public void deleteById(int id) {\n		String sql = \"delete from student where id=?\";\n		this.getJdbcTemplate().update(sql, id);\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		String sql = \"update student set name=?, age=? where id=?\";\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());\n	}\n\n	@Override\n	public List<String> selectAllStudentsNames() {\n		String sql = \"select name from student\";\n		return this.getJdbcTemplate().queryForList(sql, String.class);\n	}\n\n	@Override\n	public String selectStudentNameById(int id) {\n		String sql = \"select name from student where id=?\";\n		return this.getJdbcTemplate().queryForObject(sql, String.class, id);\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		String sql = \"select id,name,age from student\";\n		return this.getJdbcTemplate().query(sql, new StudentRowMapper());\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		String sql = \"select id,name,age from student where id=?\";\n		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);\n	}\n\n}\n```\n*StudentRowMapper.java*\n```\npublic class StudentRowMapper implements RowMapper<Student> {\n	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到\n	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度\n	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的\n	@Override\n	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\n		Student student = new Student();\n		student.setId(rs.getInt(\"id\"));\n		student.setName(rs.getString(\"name\"));\n		student.setAge(rs.getInt(\"age\"));\n		return student;\n	}\n}\n```\n*IStudentService.java*\n```\npublic interface IStudentService {\n	void addStudent(Student student);\n	void removeById(int id);\n	void modifyStudent(Student student);\n	\n	List<String> findAllStudentsNames();\n	String findStudentNameById(int id);\n	\n	List<Student> findAllStudents();\n	Student findStudentById(int id);\n}\n```\n*StudentServiceImpl.java*\n```\npublic class StudentServiceImpl implements IStudentService {\n	private IStudentDao dao;\n	\n	public void setDao(IStudentDao dao) {\n		this.dao = dao;\n	}\n\n	@Override\n	public void addStudent(Student student) {\n		dao.insertStudent(student);\n	}\n\n	@Override\n	public void removeById(int id) {\n		dao.deleteById(id);\n	}\n\n	@Override\n	public void modifyStudent(Student student) {\n		dao.updateStudent(student);\n	}\n\n	@Override\n	public List<String> findAllStudentsNames() {\n		return dao.selectAllStudentsNames();\n	}\n\n	@Override\n	public String findStudentNameById(int id) {\n		return dao.selectStudentNameById(id);\n	}\n\n	@Override\n	public List<Student> findAllStudents() {\n		return dao.selectAllStudents();\n	}\n\n	@Override\n	public Student findStudentById(int id) {\n		return dao.selectStudentById(id);\n	}\n\n}\n```\n*MyTest.java*\n```\npublic class MyTest {\n	\n	private IStudentService service;\n\n	@Before\n	public void before() {\n		// 创建容器对象，加载Spring配置文件\n		String resource = \"applicationContext.xml\";\n		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n		service = (IStudentService) ac.getBean(\"studentService\");\n	}\n	\n	@Test\n	public void test01() {\n		Student student = new Student(\"张三\", 23);\n		service.addStudent(student);\n	}\n	\n	@Test\n	public void test02() {\n		service.removeById(2);\n	}\n	\n	@Test\n	public void test03() {\n		Student student = new Student(\"张三\", 23);\n		student.setId(3);\n		service.modifyStudent(student);\n	}\n	\n	@Test\n	public void test04() {\n		List<String> names = service.findAllStudentsNames();\n		System.out.println(names);\n	}\n	\n	@Test\n	public void test05() {\n		String name = service.findStudentNameById(3);\n		System.out.println(name);\n	}\n	\n	@Test\n	public void test06() {\n		List<Student> students = service.findAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n	\n	@Test\n	public void test07() {\n		Student student = service.findStudentById(3);\n		System.out.println(student);\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n\n	<!-- 注册数据源：Spring内置连接池 -->\n	<bean id=\"myDataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n		<property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\n		<property name=\"url\" value=\"${jdbc.url}\"/>\n		<property name=\"username\" value=\"${jdbc.user}\"/>\n		<property name=\"password\" value=\"${jdbc.password}\"/>\n	</bean>\n\n	<!-- 注册属性文件：方式一 -->\n	<!-- \n	<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n		<property name=\"location\" value=\"classpath:jdbc.properties\"/>\n	</bean>\n	 -->\n\n	<!-- 注册属性文件：方式二 -->\n	<context:property-placeholder location=\"classpath:jdbc.properties\"/>\n	\n	<!-- 注册 Dao -->\n	<bean id=\"studentDao\" class=\"top.qingrang.dao.StudentDaoImpl\">\n		<property name=\"dataSource\" ref=\"myDataSource\"/>\n	</bean>\n	\n	<!-- 注册 Service -->\n	<bean id=\"studentService\" class=\"top.qingrang.service.StudentServiceImpl\">\n		<property name=\"dao\" ref=\"studentDao\"/>\n	</bean>\n\n</beans>\n```\n## Spring 的事务管理\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000557s ]
---------------------------------------------------------------
[ 2018-11-21T22:04:40+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/253.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/253.html [运行时间：0.055453s][吞吐率：18.03req/s] [内存消耗：2,102.71kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '13625',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(三) - Spring 与 DAO
Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。

## Spring 与 JDBC 模板
*Student.java - 实体类*
```
public class Student {
	private Integer id;
	private String name;
	private int age;
	public Student() {
		super();
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
}
```
*IStudentDao.java - 接口*
```
public interface IStudentDao {
	void insertStudent(Student student);
	void deleteById(int id);
	void updateStudent(Student student);
	
	List<String> selectAllStudentsNames();
	String selectStudentNameById(int id);
	
	List<Student> selectAllStudents();
	Student selectStudentById(int id);
}
```
*StudentDaoImpl.java - 实现类*
```
public class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {

	@Override
	public void insertStudent(Student student) {
		String sql = "insert into student(name,age) values(?,?)";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());
	}

	@Override
	public void deleteById(int id) {
		String sql = "delete from student where id=?";
		this.getJdbcTemplate().update(sql, id);
	}

	@Override
	public void updateStudent(Student student) {
		String sql = "update student set name=?, age=? where id=?";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());
	}

	@Override
	public List<String> selectAllStudentsNames() {
		String sql = "select name from student";
		return this.getJdbcTemplate().queryForList(sql, String.class);
	}

	@Override
	public String selectStudentNameById(int id) {
		String sql = "select name from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, String.class, id);
	}

	@Override
	public List<Student> selectAllStudents() {
		String sql = "select id,name,age from student";
		return this.getJdbcTemplate().query(sql, new StudentRowMapper());
	}

	@Override
	public Student selectStudentById(int id) {
		String sql = "select id,name,age from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);
	}

}
```
*StudentRowMapper.java*
```
public class StudentRowMapper implements RowMapper<Student> {
	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到
	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度
	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的
	@Override
	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setId(rs.getInt("id"));
		student.setName(rs.getString("name"));
		student.setAge(rs.getInt("age"));
		return student;
	}
}
```
*IStudentService.java*
```
public interface IStudentService {
	void addStudent(Student student);
	void removeById(int id);
	void modifyStudent(Student student);
	
	List<String> findAllStudentsNames();
	String findStudentNameById(int id);
	
	List<Student> findAllStudents();
	Student findStudentById(int id);
}
```
*StudentServiceImpl.java*
```
public class StudentServiceImpl implements IStudentService {
	private IStudentDao dao;
	
	public void setDao(IStudentDao dao) {
		this.dao = dao;
	}

	@Override
	public void addStudent(Student student) {
		dao.insertStudent(student);
	}

	@Override
	public void removeById(int id) {
		dao.deleteById(id);
	}

	@Override
	public void modifyStudent(Student student) {
		dao.updateStudent(student);
	}

	@Override
	public List<String> findAllStudentsNames() {
		return dao.selectAllStudentsNames();
	}

	@Override
	public String findStudentNameById(int id) {
		return dao.selectStudentNameById(id);
	}

	@Override
	public List<Student> findAllStudents() {
		return dao.selectAllStudents();
	}

	@Override
	public Student findStudentById(int id) {
		return dao.selectStudentById(id);
	}

}
```
*MyTest.java*
```
public class MyTest {
	
	private IStudentService service;

	@Before
	public void before() {
		// 创建容器对象，加载Spring配置文件
		String resource = "applicationContext.xml";
		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
		service = (IStudentService) ac.getBean("studentService");
	}
	
	@Test
	public void test01() {
		Student student = new Student("张三", 23);
		service.addStudent(student);
	}
	
	@Test
	public void test02() {
		service.removeById(2);
	}
	
	@Test
	public void test03() {
		Student student = new Student("张三", 23);
		student.setId(3);
		service.modifyStudent(student);
	}
	
	@Test
	public void test04() {
		List<String> names = service.findAllStudentsNames();
		System.out.println(names);
	}
	
	@Test
	public void test05() {
		String name = service.findStudentNameById(3);
		System.out.println(name);
	}
	
	@Test
	public void test06() {
		List<Student> students = service.findAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}
	
	@Test
	public void test07() {
		Student student = service.findStudentById(3);
		System.out.println(student);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 注册数据源：Spring内置连接池 -->
	<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 注册属性文件：方式一 -->
	<!-- 
	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:jdbc.properties"/>
	</bean>
	 -->

	<!-- 注册属性文件：方式二 -->
	<context:property-placeholder location="classpath:jdbc.properties"/>
	
	<!-- 注册 Dao -->
	<bean id="studentDao" class="top.qingrang.dao.StudentDaoImpl">
		<property name="dataSource" ref="myDataSource"/>
	</bean>
	
	<!-- 注册 Service -->
	<bean id="studentService" class="top.qingrang.service.StudentServiceImpl">
		<property name="dao" ref="studentDao"/>
	</bean>

</beans>
```
## Spring 的事务管理
事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：
- 使用 Spring 的事务代理工厂管理事务
- 使用 Spring 的事务注解管理事务
- 使用 AspectJ 的 AOP 配置管理事务
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000507s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001197s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000405s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000283s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000719s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000295s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000354s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=253,`p_id`=2,`title`='Spring(三) - Spring 与 DAO\r',`content`='# Spring(三) - Spring 与 DAO\r\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\r\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\r\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\r\n\r\n## Spring 与 JDBC 模板\r\n*Student.java - 实体类*\r\n```\r\npublic class Student {\r\n	private Integer id;\r\n	private String name;\r\n	private int age;\r\n	public Student() {\r\n		super();\r\n	}\r\n	public Student(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\";\r\n	}\r\n}\r\n```\r\n*IStudentDao.java - 接口*\r\n```\r\npublic interface IStudentDao {\r\n	void insertStudent(Student student);\r\n	void deleteById(int id);\r\n	void updateStudent(Student student);\r\n	\r\n	List<String> selectAllStudentsNames();\r\n	String selectStudentNameById(int id);\r\n	\r\n	List<Student> selectAllStudents();\r\n	Student selectStudentById(int id);\r\n}\r\n```\r\n*StudentDaoImpl.java - 实现类*\r\n```\r\npublic class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		String sql = \"insert into student(name,age) values(?,?)\";\r\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());\r\n	}\r\n\r\n	@Override\r\n	public void deleteById(int id) {\r\n		String sql = \"delete from student where id=?\";\r\n		this.getJdbcTemplate().update(sql, id);\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		String sql = \"update student set name=?, age=? where id=?\";\r\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());\r\n	}\r\n\r\n	@Override\r\n	public List<String> selectAllStudentsNames() {\r\n		String sql = \"select name from student\";\r\n		return this.getJdbcTemplate().queryForList(sql, String.class);\r\n	}\r\n\r\n	@Override\r\n	public String selectStudentNameById(int id) {\r\n		String sql = \"select name from student where id=?\";\r\n		return this.getJdbcTemplate().queryForObject(sql, String.class, id);\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		String sql = \"select id,name,age from student\";\r\n		return this.getJdbcTemplate().query(sql, new StudentRowMapper());\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		String sql = \"select id,name,age from student where id=?\";\r\n		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);\r\n	}\r\n\r\n}\r\n```\r\n*StudentRowMapper.java*\r\n```\r\npublic class StudentRowMapper implements RowMapper<Student> {\r\n	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到\r\n	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度\r\n	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的\r\n	@Override\r\n	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n		Student student = new Student();\r\n		student.setId(rs.getInt(\"id\"));\r\n		student.setName(rs.getString(\"name\"));\r\n		student.setAge(rs.getInt(\"age\"));\r\n		return student;\r\n	}\r\n}\r\n```\r\n*IStudentService.java*\r\n```\r\npublic interface IStudentService {\r\n	void addStudent(Student student);\r\n	void removeById(int id);\r\n	void modifyStudent(Student student);\r\n	\r\n	List<String> findAllStudentsNames();\r\n	String findStudentNameById(int id);\r\n	\r\n	List<Student> findAllStudents();\r\n	Student findStudentById(int id);\r\n}\r\n```\r\n*StudentServiceImpl.java*\r\n```\r\npublic class StudentServiceImpl implements IStudentService {\r\n	private IStudentDao dao;\r\n	\r\n	public void setDao(IStudentDao dao) {\r\n		this.dao = dao;\r\n	}\r\n\r\n	@Override\r\n	public void addStudent(Student student) {\r\n		dao.insertStudent(student);\r\n	}\r\n\r\n	@Override\r\n	public void removeById(int id) {\r\n		dao.deleteById(id);\r\n	}\r\n\r\n	@Override\r\n	public void modifyStudent(Student student) {\r\n		dao.updateStudent(student);\r\n	}\r\n\r\n	@Override\r\n	public List<String> findAllStudentsNames() {\r\n		return dao.selectAllStudentsNames();\r\n	}\r\n\r\n	@Override\r\n	public String findStudentNameById(int id) {\r\n		return dao.selectStudentNameById(id);\r\n	}\r\n\r\n	@Override\r\n	public List<Student> findAllStudents() {\r\n		return dao.selectAllStudents();\r\n	}\r\n\r\n	@Override\r\n	public Student findStudentById(int id) {\r\n		return dao.selectStudentById(id);\r\n	}\r\n\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\npublic class MyTest {\r\n	\r\n	private IStudentService service;\r\n\r\n	@Before\r\n	public void before() {\r\n		// 创建容器对象，加载Spring配置文件\r\n		String resource = \"applicationContext.xml\";\r\n		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n		service = (IStudentService) ac.getBean(\"studentService\");\r\n	}\r\n	\r\n	@Test\r\n	public void test01() {\r\n		Student student = new Student(\"张三\", 23);\r\n		service.addStudent(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test02() {\r\n		service.removeById(2);\r\n	}\r\n	\r\n	@Test\r\n	public void test03() {\r\n		Student student = new Student(\"张三\", 23);\r\n		student.setId(3);\r\n		service.modifyStudent(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test04() {\r\n		List<String> names = service.findAllStudentsNames();\r\n		System.out.println(names);\r\n	}\r\n	\r\n	@Test\r\n	public void test05() {\r\n		String name = service.findStudentNameById(3);\r\n		System.out.println(name);\r\n	}\r\n	\r\n	@Test\r\n	public void test06() {\r\n		List<Student> students = service.findAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n	\r\n	@Test\r\n	public void test07() {\r\n		Student student = service.findStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n	<!-- 注册数据源：Spring内置连接池 -->\r\n	<bean id=\"myDataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\r\n		<property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\r\n		<property name=\"url\" value=\"${jdbc.url}\"/>\r\n		<property name=\"username\" value=\"${jdbc.user}\"/>\r\n		<property name=\"password\" value=\"${jdbc.password}\"/>\r\n	</bean>\r\n\r\n	<!-- 注册属性文件：方式一 -->\r\n	<!-- \r\n	<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\r\n		<property name=\"location\" value=\"classpath:jdbc.properties\"/>\r\n	</bean>\r\n	 -->\r\n\r\n	<!-- 注册属性文件：方式二 -->\r\n	<context:property-placeholder location=\"classpath:jdbc.properties\"/>\r\n	\r\n	<!-- 注册 Dao -->\r\n	<bean id=\"studentDao\" class=\"top.qingrang.dao.StudentDaoImpl\">\r\n		<property name=\"dataSource\" ref=\"myDataSource\"/>\r\n	</bean>\r\n	\r\n	<!-- 注册 Service -->\r\n	<bean id=\"studentService\" class=\"top.qingrang.service.StudentServiceImpl\">\r\n		<property name=\"dao\" ref=\"studentDao\"/>\r\n	</bean>\r\n\r\n</beans>\r\n```\r\n## Spring 的事务管理\r\n事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：\r\n- 使用 Spring 的事务代理工厂管理事务\r\n- 使用 Spring 的事务注解管理事务\r\n- 使用 AspectJ 的 AOP 配置管理事务\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 253 [ RunTime:0.000593s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001230s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000350s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001063s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000284s ]
---------------------------------------------------------------
[ 2018-11-21T22:04:41+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/253.html
[ info ] qingrang.top/daily/admin/note/shownote/id/253.html [运行时间：0.046638s][吞吐率：21.44req/s] [内存消耗：1,988.79kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000424s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001189s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000420s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000748s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000262s ]
---------------------------------------------------------------
[ 2018-11-21T22:04:56+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/253.html
[ info ] qingrang.top/daily/admin/note/editnote/id/253.html [运行时间：0.058188s][吞吐率：17.19req/s] [内存消耗：2,036.36kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000481s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001422s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000441s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000769s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000252s ]
---------------------------------------------------------------
[ 2018-11-21T22:05:21+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/253.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/253.html [运行时间：0.057433s][吞吐率：17.41req/s] [内存消耗：2,102.67kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '13646',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(三) - Spring 与 DAO
[TOC]

Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。

## Spring 与 JDBC 模板
*Student.java - 实体类*
```
public class Student {
	private Integer id;
	private String name;
	private int age;
	public Student() {
		super();
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
}
```
*IStudentDao.java - 接口*
```
public interface IStudentDao {
	void insertStudent(Student student);
	void deleteById(int id);
	void updateStudent(Student student);
	
	List<String> selectAllStudentsNames();
	String selectStudentNameById(int id);
	
	List<Student> selectAllStudents();
	Student selectStudentById(int id);
}
```
*StudentDaoImpl.java - 实现类*
```
public class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {

	@Override
	public void insertStudent(Student student) {
		String sql = "insert into student(name,age) values(?,?)";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());
	}

	@Override
	public void deleteById(int id) {
		String sql = "delete from student where id=?";
		this.getJdbcTemplate().update(sql, id);
	}

	@Override
	public void updateStudent(Student student) {
		String sql = "update student set name=?, age=? where id=?";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());
	}

	@Override
	public List<String> selectAllStudentsNames() {
		String sql = "select name from student";
		return this.getJdbcTemplate().queryForList(sql, String.class);
	}

	@Override
	public String selectStudentNameById(int id) {
		String sql = "select name from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, String.class, id);
	}

	@Override
	public List<Student> selectAllStudents() {
		String sql = "select id,name,age from student";
		return this.getJdbcTemplate().query(sql, new StudentRowMapper());
	}

	@Override
	public Student selectStudentById(int id) {
		String sql = "select id,name,age from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);
	}

}
```
*StudentRowMapper.java*
```
public class StudentRowMapper implements RowMapper<Student> {
	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到
	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度
	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的
	@Override
	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setId(rs.getInt("id"));
		student.setName(rs.getString("name"));
		student.setAge(rs.getInt("age"));
		return student;
	}
}
```
*IStudentService.java*
```
public interface IStudentService {
	void addStudent(Student student);
	void removeById(int id);
	void modifyStudent(Student student);
	
	List<String> findAllStudentsNames();
	String findStudentNameById(int id);
	
	List<Student> findAllStudents();
	Student findStudentById(int id);
}
```
*StudentServiceImpl.java*
```
public class StudentServiceImpl implements IStudentService {
	private IStudentDao dao;
	
	public void setDao(IStudentDao dao) {
		this.dao = dao;
	}

	@Override
	public void addStudent(Student student) {
		dao.insertStudent(student);
	}

	@Override
	public void removeById(int id) {
		dao.deleteById(id);
	}

	@Override
	public void modifyStudent(Student student) {
		dao.updateStudent(student);
	}

	@Override
	public List<String> findAllStudentsNames() {
		return dao.selectAllStudentsNames();
	}

	@Override
	public String findStudentNameById(int id) {
		return dao.selectStudentNameById(id);
	}

	@Override
	public List<Student> findAllStudents() {
		return dao.selectAllStudents();
	}

	@Override
	public Student findStudentById(int id) {
		return dao.selectStudentById(id);
	}

}
```
*MyTest.java*
```
public class MyTest {
	
	private IStudentService service;

	@Before
	public void before() {
		// 创建容器对象，加载Spring配置文件
		String resource = "applicationContext.xml";
		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
		service = (IStudentService) ac.getBean("studentService");
	}
	
	@Test
	public void test01() {
		Student student = new Student("张三", 23);
		service.addStudent(student);
	}
	
	@Test
	public void test02() {
		service.removeById(2);
	}
	
	@Test
	public void test03() {
		Student student = new Student("张三", 23);
		student.setId(3);
		service.modifyStudent(student);
	}
	
	@Test
	public void test04() {
		List<String> names = service.findAllStudentsNames();
		System.out.println(names);
	}
	
	@Test
	public void test05() {
		String name = service.findStudentNameById(3);
		System.out.println(name);
	}
	
	@Test
	public void test06() {
		List<Student> students = service.findAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}
	
	@Test
	public void test07() {
		Student student = service.findStudentById(3);
		System.out.println(student);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 注册数据源：Spring内置连接池 -->
	<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 注册属性文件：方式一 -->
	<!-- 
	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:jdbc.properties"/>
	</bean>
	 -->

	<!-- 注册属性文件：方式二 -->
	<context:property-placeholder location="classpath:jdbc.properties"/>
	
	<!-- 注册 Dao -->
	<bean id="studentDao" class="top.qingrang.dao.StudentDaoImpl">
		<property name="dataSource" ref="myDataSource"/>
	</bean>
	
	<!-- 注册 Service -->
	<bean id="studentService" class="top.qingrang.service.StudentServiceImpl">
		<property name="dao" ref="studentDao"/>
	</bean>

</beans>
```
## Spring 的事务管理
事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：
- 使用 Spring 的事务代理工厂管理事务
- 使用 Spring 的事务注解管理事务
- 使用 AspectJ 的 AOP 配置管理事务
',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000466s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001139s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000435s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000277s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000799s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000312s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000245s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=253,`p_id`=2,`title`='Spring(三) - Spring 与 DAO\r',`content`='# Spring(三) - Spring 与 DAO\r\n[TOC]\r\n\r\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\r\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\r\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\r\n\r\n## Spring 与 JDBC 模板\r\n*Student.java - 实体类*\r\n```\r\npublic class Student {\r\n	private Integer id;\r\n	private String name;\r\n	private int age;\r\n	public Student() {\r\n		super();\r\n	}\r\n	public Student(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\";\r\n	}\r\n}\r\n```\r\n*IStudentDao.java - 接口*\r\n```\r\npublic interface IStudentDao {\r\n	void insertStudent(Student student);\r\n	void deleteById(int id);\r\n	void updateStudent(Student student);\r\n	\r\n	List<String> selectAllStudentsNames();\r\n	String selectStudentNameById(int id);\r\n	\r\n	List<Student> selectAllStudents();\r\n	Student selectStudentById(int id);\r\n}\r\n```\r\n*StudentDaoImpl.java - 实现类*\r\n```\r\npublic class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		String sql = \"insert into student(name,age) values(?,?)\";\r\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());\r\n	}\r\n\r\n	@Override\r\n	public void deleteById(int id) {\r\n		String sql = \"delete from student where id=?\";\r\n		this.getJdbcTemplate().update(sql, id);\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		String sql = \"update student set name=?, age=? where id=?\";\r\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());\r\n	}\r\n\r\n	@Override\r\n	public List<String> selectAllStudentsNames() {\r\n		String sql = \"select name from student\";\r\n		return this.getJdbcTemplate().queryForList(sql, String.class);\r\n	}\r\n\r\n	@Override\r\n	public String selectStudentNameById(int id) {\r\n		String sql = \"select name from student where id=?\";\r\n		return this.getJdbcTemplate().queryForObject(sql, String.class, id);\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		String sql = \"select id,name,age from student\";\r\n		return this.getJdbcTemplate().query(sql, new StudentRowMapper());\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		String sql = \"select id,name,age from student where id=?\";\r\n		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);\r\n	}\r\n\r\n}\r\n```\r\n*StudentRowMapper.java*\r\n```\r\npublic class StudentRowMapper implements RowMapper<Student> {\r\n	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到\r\n	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度\r\n	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的\r\n	@Override\r\n	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n		Student student = new Student();\r\n		student.setId(rs.getInt(\"id\"));\r\n		student.setName(rs.getString(\"name\"));\r\n		student.setAge(rs.getInt(\"age\"));\r\n		return student;\r\n	}\r\n}\r\n```\r\n*IStudentService.java*\r\n```\r\npublic interface IStudentService {\r\n	void addStudent(Student student);\r\n	void removeById(int id);\r\n	void modifyStudent(Student student);\r\n	\r\n	List<String> findAllStudentsNames();\r\n	String findStudentNameById(int id);\r\n	\r\n	List<Student> findAllStudents();\r\n	Student findStudentById(int id);\r\n}\r\n```\r\n*StudentServiceImpl.java*\r\n```\r\npublic class StudentServiceImpl implements IStudentService {\r\n	private IStudentDao dao;\r\n	\r\n	public void setDao(IStudentDao dao) {\r\n		this.dao = dao;\r\n	}\r\n\r\n	@Override\r\n	public void addStudent(Student student) {\r\n		dao.insertStudent(student);\r\n	}\r\n\r\n	@Override\r\n	public void removeById(int id) {\r\n		dao.deleteById(id);\r\n	}\r\n\r\n	@Override\r\n	public void modifyStudent(Student student) {\r\n		dao.updateStudent(student);\r\n	}\r\n\r\n	@Override\r\n	public List<String> findAllStudentsNames() {\r\n		return dao.selectAllStudentsNames();\r\n	}\r\n\r\n	@Override\r\n	public String findStudentNameById(int id) {\r\n		return dao.selectStudentNameById(id);\r\n	}\r\n\r\n	@Override\r\n	public List<Student> findAllStudents() {\r\n		return dao.selectAllStudents();\r\n	}\r\n\r\n	@Override\r\n	public Student findStudentById(int id) {\r\n		return dao.selectStudentById(id);\r\n	}\r\n\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\npublic class MyTest {\r\n	\r\n	private IStudentService service;\r\n\r\n	@Before\r\n	public void before() {\r\n		// 创建容器对象，加载Spring配置文件\r\n		String resource = \"applicationContext.xml\";\r\n		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n		service = (IStudentService) ac.getBean(\"studentService\");\r\n	}\r\n	\r\n	@Test\r\n	public void test01() {\r\n		Student student = new Student(\"张三\", 23);\r\n		service.addStudent(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test02() {\r\n		service.removeById(2);\r\n	}\r\n	\r\n	@Test\r\n	public void test03() {\r\n		Student student = new Student(\"张三\", 23);\r\n		student.setId(3);\r\n		service.modifyStudent(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test04() {\r\n		List<String> names = service.findAllStudentsNames();\r\n		System.out.println(names);\r\n	}\r\n	\r\n	@Test\r\n	public void test05() {\r\n		String name = service.findStudentNameById(3);\r\n		System.out.println(name);\r\n	}\r\n	\r\n	@Test\r\n	public void test06() {\r\n		List<Student> students = service.findAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n	\r\n	@Test\r\n	public void test07() {\r\n		Student student = service.findStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n	<!-- 注册数据源：Spring内置连接池 -->\r\n	<bean id=\"myDataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\r\n		<property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\r\n		<property name=\"url\" value=\"${jdbc.url}\"/>\r\n		<property name=\"username\" value=\"${jdbc.user}\"/>\r\n		<property name=\"password\" value=\"${jdbc.password}\"/>\r\n	</bean>\r\n\r\n	<!-- 注册属性文件：方式一 -->\r\n	<!-- \r\n	<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\r\n		<property name=\"location\" value=\"classpath:jdbc.properties\"/>\r\n	</bean>\r\n	 -->\r\n\r\n	<!-- 注册属性文件：方式二 -->\r\n	<context:property-placeholder location=\"classpath:jdbc.properties\"/>\r\n	\r\n	<!-- 注册 Dao -->\r\n	<bean id=\"studentDao\" class=\"top.qingrang.dao.StudentDaoImpl\">\r\n		<property name=\"dataSource\" ref=\"myDataSource\"/>\r\n	</bean>\r\n	\r\n	<!-- 注册 Service -->\r\n	<bean id=\"studentService\" class=\"top.qingrang.service.StudentServiceImpl\">\r\n		<property name=\"dao\" ref=\"studentDao\"/>\r\n	</bean>\r\n\r\n</beans>\r\n```\r\n## Spring 的事务管理\r\n事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：\r\n- 使用 Spring 的事务代理工厂管理事务\r\n- 使用 Spring 的事务注解管理事务\r\n- 使用 AspectJ 的 AOP 配置管理事务\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 253 [ RunTime:0.000686s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001117s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000589s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001120s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000269s ]
---------------------------------------------------------------
[ 2018-11-21T22:05:21+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/253.html
[ info ] qingrang.top/daily/admin/note/shownote/id/253.html [运行时间：0.051583s][吞吐率：19.39req/s] [内存消耗：1,988.79kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000512s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001246s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000434s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001329s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000394s ]
---------------------------------------------------------------
[ 2018-11-21T23:05:12+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/253.html
[ info ] qingrang.top/daily/admin/note/editnote/id/253.html [运行时间：0.062474s][吞吐率：16.01req/s] [内存消耗：2,036.37kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000820s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001463s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000457s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000823s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000265s ]
---------------------------------------------------------------
[ 2018-11-21T23:22:37+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/253.html
[ info ] qingrang.top/daily/admin/note/shownote/id/253.html [运行时间：0.061119s][吞吐率：16.36req/s] [内存消耗：1,988.79kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000740s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.002254s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000562s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.001391s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000356s ]
---------------------------------------------------------------
[ 2018-11-21T23:22:52+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/253.html
[ info ] qingrang.top/daily/admin/note/editnote/id/253.html [运行时间：0.052366s][吞吐率：19.10req/s] [内存消耗：2,036.79kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000504s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001278s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000408s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000818s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000265s ]
---------------------------------------------------------------
[ 2018-11-21T23:29:35+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.064691s][吞吐率：15.46req/s] [内存消耗：2,113.91kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '22743',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring(三) - Spring 与 DAO
[TOC]

Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。

## Spring 与 JDBC 模板
*Student.java - 实体类*
```
public class Student {
	private Integer id;
	private String name;
	private int age;
	public Student() {
		super();
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
}
```
*IStudentDao.java - 接口*
```
public interface IStudentDao {
	void insertStudent(Student student);
	void deleteById(int id);
	void updateStudent(Student student);
	
	List<String> selectAllStudentsNames();
	String selectStudentNameById(int id);
	
	List<Student> selectAllStudents();
	Student selectStudentById(int id);
}
```
*StudentDaoImpl.java - 实现类*
```
public class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {

	@Override
	public void insertStudent(Student student) {
		String sql = "insert into student(name,age) values(?,?)";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());
	}

	@Override
	public void deleteById(int id) {
		String sql = "delete from student where id=?";
		this.getJdbcTemplate().update(sql, id);
	}

	@Override
	public void updateStudent(Student student) {
		String sql = "update student set name=?, age=? where id=?";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());
	}

	@Override
	public List<String> selectAllStudentsNames() {
		String sql = "select name from student";
		return this.getJdbcTemplate().queryForList(sql, String.class);
	}

	@Override
	public String selectStudentNameById(int id) {
		String sql = "select name from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, String.class, id);
	}

	@Override
	public List<Student> selectAllStudents() {
		String sql = "select id,name,age from student";
		return this.getJdbcTemplate().query(sql, new StudentRowMapper());
	}

	@Override
	public Student selectStudentById(int id) {
		String sql = "select id,name,age from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);
	}

}
```
*StudentRowMapper.java*
```
public class StudentRowMapper implements RowMapper<Student> {
	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到
	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度
	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的
	@Override
	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setId(rs.getInt("id"));
		student.setName(rs.getString("name"));
		student.setAge(rs.getInt("age"));
		return student;
	}
}
```
*IStudentService.java*
```
public interface IStudentService {
	void addStudent(Student student);
	void removeById(int id);
	void modifyStudent(Student student);
	
	List<String> findAllStudentsNames();
	String findStudentNameById(int id);
	
	List<Student> findAllStudents();
	Student findStudentById(int id);
}
```
*StudentServiceImpl.java*
```
public class StudentServiceImpl implements IStudentService {
	private IStudentDao dao;
	
	public void setDao(IStudentDao dao) {
		this.dao = dao;
	}

	@Override
	public void addStudent(Student student) {
		dao.insertStudent(student);
	}

	@Override
	public void removeById(int id) {
		dao.deleteById(id);
	}

	@Override
	public void modifyStudent(Student student) {
		dao.updateStudent(student);
	}

	@Override
	public List<String> findAllStudentsNames() {
		return dao.selectAllStudentsNames();
	}

	@Override
	public String findStudentNameById(int id) {
		return dao.selectStudentNameById(id);
	}

	@Override
	public List<Student> findAllStudents() {
		return dao.selectAllStudents();
	}

	@Override
	public Student findStudentById(int id) {
		return dao.selectStudentById(id);
	}

}
```
*MyTest.java*
```
public class MyTest {
	
	private IStudentService service;

	@Before
	public void before() {
		// 创建容器对象，加载Spring配置文件
		String resource = "applicationContext.xml";
		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
		service = (IStudentService) ac.getBean("studentService");
	}
	
	@Test
	public void test01() {
		Student student = new Student("张三", 23);
		service.addStudent(student);
	}
	
	@Test
	public void test02() {
		service.removeById(2);
	}
	
	@Test
	public void test03() {
		Student student = new Student("张三", 23);
		student.setId(3);
		service.modifyStudent(student);
	}
	
	@Test
	public void test04() {
		List<String> names = service.findAllStudentsNames();
		System.out.println(names);
	}
	
	@Test
	public void test05() {
		String name = service.findStudentNameById(3);
		System.out.println(name);
	}
	
	@Test
	public void test06() {
		List<Student> students = service.findAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}
	
	@Test
	public void test07() {
		Student student = service.findStudentById(3);
		System.out.println(student);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 注册数据源：Spring内置连接池 -->
	<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 注册属性文件：方式一 -->
	<!-- 
	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:jdbc.properties"/>
	</bean>
	 -->

	<!-- 注册属性文件：方式二 -->
	<context:property-placeholder location="classpath:jdbc.properties"/>
	
	<!-- 注册 Dao -->
	<bean id="studentDao" class="top.qingrang.dao.StudentDaoImpl">
		<property name="dataSource" ref="myDataSource"/>
	</bean>
	
	<!-- 注册 Service -->
	<bean id="studentService" class="top.qingrang.service.StudentServiceImpl">
		<property name="dao" ref="studentDao"/>
	</bean>

</beans>
```
## Spring 的事务管理
事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：
- 使用 Spring 的事务代理工厂管理事务
- 使用 Spring 的事务注解管理事务
- 使用 AspectJ 的 AOP 配置管理事务

### Spring 事务管理 API
Spring 的事务管理，主要用到两个事务相关的接口。
#### 事务管理器接口
事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。
##### 常用的两个实现类
PlatformTransactionManager 接口有两个常用的实现类：
- DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。
- HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。

##### Spring 的回滚方式
Spring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。 不过，对于受查异常，程序员也可以手工设置其回滚方式。

#### 事务定义接口
事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。
##### 定义了五个事务隔离级别常量
这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。
- DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ；Oracle 默认为 READ_COMMITTED。
- READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。
- READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。
- REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读
- SERIALIZABLE： 串行化。不存在并发问题。

##### 定义了七个事务传播行为常量
所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。
1. REQUIRED：
指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。
如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther()方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用doOther()方法时没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。
1. SUPPORTS
指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。
1. MANDATORY
指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。
1. REQUIRES_NEW
总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。
1. NOT_SUPPORTED
指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。
1. NEVER
指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。
1. NESTED
指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。

##### 定义了默认事务超时时限
常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。

注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。
## Demo
>本例要实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。

',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000602s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001087s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring(三) - Spring 与 DAO',`content`='# Spring(三) - Spring 与 DAO\n[TOC]\n\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\n\n## Spring 与 JDBC 模板\n*Student.java - 实体类*\n```\npublic class Student {\n	private Integer id;\n	private String name;\n	private int age;\n	public Student() {\n		super();\n	}\n	public Student(String name, int age) {\n		super();\n		this.name = name;\n		this.age = age;\n	}\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public int getAge() {\n		return age;\n	}\n	public void setAge(int age) {\n		this.age = age;\n	}\n	@Override\n	public String toString() {\n		return \"Student [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\";\n	}\n}\n```\n*IStudentDao.java - 接口*\n```\npublic interface IStudentDao {\n	void insertStudent(Student student);\n	void deleteById(int id);\n	void updateStudent(Student student);\n	\n	List<String> selectAllStudentsNames();\n	String selectStudentNameById(int id);\n	\n	List<Student> selectAllStudents();\n	Student selectStudentById(int id);\n}\n```\n*StudentDaoImpl.java - 实现类*\n```\npublic class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {\n\n	@Override\n	public void insertStudent(Student student) {\n		String sql = \"insert into student(name,age) values(?,?)\";\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());\n	}\n\n	@Override\n	public void deleteById(int id) {\n		String sql = \"delete from student where id=?\";\n		this.getJdbcTemplate().update(sql, id);\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		String sql = \"update student set name=?, age=? where id=?\";\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());\n	}\n\n	@Override\n	public List<String> selectAllStudentsNames() {\n		String sql = \"select name from student\";\n		return this.getJdbcTemplate().queryForList(sql, String.class);\n	}\n\n	@Override\n	public String selectStudentNameById(int id) {\n		String sql = \"select name from student where id=?\";\n		return this.getJdbcTemplate().queryForObject(sql, String.class, id);\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		String sql = \"select id,name,age from student\";\n		return this.getJdbcTemplate().query(sql, new StudentRowMapper());\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		String sql = \"select id,name,age from student where id=?\";\n		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);\n	}\n\n}\n```\n*StudentRowMapper.java*\n```\npublic class StudentRowMapper implements RowMapper<Student> {\n	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到\n	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度\n	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的\n	@Override\n	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\n		Student student = new Student();\n		student.setId(rs.getInt(\"id\"));\n		student.setName(rs.getString(\"name\"));\n		student.setAge(rs.getInt(\"age\"));\n		return student;\n	}\n}\n```\n*IStudentService.java*\n```\npublic interface IStudentService {\n	void addStudent(Student student);\n	void removeById(int id);\n	void modifyStudent(Student student);\n	\n	List<String> findAllStudentsNames();\n	String findStudentNameById(int id);\n	\n	List<Student> findAllStudents();\n	Student findStudentById(int id);\n}\n```\n*StudentServiceImpl.java*\n```\npublic class StudentServiceImpl implements IStudentService {\n	private IStudentDao dao;\n	\n	public void setDao(IStudentDao dao) {\n		this.dao = dao;\n	}\n\n	@Override\n	public void addStudent(Student student) {\n		dao.insertStudent(student);\n	}\n\n	@Override\n	public void removeById(int id) {\n		dao.deleteById(id);\n	}\n\n	@Override\n	public void modifyStudent(Student student) {\n		dao.updateStudent(student);\n	}\n\n	@Override\n	public List<String> findAllStudentsNames() {\n		return dao.selectAllStudentsNames();\n	}\n\n	@Override\n	public String findStudentNameById(int id) {\n		return dao.selectStudentNameById(id);\n	}\n\n	@Override\n	public List<Student> findAllStudents() {\n		return dao.selectAllStudents();\n	}\n\n	@Override\n	public Student findStudentById(int id) {\n		return dao.selectStudentById(id);\n	}\n\n}\n```\n*MyTest.java*\n```\npublic class MyTest {\n	\n	private IStudentService service;\n\n	@Before\n	public void before() {\n		// 创建容器对象，加载Spring配置文件\n		String resource = \"applicationContext.xml\";\n		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n		service = (IStudentService) ac.getBean(\"studentService\");\n	}\n	\n	@Test\n	public void test01() {\n		Student student = new Student(\"张三\", 23);\n		service.addStudent(student);\n	}\n	\n	@Test\n	public void test02() {\n		service.removeById(2);\n	}\n	\n	@Test\n	public void test03() {\n		Student student = new Student(\"张三\", 23);\n		student.setId(3);\n		service.modifyStudent(student);\n	}\n	\n	@Test\n	public void test04() {\n		List<String> names = service.findAllStudentsNames();\n		System.out.println(names);\n	}\n	\n	@Test\n	public void test05() {\n		String name = service.findStudentNameById(3);\n		System.out.println(name);\n	}\n	\n	@Test\n	public void test06() {\n		List<Student> students = service.findAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n	\n	@Test\n	public void test07() {\n		Student student = service.findStudentById(3);\n		System.out.println(student);\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n\n	<!-- 注册数据源：Spring内置连接池 -->\n	<bean id=\"myDataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n		<property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\n		<property name=\"url\" value=\"${jdbc.url}\"/>\n		<property name=\"username\" value=\"${jdbc.user}\"/>\n		<property name=\"password\" value=\"${jdbc.password}\"/>\n	</bean>\n\n	<!-- 注册属性文件：方式一 -->\n	<!-- \n	<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n		<property name=\"location\" value=\"classpath:jdbc.properties\"/>\n	</bean>\n	 -->\n\n	<!-- 注册属性文件：方式二 -->\n	<context:property-placeholder location=\"classpath:jdbc.properties\"/>\n	\n	<!-- 注册 Dao -->\n	<bean id=\"studentDao\" class=\"top.qingrang.dao.StudentDaoImpl\">\n		<property name=\"dataSource\" ref=\"myDataSource\"/>\n	</bean>\n	\n	<!-- 注册 Service -->\n	<bean id=\"studentService\" class=\"top.qingrang.service.StudentServiceImpl\">\n		<property name=\"dao\" ref=\"studentDao\"/>\n	</bean>\n\n</beans>\n```\n## Spring 的事务管理\n事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：\n- 使用 Spring 的事务代理工厂管理事务\n- 使用 Spring 的事务注解管理事务\n- 使用 AspectJ 的 AOP 配置管理事务\n\n### Spring 事务管理 API\nSpring 的事务管理，主要用到两个事务相关的接口。\n#### 事务管理器接口\n事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。\n##### 常用的两个实现类\nPlatformTransactionManager 接口有两个常用的实现类：\n- DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。\n- HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。\n\n##### Spring 的回滚方式\nSpring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。 不过，对于受查异常，程序员也可以手工设置其回滚方式。\n\n#### 事务定义接口\n事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。\n##### 定义了五个事务隔离级别常量\n这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。\n- DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ；Oracle 默认为 READ_COMMITTED。\n- READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。\n- READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。\n- REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读\n- SERIALIZABLE： 串行化。不存在并发问题。\n\n##### 定义了七个事务传播行为常量\n所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。\n1. REQUIRED：\n指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。\n如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther()方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用doOther()方法时没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。\n1. SUPPORTS\n指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。\n1. MANDATORY\n指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。\n1. REQUIRES_NEW\n总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。\n1. NOT_SUPPORTED\n指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。\n1. NEVER\n指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。\n1. NESTED\n指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。\n\n##### 定义了默认事务超时时限\n常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。\n\n注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。\n## Demo\n>本例要实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000952s ]
---------------------------------------------------------------
[ 2018-11-21T23:30:39+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/editnote/id/250.html
[ info ] qingrang.top/daily/admin/note/editnote/id/250.html [运行时间：0.057135s][吞吐率：17.50req/s] [内存消耗：2,101.09kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'editnote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '250',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->editNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/editnote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000616s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001604s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 250 LIMIT 1 [ RunTime:0.000642s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000774s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000252s ]
---------------------------------------------------------------
[ 2018-11-21T23:34:42+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/savenote.html
[ info ] qingrang.top/daily/admin/note/savenote.html [运行时间：0.046487s][吞吐率：21.51req/s] [内存消耗：2,118.25kb] [文件加载：56]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'savenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '23443',
  'accept' => 'text/plain, */*; q=0.01',
  'origin' => 'http://qingrang.top',
  'x-requested-with' => 'XMLHttpRequest',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'content-type' => 'application/x-www-form-urlencoded; charset=UTF-8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'ogroup' => 'Default',
  'context' => '# Spring(三) - Spring 与 DAO
[TOC]

Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。

## Spring 与 JDBC 模板
*Student.java - 实体类*
```
public class Student {
	private Integer id;
	private String name;
	private int age;
	public Student() {
		super();
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
}
```
*IStudentDao.java - 接口*
```
public interface IStudentDao {
	void insertStudent(Student student);
	void deleteById(int id);
	void updateStudent(Student student);
	
	List<String> selectAllStudentsNames();
	String selectStudentNameById(int id);
	
	List<Student> selectAllStudents();
	Student selectStudentById(int id);
}
```
*StudentDaoImpl.java - 实现类*
```
public class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {

	@Override
	public void insertStudent(Student student) {
		String sql = "insert into student(name,age) values(?,?)";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());
	}

	@Override
	public void deleteById(int id) {
		String sql = "delete from student where id=?";
		this.getJdbcTemplate().update(sql, id);
	}

	@Override
	public void updateStudent(Student student) {
		String sql = "update student set name=?, age=? where id=?";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());
	}

	@Override
	public List<String> selectAllStudentsNames() {
		String sql = "select name from student";
		return this.getJdbcTemplate().queryForList(sql, String.class);
	}

	@Override
	public String selectStudentNameById(int id) {
		String sql = "select name from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, String.class, id);
	}

	@Override
	public List<Student> selectAllStudents() {
		String sql = "select id,name,age from student";
		return this.getJdbcTemplate().query(sql, new StudentRowMapper());
	}

	@Override
	public Student selectStudentById(int id) {
		String sql = "select id,name,age from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);
	}

}
```
*StudentRowMapper.java*
```
public class StudentRowMapper implements RowMapper<Student> {
	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到
	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度
	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的
	@Override
	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setId(rs.getInt("id"));
		student.setName(rs.getString("name"));
		student.setAge(rs.getInt("age"));
		return student;
	}
}
```
*IStudentService.java*
```
public interface IStudentService {
	void addStudent(Student student);
	void removeById(int id);
	void modifyStudent(Student student);
	
	List<String> findAllStudentsNames();
	String findStudentNameById(int id);
	
	List<Student> findAllStudents();
	Student findStudentById(int id);
}
```
*StudentServiceImpl.java*
```
public class StudentServiceImpl implements IStudentService {
	private IStudentDao dao;
	
	public void setDao(IStudentDao dao) {
		this.dao = dao;
	}

	@Override
	public void addStudent(Student student) {
		dao.insertStudent(student);
	}

	@Override
	public void removeById(int id) {
		dao.deleteById(id);
	}

	@Override
	public void modifyStudent(Student student) {
		dao.updateStudent(student);
	}

	@Override
	public List<String> findAllStudentsNames() {
		return dao.selectAllStudentsNames();
	}

	@Override
	public String findStudentNameById(int id) {
		return dao.selectStudentNameById(id);
	}

	@Override
	public List<Student> findAllStudents() {
		return dao.selectAllStudents();
	}

	@Override
	public Student findStudentById(int id) {
		return dao.selectStudentById(id);
	}

}
```
*MyTest.java*
```
public class MyTest {
	
	private IStudentService service;

	@Before
	public void before() {
		// 创建容器对象，加载Spring配置文件
		String resource = "applicationContext.xml";
		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
		service = (IStudentService) ac.getBean("studentService");
	}
	
	@Test
	public void test01() {
		Student student = new Student("张三", 23);
		service.addStudent(student);
	}
	
	@Test
	public void test02() {
		service.removeById(2);
	}
	
	@Test
	public void test03() {
		Student student = new Student("张三", 23);
		student.setId(3);
		service.modifyStudent(student);
	}
	
	@Test
	public void test04() {
		List<String> names = service.findAllStudentsNames();
		System.out.println(names);
	}
	
	@Test
	public void test05() {
		String name = service.findStudentNameById(3);
		System.out.println(name);
	}
	
	@Test
	public void test06() {
		List<Student> students = service.findAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}
	
	@Test
	public void test07() {
		Student student = service.findStudentById(3);
		System.out.println(student);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 注册数据源：Spring内置连接池 -->
	<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 注册属性文件：方式一 -->
	<!-- 
	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:jdbc.properties"/>
	</bean>
	 -->

	<!-- 注册属性文件：方式二 -->
	<context:property-placeholder location="classpath:jdbc.properties"/>
	
	<!-- 注册 Dao -->
	<bean id="studentDao" class="top.qingrang.dao.StudentDaoImpl">
		<property name="dataSource" ref="myDataSource"/>
	</bean>
	
	<!-- 注册 Service -->
	<bean id="studentService" class="top.qingrang.service.StudentServiceImpl">
		<property name="dao" ref="studentDao"/>
	</bean>

</beans>
```
## Spring 的事务管理
事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：
- 使用 Spring 的事务代理工厂管理事务
- 使用 Spring 的事务注解管理事务
- 使用 AspectJ 的 AOP 配置管理事务

### Spring 事务管理 API
Spring 的事务管理，主要用到两个事务相关的接口。
#### 事务管理器接口
事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。
##### 常用的两个实现类
PlatformTransactionManager 接口有两个常用的实现类：
- DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。
- HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。

##### Spring 的回滚方式
Spring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。 不过，对于受查异常，程序员也可以手工设置其回滚方式。

#### 事务定义接口
事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。
##### 定义了五个事务隔离级别常量
这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。
- DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ；Oracle 默认为 READ_COMMITTED。
- READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。
- READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。
- REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读
- SERIALIZABLE： 串行化。不存在并发问题。

##### 定义了七个事务传播行为常量
所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。
1. REQUIRED：
指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。
如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther()方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用doOther()方法时没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-21-56.png)
1. SUPPORTS
指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-13.png)
1. MANDATORY
指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-40.png)
1. REQUIRES_NEW
总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-55.png)
1. NOT_SUPPORTED
指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-07.png)
1. NEVER
指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-22.png)
1. NESTED
指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-40.png)

##### 定义了默认事务超时时限
常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。

注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。
## Demo
>本例要实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。

',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->saveNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000544s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001181s ]
[ sql ] [ SQL ] UPDATE `note`  SET `title`='Spring(三) - Spring 与 DAO',`content`='# Spring(三) - Spring 与 DAO\n[TOC]\n\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\n\n## Spring 与 JDBC 模板\n*Student.java - 实体类*\n```\npublic class Student {\n	private Integer id;\n	private String name;\n	private int age;\n	public Student() {\n		super();\n	}\n	public Student(String name, int age) {\n		super();\n		this.name = name;\n		this.age = age;\n	}\n	public Integer getId() {\n		return id;\n	}\n	public void setId(Integer id) {\n		this.id = id;\n	}\n	public String getName() {\n		return name;\n	}\n	public void setName(String name) {\n		this.name = name;\n	}\n	public int getAge() {\n		return age;\n	}\n	public void setAge(int age) {\n		this.age = age;\n	}\n	@Override\n	public String toString() {\n		return \"Student [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\";\n	}\n}\n```\n*IStudentDao.java - 接口*\n```\npublic interface IStudentDao {\n	void insertStudent(Student student);\n	void deleteById(int id);\n	void updateStudent(Student student);\n	\n	List<String> selectAllStudentsNames();\n	String selectStudentNameById(int id);\n	\n	List<Student> selectAllStudents();\n	Student selectStudentById(int id);\n}\n```\n*StudentDaoImpl.java - 实现类*\n```\npublic class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {\n\n	@Override\n	public void insertStudent(Student student) {\n		String sql = \"insert into student(name,age) values(?,?)\";\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());\n	}\n\n	@Override\n	public void deleteById(int id) {\n		String sql = \"delete from student where id=?\";\n		this.getJdbcTemplate().update(sql, id);\n	}\n\n	@Override\n	public void updateStudent(Student student) {\n		String sql = \"update student set name=?, age=? where id=?\";\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());\n	}\n\n	@Override\n	public List<String> selectAllStudentsNames() {\n		String sql = \"select name from student\";\n		return this.getJdbcTemplate().queryForList(sql, String.class);\n	}\n\n	@Override\n	public String selectStudentNameById(int id) {\n		String sql = \"select name from student where id=?\";\n		return this.getJdbcTemplate().queryForObject(sql, String.class, id);\n	}\n\n	@Override\n	public List<Student> selectAllStudents() {\n		String sql = \"select id,name,age from student\";\n		return this.getJdbcTemplate().query(sql, new StudentRowMapper());\n	}\n\n	@Override\n	public Student selectStudentById(int id) {\n		String sql = \"select id,name,age from student where id=?\";\n		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);\n	}\n\n}\n```\n*StudentRowMapper.java*\n```\npublic class StudentRowMapper implements RowMapper<Student> {\n	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到\n	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度\n	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的\n	@Override\n	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\n		Student student = new Student();\n		student.setId(rs.getInt(\"id\"));\n		student.setName(rs.getString(\"name\"));\n		student.setAge(rs.getInt(\"age\"));\n		return student;\n	}\n}\n```\n*IStudentService.java*\n```\npublic interface IStudentService {\n	void addStudent(Student student);\n	void removeById(int id);\n	void modifyStudent(Student student);\n	\n	List<String> findAllStudentsNames();\n	String findStudentNameById(int id);\n	\n	List<Student> findAllStudents();\n	Student findStudentById(int id);\n}\n```\n*StudentServiceImpl.java*\n```\npublic class StudentServiceImpl implements IStudentService {\n	private IStudentDao dao;\n	\n	public void setDao(IStudentDao dao) {\n		this.dao = dao;\n	}\n\n	@Override\n	public void addStudent(Student student) {\n		dao.insertStudent(student);\n	}\n\n	@Override\n	public void removeById(int id) {\n		dao.deleteById(id);\n	}\n\n	@Override\n	public void modifyStudent(Student student) {\n		dao.updateStudent(student);\n	}\n\n	@Override\n	public List<String> findAllStudentsNames() {\n		return dao.selectAllStudentsNames();\n	}\n\n	@Override\n	public String findStudentNameById(int id) {\n		return dao.selectStudentNameById(id);\n	}\n\n	@Override\n	public List<Student> findAllStudents() {\n		return dao.selectAllStudents();\n	}\n\n	@Override\n	public Student findStudentById(int id) {\n		return dao.selectStudentById(id);\n	}\n\n}\n```\n*MyTest.java*\n```\npublic class MyTest {\n	\n	private IStudentService service;\n\n	@Before\n	public void before() {\n		// 创建容器对象，加载Spring配置文件\n		String resource = \"applicationContext.xml\";\n		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\n		service = (IStudentService) ac.getBean(\"studentService\");\n	}\n	\n	@Test\n	public void test01() {\n		Student student = new Student(\"张三\", 23);\n		service.addStudent(student);\n	}\n	\n	@Test\n	public void test02() {\n		service.removeById(2);\n	}\n	\n	@Test\n	public void test03() {\n		Student student = new Student(\"张三\", 23);\n		student.setId(3);\n		service.modifyStudent(student);\n	}\n	\n	@Test\n	public void test04() {\n		List<String> names = service.findAllStudentsNames();\n		System.out.println(names);\n	}\n	\n	@Test\n	public void test05() {\n		String name = service.findStudentNameById(3);\n		System.out.println(name);\n	}\n	\n	@Test\n	public void test06() {\n		List<Student> students = service.findAllStudents();\n		for (Student student : students) {\n			System.out.println(student);\n		}\n	}\n	\n	@Test\n	public void test07() {\n		Student student = service.findStudentById(3);\n		System.out.println(student);\n	}\n}\n```\n*applicationContext.mxl*\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\n        http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n\n	<!-- 注册数据源：Spring内置连接池 -->\n	<bean id=\"myDataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n		<property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\n		<property name=\"url\" value=\"${jdbc.url}\"/>\n		<property name=\"username\" value=\"${jdbc.user}\"/>\n		<property name=\"password\" value=\"${jdbc.password}\"/>\n	</bean>\n\n	<!-- 注册属性文件：方式一 -->\n	<!-- \n	<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n		<property name=\"location\" value=\"classpath:jdbc.properties\"/>\n	</bean>\n	 -->\n\n	<!-- 注册属性文件：方式二 -->\n	<context:property-placeholder location=\"classpath:jdbc.properties\"/>\n	\n	<!-- 注册 Dao -->\n	<bean id=\"studentDao\" class=\"top.qingrang.dao.StudentDaoImpl\">\n		<property name=\"dataSource\" ref=\"myDataSource\"/>\n	</bean>\n	\n	<!-- 注册 Service -->\n	<bean id=\"studentService\" class=\"top.qingrang.service.StudentServiceImpl\">\n		<property name=\"dao\" ref=\"studentDao\"/>\n	</bean>\n\n</beans>\n```\n## Spring 的事务管理\n事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：\n- 使用 Spring 的事务代理工厂管理事务\n- 使用 Spring 的事务注解管理事务\n- 使用 AspectJ 的 AOP 配置管理事务\n\n### Spring 事务管理 API\nSpring 的事务管理，主要用到两个事务相关的接口。\n#### 事务管理器接口\n事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。\n##### 常用的两个实现类\nPlatformTransactionManager 接口有两个常用的实现类：\n- DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。\n- HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。\n\n##### Spring 的回滚方式\nSpring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。 不过，对于受查异常，程序员也可以手工设置其回滚方式。\n\n#### 事务定义接口\n事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。\n##### 定义了五个事务隔离级别常量\n这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。\n- DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ；Oracle 默认为 READ_COMMITTED。\n- READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。\n- READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。\n- REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读\n- SERIALIZABLE： 串行化。不存在并发问题。\n\n##### 定义了七个事务传播行为常量\n所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。\n1. REQUIRED：\n指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。\n如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther()方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用doOther()方法时没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-21-56.png)\n1. SUPPORTS\n指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-13.png)\n1. MANDATORY\n指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-40.png)\n1. REQUIRES_NEW\n总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-55.png)\n1. NOT_SUPPORTED\n指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-07.png)\n1. NEVER\n指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-22.png)\n1. NESTED\n指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-40.png)\n\n##### 定义了默认事务超时时限\n常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。\n\n注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。\n## Demo\n>本例要实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。\n\n',`groups`='Default',`p_id`=1  WHERE  `id` = 1 [ RunTime:0.000660s ]
---------------------------------------------------------------
[ 2018-11-21T23:35:08+08:00 ] 74.120.168.12 74.120.168.12 POST /daily/admin/note/updatenote/id/253.html
[ info ] qingrang.top/daily/admin/note/updatenote/id/253.html [运行时间：0.061298s][吞吐率：16.31req/s] [内存消耗：2,136.48kb] [文件加载：58]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'updatenote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'content-length' => '25011',
  'cache-control' => 'max-age=0',
  'origin' => 'http://qingrang.top',
  'upgrade-insecure-requests' => '1',
  'content-type' => 'application/x-www-form-urlencoded',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'summary' => '',
  'content' => '# Spring(三) - Spring 与 DAO
[TOC]

Spring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：
- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。
- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。

## Spring 与 JDBC 模板
*Student.java - 实体类*
```
public class Student {
	private Integer id;
	private String name;
	private int age;
	public Student() {
		super();
	}
	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
	}
}
```
*IStudentDao.java - 接口*
```
public interface IStudentDao {
	void insertStudent(Student student);
	void deleteById(int id);
	void updateStudent(Student student);
	
	List<String> selectAllStudentsNames();
	String selectStudentNameById(int id);
	
	List<Student> selectAllStudents();
	Student selectStudentById(int id);
}
```
*StudentDaoImpl.java - 实现类*
```
public class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {

	@Override
	public void insertStudent(Student student) {
		String sql = "insert into student(name,age) values(?,?)";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());
	}

	@Override
	public void deleteById(int id) {
		String sql = "delete from student where id=?";
		this.getJdbcTemplate().update(sql, id);
	}

	@Override
	public void updateStudent(Student student) {
		String sql = "update student set name=?, age=? where id=?";
		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());
	}

	@Override
	public List<String> selectAllStudentsNames() {
		String sql = "select name from student";
		return this.getJdbcTemplate().queryForList(sql, String.class);
	}

	@Override
	public String selectStudentNameById(int id) {
		String sql = "select name from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, String.class, id);
	}

	@Override
	public List<Student> selectAllStudents() {
		String sql = "select id,name,age from student";
		return this.getJdbcTemplate().query(sql, new StudentRowMapper());
	}

	@Override
	public Student selectStudentById(int id) {
		String sql = "select id,name,age from student where id=?";
		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);
	}

}
```
*StudentRowMapper.java*
```
public class StudentRowMapper implements RowMapper<Student> {
	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到
	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度
	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的
	@Override
	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
		Student student = new Student();
		student.setId(rs.getInt("id"));
		student.setName(rs.getString("name"));
		student.setAge(rs.getInt("age"));
		return student;
	}
}
```
*IStudentService.java*
```
public interface IStudentService {
	void addStudent(Student student);
	void removeById(int id);
	void modifyStudent(Student student);
	
	List<String> findAllStudentsNames();
	String findStudentNameById(int id);
	
	List<Student> findAllStudents();
	Student findStudentById(int id);
}
```
*StudentServiceImpl.java*
```
public class StudentServiceImpl implements IStudentService {
	private IStudentDao dao;
	
	public void setDao(IStudentDao dao) {
		this.dao = dao;
	}

	@Override
	public void addStudent(Student student) {
		dao.insertStudent(student);
	}

	@Override
	public void removeById(int id) {
		dao.deleteById(id);
	}

	@Override
	public void modifyStudent(Student student) {
		dao.updateStudent(student);
	}

	@Override
	public List<String> findAllStudentsNames() {
		return dao.selectAllStudentsNames();
	}

	@Override
	public String findStudentNameById(int id) {
		return dao.selectStudentNameById(id);
	}

	@Override
	public List<Student> findAllStudents() {
		return dao.selectAllStudents();
	}

	@Override
	public Student findStudentById(int id) {
		return dao.selectStudentById(id);
	}

}
```
*MyTest.java*
```
public class MyTest {
	
	private IStudentService service;

	@Before
	public void before() {
		// 创建容器对象，加载Spring配置文件
		String resource = "applicationContext.xml";
		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);
		service = (IStudentService) ac.getBean("studentService");
	}
	
	@Test
	public void test01() {
		Student student = new Student("张三", 23);
		service.addStudent(student);
	}
	
	@Test
	public void test02() {
		service.removeById(2);
	}
	
	@Test
	public void test03() {
		Student student = new Student("张三", 23);
		student.setId(3);
		service.modifyStudent(student);
	}
	
	@Test
	public void test04() {
		List<String> names = service.findAllStudentsNames();
		System.out.println(names);
	}
	
	@Test
	public void test05() {
		String name = service.findStudentNameById(3);
		System.out.println(name);
	}
	
	@Test
	public void test06() {
		List<Student> students = service.findAllStudents();
		for (Student student : students) {
			System.out.println(student);
		}
	}
	
	@Test
	public void test07() {
		Student student = service.findStudentById(3);
		System.out.println(student);
	}
}
```
*applicationContext.mxl*
```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<!-- 注册数据源：Spring内置连接池 -->
	<bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driver}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 注册属性文件：方式一 -->
	<!-- 
	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:jdbc.properties"/>
	</bean>
	 -->

	<!-- 注册属性文件：方式二 -->
	<context:property-placeholder location="classpath:jdbc.properties"/>
	
	<!-- 注册 Dao -->
	<bean id="studentDao" class="top.qingrang.dao.StudentDaoImpl">
		<property name="dataSource" ref="myDataSource"/>
	</bean>
	
	<!-- 注册 Service -->
	<bean id="studentService" class="top.qingrang.service.StudentServiceImpl">
		<property name="dao" ref="studentDao"/>
	</bean>

</beans>
```
## Spring 的事务管理
事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：
- 使用 Spring 的事务代理工厂管理事务
- 使用 Spring 的事务注解管理事务
- 使用 AspectJ 的 AOP 配置管理事务

### Spring 事务管理 API
Spring 的事务管理，主要用到两个事务相关的接口。
#### 事务管理器接口
事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。
##### 常用的两个实现类
PlatformTransactionManager 接口有两个常用的实现类：
- DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。
- HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。

##### Spring 的回滚方式
Spring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。 不过，对于受查异常，程序员也可以手工设置其回滚方式。

#### 事务定义接口
事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。
##### 定义了五个事务隔离级别常量
这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。
- DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ；Oracle 默认为 READ_COMMITTED。
- READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。
- READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。
- REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读
- SERIALIZABLE： 串行化。不存在并发问题。

##### 定义了七个事务传播行为常量
所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。
1. REQUIRED：
指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。
如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther()方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用doOther()方法时没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-21-56.png)
1. SUPPORTS
指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-13.png)
1. MANDATORY
指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-40.png)
1. REQUIRES_NEW
总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-55.png)
1. NOT_SUPPORTED
指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-07.png)
1. NEVER
指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-22.png)
1. NESTED
指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。
![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-40.png)

##### 定义了默认事务超时时限
常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。

注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。
## Demo
>本例要实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。

',
  'groups' => 'Java',
  'showsel' => '1',
  'showse2' => '1',
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->updateNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ CACHE ] INIT File
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000624s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001358s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000431s ]
[ sql ] [ SQL ] SELECT `groups` FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000291s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000798s ]
[ sql ] [ SQL ] SELECT `parent_id` FROM `groups` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.000294s ]
[ sql ] [ SQL ] SELECT `groups` FROM `groups` WHERE  `id` = 2 LIMIT 1 [ RunTime:0.000329s ]
[ sql ] [ SQL ] UPDATE `note`  SET `id`=253,`p_id`=2,`title`='Spring(三) - Spring 与 DAO\r',`content`='# Spring(三) - Spring 与 DAO\r\n[TOC]\r\n\r\nSpring 与 Dao 部分，是 Spring 的两大核心技术 IoC 与 AOP 的典型应用体现：\r\n- 对于 JDBC 模板的使用，是 IoC 的应用，是将 JDBC 模板对象注入给了 Dao 层的实现类。\r\n- 对于 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。\r\n\r\n## Spring 与 JDBC 模板\r\n*Student.java - 实体类*\r\n```\r\npublic class Student {\r\n	private Integer id;\r\n	private String name;\r\n	private int age;\r\n	public Student() {\r\n		super();\r\n	}\r\n	public Student(String name, int age) {\r\n		super();\r\n		this.name = name;\r\n		this.age = age;\r\n	}\r\n	public Integer getId() {\r\n		return id;\r\n	}\r\n	public void setId(Integer id) {\r\n		this.id = id;\r\n	}\r\n	public String getName() {\r\n		return name;\r\n	}\r\n	public void setName(String name) {\r\n		this.name = name;\r\n	}\r\n	public int getAge() {\r\n		return age;\r\n	}\r\n	public void setAge(int age) {\r\n		this.age = age;\r\n	}\r\n	@Override\r\n	public String toString() {\r\n		return \"Student [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\";\r\n	}\r\n}\r\n```\r\n*IStudentDao.java - 接口*\r\n```\r\npublic interface IStudentDao {\r\n	void insertStudent(Student student);\r\n	void deleteById(int id);\r\n	void updateStudent(Student student);\r\n	\r\n	List<String> selectAllStudentsNames();\r\n	String selectStudentNameById(int id);\r\n	\r\n	List<Student> selectAllStudents();\r\n	Student selectStudentById(int id);\r\n}\r\n```\r\n*StudentDaoImpl.java - 实现类*\r\n```\r\npublic class StudentDaoImpl extends JdbcDaoSupport implements IStudentDao {\r\n\r\n	@Override\r\n	public void insertStudent(Student student) {\r\n		String sql = \"insert into student(name,age) values(?,?)\";\r\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge());\r\n	}\r\n\r\n	@Override\r\n	public void deleteById(int id) {\r\n		String sql = \"delete from student where id=?\";\r\n		this.getJdbcTemplate().update(sql, id);\r\n	}\r\n\r\n	@Override\r\n	public void updateStudent(Student student) {\r\n		String sql = \"update student set name=?, age=? where id=?\";\r\n		this.getJdbcTemplate().update(sql, student.getName(), student.getAge(), student.getId());\r\n	}\r\n\r\n	@Override\r\n	public List<String> selectAllStudentsNames() {\r\n		String sql = \"select name from student\";\r\n		return this.getJdbcTemplate().queryForList(sql, String.class);\r\n	}\r\n\r\n	@Override\r\n	public String selectStudentNameById(int id) {\r\n		String sql = \"select name from student where id=?\";\r\n		return this.getJdbcTemplate().queryForObject(sql, String.class, id);\r\n	}\r\n\r\n	@Override\r\n	public List<Student> selectAllStudents() {\r\n		String sql = \"select id,name,age from student\";\r\n		return this.getJdbcTemplate().query(sql, new StudentRowMapper());\r\n	}\r\n\r\n	@Override\r\n	public Student selectStudentById(int id) {\r\n		String sql = \"select id,name,age from student where id=?\";\r\n		return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);\r\n	}\r\n\r\n}\r\n```\r\n*StudentRowMapper.java*\r\n```\r\npublic class StudentRowMapper implements RowMapper<Student> {\r\n	// rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到\r\n	//     这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度\r\n	//     来说，只要能执行到这个方法，就说明这里的rs不会是空的\r\n	@Override\r\n	public Student mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n		Student student = new Student();\r\n		student.setId(rs.getInt(\"id\"));\r\n		student.setName(rs.getString(\"name\"));\r\n		student.setAge(rs.getInt(\"age\"));\r\n		return student;\r\n	}\r\n}\r\n```\r\n*IStudentService.java*\r\n```\r\npublic interface IStudentService {\r\n	void addStudent(Student student);\r\n	void removeById(int id);\r\n	void modifyStudent(Student student);\r\n	\r\n	List<String> findAllStudentsNames();\r\n	String findStudentNameById(int id);\r\n	\r\n	List<Student> findAllStudents();\r\n	Student findStudentById(int id);\r\n}\r\n```\r\n*StudentServiceImpl.java*\r\n```\r\npublic class StudentServiceImpl implements IStudentService {\r\n	private IStudentDao dao;\r\n	\r\n	public void setDao(IStudentDao dao) {\r\n		this.dao = dao;\r\n	}\r\n\r\n	@Override\r\n	public void addStudent(Student student) {\r\n		dao.insertStudent(student);\r\n	}\r\n\r\n	@Override\r\n	public void removeById(int id) {\r\n		dao.deleteById(id);\r\n	}\r\n\r\n	@Override\r\n	public void modifyStudent(Student student) {\r\n		dao.updateStudent(student);\r\n	}\r\n\r\n	@Override\r\n	public List<String> findAllStudentsNames() {\r\n		return dao.selectAllStudentsNames();\r\n	}\r\n\r\n	@Override\r\n	public String findStudentNameById(int id) {\r\n		return dao.selectStudentNameById(id);\r\n	}\r\n\r\n	@Override\r\n	public List<Student> findAllStudents() {\r\n		return dao.selectAllStudents();\r\n	}\r\n\r\n	@Override\r\n	public Student findStudentById(int id) {\r\n		return dao.selectStudentById(id);\r\n	}\r\n\r\n}\r\n```\r\n*MyTest.java*\r\n```\r\npublic class MyTest {\r\n	\r\n	private IStudentService service;\r\n\r\n	@Before\r\n	public void before() {\r\n		// 创建容器对象，加载Spring配置文件\r\n		String resource = \"applicationContext.xml\";\r\n		ApplicationContext ac = new ClassPathXmlApplicationContext(resource);\r\n		service = (IStudentService) ac.getBean(\"studentService\");\r\n	}\r\n	\r\n	@Test\r\n	public void test01() {\r\n		Student student = new Student(\"张三\", 23);\r\n		service.addStudent(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test02() {\r\n		service.removeById(2);\r\n	}\r\n	\r\n	@Test\r\n	public void test03() {\r\n		Student student = new Student(\"张三\", 23);\r\n		student.setId(3);\r\n		service.modifyStudent(student);\r\n	}\r\n	\r\n	@Test\r\n	public void test04() {\r\n		List<String> names = service.findAllStudentsNames();\r\n		System.out.println(names);\r\n	}\r\n	\r\n	@Test\r\n	public void test05() {\r\n		String name = service.findStudentNameById(3);\r\n		System.out.println(name);\r\n	}\r\n	\r\n	@Test\r\n	public void test06() {\r\n		List<Student> students = service.findAllStudents();\r\n		for (Student student : students) {\r\n			System.out.println(student);\r\n		}\r\n	}\r\n	\r\n	@Test\r\n	public void test07() {\r\n		Student student = service.findStudentById(3);\r\n		System.out.println(student);\r\n	}\r\n}\r\n```\r\n*applicationContext.mxl*\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans \r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context \r\n        http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n	<!-- 注册数据源：Spring内置连接池 -->\r\n	<bean id=\"myDataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\r\n		<property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\r\n		<property name=\"url\" value=\"${jdbc.url}\"/>\r\n		<property name=\"username\" value=\"${jdbc.user}\"/>\r\n		<property name=\"password\" value=\"${jdbc.password}\"/>\r\n	</bean>\r\n\r\n	<!-- 注册属性文件：方式一 -->\r\n	<!-- \r\n	<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\r\n		<property name=\"location\" value=\"classpath:jdbc.properties\"/>\r\n	</bean>\r\n	 -->\r\n\r\n	<!-- 注册属性文件：方式二 -->\r\n	<context:property-placeholder location=\"classpath:jdbc.properties\"/>\r\n	\r\n	<!-- 注册 Dao -->\r\n	<bean id=\"studentDao\" class=\"top.qingrang.dao.StudentDaoImpl\">\r\n		<property name=\"dataSource\" ref=\"myDataSource\"/>\r\n	</bean>\r\n	\r\n	<!-- 注册 Service -->\r\n	<bean id=\"studentService\" class=\"top.qingrang.service.StudentServiceImpl\">\r\n		<property name=\"dao\" ref=\"studentDao\"/>\r\n	</bean>\r\n\r\n</beans>\r\n```\r\n## Spring 的事务管理\r\n事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理：\r\n- 使用 Spring 的事务代理工厂管理事务\r\n- 使用 Spring 的事务注解管理事务\r\n- 使用 AspectJ 的 AOP 配置管理事务\r\n\r\n### Spring 事务管理 API\r\nSpring 的事务管理，主要用到两个事务相关的接口。\r\n#### 事务管理器接口\r\n事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。\r\n##### 常用的两个实现类\r\nPlatformTransactionManager 接口有两个常用的实现类：\r\n- DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。\r\n- HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。\r\n\r\n##### Spring 的回滚方式\r\nSpring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。 不过，对于受查异常，程序员也可以手工设置其回滚方式。\r\n\r\n#### 事务定义接口\r\n事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。\r\n##### 定义了五个事务隔离级别常量\r\n这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。\r\n- DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ；Oracle 默认为 READ_COMMITTED。\r\n- READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。\r\n- READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。\r\n- REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读\r\n- SERIALIZABLE： 串行化。不存在并发问题。\r\n\r\n##### 定义了七个事务传播行为常量\r\n所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。\r\n1. REQUIRED：\r\n指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。\r\n如该传播行为加在 doOther()方法上。若 doSome()方法在调用 doOther()方法时就是在事务内运行的，则 doOther()方法的执行也加入到该事务内执行。若 doSome()方法在调用doOther()方法时没有在事务内执行，则 doOther()方法会创建一个事务，并在其中执行。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-21-56.png)\r\n1. SUPPORTS\r\n指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-13.png)\r\n1. MANDATORY\r\n指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-40.png)\r\n1. REQUIRES_NEW\r\n总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-22-55.png)\r\n1. NOT_SUPPORTED\r\n指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-07.png)\r\n1. NEVER\r\n指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-22.png)\r\n1. NESTED\r\n指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。\r\n![mark](https://daily-1252869435.cos.ap-chengdu.myqcloud.com/2018-11-21-23-23-40.png)\r\n\r\n##### 定义了默认事务超时时限\r\n常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。\r\n\r\n注意，事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。\r\n## Demo\r\n>本例要实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。\r\n\r\n',`groups`='Java',`is_show`=1,`publish`=1,`summary`='',`gmt_modified`='2018-11-21'  WHERE  `id` = 253 [ RunTime:0.000757s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001842s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000281s ]
[ sql ] [ SQL ] SELECT COUNT(*) AS tp_count FROM `note` WHERE  `groups` = 'Java' LIMIT 1 [ RunTime:0.001004s ]
[ sql ] [ SQL ] UPDATE `groups`  SET `g_count`=22  WHERE  `groups` = 'Java' [ RunTime:0.000312s ]
---------------------------------------------------------------
[ 2018-11-21T23:35:09+08:00 ] 74.120.168.12 74.120.168.12 GET /daily/admin/note/shownote/id/253.html
[ info ] qingrang.top/daily/admin/note/shownote/id/253.html [运行时间：0.044704s][吞吐率：22.37req/s] [内存消耗：1,993.28kb] [文件加载：55]
[ info ] [ LANG ] /var/www/html/daily/thinkphp/lang/zh-cn.php
[ info ] [ ROUTE ] array (
  'type' => 'module',
  'module' => 
  array (
    0 => 'admin',
    1 => 'note',
    2 => 'shownote',
  ),
)
[ info ] [ HEADER ] array (
  'host' => 'qingrang.top',
  'cache-control' => 'max-age=0',
  'upgrade-insecure-requests' => '1',
  'user-agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36',
  'accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
  'referer' => 'http://qingrang.top/daily/admin/note/editnote/id/253.html',
  'accept-encoding' => 'gzip, deflate',
  'accept-language' => 'zh-CN,zh;q=0.9,la;q=0.8,en;q=0.7,lb;q=0.6',
  'cookie' => 'Hm_lvt_1769181352e9adc950166aada465644e=1541082864,1541122974,1541171416,1542098176; PHPSESSID=is5rrmupuro8e6m90noomsjgt4',
  'connection' => 'close',
)
[ info ] [ PARAM ] array (
  'id' => '253',
)
[ info ] [ SESSION ] INIT array (
  'id' => '',
  'var_session_id' => '',
  'prefix' => 'think',
  'type' => '',
  'auto_start' => true,
)
[ info ] [ RUN ] app\admin\controller\Note->showNote[ /var/www/html/daily/application/admin/controller/Note.php ]
[ info ] [ DB ] INIT mysql
[ info ] [ VIEW ] /var/www/html/daily/application/admin/view/note/shownote.html [ array (
  0 => 'note',
  1 => 'groups',
) ]
[ info ] [ LOG ] INIT File
[ sql ] [ DB ] CONNECT:[ UseTime:0.000431s ] mysql:host=74.120.168.12;dbname=diary;charset=utf8
[ sql ] [ SQL ] SHOW COLUMNS FROM `note` [ RunTime:0.001231s ]
[ sql ] [ SQL ] SELECT * FROM `note` WHERE  `id` = 253 LIMIT 1 [ RunTime:0.000434s ]
[ sql ] [ SQL ] SHOW COLUMNS FROM `groups` [ RunTime:0.000796s ]
[ sql ] [ SQL ] SELECT * FROM `groups` [ RunTime:0.000276s ]
